1
00:00:00,000 --> 00:00:02,988
[REEL-TO-REEL PLAYER STARTING]

2
00:00:02,988 --> 00:00:05,976
[MUSIC PLAYING]

3
00:01:13,350 --> 00:01:16,090
DAVID J. MALAN: All right, this is CS50.

4
00:01:16,090 --> 00:01:25,060
And this is week 1, wherein we continue programming, but we do it in a different language because recall last time, we focused on this graphical language called Scratch.

5
00:01:25,060 --> 00:01:31,750
But we use Scratch, not only because it's sort of fun and accessible, but because it allows us to explore a lot of these concepts here,

6
00:01:31,750 --> 00:01:36,410
namely functions, and conditionals, Boolean expressions, loops, variables, and more.

7
00:01:36,410 --> 00:01:44,980
And so, indeed, even if today's syntax, as we transition to this new language called C, feels a little bit cryptic, maybe a little intimidating at first,

8
00:01:44,980 --> 00:01:52,670
and you don't quite see all of the meaning of the symbols beyond the syntax itself, realize that the ideas are ultimately going to be the same.

9
00:01:52,670 --> 00:02:02,350
In fact, as we transition from what was last week-- a Hello World program that looked a little something like this-- this week, of course, it's going to now look a little more cryptic.

10
00:02:02,350 --> 00:02:04,350
It's going to look a little something like this.

11
00:02:04,350 --> 00:02:11,578
And now even if you can't quite distinguish what all of the various symbols mean in this code, it turns out that at the end of the day, it's indeed going to do what you expect.

12
00:02:11,578 --> 00:02:15,370
It's just going to say, hello, world on the screen, just like we did in Scratch.

13
00:02:15,370 --> 00:02:19,610
So let's start to apply some terminology to these tokens first.

14
00:02:19,610 --> 00:02:24,040
So what we're about to see, what we're about to write henceforth, we're going to start calling source code.

15
00:02:24,040 --> 00:02:27,908
Code that you the human programmer write is just henceforth called source code.

16
00:02:27,908 --> 00:02:29,200
Doesn't matter if it's Scratch.

17
00:02:29,200 --> 00:02:32,370
Doesn't matter if it's C. Doesn't matter if it's Python before long.

18
00:02:32,370 --> 00:02:37,330
Source code is the general term for really what you and I as human programmers will ultimately write.

19
00:02:37,330 --> 00:02:42,190
Of course, computers don't understand source code, it turns out.

20
00:02:42,190 --> 00:02:47,200
Computers don't understand Scratch and Puzzle Pieces, per se, or C code like we're about to see.

21
00:02:47,200 --> 00:02:49,870
They only understand this, which we called what last week?

22
00:02:49,870 --> 00:02:50,650
AUDIENCE: Zeros and ones.

23
00:02:50,650 --> 00:02:51,525
DAVID J. MALAN: Yeah.

24
00:02:51,525 --> 00:02:53,080
So this is binary, zeros and ones.

25
00:02:53,080 --> 00:02:56,470
But really, it's just information represented in binary.

26
00:02:56,470 --> 00:03:04,810
And in fact, the technical term now for patterns of zeros and ones that a computer not only understands how to interpret as letters, or numbers,

27
00:03:04,810 --> 00:03:12,880
or colors, or images, or more, but knows how to execute as well henceforth is going to be called machine code to contrast it with source code.

28
00:03:12,880 --> 00:03:18,860
So whereas you and I, the humans, write source code, it's the computer that ultimately only understands machine code.

29
00:03:18,860 --> 00:03:28,600
And even though we won't get into the details of exactly what pattern of symbols means what, you'll see that in this kind of pattern of zeros and ones, there's going to be numbers.

30
00:03:28,600 --> 00:03:29,530
There's going to be letters.

31
00:03:29,530 --> 00:03:36,430
But there's also going to be instructions because, indeed, computers are really good at doing things-- addition, subtraction, moving things in and out of memory.

32
00:03:36,430 --> 00:03:44,740
And suffice it to say that the Macs, the PCs, the other computers of the world have just decided as a society what certain patterns of zeros and ones

33
00:03:44,740 --> 00:03:49,200
mean when it comes to operations as well-- so not just data, but instructions.

34
00:03:49,200 --> 00:03:52,575
But those patterns are not something we're going to focus on in a class like this.

35
00:03:52,575 --> 00:03:58,910
We're going to focus on the higher level software side of things, simply assuming that we need to somehow output machine code.

36
00:03:58,910 --> 00:04:07,120
So it turns out, then, that this problem we have to solve getting from source code to machine code actually fits into the same paradigm as last time.

37
00:04:07,120 --> 00:04:11,230
But the input in this case is going to be source code on the one hand.

38
00:04:11,230 --> 00:04:15,430
That's what you and I ideally will write so that we don't have to write zeros and ones.

39
00:04:15,430 --> 00:04:21,730
But we need to somehow output machine code because that's what your Macs, PCs, phones are actually going to understand.

40
00:04:21,730 --> 00:04:28,690
Well, it turns out there are special programs in life whose purpose is to do exactly this conversion-- convert the source code you

41
00:04:28,690 --> 00:04:32,320
and I write to the machine code that our phones and computers understand.

42
00:04:32,320 --> 00:04:36,050
And that type of program is going to be called a compiler.

43
00:04:36,050 --> 00:04:39,400
So indeed today, we'll introduce you to another piece of software.

44
00:04:39,400 --> 00:04:40,810
And these come in many forms.

45
00:04:40,810 --> 00:04:48,805
We'll use a popular one here that allows you to convert source code in C to machine code in zeros and ones.

46
00:04:48,805 --> 00:04:50,680
Now, you didn't have to do this with Scratch.

47
00:04:50,680 --> 00:04:57,280
In the world of Scratch, it was as simple as clicking the green flag because essentially MIT did all of the heavy lifting there figuring out

48
00:04:57,280 --> 00:05:00,760
how to convert these graphical puzzle pieces to the underlying machine code.

49
00:05:00,760 --> 00:05:06,550
But now starting today, as we begin to study programming and computer science proper, now that power moves to you.

50
00:05:06,550 --> 00:05:09,340
And it's up to you now to do that kind of conversion.

51
00:05:09,340 --> 00:05:19,973
But thankfully, the fact that these compilers exist means that you and I don't have to program in machine code like our ancestors once upon a time did, be it virtually or with physical punch cards,

52
00:05:19,973 --> 00:05:21,640
like pieces of paper with holes in them.

53
00:05:21,640 --> 00:05:25,810
You and I get to focus on our keyboard, as such.

54
00:05:25,810 --> 00:05:29,370
But it's not just going to be a matter today of writing code.

55
00:05:29,370 --> 00:05:32,930
It's going to be a matter ultimately today onward of writing good code as well.

56
00:05:32,930 --> 00:05:35,180
And this is the kind of thing that you don't just learn overnight.

57
00:05:35,180 --> 00:05:35,870
It takes time.

58
00:05:35,870 --> 00:05:36,620
It takes practice.

59
00:05:36,620 --> 00:05:41,050
Just like writing an essay in any subject might take time, and practice, and iteration over time.

60
00:05:41,050 --> 00:05:49,360
But in a programming class like CS50, we're going to aspire to evaluate the quality of code along these three axes, generally.

61
00:05:49,360 --> 00:05:51,040
Is it correct, first and foremost?

62
00:05:51,040 --> 00:05:52,810
Does the code do what it's supposed to do?

63
00:05:52,810 --> 00:05:55,835
After all, if it doesn't, well, what was the point of writing it in the first place?

64
00:05:55,835 --> 00:05:59,350
So it goes without saying that you want code you write to be correct.

65
00:05:59,350 --> 00:06:00,820
And it's obviously not always.

66
00:06:00,820 --> 00:06:07,030
Again, anytime your Mac, or PC, or phone has crashed, some human somewhere wrote buggy-- that is code with mistakes.

67
00:06:07,030 --> 00:06:10,060
But code correctness is going to be the first and foremost goal.

68
00:06:10,060 --> 00:06:13,930
But then there's a more subjective goal see in time, a matter of design.

69
00:06:13,930 --> 00:06:24,170
And we saw a little bit of this last week when I proposed that we could design even scratch programs better, maybe by using loops instead of just by copying and pasting the same blocks again and again.

70
00:06:24,170 --> 00:06:26,080
So design is more subjective.

71
00:06:26,080 --> 00:06:32,882
It's more of a learned art whereby two people might ultimately disagree as to which version of a program is better designed.

72
00:06:32,882 --> 00:06:40,090
But we'll give you building blocks and principles over the coming weeks so that you can have a better sense for yourself if your own code is well designed.

73
00:06:40,090 --> 00:06:41,530
And why is that valuable?

74
00:06:41,530 --> 00:06:49,438
Well, the better designed your code is, often the faster it's going to run, the more maintainable it's going to be by you or colleagues if you're working with others in the real world.

75
00:06:49,438 --> 00:06:50,900
So good design is a good thing.

76
00:06:50,900 --> 00:06:54,490
It helps you communicate your ideas, just like in a typical English essay.

77
00:06:54,490 --> 00:06:57,523
And then lastly, we'll talk this week onward about style.

78
00:06:57,523 --> 00:06:59,690
And this is really just the aesthetics of your code.

79
00:06:59,690 --> 00:07:10,750
It turns out that computers often don't care how sloppy your actual code is, where in the world of code, it turns out that you don't really need to indent things in a beautiful way.

80
00:07:10,750 --> 00:07:13,150
You don't need to paginate things like might in an essay.

81
00:07:13,150 --> 00:07:16,390
The computer generally does not care, but the human does.

82
00:07:16,390 --> 00:07:17,817
The teaching assistant does.

83
00:07:17,817 --> 00:07:21,560
You will care the next day when you're just trying to understand what your code does.

84
00:07:21,560 --> 00:07:25,520
So we'll focus lastly on style, the aesthetics of the code that you're writing.

85
00:07:25,520 --> 00:07:27,280
So where are we going to write code?

86
00:07:27,280 --> 00:07:28,940
Where are we going to compile code?

87
00:07:28,940 --> 00:07:39,280
So for this class, not only with C, but the other languages we use later in the term, we're going to use a free text editor that is program called Visual Studio Code, AKA VS Code.

88
00:07:39,280 --> 00:07:45,970
It's super popular nowadays, not just for C, but for C++, and Python, and Java, and any number of other languages.

89
00:07:45,970 --> 00:07:49,270
It's a text editor in the sense that it lets you edit text.

90
00:07:49,270 --> 00:07:52,150
And that's all code is going to be.

91
00:07:52,150 --> 00:07:54,907
Now, strictly speaking, you could write code on paper/pencil.

92
00:07:54,907 --> 00:07:59,532
In fact, in high school if you took a class, you might have done that one or more times as an in-class exercise.

93
00:07:59,532 --> 00:08:02,532
You can't run it on paper, of course, but you could write it, certainly.

94
00:08:02,532 --> 00:08:07,240
You could use something like Microsoft Word, or Notepad.exe, or Text Edit on the Mac.

95
00:08:07,240 --> 00:08:15,250
But none of those programs are really designed to format the code in the best way for you, nor are they designed to let you compile and run the code.

96
00:08:15,250 --> 00:08:22,240
So VS Code is going to be a tool via which you can do all that and more-- write the code, compile the code, run the code.

97
00:08:22,240 --> 00:08:29,110
So that you all don't have to wrestle with stupid technical support headaches at the beginning of the course by installing this software and that

98
00:08:29,110 --> 00:08:34,780
on your Macs or PCs, we'll use a cloud-based version of VS Code at code.cs50.io.

99
00:08:34,780 --> 00:08:36,580
And that's going to be the exact same tool.

100
00:08:36,580 --> 00:08:46,090
And the goal, then, is by the end of the semester to migrate you off of that cloud-based environment to your own Mac and PC so that even if CS50 is the only CS class you ever take,

101
00:08:46,090 --> 00:08:55,760
you're 100% equipped to continue writing code after the class using not something that's even CS50-specific, but a de facto industry standard, at least for some time.

102
00:08:55,760 --> 00:08:59,020
So what's this program VS Code going to look like, be it on your Mac,

103
00:08:59,020 --> 00:09:00,990
PC, or initially in your browser?

104
00:09:00,990 --> 00:09:02,990
It's going to look a little something like this.

105
00:09:02,990 --> 00:09:05,657
And there's going to be several different regions to the screen.

106
00:09:05,657 --> 00:09:10,335
And pictured here is that very same code I keep proposing as the simplest program you can write in C.

107
00:09:10,335 --> 00:09:12,460
And what are these different regions of the screen?

108
00:09:12,460 --> 00:09:15,440
Well, there's essentially these four here.

109
00:09:15,440 --> 00:09:21,160
So first, highlighted up top is going to be one or more tabs where you're going to actually write code.

110
00:09:21,160 --> 00:09:24,940
So much like in Google Docs or Microsoft Word, you can have tabs open with files.

111
00:09:24,940 --> 00:09:30,830
Similarly in VS Code-- or, really, any programming environment-- you generally nowadays have tabs of some sort.

112
00:09:30,830 --> 00:09:34,480
And this is going to be a tab containing a file, it seems, called hello.c.

113
00:09:34,480 --> 00:09:38,020
And that's going to be the very first file we write in just a moment.

114
00:09:38,020 --> 00:09:41,920
Down here, though, is going to be an interface that many of you might not know.

115
00:09:41,920 --> 00:09:44,170
This is what's called a terminal window.

116
00:09:44,170 --> 00:09:47,920
And a terminal window provides what's generally called a Command Line

117
00:09:47,920 --> 00:09:49,720
Interface, or CLI.

118
00:09:49,720 --> 00:09:53,680
And this is in contrast with a Graphical User Interface, or GUI.

119
00:09:53,680 --> 00:09:57,760
Now, you and I, every day, are using GUIs on our phones, on our PCs.

120
00:09:57,760 --> 00:10:01,420
And a GUI is literally graphical-- so menus, and buttons, and icons.

121
00:10:01,420 --> 00:10:06,380
And you generally use your finger or a trackpad or a mouse or something like that to interact with it.

122
00:10:06,380 --> 00:10:14,620
But it turns out that many programmers-- they're saying most programmers, at least over time, come to prefer, not a GUI, but a CLI, a Command Line Interface

123
00:10:14,620 --> 00:10:20,650
where you actually do everything somewhat arcanely via keyboard alone.

124
00:10:20,650 --> 00:10:21,250
Why?

125
00:10:21,250 --> 00:10:26,260
Well, it turns out, there's just more features built in to most computers if you can access them with a keyboard.

126
00:10:26,260 --> 00:10:29,530
It turns out, most of us can type faster than you can point and click.

127
00:10:29,530 --> 00:10:32,330
And so that ends up being an efficiency gain over time.

128
00:10:32,330 --> 00:10:40,390
So in time, will you get comfortable using this terminal window to do things like compile your code or make your program as well as run it.

129
00:10:40,390 --> 00:10:45,800
So you won't be in the habit initially of just double clicking icons like we do in our typical real world.

130
00:10:45,800 --> 00:10:47,890
You'll do it the programmer's way.

131
00:10:47,890 --> 00:10:51,820
But it's not to the exclusion of adding icons, and clickability, and more.

132
00:10:51,820 --> 00:11:02,110
On the left-hand side of VS Code, there's going to be a somewhat familiar File Explorer, some kind of hierarchical tree, like on your Mac or PC where you can see all of the files in your account.

133
00:11:02,110 --> 00:11:06,140
Pictured here, for instance, is just hello.c, which I'll create myself in a moment.

134
00:11:06,140 --> 00:11:12,260
And then far away on the left is the so-called Activity Bar, and this is where you just get a lot of traditional menus and buttons.

135
00:11:12,260 --> 00:11:16,250
So VS Code itself gives you both a GUI and a CLI.

136
00:11:16,250 --> 00:11:22,250
But it's within the CLI, the terminal window, the bottom region of the screen that we're actually going to type most of our commands.

137
00:11:22,250 --> 00:11:28,380
And in general in class, I'm going to hide all of the graphical stuff that's just not of all that much interest.

138
00:11:28,380 --> 00:11:32,878
So with that said, let me actually change over to a live version of VS Code.

139
00:11:32,878 --> 00:11:34,670
And I've indeed hidden in the Activity Bar.

140
00:11:34,670 --> 00:11:36,470
I've indeed hidden the File Explorer.

141
00:11:36,470 --> 00:11:42,840
So what I have here for visibility sake is a really big area for writing code and a really big terminal window at the bottom.

142
00:11:42,840 --> 00:11:45,260
You'll see in the terminal window, there's dollar sign.

143
00:11:45,260 --> 00:11:47,160
And this doesn't mean any form of currency.

144
00:11:47,160 --> 00:11:51,230
This is just the standard symbol that represents type commands here.

145
00:11:51,230 --> 00:11:55,490
So the fact that there's just dollar sign and a cursor means, eventually, that's where I'm going to type commands.

146
00:11:55,490 --> 00:11:58,020
But first, I'm going to actually create some code.

147
00:11:58,020 --> 00:12:08,870
So how might I program using VS Code-- be it on my Mac, PC, or in this cloud-based environment that you'll get set up for problem set 1-- go about writing my first file?

148
00:12:08,870 --> 00:12:10,610
Well, perhaps the easiest way is this.

149
00:12:10,610 --> 00:12:15,200
Literally run the command code and then the name of the file you want to create.

150
00:12:15,200 --> 00:12:18,838
Notice that I deliberately end the file with .c in lowercase.

151
00:12:18,838 --> 00:12:21,380
Notice that I've deliberately lowercased the whole file name.

152
00:12:21,380 --> 00:12:22,672
And these are just conventions.

153
00:12:22,672 --> 00:12:24,140
You could use a capital H.

154
00:12:24,140 --> 00:12:27,260
You kind of could use a capital C. But just don't do that.

155
00:12:27,260 --> 00:12:31,100
Follow best practices so that it's consistent with what most everyone else would do.

156
00:12:31,100 --> 00:12:35,540
When I hit Enter, I just get an empty tab, just like the screenshot a moment ago.

157
00:12:35,540 --> 00:12:40,100
And it's in this tab where I can now write my very first program in C.

158
00:12:40,100 --> 00:12:45,992
Unfortunately, it's not quite as user-friendly as Scratch where you drag and drop a couple of puzzle pieces and, boom, it's done.

159
00:12:45,992 --> 00:12:47,450
So I'm going to do this for memory.

160
00:12:47,450 --> 00:12:49,970
But this, too, will become familiar to you over time.

161
00:12:49,970 --> 00:12:53,720
I'm going to include something called stdio.h.

162
00:12:53,720 --> 00:12:57,230
I'm going to type int main, void in parentheses.

163
00:12:57,230 --> 00:13:01,190
On a new line, I'm going to insert some curly braces, as we'll call them.

164
00:13:01,190 --> 00:13:12,800
And then I'm going to type printf, and then some parentheses, and then in quotes, hello, comma, world, then a backslash, then a lowercase n, then a close quote, and then a semicolon

165
00:13:12,800 --> 00:13:14,280
at the very end of the line.

166
00:13:14,280 --> 00:13:19,010
So all I've done is recreate, just from memory, that very first program.

167
00:13:19,010 --> 00:13:21,710
In a little bit, we'll make clear what most of this does.

168
00:13:21,710 --> 00:13:23,857
But for now, let's just actually run this thing.

169
00:13:23,857 --> 00:13:29,840
And just like I clicked the green flag last week for the first time, let's actually compile and run this program.

170
00:13:29,840 --> 00:13:37,408
If it were your Mac or PC and Google, or Microsoft, or someone else had made the software, at this point in the story, we'd be double clicking an icon.

171
00:13:37,408 --> 00:13:38,450
But we can't do that yet.

172
00:13:38,450 --> 00:13:39,930
This is still source code.

173
00:13:39,930 --> 00:13:42,380
So I'm going to click back down in my terminal window.

174
00:13:42,380 --> 00:13:47,880
Notice I have a second dollar sign below the first, which just means it's ready for a second command.

175
00:13:47,880 --> 00:13:59,360
And now the command via which to make this an actual program, to compile it from source code to machine code is, going to be quite simply make and then the name of the program I want to make.

176
00:13:59,360 --> 00:14:05,870
Slight subtlety-- I'm omitting deliberately .c because the program I want to make, I just want to call hello.

177
00:14:05,870 --> 00:14:07,400
Don't write make hello.c.

178
00:14:07,400 --> 00:14:08,780
Just write make hello.

179
00:14:08,780 --> 00:14:13,040
And this program make is essentially our compiler.

180
00:14:13,040 --> 00:14:17,580
Technically speaking, it's a program that automates the compilation of my program for me.

181
00:14:17,580 --> 00:14:20,180
But it is going to see that I've typed the word hello.

182
00:14:20,180 --> 00:14:30,690
It's going to automatically look now for a file on the hard drive called hello.c and convert it from source code in C to machine code in zeros and ones.

183
00:14:30,690 --> 00:14:37,170
So if I didn't make any typos, Enter, nothing seems to happen.

184
00:14:37,170 --> 00:14:38,210
And that's a good thing.

185
00:14:38,210 --> 00:14:41,862
Almost always, if nothing gets outputted on the screen, you did good.

186
00:14:41,862 --> 00:14:43,070
You didn't make any mistakes.

187
00:14:43,070 --> 00:14:43,880
You didn't get yelled at.

188
00:14:43,880 --> 00:14:45,000
There's no error messages.

189
00:14:45,000 --> 00:14:46,590
So this is actually a good thing.

190
00:14:46,590 --> 00:14:47,942
How do I now run this program?

191
00:14:47,942 --> 00:14:52,110
Well, notice I've got a third dollar sign, which just means I'm ready for a third command.

192
00:14:52,110 --> 00:14:55,400
And now I'm going to go ahead and run ./hello.

193
00:14:55,400 --> 00:14:58,798
And this is admittedly a little weird that you have to do dot slash.

194
00:14:58,798 --> 00:15:07,730
But for now just take on faith that this is how you run a program called hello In your current folder, in your current directory in this cloud-based environment.

195
00:15:07,730 --> 00:15:10,430
All right, crossing my fingers again, hitting Enter.

196
00:15:10,430 --> 00:15:12,110
And voila.

197
00:15:12,110 --> 00:15:15,950
My very first program in C, hello, world.

198
00:15:15,950 --> 00:15:21,292
And now let me go ahead and reveal the File Explorer that I proposed exists earlier.

199
00:15:21,292 --> 00:15:23,750
I'm just going to use the keyboard shortcut to reveal that.

200
00:15:23,750 --> 00:15:28,250
And generally, I keep it closed because I don't really need to constantly what files are in my account.

201
00:15:28,250 --> 00:15:35,270
But you'll see now in the File Explorer, similar in spirit to a Mac or PC but graphically a little different, here's my file, hello.c.

202
00:15:35,270 --> 00:15:37,520
It's highlighted because I have that tab open.

203
00:15:37,520 --> 00:15:40,970
But now there's a second file here called just hello.

204
00:15:40,970 --> 00:15:42,690
That's the name of my program.

205
00:15:42,690 --> 00:15:46,100
So if you were on a Mac or PC, you would ideally double click that thing.

206
00:15:46,100 --> 00:15:48,162
You can't do that in a command line environment.

207
00:15:48,162 --> 00:15:49,370
You have to run it down here.

208
00:15:49,370 --> 00:15:50,453
But that's all we've done.

209
00:15:50,453 --> 00:15:56,240
We've created a file called hello.c, and then my compiler made the program from that.

210
00:15:56,240 --> 00:16:01,970
Let me pause here and see if there's any questions because that's a lot of magical phrases.

211
00:16:01,970 --> 00:16:04,450
Yeah?

212
00:16:04,450 --> 00:16:04,950
Yeah.

213
00:16:04,950 --> 00:16:13,950
So if you're currently following along, playing along at home and you're getting some kind of error message, part of today will be for me to deliberately induce some of those error messages.

214
00:16:13,950 --> 00:16:19,320
For now let me just propose that if you literally did what I did, you must have made a typo somewhere.

215
00:16:19,320 --> 00:16:23,790
And notice that it's indeed standard io-- stdio.h.

216
00:16:23,790 --> 00:16:25,890
Maybe you typed studio.h?

217
00:16:25,890 --> 00:16:30,600
OK, super common mistake, I could call you out.

218
00:16:30,600 --> 00:16:32,280
It is not studio.h.

219
00:16:32,280 --> 00:16:34,560
It is stdio.h-- so common.

220
00:16:34,560 --> 00:16:41,730
But this is exactly representative of the kind of stupid headaches you're going to run into this week, probably for a few weeks, probably, honestly, for a few years.

221
00:16:41,730 --> 00:16:49,110
But you start to see past these stupid mistakes over time, and it just gets easier and easier because the computer is going to be so regimented.

222
00:16:49,110 --> 00:16:50,950
It will only do what you tell it to do.

223
00:16:50,950 --> 00:16:55,890
And if you say because it's verbally sounds like studio.h, it's not going to know what the file is.

224
00:16:55,890 --> 00:16:58,182
So actually, thank you for tripping over that so early.

225
00:16:58,182 --> 00:16:59,740
That's super common to happen.

226
00:16:59,740 --> 00:17:00,240
Yeah?

227
00:17:00,240 --> 00:17:02,540
AUDIENCE: Why do you have two hello files?

228
00:17:02,540 --> 00:17:03,799
DAVID J. MALAN: Why do I have to hello files?

229
00:17:03,799 --> 00:17:04,400
AUDIENCE: Yes.

230
00:17:04,400 --> 00:17:06,400
DAVID J. MALAN: So why do I have to hello files?

231
00:17:06,400 --> 00:17:10,520
One is the one I created as the human called hello.c, and it's pictured right here.

232
00:17:10,520 --> 00:17:17,040
But then when I ran make hello, that process compiled my source code into machine code.

233
00:17:17,040 --> 00:17:25,700
So this second file just called hello is the file that contains all of those zeros and ones that the server actually understands.

234
00:17:25,700 --> 00:17:27,200
All right, so yeah, question?

235
00:17:27,200 --> 00:17:29,710
AUDIENCE: The access to the hello [INAUDIBLE]

236
00:17:29,710 --> 00:17:38,230
DAVID J. MALAN: If you try clicking on the hello file, you'll see in this environment the VS Code, quote/unquote, The file is not displayed in the editor because it is either binary--

237
00:17:38,230 --> 00:17:41,437
AKA zeros and ones-- or uses an unsupported text encoding.

238
00:17:41,437 --> 00:17:42,520
In this case, it's binary.

239
00:17:42,520 --> 00:17:43,660
It's zeros and ones.

240
00:17:43,660 --> 00:17:47,680
Now, you could use software to see those zeros and ones.

241
00:17:47,680 --> 00:17:50,320
It won't be intellectually enlightening to most any human.

242
00:17:50,320 --> 00:17:53,165
So VS Code just takes the choice of not showing it to you at all.

243
00:17:53,165 --> 00:17:56,290
So that would be a common mistake too, clicking on a file you don't intend.

244
00:17:56,290 --> 00:18:00,190
But the source code is indeed going to be editable by us.

245
00:18:00,190 --> 00:18:01,900
All right, so I've written this program.

246
00:18:01,900 --> 00:18:06,700
It seems to magically work, at least with some effort if you get every single keystroke right.

247
00:18:06,700 --> 00:18:08,440
Well, what is it that's going on?

248
00:18:08,440 --> 00:18:09,460
And how is this working?

249
00:18:09,460 --> 00:18:17,740
Well, first of all, notice that even without my highlighting things or choosing buttons for menus, notice that it's already color coded.

250
00:18:17,740 --> 00:18:22,510
And yet, I wasn't highlighting along the way in Google Docs style, changing the color, certainly.

251
00:18:22,510 --> 00:18:29,600
Well, it turns out, what VS Code and most programming environments nowadays do for you automatically is syntax highlighting.

252
00:18:29,600 --> 00:18:36,760
So syntax highlighting is just this feature of typical text editors nowadays that analyzes the code that you've typed.

253
00:18:36,760 --> 00:18:47,570
And when it notices certain types of keystrokes, things that represent functions, or conditionals, or loops, or variables-- a lot of the vocab from last week-- it just highlights it ever so differently

254
00:18:47,570 --> 00:18:48,070
for you.

255
00:18:48,070 --> 00:18:51,430
So main, for instance, which we'll soon see, is in purple here.

256
00:18:51,430 --> 00:18:53,890
Int, and void, and include are in red.

257
00:18:53,890 --> 00:18:55,630
Hello, world is in blue.

258
00:18:55,630 --> 00:18:57,390
My parentheses are in green.

259
00:18:57,390 --> 00:18:59,290
This will totally vary by programmer too.

260
00:18:59,290 --> 00:19:04,870
In fact, if you do want to change these colors for problem set 1 for your own environment, you can poke around

261
00:19:04,870 --> 00:19:07,190
VS Code Settings via the gear icon.

262
00:19:07,190 --> 00:19:09,820
You can change to a different color theme.

263
00:19:09,820 --> 00:19:13,480
Syntax highlighting isn't some specific color scheme like it is in Scratch.

264
00:19:13,480 --> 00:19:16,485
It just generally is to each human their own preference.

265
00:19:16,485 --> 00:19:20,830
But that's all that's happening here is this notion of syntax highlighting at the moment.

266
00:19:20,830 --> 00:19:25,510
Well, what more is going on in this code before I run it, but rather write it?

267
00:19:25,510 --> 00:19:28,790
Well, it looks a little something like this if I take away all of the colors.

268
00:19:28,790 --> 00:19:32,500
And then just for discussion's sake, let me go ahead and color it a little more like Scratch.

269
00:19:32,500 --> 00:19:45,070
Recall that our very first Scratch program that just said hello, world on the screen had a green flag clicked icon-- puzzle piece, roughly in orange, and then a purple say block beneath it.

270
00:19:45,070 --> 00:19:50,950
So whereas this is the C version, if we run rewind to last week, this was the same program in Scratch.

271
00:19:50,950 --> 00:19:53,090
But what's happening now is exactly the same.

272
00:19:53,090 --> 00:20:03,190
So if you think back to last week and you've got some function, like the say function in purple, that might take one or more arguments, like inputs that influences what it says on the screen.

273
00:20:03,190 --> 00:20:08,480
And then functions, recall, can sometimes have side effects, like the speech bubble appears on the screen.

274
00:20:08,480 --> 00:20:18,790
So last week when we used the say block and we passed in an argument of hello, world at left, we got this visual side effect on the screen that says now hello, world in the speech bubble.

275
00:20:18,790 --> 00:20:23,230
And that's exactly what just happened in VS Code but much, much more textually.

276
00:20:23,230 --> 00:20:25,900
And let's look a little closer now at the code itself.

277
00:20:25,900 --> 00:20:38,350
Let me wave my hand at the equivalent of when green flag clicked part of my code, and let's focus only on the say block in Scratch and the corresponding function in C.

278
00:20:38,350 --> 00:20:44,830
So if I step through this and I wanted to convert what we did last week with the say block to C,

279
00:20:44,830 --> 00:20:48,520
I would first use the print function-- although that's actually a bit of a white lie.

280
00:20:48,520 --> 00:20:50,440
It's actually the printf function.

281
00:20:50,440 --> 00:20:52,030
Printf means formatted.

282
00:20:52,030 --> 00:20:55,360
And it's just a function that allows you to format text on the screen.

283
00:20:55,360 --> 00:20:58,570
There is no say function in C. There's a printf function.

284
00:20:58,570 --> 00:21:08,050
What MIT did down the road years ago was they took what existed historically as printf, and they simplified it for a broader audience by just calling it essentially say instead.

285
00:21:08,050 --> 00:21:16,250
But notice that now if I want to convert the Scratch code at left to C code it right, it's the same shape.

286
00:21:16,250 --> 00:21:23,510
So MIT deliberately used this white oval, if only because it conjures this idea of having parentheses too.

287
00:21:23,510 --> 00:21:31,240
So on the right, if I want to pass an argument or an input to the printf function, I use an open parentheses and a close parentheses.

288
00:21:31,240 --> 00:21:37,460
In those parentheses, I then type whatever it is I want to print on the screen-- in this case, hello, comma, world.

289
00:21:37,460 --> 00:21:42,160
But notice I've deliberately left some room because you need some extra keystrokes in the world of C.

290
00:21:42,160 --> 00:21:52,100
Any time you type out some text-- otherwise known as a string of text, to use computer science jargon-- you need to quote it, in this case with double quotes.

291
00:21:52,100 --> 00:21:54,520
Double quote at the left, double quote at the right.

292
00:21:54,520 --> 00:22:01,660
And notice too I'm going to include some slightly cryptic symbol here too-- backslash n, which I also typed and said verbally earlier,

293
00:22:01,660 --> 00:22:05,480
and then one last nuisance at the end of this, which is a semicolon.

294
00:22:05,480 --> 00:22:08,890
So suffice it to say, this is why we start with Scratch.

295
00:22:08,890 --> 00:22:10,960
This, drag and drop, you're good to go.

296
00:22:10,960 --> 00:22:16,630
In a language like C, printf, parentheses, double quotes, the text you want, backslash n, semicolon at the end.

297
00:22:16,630 --> 00:22:18,970
There's just so much syntactic overhead.

298
00:22:18,970 --> 00:22:21,290
But at the end of the day, it's just a function.

299
00:22:21,290 --> 00:22:27,130
And you'll get used to these nuisances like the parentheses, the quotes, the semicolon, and the like.

300
00:22:27,130 --> 00:22:33,380
But things can very easily you go wrong, and it's very easy to make mistakes, even with lines of code like this.

301
00:22:33,380 --> 00:22:34,190
So let me do this.

302
00:22:34,190 --> 00:22:37,070
Let me go back to VS Code where I have the exact same code.

303
00:22:37,070 --> 00:22:40,910
Notice that on line 5 is exactly that line of code.

304
00:22:40,910 --> 00:22:42,910
So this is the equivalent of the say block.

305
00:22:42,910 --> 00:22:46,090
And let's consider what mistakes I may make early on or even now

306
00:22:46,090 --> 00:22:49,930
20 years later after learning this that are quite common in general.

307
00:22:49,930 --> 00:22:52,180
Suppose I forget the semicolon there.

308
00:22:52,180 --> 00:22:53,380
So easy to do.

309
00:22:53,380 --> 00:22:54,910
You will do this eventually.

310
00:22:54,910 --> 00:22:59,920
Let's see what happens now when I go back to my terminal window and try to compile my code again.

311
00:22:59,920 --> 00:23:02,590
Just to keep things tidy, I'm going to clear my screen.

312
00:23:02,590 --> 00:23:06,460
But that's just for lecture's sake so that we can focus only on the most recent command.

313
00:23:06,460 --> 00:23:09,940
But I'm going to go ahead now and rerun make hello.

314
00:23:09,940 --> 00:23:13,690
This will ensure that my program is recompiled.

315
00:23:13,690 --> 00:23:14,950
And this is a manual process.

316
00:23:14,950 --> 00:23:16,060
I changed my code.

317
00:23:16,060 --> 00:23:18,670
The zeros and ones on the hard drive have not changed.

318
00:23:18,670 --> 00:23:21,980
I need to recompile it to output the latest machine code.

319
00:23:21,980 --> 00:23:22,580
So here we go.

320
00:23:22,580 --> 00:23:24,830
I'm going to hit Enter, crossing my fingers as before.

321
00:23:24,830 --> 00:23:29,320
But again, I remove the semicolon by accident.

322
00:23:29,320 --> 00:23:29,980
Oh, my god.

323
00:23:29,980 --> 00:23:33,700
There's more lines of errors now than there are of actual code.

324
00:23:33,700 --> 00:23:35,770
And this, too, takes some getting used to.

325
00:23:35,770 --> 00:23:42,760
The programs we're using were not necessarily written with the least comfortable audience in mind but, really, professional programmers back in the day.

326
00:23:42,760 --> 00:23:47,750
But through practice, and through experience, and through mistakes, you'll start to notice patterns here too.

327
00:23:47,750 --> 00:23:49,090
So here's what I typed.

328
00:23:49,090 --> 00:23:51,220
Make hello after the sign prompt.

329
00:23:51,220 --> 00:23:57,010
Now I get yelled at as follows, hello.c, colon, 5, colon, 29.

330
00:23:57,010 --> 00:23:58,420
Well, what's that referring to?

331
00:23:58,420 --> 00:24:03,460
I've screwed up somewhere-- on line 5, on the 29th character on that line.

332
00:24:03,460 --> 00:24:07,448
Generally, the specific character is not that useful unless you actually want to count it out.

333
00:24:07,448 --> 00:24:08,630
But line 5 is a good clue.

334
00:24:08,630 --> 00:24:09,130
Why?

335
00:24:09,130 --> 00:24:11,660
It means I screwed up somewhere on line 5 here.

336
00:24:11,660 --> 00:24:12,160
All right.

337
00:24:12,160 --> 00:24:13,360
Well, what is the error?

338
00:24:13,360 --> 00:24:16,242
Expected a semicolon after expression.

339
00:24:16,242 --> 00:24:20,103
And this error is actually pretty obvious now that I see it and I realize, oh, wait a minute.

340
00:24:20,103 --> 00:24:21,520
All right, here's my line of code.

341
00:24:21,520 --> 00:24:30,550
Here in sort of ASCII art, so to speak-- textual text representing graphics-- it wants me to put in green here the semicolon at the end of that line.

342
00:24:30,550 --> 00:24:33,850
1 error generated, builtin-- so some esoteric stuff there.

343
00:24:33,850 --> 00:24:36,340
But my program did not compile.

344
00:24:36,340 --> 00:24:39,470
When you see an error like this, it means it did not work.

345
00:24:39,470 --> 00:24:40,360
So what's the fix?

346
00:24:40,360 --> 00:24:45,470
Well, obviously, the fix is to go back up here, put the semicolon there.

347
00:24:45,470 --> 00:24:48,760
And now if I recompile my code with make hello--

348
00:24:48,760 --> 00:24:52,990
I won't clear my screen just yet just to show you the difference-- now it just worked.

349
00:24:52,990 --> 00:24:55,550
So we're back in business as before.

350
00:24:55,550 --> 00:25:02,240
All right, let me pause here, though, and ask if there's any questions about what I just did.

351
00:25:02,240 --> 00:25:04,460
These error messages will become frequent initially.

352
00:25:04,460 --> 00:25:04,960
Yeah?

353
00:25:04,960 --> 00:25:08,848
AUDIENCE: So do you need a semicolon after line or just some of them?

354
00:25:08,848 --> 00:25:10,390
DAVID J. MALAN: Really good question.

355
00:25:10,390 --> 00:25:12,960
Do you need a semicolon after every line or just some?

356
00:25:12,960 --> 00:25:14,022
It turns out, just some.

357
00:25:14,022 --> 00:25:18,240
This is something you'll learn through practice, through demonstrations and examples today.

358
00:25:18,240 --> 00:25:22,810
Generally, you put a semicolon after a statement, so to speak.

359
00:25:22,810 --> 00:25:25,230
And this is the technical term for this line of code.

360
00:25:25,230 --> 00:25:25,950
It's a statement.

361
00:25:25,950 --> 00:25:29,230
And think of it as it's the code equivalent of an English sentence.

362
00:25:29,230 --> 00:25:34,830
So the semicolon in code is like a period in English when you're done with that particular thought.

363
00:25:34,830 --> 00:25:37,650
You don't need semicolons for now anywhere else.

364
00:25:37,650 --> 00:25:39,750
And we'll see examples of where else you put them.

365
00:25:39,750 --> 00:25:46,980
But it usually is at the end of a line of code that isn't purely syntactic like curly braces instead.

366
00:25:46,980 --> 00:25:51,600
Other questions on the mistake I just fixed and created for myself?

367
00:25:51,600 --> 00:25:52,230
Yeah?

368
00:25:52,230 --> 00:25:55,170
AUDIENCE: [INAUDIBLE]

369
00:25:55,170 --> 00:25:56,170
DAVID J. MALAN: Correct.

370
00:25:56,170 --> 00:25:58,950
So line 5 is where the error is most likely.

371
00:25:58,950 --> 00:26:02,250
Character 29 means it's 29 characters that way.

372
00:26:02,250 --> 00:26:04,800
And then it's actually, in this case, giving me a suggestion.

373
00:26:04,800 --> 00:26:09,750
The compiler won't always know how to advise me, especially if I've made a real mess of my code.

374
00:26:09,750 --> 00:26:13,260
But often, it will do its best to give you the answer like this.

375
00:26:13,260 --> 00:26:14,170
Yeah?

376
00:26:14,170 --> 00:26:16,930
AUDIENCE: How come you first put code hello.c?

377
00:26:16,930 --> 00:26:22,940
DAVID J. MALAN: Ah, so how come I first typed code, space, hello.c, and now I'm typing make hello?

378
00:26:22,940 --> 00:26:24,180
Two different processes.

379
00:26:24,180 --> 00:26:31,280
So when I typed code, space, hello.c, that was because I wanted to open VS Code and create a new file called hello.c.

380
00:26:31,280 --> 00:26:34,910
It's like going to File, New in a Mac or PC.

381
00:26:34,910 --> 00:26:42,560
Thereafter, though, once the file exists and is actually open here-- and it does autosave, you don't need to hit Command-S or Control-S all the time--

382
00:26:42,560 --> 00:26:46,110
I can now compile it with make hello again and again.

383
00:26:46,110 --> 00:26:54,020
So theoretically, I should never need to type code, space, hello.c again unless I want to create a brand-new file called the same thing.

384
00:26:54,020 --> 00:26:57,200
All right, so what about this other piece of syntax here?

385
00:26:57,200 --> 00:26:58,790
Let me clear my terminal window here.

386
00:26:58,790 --> 00:27:03,380
You can also hit Control-L just to throw everything away just to clean it up aesthetically.

387
00:27:03,380 --> 00:27:11,460
Suppose that I omit whatever this sequence of symbols is, backslash n, since I'm not really sure at first glance why that's even there.

388
00:27:11,460 --> 00:27:20,450
Does anyone want to conjecture, especially if you've never programmed before, what might happen now if I recompile and rerun this version of the program?

389
00:27:20,450 --> 00:27:25,130
I left the semicolon, but I took away the backslash n.

390
00:27:25,130 --> 00:27:28,390
Any instincts?

391
00:27:28,390 --> 00:27:29,920
All right, well-- yeah?

392
00:27:29,920 --> 00:27:34,190
AUDIENCE: Will the next dollar sign appear straight after your hello, world?

393
00:27:34,190 --> 00:27:35,190
DAVID J. MALAN: It will.

394
00:27:35,190 --> 00:27:38,740
The next dollar sign will appear right after my hello, world.

395
00:27:38,740 --> 00:27:40,564
But what makes you think that?

396
00:27:40,564 --> 00:27:43,010
AUDIENCE: Because the backslash n creates a new line?

397
00:27:43,010 --> 00:27:44,010
DAVID J. MALAN: Exactly.

398
00:27:44,010 --> 00:27:48,060
Backslash n is actually a special sequence of symbols that creates a new line.

399
00:27:48,060 --> 00:27:55,420
And so, to your point, if I recompile this program, make hello, Enter-- no syntax error, so it did compile this time.

400
00:27:55,420 --> 00:27:57,180
So you don't need the backslash n.

401
00:27:57,180 --> 00:27:58,800
You do need the semicolon.

402
00:27:58,800 --> 00:28:03,510
But if you don't have the backslash n, watch what happens when I do ./hello this time.

403
00:28:03,510 --> 00:28:07,230
Now, indeed, I see hello, comma, world and then a weird dollar sign.

404
00:28:07,230 --> 00:28:08,460
And this is still a prompt.

405
00:28:08,460 --> 00:28:12,270
I can still type commands at it, like clear, and everything gets cleaned up.

406
00:28:12,270 --> 00:28:13,710
But it just looks kind of stupid.

407
00:28:13,710 --> 00:28:18,240
If I run it again here with ./hello, it's just not very user friendly.

408
00:28:18,240 --> 00:28:24,460
It is convention that when you're done running your program, you should ideally clean things up, move the cursor to the next line for the user.

409
00:28:24,460 --> 00:28:34,980
And so the backslash n is simply the special symbol, otherwise known as an escape sequence that C knows means move the cursor to the next line.

410
00:28:34,980 --> 00:28:39,640
In other languages, Python among them, uses this same symbology as well.

411
00:28:39,640 --> 00:28:44,850
Now, if I go back to the code here and, for instance,

412
00:28:44,850 --> 00:28:47,220
I try to do this differently.

413
00:28:47,220 --> 00:28:49,020
Suppose I don't put the backslash n.

414
00:28:49,020 --> 00:28:52,860
I just hit Enter like a normal person would in Google Docs or Microsoft Word.

415
00:28:52,860 --> 00:28:55,107
Let me go ahead and try compiling this program.

416
00:28:55,107 --> 00:28:56,940
And this, you would hope, would work, right?

417
00:28:56,940 --> 00:29:02,220
You would hope this would print out hello, world and then a blank line because I move the cursor to the next line.

418
00:29:02,220 --> 00:29:02,790
But no.

419
00:29:02,790 --> 00:29:07,290
If I run make hello now and try to compile that, C does not like this.

420
00:29:07,290 --> 00:29:17,070
Now I get a different error, still on line 5, this time starting at character 12-- error, missing terminating double quote character and then some other esoteric stuff.

421
00:29:17,070 --> 00:29:21,900
And then this does not sound good-- fatal error this time, too many errors emitted, stopping now.

422
00:29:21,900 --> 00:29:23,470
So I really screwed up here.

423
00:29:23,470 --> 00:29:25,320
So why can't I do this?

424
00:29:25,320 --> 00:29:26,190
Just because.

425
00:29:26,190 --> 00:29:31,380
The humans who designed C decided that if you have a string of text, it must stay on the same line.

426
00:29:31,380 --> 00:29:32,760
It can get really long.

427
00:29:32,760 --> 00:29:36,150
It can soft wrap-- that is, without you hitting Enter.

428
00:29:36,150 --> 00:29:38,220
But you can't hit Enter to create a new line.

429
00:29:38,220 --> 00:29:43,958
If you deliberately want a new line, you have to indeed use this backslash n escape character.

430
00:29:43,958 --> 00:29:45,250
So let me go ahead and do this.

431
00:29:45,250 --> 00:29:46,710
Let me put it back.

432
00:29:46,710 --> 00:29:48,720
Let me go back to my terminal window.

433
00:29:48,720 --> 00:29:50,080
I'll clear the screen again.

434
00:29:50,080 --> 00:29:54,090
Let me go ahead now and do make hello to recompile to that version-- ./hello.

435
00:29:54,090 --> 00:29:54,900
And voila.

436
00:29:54,900 --> 00:29:57,780
We're back in business with hello.

437
00:29:57,780 --> 00:30:04,920
All right, so now let's tease apart some other aspects of this code because there's a lot going on just to get us to say hello, world on the screen.

438
00:30:04,920 --> 00:30:10,145
For today, we're largely going to ignore this-- int main(void) and these curly braces here.

439
00:30:10,145 --> 00:30:12,520
We'll come back to that before long as to why it's there.

440
00:30:12,520 --> 00:30:19,180
But for now just think of int main(void) and these curly braces here as really being the C equivalent of when green flag clicked.

441
00:30:19,180 --> 00:30:19,680
Why?

442
00:30:19,680 --> 00:30:20,638
You just need it there.

443
00:30:20,638 --> 00:30:22,320
That's how you get your program going.

444
00:30:22,320 --> 00:30:26,340
And main is indeed going to be some special function, but more on that another time.

445
00:30:26,340 --> 00:30:28,950
But why do I have this line of code here?

446
00:30:28,950 --> 00:30:33,990
The correct spelling is indeed stdio.h, S-T-D-I-O dot H.

447
00:30:33,990 --> 00:30:37,500
And they're angled brackets this time, so that's a little new.

448
00:30:37,500 --> 00:30:40,290
There's a hash and then an include keyword.

449
00:30:40,290 --> 00:30:45,165
If you don't know what something is, there's not really that much harm in just getting rid of it and see what happens.

450
00:30:45,165 --> 00:30:46,360
So let me delete that line.

451
00:30:46,360 --> 00:30:50,160
Let me go back to my terminal window, clear the screen, and then run make hello again.

452
00:30:50,160 --> 00:30:53,290
And let's try compiling this program now without that first line.

453
00:30:53,290 --> 00:30:53,790
Why?

454
00:30:53,790 --> 00:30:56,340
I don't understand it, so let's see what happens.

455
00:30:56,340 --> 00:31:09,150
All right, here's yet another error, but let's see-- hello.c, line 5, character 5-- so it's pretty early on-- error, implicitly declaring library function printf with type int and then dot, dot, dot.

456
00:31:09,150 --> 00:31:14,490
So implicitly declaring library function printf-- so this is very cryptic sounding.

457
00:31:14,490 --> 00:31:16,920
You'll get better at understanding phrases like these.

458
00:31:16,920 --> 00:31:22,620
But apparently, I do need the include line for stdio.h.

459
00:31:22,620 --> 00:31:23,820
But why?

460
00:31:23,820 --> 00:31:33,330
Based on this symptom, what might your instinct be for what that first line of code is doing for us in the first place?

461
00:31:33,330 --> 00:31:35,370
Why intuitively must it be there?

462
00:31:35,370 --> 00:31:37,290
AUDIENCE: It's how the [INAUDIBLE] functions.

463
00:31:37,290 --> 00:31:38,290
DAVID J. MALAN: Exactly.

464
00:31:38,290 --> 00:31:42,137
It's like importing a library so that you can do things like print things out on the screen.

465
00:31:42,137 --> 00:31:45,220
Now, in Scratch, you didn't have to do this for most of the puzzle pieces.

466
00:31:45,220 --> 00:31:47,950
But you might recall that partway through week 0,

467
00:31:47,950 --> 00:31:59,170
I went to the Extensions button at the bottom left of the Scratch screen, and I imported some extra puzzle pieces for text to speech that gave us the creepy humanized voice that actually came out

468
00:31:59,170 --> 00:32:00,100
of the cat's mouth.

469
00:32:00,100 --> 00:32:04,390
Well, that was like adding a library-- code that someone else wrote.

470
00:32:04,390 --> 00:32:06,550
In that case, it was a third party.

471
00:32:06,550 --> 00:32:08,380
But I gave myself access to it.

472
00:32:08,380 --> 00:32:09,250
Same here.

473
00:32:09,250 --> 00:32:13,900
Turns out that you don't really get printf automatically in C.

474
00:32:13,900 --> 00:32:20,020
You have to include a so-called header file that declares that function to exist.

475
00:32:20,020 --> 00:32:22,570
Now, the reason for this historically is just efficiency.

476
00:32:22,570 --> 00:32:30,610
Back in the day when computers were really slower and resource constrained, you don't want to just give yourself access to the entire kitchen sink of functionality.

477
00:32:30,610 --> 00:32:34,690
You only want to include only the functions you actually care about.

478
00:32:34,690 --> 00:32:42,680
Nowadays, it's a copy/paste step because you almost always want to print something out on the screen, at least when writing programs like these.

479
00:32:42,680 --> 00:32:50,350
But these so-called header files contain enough information about all of the functions in what's called the Standard I/O Library.

480
00:32:50,350 --> 00:32:53,450
And standard I/O just means standard Input and Output.

481
00:32:53,450 --> 00:32:54,700
And that's appropriate, right?

482
00:32:54,700 --> 00:32:57,010
Because printing is pretty basic output.

483
00:32:57,010 --> 00:33:01,310
Turns out, there's other functions for getting input from the human's keyboard-- more on that in a bit.

484
00:33:01,310 --> 00:33:07,630
But any time you want to print something on the screen in C, you indeed need to include this header file at the top of your code.

485
00:33:07,630 --> 00:33:11,350
And that's going to essentially inform the compiler, hey, compiler,

486
00:33:11,350 --> 00:33:18,320
I want to use functionality from the Standard I/O Library, including printf in this case.

487
00:33:18,320 --> 00:33:24,040
And if you omit the header file by accident, it's just not going to work because it doesn't know what printf is.

488
00:33:24,040 --> 00:33:27,970
It's some unrecognized symbol in that case.

489
00:33:27,970 --> 00:33:37,590
All right, questions, then, about this line of code, this line of code here, or what these header files are?

490
00:33:37,590 --> 00:33:40,890
All right, you might wonder, well, how do you know what functions exist?

491
00:33:40,890 --> 00:33:43,990
How do you know what files you might indeed want to include?

492
00:33:43,990 --> 00:33:48,720
Well, it turns out that C is a many-year-old language, and it has ample documentation.

493
00:33:48,720 --> 00:33:52,770
A caveat is that its documentation isn't necessarily all that user friendly.

494
00:33:52,770 --> 00:34:01,680
But what we have for the course is a simplified version of the official documentation for C at this URL here, manual.cs50.io.

495
00:34:01,680 --> 00:34:06,150
So in the world of C, and other languages too, there are what are called manual pages.

496
00:34:06,150 --> 00:34:14,560
And these are just text-based documentation that, honestly, is typically written in a voice that you have to be an experienced programmer to understand some of it.

497
00:34:14,560 --> 00:34:24,074
So what we've done in this version of the same documentation is we've imported all of the original official documentation, but we've added less comfortable translations in English

498
00:34:24,074 --> 00:34:27,713
for a lot of the functionality that you might use in class just to help onboard you.

499
00:34:27,713 --> 00:34:30,630
So at the end of the day, you don't need this documentation long term.

500
00:34:30,630 --> 00:34:39,969
But just to get started, we'll translate it into terminology that you might appreciate from a teaching assistant, for instance, as opposed to the original author of these documents.

501
00:34:39,969 --> 00:34:52,830
And so, for instance, if you were interested in reading up on what functions exist in the stdio.h file, well, you could go to a URL like this, or you could search for it at manual.cs50.io.

502
00:34:52,830 --> 00:34:58,350
That would show you a list of all of the available functions in that library, and print if indeed would be one of them.

503
00:34:58,350 --> 00:35:04,110
And then you could click further on that, reaching a URL like this that's going to give you all of the documentation for how to use printf.

504
00:35:04,110 --> 00:35:07,560
It turns out, you can do even more than just printing out hello, world.

505
00:35:07,560 --> 00:35:09,450
And we'll scratch the surface of that today.

506
00:35:09,450 --> 00:35:18,160
But it turns out that the documentation will always be your authoritative source ultimately for questions like, what can I do, and how can I do it?

507
00:35:18,160 --> 00:35:25,980
Meanwhile, it turns out that CS50 has its own library and accessible via header file called cs50.h.

508
00:35:25,980 --> 00:35:34,110
It turns out in C that output is actually pretty easy, relatively speaking, once you get used to all the curly braces, parentheses, quote marks, and the like.

509
00:35:34,110 --> 00:35:36,670
But input is a little more difficult.

510
00:35:36,670 --> 00:35:41,100
And if you have programmed before, input's not that hard to do in Python.

511
00:35:41,100 --> 00:35:42,540
It's not that hard to do in Java.

512
00:35:42,540 --> 00:35:46,312
It's more difficult to do in C. And we'll see why in a couple of weeks.

513
00:35:46,312 --> 00:35:56,430
But for the first couple of weeks of the class, we actually provide you with some training wheels, of sorts, whereby we have a number of functions that are declared in this file, cs50.h.

514
00:35:56,430 --> 00:35:59,220
It lives its documentation at a URL like this.

515
00:35:59,220 --> 00:36:01,230
And in a moment, we'll use a few of these.

516
00:36:01,230 --> 00:36:11,790
You'll see that CS50 provides you with some functions like get_char for get a single character from the user's keyboard, get_int to get an integer from the user's keyboard,

517
00:36:11,790 --> 00:36:16,930
get_string to get a sequence of text from the user's keyboard, and a bunch of others as well.

518
00:36:16,930 --> 00:36:26,710
So let's actually use some of these functions, how about, by revisiting, really, the second program we wrote in Scratch last time, which adds some input to the output.

519
00:36:26,710 --> 00:36:28,830
So first version of Scratch was just hello, world.

520
00:36:28,830 --> 00:36:31,200
Said the same thing every time you click the green flag.

521
00:36:31,200 --> 00:36:33,180
Version 2, recall, though, did this.

522
00:36:33,180 --> 00:36:35,190
It asked the user, what's your name?

523
00:36:35,190 --> 00:36:40,870
And then that somehow gave it back a return value, we called it.

524
00:36:40,870 --> 00:36:46,420
And we then joined hello and that name to say something a little more interesting on the screen.

525
00:36:46,420 --> 00:36:48,420
So what did that model look like?

526
00:36:48,420 --> 00:36:49,560
Same thing as before.

527
00:36:49,560 --> 00:36:54,480
We've got a function in the middle where function is like the code implementation of our algorithm.

528
00:36:54,480 --> 00:37:00,000
That takes in one or more arguments, like what is it you want to say on the screen ultimately?

529
00:37:00,000 --> 00:37:03,580
And return value, in this case, is going to be actually a value that comes back.

530
00:37:03,580 --> 00:37:08,490
So in the case of getting input, we can consider this ask block again, like last week.

531
00:37:08,490 --> 00:37:12,420
The input to it is whatever words of English you want to ask the user.

532
00:37:12,420 --> 00:37:14,670
And then it returns a value.

533
00:37:14,670 --> 00:37:17,550
And this was called by default in MIT'S world answer.

534
00:37:17,550 --> 00:37:22,300
But we'll see in C, you can call these return values anything you want ultimately in variables.

535
00:37:22,300 --> 00:37:24,100
But this is different from a side effect.

536
00:37:24,100 --> 00:37:28,980
A side effect is just something visual often that happens on the screen, like the speech bubble or hello, world.

537
00:37:28,980 --> 00:37:34,020
A return value is actually a value you get back from a function that you can use or reuse.

538
00:37:34,020 --> 00:37:38,400
So how do we convert this Scratch block from last week to C code this week?

539
00:37:38,400 --> 00:37:42,580
Well, if you want to ask the user for something like their name, you can do this.

540
00:37:42,580 --> 00:37:45,600
You use a CS50 function called get_string.

541
00:37:45,600 --> 00:37:49,950
And you use the parentheses to represent here comes the inputs there too.

542
00:37:49,950 --> 00:37:54,300
You can then put the sentence you want to ask the user-- quote/unquote, what's your name?

543
00:37:54,300 --> 00:37:57,150
But you do indeed need the quotes literally in C.

544
00:37:57,150 --> 00:37:59,220
So I'll go ahead and add those as well.

545
00:37:59,220 --> 00:38:08,998
Subtle, but I've deliberately included a space after the question mark, but before the double quote, just so that the cursor moves one step over because, in this case,

546
00:38:08,998 --> 00:38:11,790
we're not going to get a special speech box like we did in Scratch.

547
00:38:11,790 --> 00:38:19,800
It's just going to leave the cursor where it is, so we'll see that, aesthetically, that just moves the blinking cursor one space after the sentence on the screen.

548
00:38:19,800 --> 00:38:27,180
All right, but the catch is with Scratch, we just automatically got back the answer from the user in a special variable called answer.

549
00:38:27,180 --> 00:38:30,270
In C, you're going to have to be a little more specific.

550
00:38:30,270 --> 00:38:40,420
In C, If you want to get back a return value from a function like get_string, you have to use an equal sign and then the name of a variable on the left.

551
00:38:40,420 --> 00:38:42,280
The choice of variables is up to you.

552
00:38:42,280 --> 00:38:44,290
I could have called this anything-- x, y, z.

553
00:38:44,290 --> 00:38:47,470
I'm going to more descriptively call it answer for parity with what

554
00:38:47,470 --> 00:38:48,880
MIT did with Scratch.

555
00:38:48,880 --> 00:38:53,090
But notice that this doesn't represent equality, per se.

556
00:38:53,090 --> 00:38:55,640
This is assignment in this case.

557
00:38:55,640 --> 00:39:03,590
So in C, when you use a single equal sign, that means copy the value on the right over to the value on the left-- from right to left.

558
00:39:03,590 --> 00:39:05,390
So what does this do for us?

559
00:39:05,390 --> 00:39:14,750
Well, if get_string is a function that prompts the user with, quote/unquote, what's your name, and it has I claim a return value, that means it hands me back some value.

560
00:39:14,750 --> 00:39:17,960
But it's up to me in C to do something with that value.

561
00:39:17,960 --> 00:39:21,520
So if I want to copy that value into a variable that I can use and reuse,

562
00:39:21,520 --> 00:39:27,340
I use an equal sign, and I invent on the left-hand side of that equal sign any variable name I want.

563
00:39:27,340 --> 00:39:28,450
There are certain rules.

564
00:39:28,450 --> 00:39:29,700
There are certain conventions.

565
00:39:29,700 --> 00:39:34,570
But generally if you use a single word with all lowercase, you're in good shape.

566
00:39:34,570 --> 00:39:37,040
But C's a little more pedantic than that.

567
00:39:37,040 --> 00:39:43,330
And those of you who have programmed before might not be used to this, for instance, in Python, which is a world we'll get to in a few weeks.

568
00:39:43,330 --> 00:39:48,670
You also have to tell C what type of value you're storing.

569
00:39:48,670 --> 00:39:55,270
So if I do want a string of text from the user-- so not an integer, not a single character.

570
00:39:55,270 --> 00:39:59,270
I want a whole string of text, like a phrase, a sentence, a name, in this case--

571
00:39:59,270 --> 00:40:04,250
I have to tell C that this variable is of type string.

572
00:40:04,250 --> 00:40:06,267
So it's a little wordy, but you get used to it.

573
00:40:06,267 --> 00:40:07,600
And you just have to be precise.

574
00:40:07,600 --> 00:40:12,760
You're informing the computer what type of value is going in this variable.

575
00:40:12,760 --> 00:40:19,210
All right, it's so close to being correct, but I have omitted something that's annoyingly important still.

576
00:40:19,210 --> 00:40:20,470
What's missing still?

577
00:40:20,470 --> 00:40:21,070
Yeah?

578
00:40:21,070 --> 00:40:21,970
AUDIENCE: Semicolon?

579
00:40:21,970 --> 00:40:23,178
DAVID J. MALAN: So semicolon.

580
00:40:23,178 --> 00:40:24,230
This is a statement.

581
00:40:24,230 --> 00:40:27,040
This is like a full thought, if you will.

582
00:40:27,040 --> 00:40:31,680
In Code, I do need to end it ultimately with the semicolon at the end there.

583
00:40:31,680 --> 00:40:35,720
All right, so this was more of a mouthful, but let's try using this in now my code.

584
00:40:35,720 --> 00:40:40,250
Let me go back to VS Code where I have version 0 of my code here.

585
00:40:40,250 --> 00:40:51,370
Let me go ahead and include one other file at the top of hello.c, namely include cs50.h so that I have access now to get_string and anything else I might want.

586
00:40:51,370 --> 00:40:56,710
Now let me go ahead and add a line of code here inside of these curly braces.

587
00:40:56,710 --> 00:41:04,847
And let me go ahead and do this-- string answer equals get_string, quote/unquote, what's your name, question mark.

588
00:41:04,847 --> 00:41:07,180
I'm going to add an extra space before the double quote.

589
00:41:07,180 --> 00:41:10,430
I'm going to indeed end my thought with a semicolon.

590
00:41:10,430 --> 00:41:14,260
And now let me deliberately make a mistake, just to make a point here.

591
00:41:14,260 --> 00:41:19,840
Let me now try changing hello, world to hello, comma, answer.

592
00:41:19,840 --> 00:41:24,520
Now, perhaps, even though this is some new lines of code, you can see where I've errored already.

593
00:41:24,520 --> 00:41:26,980
But let me try making this program now.

594
00:41:26,980 --> 00:41:27,970
So far, so good.

595
00:41:27,970 --> 00:41:29,120
So no error messages.

596
00:41:29,120 --> 00:41:30,140
So that's a good thing.

597
00:41:30,140 --> 00:41:34,000
Let me go ahead and run ./hello, and you'll see the prompt.

598
00:41:34,000 --> 00:41:35,650
What's your name, question mark.

599
00:41:35,650 --> 00:41:43,600
And notice, the cursor is indeed one space to the right just because I thought it would look prettier to put a little blank space there as opposed to leaving it right after the question mark.

600
00:41:43,600 --> 00:41:44,530
Let me type my name.

601
00:41:44,530 --> 00:41:48,340
But even if you've never programmed before, I have screwed up here.

602
00:41:48,340 --> 00:41:51,240
What are we going to see on the screen when I hit Enter?

603
00:41:51,240 --> 00:41:52,240
AUDIENCE: Hello, answer.

604
00:41:52,240 --> 00:41:53,115
DAVID J. MALAN: Yeah.

605
00:41:53,115 --> 00:41:54,280
Hello, answer, most likely.

606
00:41:54,280 --> 00:41:54,730
Why?

607
00:41:54,730 --> 00:41:56,855
Because the computer is going to take me literally.

608
00:41:56,855 --> 00:41:59,020
And if I say, quote/unquote, hello, answer.

609
00:41:59,020 --> 00:42:03,260
That is the string of text followed by a new line that's going to be outputted to the screen.

610
00:42:03,260 --> 00:42:08,530
So we need some way of actually plugging answer into this line of code.

611
00:42:08,530 --> 00:42:14,140
It's not quite as simple as scratch where you could just grab a second say block and drag and drop the variable there.

612
00:42:14,140 --> 00:42:15,670
We actually need a new syntax.

613
00:42:15,670 --> 00:42:22,900
And it's going to look weird at first, but it is everywhere in software nowadays, especially in the world of C and certain other languages.

614
00:42:22,900 --> 00:42:27,610
So let me go ahead and propose that I solve it as follows.

615
00:42:27,610 --> 00:42:32,350
Well, back when we did this in Scratch, remember that the most elegant solution was this here.

616
00:42:32,350 --> 00:42:36,550
We used the say block still, which is going to be analogous to printf today.

617
00:42:36,550 --> 00:42:43,340
But I use the join puzzle piece and Scratch to combine hello, comma, space, and then the name of the human.

618
00:42:43,340 --> 00:42:45,790
So how do we translate this code to C?

619
00:42:45,790 --> 00:42:47,830
Well, it's going to look a little different now.

620
00:42:47,830 --> 00:42:53,530
I'm going to start with printf with some parentheses and a semicolon representing the say block.

621
00:42:53,530 --> 00:42:55,240
But how do I now do this joining?

622
00:42:55,240 --> 00:42:58,330
This is where the puzzle pieces don't quite translate perfectly.

623
00:42:58,330 --> 00:43:00,290
This would be the way to do this.

624
00:43:00,290 --> 00:43:03,430
You put hello, comma, and then a placeholder.

625
00:43:03,430 --> 00:43:07,810
So this is what's known as a format code in C, specifically for printf.

626
00:43:07,810 --> 00:43:11,350
And it just means this is a placeholder for a string.

627
00:43:11,350 --> 00:43:12,740
Again, a string is just text.

628
00:43:12,740 --> 00:43:23,903
So this means, hey, computer, print out literally, hello, comma, space, and then not literally %s. %s is treated specially to mean plug in some value here.

629
00:43:23,903 --> 00:43:25,570
All right, so what else do I still need?

630
00:43:25,570 --> 00:43:32,460
Well, this is still some text, so I'm still going to surround the whole thing with double quotes.

631
00:43:32,460 --> 00:43:37,870
I'm still going to include my backslash n just to keep things tidy and move the cursor to the next line.

632
00:43:37,870 --> 00:43:45,120
So the last step here in C is to somehow join the answer with that word hello.

633
00:43:45,120 --> 00:43:51,000
And the way you do this is with printf, passing it not one argument, which is what I keep doing.

634
00:43:51,000 --> 00:43:53,820
I keep passing it one string of text, quote/unquote.

635
00:43:53,820 --> 00:44:02,760
I'm going to now add a comma and then the name of the value that I want printf to go back and plug into that %s.

636
00:44:02,760 --> 00:44:04,410
And printf is just smart about this.

637
00:44:04,410 --> 00:44:10,980
If you have one %s and one additional argument after a comma, it just does-- from right to left, it plugs it in.

638
00:44:10,980 --> 00:44:16,470
If you have two %s's and two variables after the comma, that's OK too.

639
00:44:16,470 --> 00:44:22,380
If you separate them with commas, it'll plug the first into the first %s and the second variable into the second %s.

640
00:44:22,380 --> 00:44:24,750
So it's just left to right, order of operations.

641
00:44:24,750 --> 00:44:30,302
It's not as pretty or as simple as this, but this is how it's done in C.

642
00:44:30,302 --> 00:44:32,760
All right, let me pause because this is a lot of symbology.

643
00:44:32,760 --> 00:44:35,080
Any questions on this technique here?

644
00:44:35,080 --> 00:44:35,580
Yeah?

645
00:44:35,580 --> 00:44:39,725
AUDIENCE: Why did you exclude the backslash n in the previous section?

646
00:44:39,725 --> 00:44:41,600
DAVID J. MALAN: Yeah, a really good question.

647
00:44:41,600 --> 00:44:45,550
Why did I exclude the backslash n a moment ago?

648
00:44:45,550 --> 00:44:48,280
Really, just my sense of aesthetics, if you will.

649
00:44:48,280 --> 00:44:49,760
No good reason beyond that.

650
00:44:49,760 --> 00:44:54,460
So if I look back at my code, you quite rightly notice that I didn't have a backslash n there.

651
00:44:54,460 --> 00:44:57,400
That's just because, for whatever sense of style that I have,

652
00:44:57,400 --> 00:45:00,460
I wanted the name to be typed right after the question.

653
00:45:00,460 --> 00:45:04,030
I totally could have added a backslash n there instead of a space.

654
00:45:04,030 --> 00:45:06,490
That would have just allowed me to type down here.

655
00:45:06,490 --> 00:45:07,490
Totally fine.

656
00:45:07,490 --> 00:45:09,670
Just wanted to show you something different.

657
00:45:09,670 --> 00:45:10,210
Good catch.

658
00:45:10,210 --> 00:45:10,660
Yeah?

659
00:45:10,660 --> 00:45:12,070
AUDIENCE: Can you show an example with two %s's?

660
00:45:12,070 --> 00:45:14,470
DAVID J. MALAN: Can I show an example with two %s's?

661
00:45:14,470 --> 00:45:15,250
Surely.

662
00:45:15,250 --> 00:45:17,570
So let me in VS Code do this.

663
00:45:17,570 --> 00:45:20,050
Let me clear my terminal window to clean things up.

664
00:45:20,050 --> 00:45:21,170
And let me do this.

665
00:45:21,170 --> 00:45:26,080
Instead of calling the variable answer all over the place, let me call it first.

666
00:45:26,080 --> 00:45:27,490
And I'll ask two questions.

667
00:45:27,490 --> 00:45:28,880
What's your first name?

668
00:45:28,880 --> 00:45:41,720
And now let me do string last equals get_string-- whoops, capitalization matters, so let me fix my capital S there-- quote/unquote, What's your last name, question mark, semicolon.

669
00:45:41,720 --> 00:45:47,320
And now we'll plug in one %s and a second %s.

670
00:45:47,320 --> 00:45:52,720
And now I'm going to plug in first first and last last, coincidentally.

671
00:45:52,720 --> 00:45:55,240
And now I'm going to go back to the terminal window.

672
00:45:55,240 --> 00:46:00,280
Make hello-- crossing my fingers, all good-- ./hello.

673
00:46:00,280 --> 00:46:02,620
Here's my first question, David.

674
00:46:02,620 --> 00:46:04,240
Here's my second question, Malan.

675
00:46:04,240 --> 00:46:05,650
And again?

676
00:46:05,650 --> 00:46:06,670
Hello, David Malan.

677
00:46:06,670 --> 00:46:08,440
So it just inserts them left to right.

678
00:46:08,440 --> 00:46:12,670
All I was doing for parity with Scratch though-- and let me go ahead and undo this again.

679
00:46:12,670 --> 00:46:15,130
I'll go back to answer, like this.

680
00:46:15,130 --> 00:46:17,800
I'll go back to just asking for the person's name.

681
00:46:17,800 --> 00:46:19,300
I'm going to delete mention of last.

682
00:46:19,300 --> 00:46:21,520
I'm going to delete mention of the second %s.

683
00:46:21,520 --> 00:46:27,720
And now if I recompile this simpler version, oh, I did screw up-- didn't intend it.

684
00:46:27,720 --> 00:46:29,220
What did I do wrong?

685
00:46:29,220 --> 00:46:31,353
AUDIENCE: You forgot to change first in line 7.

686
00:46:31,353 --> 00:46:33,270
DAVID J. MALAN: Yeah, so just newbie mistakes.

687
00:46:33,270 --> 00:46:39,610
So I changed my variable back to answer just to be consistent with week 0, but I didn't change it here.

688
00:46:39,610 --> 00:46:42,750
So I have an use of undeclared identifier first.

689
00:46:42,750 --> 00:46:46,470
It's undeclared in the sense that I declared answer a line prior.

690
00:46:46,470 --> 00:46:47,950
I didn't declare first.

691
00:46:47,950 --> 00:46:51,060
So indeed, intuitively, I want to just change that to that.

692
00:46:51,060 --> 00:46:56,740
Let me now do make hello again, ./hello, type in just my first name this time.

693
00:46:56,740 --> 00:46:59,400
And there it is-- hello, David.

694
00:46:59,400 --> 00:47:02,220
Questions on this then syntax with printf?

695
00:47:02,220 --> 00:47:03,390
Yeah?

696
00:47:03,390 --> 00:47:04,608
AUDIENCE: [INAUDIBLE]

697
00:47:04,608 --> 00:47:06,150
DAVID J. MALAN: Ah, the placeholder--

698
00:47:06,150 --> 00:47:09,240
I'll zoom in-- is just a single percent then an s.

699
00:47:09,240 --> 00:47:23,400
So inside of my string here is %s, and then I have a comma outside the quotes, and then the name of the variable whose value I want to plug in for that %s.

700
00:47:23,400 --> 00:47:30,300
And now notice there's technically two commas inside of these parentheses on line 7.

701
00:47:30,300 --> 00:47:37,290
And yet, I claim that printf, at the moment, is only taking in two arguments.

702
00:47:37,290 --> 00:47:41,582
Why is there then two commas but only two arguments?

703
00:47:41,582 --> 00:47:45,700
If there were two commas, you would think there would be three arguments, right?

704
00:47:45,700 --> 00:47:49,700
AUDIENCE: The comma is between the quotes, so it counts as a comma [INAUDIBLE]

705
00:47:49,700 --> 00:47:50,700
DAVID J. MALAN: Exactly.

706
00:47:50,700 --> 00:47:53,160
The comma in between the quotes is just an English thing.

707
00:47:53,160 --> 00:47:55,240
It's separating the hello from the name.

708
00:47:55,240 --> 00:48:05,580
So that's why indeed it's not only in quotes, that's also why programs like VS Code tend to syntax highlight it a little differently just so that it jumps out as different to you,

709
00:48:05,580 --> 00:48:10,830
even though, in this case, it's a little subtle-- a light blue versus white-- but indeed, it's trying its best.

710
00:48:10,830 --> 00:48:13,150
Other questions now on this placeholder?

711
00:48:13,150 --> 00:48:13,650
Yeah?

712
00:48:13,650 --> 00:48:21,943
AUDIENCE: If you wanted to put an exclamation point at the end, would you put a comma after your answer variable, and would that put it [INAUDIBLE],, or would you have to add a new line?

713
00:48:21,943 --> 00:48:23,360
DAVID J. MALAN: Ah, good question.

714
00:48:23,360 --> 00:48:28,230
If I wanted to add an exclamation point after the name, would I have to add another placeholder and so forth?

715
00:48:28,230 --> 00:48:29,980
I could actually do that much more simply.

716
00:48:29,980 --> 00:48:33,610
I can just put the exclamation point right after the percent sign.

717
00:48:33,610 --> 00:48:35,830
I don't need an additional placeholder, per se.

718
00:48:35,830 --> 00:48:45,580
If I zoom out now and run make hello again, ./hello, and type in just my name-- no exclamation point-- now you'll see more excitedly, hello, comma, David.

719
00:48:45,580 --> 00:48:46,510
So printf is smart.

720
00:48:46,510 --> 00:48:51,400
It will figure out where the %s is and then go and replace it.

721
00:48:51,400 --> 00:49:01,240
Now, let me propose that a common thing in programming is that as soon as we make a decision as how to design something, we often paint ourselves into a corner and regret a decision.

722
00:49:01,240 --> 00:49:11,680
Can anyone think of a problem that arises from using %s as a placeholder in this string to printf?

723
00:49:11,680 --> 00:49:14,635
What could go wrong if we're using percent in this special way?

724
00:49:14,635 --> 00:49:16,775
AUDIENCE: [INAUDIBLE]

725
00:49:16,775 --> 00:49:17,650
DAVID J. MALAN: Yeah.

726
00:49:17,650 --> 00:49:20,320
If you literally want to say, for whatever weird reason,

727
00:49:20,320 --> 00:49:23,245
%s on the screen-- or honestly, even just a single %.

728
00:49:23,245 --> 00:49:29,650
It turns out that a percent sign is treated specially inside of printf strings.

729
00:49:29,650 --> 00:49:31,460
So what's the solution here?

730
00:49:31,460 --> 00:49:34,690
There's different patterns of solutions to problems like these.

731
00:49:34,690 --> 00:49:40,990
But suppose you wanted to say, I got 100%, for instance.

732
00:49:40,990 --> 00:49:43,480
Let me go ahead and change this completely.

733
00:49:43,480 --> 00:49:47,290
So I got 100% on your test or whatever.

734
00:49:47,290 --> 00:49:50,860
All right, let me go ahead and run make hello, Enter.

735
00:49:50,860 --> 00:49:52,950
All right, so invalid conversions specifier.

736
00:49:52,950 --> 00:49:57,410
I mean, I have no idea what this means, but it's underlining the percent sign as problematic.

737
00:49:57,410 --> 00:50:00,730
Well, it turns out that humans years ago decided, ugh, all right, damn it.

738
00:50:00,730 --> 00:50:01,615
We already used %.

739
00:50:01,615 --> 00:50:04,990
Well, two percent signs will mean one %, literally.

740
00:50:04,990 --> 00:50:09,727
So now if I rerun make hello, aha, ./hello, I got 100%.

741
00:50:09,727 --> 00:50:15,190
So there's going to be things like that, honestly, that you have to ask someone, you have to Google, you have to look it up in the documentation.

742
00:50:15,190 --> 00:50:17,840
But there's always a solution to those kinds of problems.

743
00:50:17,840 --> 00:50:19,930
And thankfully, they don't come up all that often.

744
00:50:19,930 --> 00:50:21,230
Yeah?

745
00:50:21,230 --> 00:50:22,360
Oh, just pointing.

746
00:50:22,360 --> 00:50:23,060
Other questions?

747
00:50:23,060 --> 00:50:23,560
Yeah?

748
00:50:23,560 --> 00:50:27,622
AUDIENCE: So if you have multiple [INAUDIBLE]

749
00:50:27,622 --> 00:50:31,380
DAVID J. MALAN: If you have multiple variables, it is in the left-right order.

750
00:50:31,380 --> 00:50:35,520
So printf will analyze the first string of text that you pass in between quotes.

751
00:50:35,520 --> 00:50:41,207
And whatever the first % is, the first variable that's passed in after a comma gets plugged in there.

752
00:50:41,207 --> 00:50:44,832
And then the second gets plugged into the second, third, and to the third, and so forth.

753
00:50:44,832 --> 00:50:47,130
So it's just based on left to right.

754
00:50:47,130 --> 00:50:48,220
Yeah?

755
00:50:48,220 --> 00:50:50,760
AUDIENCE: This more of a clarification question.

756
00:50:50,760 --> 00:50:52,453
What exactly does the %s mean?

757
00:50:52,453 --> 00:50:54,120
DAVID J. MALAN: It's just a placeholder.

758
00:50:54,120 --> 00:50:59,070
It's called a format code, and it just means colloquially, plug in some value here.

759
00:50:59,070 --> 00:51:04,560
And printf-- the humans who wrote printf decades ago decided to treat %s special.

760
00:51:04,560 --> 00:51:04,890
Why?

761
00:51:04,890 --> 00:51:05,490
Just because.

762
00:51:05,490 --> 00:51:06,900
They needed some placeholder.

763
00:51:06,900 --> 00:51:10,110
They decided that, eh, no one's ever going to really want to type %s.

764
00:51:10,110 --> 00:51:12,420
And if they do, they can just do %%s.

765
00:51:12,420 --> 00:51:24,960
So they decided to implement printf in such a way that they have code that analyzes whatever text comes in, looks for %s, and then somehow plugs in the subsequent values into that placeholder.

766
00:51:24,960 --> 00:51:28,390
And just the-- ah, question?

767
00:51:28,390 --> 00:51:28,890
Sorry?

768
00:51:28,890 --> 00:51:30,870
AUDIENCE: What if we wanted to do our initials or something?

769
00:51:30,870 --> 00:51:38,070
DAVID J. MALAN: Ah, so what if you wanted to do a single characters, like initials, like D M or D J M for first, middle, last, absolutely.

770
00:51:38,070 --> 00:51:44,310
And that, too, is a perfect segue from the two of you to what, in general, are going to be called data types in C.

771
00:51:44,310 --> 00:51:48,135
So it turns out, in C, there's not only strings as text.

772
00:51:48,135 --> 00:51:52,560
And we'll see in more detail over the next couple of weeks what a string really is underneath the hood.

773
00:51:52,560 --> 00:51:55,620
But strings of text are not the only thing that programs can output.

774
00:51:55,620 --> 00:51:58,860
They can indeed output single characters, as for initials.

775
00:51:58,860 --> 00:52:01,020
They can output integers as well.

776
00:52:01,020 --> 00:52:05,868
Turns out that printf has different format codes for all sorts of different data types.

777
00:52:05,868 --> 00:52:13,920
And just some of the data types we'll see in the coming weeks will be this list here, which you'll notice it almost perfectly lines up with the CS50 functions

778
00:52:13,920 --> 00:52:17,722
that I rattled off earlier, like get_char, get_int, get_string.

779
00:52:17,722 --> 00:52:23,490
The reason we called those functions that is because each of them is designed to return to you a different type of value.

780
00:52:23,490 --> 00:52:26,070
We've used get_string already in this example here.

781
00:52:26,070 --> 00:52:29,880
We'll soon see get_int, and we'll see opportunities to use others.

782
00:52:29,880 --> 00:52:38,400
But these indeed are the menu of available data types plus others-- dot, dot, dot-- that you can use when writing a program in C.

783
00:52:38,400 --> 00:52:48,420
The onus, therefore, is on you to decide in advance, do I want to store an int in this variable, or a string, or, heck, when writing fancier code, an image, or a sound, or a video, even.

784
00:52:48,420 --> 00:52:51,030
Those can all be different data types, dot dot dot.

785
00:52:51,030 --> 00:52:54,300
But for now we'll focus really on just these primitives.

786
00:52:54,300 --> 00:52:54,988
That was a lot.

787
00:52:54,988 --> 00:52:57,030
Let's go ahead and take a five-minute break here.

788
00:52:57,030 --> 00:52:57,680
No cookies yet.

789
00:52:57,680 --> 00:53:00,180
But in five minutes, we'll come back, dive into more detail.

790
00:53:00,180 --> 00:53:02,097
On our second break today, we'll have cookies.

791
00:53:05,640 --> 00:53:07,295
All right, we are back.

792
00:53:07,295 --> 00:53:11,587
And so if you have been playing along at home but hitting some bumps in the road, that's totally normal.

793
00:53:11,587 --> 00:53:18,020
And indeed, the goals of lecture generally will be to give you a sense, conceptually, of where we'll be going during the course of the week.

794
00:53:18,020 --> 00:53:25,730
But it's indeed through the hands-on labs and problem sets that you'll really have an opportunity at your own pace to work through some of those same bumps in the road.

795
00:53:25,730 --> 00:53:28,880
But for today, let me give you a few more building blocks.

796
00:53:28,880 --> 00:53:31,460
And these two will translate from Scratch initially.

797
00:53:31,460 --> 00:53:43,370
Namely, like conditionals, like how now in C, after knowing now how we can use functions-- at least get_string and printf-- and we can use variables like the string I created earlier,

798
00:53:43,370 --> 00:53:47,100
how can I now add to the mix things like decision making and conditionals at that?

799
00:53:47,100 --> 00:53:50,780
Well, with conditionals in Scratch, we had this kind of syntax on the left.

800
00:53:50,780 --> 00:53:56,360
Here in Scratch is how you might express if two variables, x and y, have this relationship.

801
00:53:56,360 --> 00:54:01,020
If x is less than y, then say on the screen, x is less than y.

802
00:54:01,020 --> 00:54:03,320
Well, let me translate that to the right now in C code.

803
00:54:03,320 --> 00:54:09,530
So in C, the corresponding code is going to look like this, assuming x and y already exist-- more on that later.

804
00:54:09,530 --> 00:54:13,140
And notice a pattern we're going to see again and again.

805
00:54:13,140 --> 00:54:20,390
There is going to be parentheses around the x and less than y-- so parentheses around the Boolean expression, recall.

806
00:54:20,390 --> 00:54:27,680
The Boolean expression is the true/false, the yes/no answer, a question that you're trying to ask in order to decide whether or not to do something.

807
00:54:27,680 --> 00:54:29,310
So you use parentheses there.

808
00:54:29,310 --> 00:54:38,660
So similar in functions where we use parentheses for printf and parentheses for get_string, and this is just a weird inconsistency stylistically.

809
00:54:38,660 --> 00:54:44,690
When using the keyword if, you should, as a matter of best practice, put a space after the word if.

810
00:54:44,690 --> 00:54:49,070
When using a function like printf or get_string, you shouldn't.

811
00:54:49,070 --> 00:54:55,970
Both will work, but you'll find that these are conventions stylistically that most people adhere to-- so space when using an if here.

812
00:54:55,970 --> 00:55:02,360
All right, now inside of the curly braces is where the actual code goes that you want to execute conditionally.

813
00:55:02,360 --> 00:55:12,740
So if you want to print out x is less than y only if x is actually less than y in C, you use this open curly brace-- which, up until now, you've probably rarely used on your keyboard--

814
00:55:12,740 --> 00:55:14,820
and the closed curly brace down here.

815
00:55:14,820 --> 00:55:25,050
And those are hugging, if you will, the one or more lines of code underneath the if-- very similar in spirit to how the orange block here hugs the purple puzzle piece here.

816
00:55:25,050 --> 00:55:27,050
So there's no graphics in C. It's all text.

817
00:55:27,050 --> 00:55:31,760
So you can think of those curly braces as really representing the same idea.

818
00:55:31,760 --> 00:55:41,430
As a side note, if you only have one line of code inside of the if condition, if you will, you strictly, speaking, don't need the curly braces.

819
00:55:41,430 --> 00:55:43,670
But as a matter of good style, do include them.

820
00:55:43,670 --> 00:55:46,040
It will make more obvious what your intent is.

821
00:55:46,040 --> 00:55:52,700
How about in Scratch if you wanted to express this-- two ways in the road that you might go, left or right, so to speak?

822
00:55:52,700 --> 00:55:56,480
Well, if x is less than y, I want to say, x is less than y.

823
00:55:56,480 --> 00:56:01,190
Else, I want to say the opposite, x is not less than y in this case.

824
00:56:01,190 --> 00:56:03,710
So I'm making a decision based on that Boolean expression.

825
00:56:03,710 --> 00:56:14,690
In C, It's almost the same, but you're adding to the mix the key word else-- so MIT borrowed for Scratch the same keyword there-- and a second pair of curly braces, open and close respectively.

826
00:56:14,690 --> 00:56:17,150
And you might guess now what goes inside of those.

827
00:56:17,150 --> 00:56:22,905
Well, you print out x is less than y, or you print out x is not less than y.

828
00:56:22,905 --> 00:56:25,280
All right, what if there is a three-way fork in the road?

829
00:56:25,280 --> 00:56:29,370
In Scratch, this actually gets a little unwieldy graphically, if you will.

830
00:56:29,370 --> 00:56:36,110
But notice that in Scratch, this is how we could express if x is less than y, say x is less than y.

831
00:56:36,110 --> 00:56:40,760
Else if x is greater than y, say x is greater than y.

832
00:56:40,760 --> 00:56:45,470
Else if x equals y, then say x is equal to y.

833
00:56:45,470 --> 00:56:48,770
Now, minor inconsistency here.

834
00:56:48,770 --> 00:56:54,435
Just a little bit ago, I claimed, in C, that an equal sign represents what operation?

835
00:56:54,435 --> 00:56:55,310
AUDIENCE: Assignment.

836
00:56:55,310 --> 00:56:57,770
DAVID J. MALAN: Assignment from right to left.

837
00:56:57,770 --> 00:57:06,360
Insofar as Scratch is really meant for kids, and they didn't really want to get into the weeds of this kind of semantic, equal sign in Scratch means equality.

838
00:57:06,360 --> 00:57:09,050
However, we're going to need to fix this in C in just a moment.

839
00:57:09,050 --> 00:57:11,750
In C, equal sign means assignment right to left.

840
00:57:11,750 --> 00:57:14,210
In Scratch, it literally means what you would expect.

841
00:57:14,210 --> 00:57:20,780
All right, let's translate this code then to C. On the right, this code would correspond really to this.

842
00:57:20,780 --> 00:57:29,100
And you can perhaps see, somewhat goofily, what the solution was, not unlike the %% solution earlier when humans painted themselves into one other corner.

843
00:57:29,100 --> 00:57:36,620
You say if, you say else if, and you say else if, and how did we resolve the use of a single equal sign already?

844
00:57:36,620 --> 00:57:47,090
In C, when you want to express equality-- is the thing on the left equal to the thing on the right-- you literally use two equal signs right next to each other, no space in between them.

845
00:57:47,090 --> 00:57:53,640
But now this code would be correct on both the left and the right, whether you're doing this in Scratch or C respectively.

846
00:57:53,640 --> 00:57:58,400
But now we can nitpick our code, specifically the design thereof.

847
00:57:58,400 --> 00:58:04,280
Logically, can anyone critique the design of this code, either in Scratch or C?

848
00:58:04,280 --> 00:58:06,200
I feel like we could do better.

849
00:58:06,200 --> 00:58:07,576
How about in back?

850
00:58:07,576 --> 00:58:12,930
AUDIENCE: The only option after it getting greater than or less than is [INAUDIBLE].

851
00:58:12,930 --> 00:58:13,930
DAVID J. MALAN: Perfect.

852
00:58:13,930 --> 00:58:22,510
Logically, it's got to be the case that x is less than y, or x is greater than y, or by conclusion, it's got to be equal to y.

853
00:58:22,510 --> 00:58:26,170
So why are you wasting my time or the computer's time asking a third question?

854
00:58:26,170 --> 00:58:31,510
You don't need to ask this final else if because logically, as you note, it should go without saying.

855
00:58:31,510 --> 00:58:33,220
So it's a minor tweak.

856
00:58:33,220 --> 00:58:37,120
You're doing extra work potentially in the cases where x equals y.

857
00:58:37,120 --> 00:58:38,350
So we can just refine that.

858
00:58:38,350 --> 00:58:47,110
And just like in Scratch, you could just use an else block, similarly in C, could we simplify this code to just an else, a sort of catch-all logically

859
00:58:47,110 --> 00:58:52,400
that just handles the reality that, of course, that's going to be the final situation instead.

860
00:58:52,400 --> 00:58:56,770
All right, so we have this ability now to express conditionals with Boolean expressions.

861
00:58:56,770 --> 00:58:59,030
Let's actually do something with this next here.

862
00:58:59,030 --> 00:59:00,610
So let me go back to VS Code.

863
00:59:00,610 --> 00:59:05,020
I've closed hello.c, and I want to create a second file for the sake of some demos now.

864
00:59:05,020 --> 00:59:11,440
Recall that you can create a new files by typing code, space, and then the name of the file you want to create.

865
00:59:11,440 --> 00:59:13,565
For instance, I might do compare.c.

866
00:59:13,565 --> 00:59:17,740
I want to write a program that's going to start comparing some values for demonstration's sake.

867
00:59:17,740 --> 00:59:25,180
But before I do that, let me just show you by opening the File Explorer at right, this is similar in spirit to a Mac or PC.

868
00:59:25,180 --> 00:59:30,010
You can go up here and click on an icon, and you can click on the plus icon, and you'll get a blue box.

869
00:59:30,010 --> 00:59:34,120
And I can type in compare.c, and I can just manually create it that way.

870
00:59:34,120 --> 00:59:37,930
Notice that opens the tab even without my having typed code.

871
00:59:37,930 --> 00:59:42,820
So again, on the left, you have a GUI, a Graphical User Interface, albeit a simplistic one.

872
00:59:42,820 --> 00:59:47,260
On the right and at the bottom here, you have a command line interface, but they're one in the same.

873
00:59:47,260 --> 00:59:58,930
What's nice, though, is that if I close this file accidentally, intentionally, whatnot, I can reopen it without creating a new one by just running that same command-- code, space, compare.c.

874
00:59:58,930 --> 01:00:00,340
So code is a VS Code thing.

875
01:00:00,340 --> 01:00:02,140
It's just a user-friendly shortcut.

876
01:00:02,140 --> 01:00:05,888
But it's just creating a file or opening an existing file like that.

877
01:00:05,888 --> 01:00:08,930
I'm going to hide the File Explorer just to make more room for code here.

878
01:00:08,930 --> 01:00:10,222
And let's go ahead and do this.

879
01:00:10,222 --> 01:00:15,340
Let's write a program that compares two values that the human inputs, but not strings this time.

880
01:00:15,340 --> 01:00:17,170
Let's use some actual integers.

881
01:00:17,170 --> 01:00:23,260
All right, I'm going to go ahead and include the CS50 library's header file at top-- cs50.h.

882
01:00:23,260 --> 01:00:25,804
I'm going to also include stdio.h.

883
01:00:25,804 --> 01:00:26,668
Why?

884
01:00:26,668 --> 01:00:31,190
One gives me user-friendly input via get_string, get_int, and so forth.

885
01:00:31,190 --> 01:00:35,560
One gives me user-friendly output via printf in the case of stdio.h.

886
01:00:35,560 --> 01:00:40,310
Now I'm just going to blindly type this line of code, which we'll come back to in future weeks.

887
01:00:40,310 --> 01:00:44,920
But for now, that's analogous to the when green flag clicked code in Scratch.

888
01:00:44,920 --> 01:00:46,460
And now let's go ahead and do this.

889
01:00:46,460 --> 01:00:51,713
Let me go ahead and get_int from the user and ask the user, What's x, question mark.

890
01:00:51,713 --> 01:00:53,380
I'm not going to bother with a new line.

891
01:00:53,380 --> 01:00:56,410
I want to keep it all in one line, just for aesthetics' sake.

892
01:00:56,410 --> 01:00:59,710
But when I get back and int, just like I get back a string,

893
01:00:59,710 --> 01:01:01,580
I get back a return value.

894
01:01:01,580 --> 01:01:06,040
So if I want to store the result of get_int somewhere,

895
01:01:06,040 --> 01:01:07,927
I had better put it in a variable.

896
01:01:07,927 --> 01:01:09,760
And I can call the variable anything I want.

897
01:01:09,760 --> 01:01:12,790
Previously, I used answer, or first, or last.

898
01:01:12,790 --> 01:01:14,410
Now I'm going to use x.

899
01:01:14,410 --> 01:01:19,870
But there's still two things left to do here logically, even though we haven't technically done this yet.

900
01:01:19,870 --> 01:01:21,130
What I still need to do?

901
01:01:21,130 --> 01:01:22,410
AUDIENCE: A semicolon.

902
01:01:22,410 --> 01:01:24,535
DAVID J. MALAN: So I need the semicolon at the end.

903
01:01:24,535 --> 01:01:26,010
AUDIENCE: And the int first.

904
01:01:26,010 --> 01:01:27,885
DAVID J. MALAN: And the int at the beginning.

905
01:01:27,885 --> 01:01:32,840
You the programmer, starting today, need to decide what you're going to be storing in your variables.

906
01:01:32,840 --> 01:01:35,750
And you just need to tell the computer that so that it knows.

907
01:01:35,750 --> 01:01:41,240
Now, as a teaser for languages like Python, more modern languages, turns out, humans realized, well, gee, this is stupid.

908
01:01:41,240 --> 01:01:44,115
Why can't the computer just figure out that I'm putting an int there?

909
01:01:44,115 --> 01:01:45,800
Why do I have to tell it proactively?

910
01:01:45,800 --> 01:01:50,990
So in some languages nowadays, like Python will get rid of some of this syntax, will get rid of the semicolons.

911
01:01:50,990 --> 01:01:54,530
But for now we're looking at, really, the origins of how this all worked.

912
01:01:54,530 --> 01:01:57,380
All right, so I've done this one line ending with semicolon.

913
01:01:57,380 --> 01:01:58,440
Let me do one other.

914
01:01:58,440 --> 01:02:02,390
And let me get a second int asking the user, What's y, question mark.

915
01:02:02,390 --> 01:02:06,680
So almost identical but different responses from the user, hopefully.

916
01:02:06,680 --> 01:02:18,950
And let me just ask simply if x is less than y, in parentheses, then some curly braces, let me go ahead and print out, quote/unquote, x is less than y backslash n.

917
01:02:18,950 --> 01:02:20,600
And now just as a side note--

918
01:02:20,600 --> 01:02:23,240
I seem to be typing fast.

919
01:02:23,240 --> 01:02:25,610
Some of that is because VS Code is helping me.

920
01:02:25,610 --> 01:02:29,720
Let me go back to this first line with the if, hit Enter.

921
01:02:29,720 --> 01:02:33,630
And now I'm only on my keyboard going to type the open curly brace.

922
01:02:33,630 --> 01:02:36,410
This is a feature of many text editors nowadays.

923
01:02:36,410 --> 01:02:37,980
It finishes part of your thought.

924
01:02:37,980 --> 01:02:38,480
Why?

925
01:02:38,480 --> 01:02:42,660
Just to save yourself a keystroke to make sure you don't accidentally forget the closing one.

926
01:02:42,660 --> 01:02:45,750
So you'll notice sometimes that things are happening that you didn't type.

927
01:02:45,750 --> 01:02:49,550
It's just VS Code or future programs you use trying to be helpful for you.

928
01:02:49,550 --> 01:02:57,050
I'll go ahead and manually type out now printf x is less than y backslash n close quote semicolon.

929
01:02:57,050 --> 01:03:02,000
So let me go ahead now and try to run this, and we'll see-- let's see.

930
01:03:02,000 --> 01:03:09,050
So make-- not hello-- but make compare because this file is called compare.c, hitting Enter.

931
01:03:09,050 --> 01:03:12,320
No output is good because it means I haven't messed up.

932
01:03:12,320 --> 01:03:16,580
Let me ./compare instead of ./hello, Enter.

933
01:03:16,580 --> 01:03:17,390
What's x?

934
01:03:17,390 --> 01:03:18,410
How about 1?

935
01:03:18,410 --> 01:03:19,040
What's y?

936
01:03:19,040 --> 01:03:19,840
How about 2?

937
01:03:19,840 --> 01:03:22,230
X is less than y.

938
01:03:22,230 --> 01:03:23,387
Well, let's try it again.

939
01:03:23,387 --> 01:03:25,220
And here, I'll save you some keystrokes too.

940
01:03:25,220 --> 01:03:26,360
Let me clear my screen.

941
01:03:26,360 --> 01:03:35,310
Instead of constantly typing ./this and ./that, you can also use your keyboard's arrow keys in VS Code to scroll back through time.

942
01:03:35,310 --> 01:03:37,940
So if I hit Up once, there's the last command I wrote.

943
01:03:37,940 --> 01:03:41,480
If I do it Up twice, there's the second to last command I wrote.

944
01:03:41,480 --> 01:03:46,550
So sometimes if you see me doing things fast, it's just because I'm cheating and going through my history like that.

945
01:03:46,550 --> 01:03:51,380
All right, let me go ahead, though, and rerun ./compare, Enter.

946
01:03:51,380 --> 01:03:52,670
Let's reverse it this time--

947
01:03:52,670 --> 01:03:55,100
2 for x, 1 for y.

948
01:03:55,100 --> 01:03:56,870
And now, of course, there's no output.

949
01:03:56,870 --> 01:04:00,170
All right, well, that's logically to be expected because we didn't have an else here.

950
01:04:00,170 --> 01:04:00,980
So let's add that.

951
01:04:00,980 --> 01:04:12,350
Else-- now let's open my curly braces, letting VS Code do one of them for me-- printf, quote/unquote, x is not less than y backslash n semicolon.

952
01:04:12,350 --> 01:04:16,430
Let me go ahead and try this again-- ./compare, Enter.

953
01:04:16,430 --> 01:04:19,100
Again, 2 for x, 1 for y.

954
01:04:19,100 --> 01:04:22,990
And we should see-- huh.

955
01:04:22,990 --> 01:04:24,830
What did I do wrong?

956
01:04:24,830 --> 01:04:27,050
Why am I not seeing any else output?

957
01:04:27,050 --> 01:04:27,550
Yeah?

958
01:04:27,550 --> 01:04:29,592
AUDIENCE: You changed your code when you rebuild.

959
01:04:29,592 --> 01:04:30,690
You need to compile it.

960
01:04:30,690 --> 01:04:31,290
DAVID J. MALAN: Exactly.

961
01:04:31,290 --> 01:04:34,415
You got to get into the habit after you change your code of recompiling it.

962
01:04:34,415 --> 01:04:39,000
Or otherwise, the zeros and ones in the server are the old ones until you manually compile.

963
01:04:39,000 --> 01:04:41,040
So let's fix this-- make compare, Enter.

964
01:04:41,040 --> 01:04:42,030
No error messages.

965
01:04:42,030 --> 01:04:45,420
That's good. ./compare, 2, 1.

966
01:04:45,420 --> 01:04:47,320
And now I get back the output.

967
01:04:47,320 --> 01:04:49,230
So x is not less than y.

968
01:04:49,230 --> 01:04:52,390
How about if I go and add in the third condition?

969
01:04:52,390 --> 01:04:55,650
Well, we can do this either efficiently or inefficiently.

970
01:04:55,650 --> 01:04:57,270
Let me go ahead and refine this.

971
01:04:57,270 --> 01:05:03,780
So else if x is greater than y, let's literally say, x is greater than y.

972
01:05:03,780 --> 01:05:07,950
And now I could do x else if x equals equals y.

973
01:05:07,950 --> 01:05:11,080
But I think we already claimed that that's unnecessarily inefficient.

974
01:05:11,080 --> 01:05:12,810
So let's just have our catchall.

975
01:05:12,810 --> 01:05:19,960
And here I'm going to say, quote/unquote, x is equal to y backslash n, close quote there.

976
01:05:19,960 --> 01:05:24,070
So I think now with this code, we've handled all three scenarios.

977
01:05:24,070 --> 01:05:28,680
Let me go ahead and recompile it properly-- make compare, ./compare.

978
01:05:28,680 --> 01:05:32,340
And now 1 and 2-- is less than y.

979
01:05:32,340 --> 01:05:33,510
Let me run it again.

980
01:05:33,510 --> 01:05:36,690
2 and 1-- x is greater than y.

981
01:05:36,690 --> 01:05:41,100
And lastly, 1 and 1, and x is equal to y.

982
01:05:41,100 --> 01:05:43,270
So for the most part, our code is getting longer.

983
01:05:43,270 --> 01:05:47,700
We're up to 21 lines of code, though some of them are just single characters on the screen.

984
01:05:47,700 --> 01:05:49,410
Almost everything else is the same.

985
01:05:49,410 --> 01:06:01,810
I'm using the CS50 library's header file for my get_int function, stdio.h for my printf function, and the rest of this is just now new syntax for conditionals as well.

986
01:06:01,810 --> 01:06:08,237
Questions, then, on this C implementation of just some basic comparisons like this?

987
01:06:08,237 --> 01:06:08,820
Any questions?

988
01:06:08,820 --> 01:06:09,320
Yeah?

989
01:06:09,320 --> 01:06:14,530
AUDIENCE: Just a syntax question-- do the opening brackets need to be on a separate line?

990
01:06:14,530 --> 01:06:15,190
DAVID J. MALAN: Good question.

991
01:06:15,190 --> 01:06:17,440
Do the opening brackets need to be on a separate line?

992
01:06:17,440 --> 01:06:18,610
In CS50, yes.

993
01:06:18,610 --> 01:06:25,540
What you'll see is that as part of the submission process, we compare your code against a style guide, which is the norm in industry.

994
01:06:25,540 --> 01:06:29,290
A company would have its own sense of style and how its code should look.

995
01:06:29,290 --> 01:06:35,080
And there's generally automated tools within a company that help give feedback on the code or stylize it as such.

996
01:06:35,080 --> 01:06:38,410
There are alternative styles than what we use in the class.

997
01:06:38,410 --> 01:06:48,430
We deliberately keep and ask that you keep the curly braces on their own line, if only because it rather resembles like the hugging nature of Scratch's blocks

998
01:06:48,430 --> 01:06:51,370
and just makes clear that they're balanced, opened and closed.

999
01:06:51,370 --> 01:06:59,420
However, another common paradigm in some languages and with some programmers is to do something like this on each of them.

1000
01:06:59,420 --> 01:07:03,670
So you have the opening curly brace on the same line as here.

1001
01:07:03,670 --> 01:07:05,030
We do not recommend this.

1002
01:07:05,030 --> 01:07:07,900
This is en vogue in the JavaScript world and some others.

1003
01:07:07,900 --> 01:07:16,210
But ultimately in the real world, it's up to each individual programmer and/or the company they're working for, if applicable, to decide on those things.

1004
01:07:16,210 --> 01:07:21,140
All right, so beyond, then, these conditionals, what if we want to do something that's maybe pretty common?

1005
01:07:21,140 --> 01:07:28,360
So almost every piece of software or website nowadays that you use has you agree to some terms and conditions by typing Yes or No or just

1006
01:07:28,360 --> 01:07:30,280
Y for Yes and N for No.

1007
01:07:30,280 --> 01:07:33,195
So how could we implement some kind of agreement system?

1008
01:07:33,195 --> 01:07:34,070
Well, let me do this.

1009
01:07:34,070 --> 01:07:37,810
Let me create a new program, a third one called agree.c.

1010
01:07:37,810 --> 01:07:41,230
So I'm going to write code agree.c just to give myself a new tab.

1011
01:07:41,230 --> 01:07:44,230
I'm going to start, as always now, include cs50.h.

1012
01:07:44,230 --> 01:07:46,480
Let's include stdio.h.

1013
01:07:46,480 --> 01:07:53,200
And then let me do my int main(void)-- which, again, for today's purposes, we'll take at face value is just copy/paste.

1014
01:07:53,200 --> 01:08:00,520
And if I just want to get Y or N, for instance, instead of Yes or No, we can just use a simpler variable here.

1015
01:08:00,520 --> 01:08:03,800
How about just a char, a character, a single character?

1016
01:08:03,800 --> 01:08:09,760
So I can use get_char to ask the user, for instance, do you agree, question mark.

1017
01:08:09,760 --> 01:08:12,880
But as before, I need to store this somewhere.

1018
01:08:12,880 --> 01:08:15,130
So I don't want a string because that's a single char.

1019
01:08:15,130 --> 01:08:16,180
I don't want an int.

1020
01:08:16,180 --> 01:08:17,380
I just want a char.

1021
01:08:17,380 --> 01:08:21,500
And it's literally C-H-A-R. And then I can call this thing anything I want.

1022
01:08:21,500 --> 01:08:27,040
It's conventional if you have a simple program with just a single variable and it's of type char, call it c.

1023
01:08:27,040 --> 01:08:28,569
If it's an int, call it i.

1024
01:08:28,569 --> 01:08:29,830
If it's a string, call it s.

1025
01:08:29,830 --> 01:08:32,590
For now I'm just going to keep it simple and call it c.

1026
01:08:32,590 --> 01:08:34,370
And now I'm going to ask a question.

1027
01:08:34,370 --> 01:08:50,380
So if c equals equals, how about, quote/unquote, y, then let me go ahead and print out Agreed backslash n, as though they agreed to my terms and conditions.

1028
01:08:50,380 --> 01:08:51,880
Otherwise, let's see.

1029
01:08:51,880 --> 01:09:03,609
Else if the character equals equals, quote/unquote, n, then let me go ahead and print out, say, Not agreed, as though they didn't, quote/unquote.

1030
01:09:03,609 --> 01:09:07,060
And let's leave it at that, I think, here initially.

1031
01:09:07,060 --> 01:09:11,830
Now, you'll notice one curiosity, one inconsistency perhaps.

1032
01:09:11,830 --> 01:09:15,760
Does anyone want to call it out, though it's somewhat subtle?

1033
01:09:15,760 --> 01:09:19,720
I've done something ever so slightly differently without explaining it yet.

1034
01:09:19,720 --> 01:09:20,380
Do you see it?

1035
01:09:20,380 --> 01:09:22,625
AUDIENCE: The single quotation mark.

1036
01:09:22,625 --> 01:09:23,500
DAVID J. MALAN: Yeah.

1037
01:09:23,500 --> 01:09:30,590
So I've suddenly used single quotation marks for my single characters and double quotes for my actual strings of text.

1038
01:09:30,590 --> 01:09:41,380
This is a necessity in C. When you're dealing with strings, like strings of text, like someone's name, a sentence, a paragraph, anything really more than one character, you typically use double quotes.

1039
01:09:41,380 --> 01:09:42,399
And indeed, you must.

1040
01:09:42,399 --> 01:09:49,819
When dealing with deliberately single characters, like I am here for y or n, you must use single quotes instead.

1041
01:09:49,819 --> 01:09:50,319
Why?

1042
01:09:50,319 --> 01:09:54,550
Because that makes sure that the computer knows that it's indeed a char and not a string.

1043
01:09:54,550 --> 01:09:55,930
So double quotes are for strings.

1044
01:09:55,930 --> 01:09:57,520
Single quotes are for chars.

1045
01:09:57,520 --> 01:10:00,550
So with that said, let me go ahead and zoom out.

1046
01:10:00,550 --> 01:10:04,780
Let me go ahead in my terminal window run make agree, Enter.

1047
01:10:04,780 --> 01:10:08,770
Seems to work OK so let me go ahead and do ./agree.

1048
01:10:08,770 --> 01:10:12,250
Let me go ahead now and type in y.

1049
01:10:12,250 --> 01:10:13,090
Here we go.

1050
01:10:13,090 --> 01:10:14,980
Enter.

1051
01:10:14,980 --> 01:10:16,540
Huh.

1052
01:10:16,540 --> 01:10:17,470
Let me try that again.

1053
01:10:17,470 --> 01:10:18,580
Rerun ./agree.

1054
01:10:18,580 --> 01:10:20,170
How about no?

1055
01:10:20,170 --> 01:10:22,480
Enter.

1056
01:10:22,480 --> 01:10:25,720
Why is it not behaving as I would have expected?

1057
01:10:25,720 --> 01:10:28,480
AUDIENCE: Because you entered the capital Y and capital N.

1058
01:10:28,480 --> 01:10:32,230
DAVID J. MALAN: Yeah, I kind of cheated there, and I hit the Caps Lock key just as I started typing in input.

1059
01:10:32,230 --> 01:10:32,730
Why?

1060
01:10:32,730 --> 01:10:37,540
Because I deliberately wanted to type in uppercase instead of lowercase, which is kind of reasonable.

1061
01:10:37,540 --> 01:10:42,770
It's a little obnoxious if you force the user to toggle their caps lock key on or off when you just need a simple answer.

1062
01:10:42,770 --> 01:10:45,310
That's not the best User Experience, or UX.

1063
01:10:45,310 --> 01:10:47,200
But it would work if I cooperated.

1064
01:10:47,200 --> 01:10:52,030
Let me run this again without caps lock-- y lowercase for yes.

1065
01:10:52,030 --> 01:10:55,210
Ah, that worked. n lowercase for no.

1066
01:10:55,210 --> 01:10:55,990
That worked.

1067
01:10:55,990 --> 01:10:57,910
But how could I get it to work for both?

1068
01:10:57,910 --> 01:10:59,180
Well, how about this?

1069
01:10:59,180 --> 01:11:01,400
Let me go ahead and just add two possibilities.

1070
01:11:01,400 --> 01:11:10,720
So else if c equals equals quote/unquote capital Y, then also do printf agreed backslash n.

1071
01:11:10,720 --> 01:11:20,980
And down here, else if c equals equals single quote capital N, then go ahead and print out, again, Not agreed.

1072
01:11:20,980 --> 01:11:23,770
This, I will claim now, is correct.

1073
01:11:23,770 --> 01:11:26,980
And I'll do make agree real fast, ./agree.

1074
01:11:26,980 --> 01:11:28,210
And I'll use capital.

1075
01:11:28,210 --> 01:11:29,170
It now works.

1076
01:11:29,170 --> 01:11:30,610
I'll use capital.

1077
01:11:30,610 --> 01:11:32,200
It again works.

1078
01:11:32,200 --> 01:11:34,510
But this is perhaps not the best design.

1079
01:11:34,510 --> 01:11:39,220
Let me hide the terminal window and pull this up on the screen all at once.

1080
01:11:39,220 --> 01:11:43,195
Why might this arguably not be the best design, even though it's correct?

1081
01:11:46,250 --> 01:11:51,170
There's another term of art we can toss here, like [SNIFFS] something smells kind of funky about this code.

1082
01:11:51,170 --> 01:11:52,450
This is an actual term of art.

1083
01:11:52,450 --> 01:11:54,100
There's code smell here.

1084
01:11:54,100 --> 01:11:55,930
Something smells a little off.

1085
01:11:55,930 --> 01:11:56,620
Why?

1086
01:11:56,620 --> 01:11:57,894
What do you think?

1087
01:11:57,894 --> 01:12:01,846
AUDIENCE: [INAUDIBLE]

1088
01:12:06,895 --> 01:12:07,770
DAVID J. MALAN: Yeah.

1089
01:12:07,770 --> 01:12:09,370
There's the same output again and again.

1090
01:12:09,370 --> 01:12:10,530
I mean, I manually typed it.

1091
01:12:10,530 --> 01:12:17,080
But honestly, I might as well have just copied and pasted most of my original code to do it again and again for the two capital letters.

1092
01:12:17,080 --> 01:12:26,875
So if line 10 and 14 are the same AND line 18 and 22 are the same, AND then the rest of these if and else ifs are almost the same,

1093
01:12:26,875 --> 01:12:28,500
[SNIFFS] there's some code smell there.

1094
01:12:28,500 --> 01:12:29,370
It's not well designed.

1095
01:12:29,370 --> 01:12:29,820
Why?

1096
01:12:29,820 --> 01:12:32,778
Because if I want to change things now, just like last week in Scratch,

1097
01:12:32,778 --> 01:12:37,120
I might have to change my code in multiple places or copy/paste is never a good thing.

1098
01:12:37,120 --> 01:12:42,760
And god forbid I want to add support for Yes and No as full words, it's really going to get long.

1099
01:12:42,760 --> 01:12:44,170
So how can we solve this?

1100
01:12:44,170 --> 01:12:47,160
Well, it turns out, we can combine some of these thoughts.

1101
01:12:47,160 --> 01:12:49,470
So let me try to improve the Yeses first.

1102
01:12:49,470 --> 01:12:54,325
It turns out, if I delete that clause, I can actually or things together.

1103
01:12:54,325 --> 01:13:02,350
In Scratch, there's a couple of puzzle pieces, if you didn't discover them, that literally have the word or and the word and on them, which allow you to combine Boolean expressions.

1104
01:13:02,350 --> 01:13:06,600
So that either this or this is true, or this and this is true.

1105
01:13:06,600 --> 01:13:09,270
In C, you can't just say the word or.

1106
01:13:09,270 --> 01:13:12,850
You instead use two vertical bars.

1107
01:13:12,850 --> 01:13:16,260
And vertical bars together mean or, logically.

1108
01:13:16,260 --> 01:13:21,780
And so I can say, c equals equals quote/unquote capital Y, Agreed.

1109
01:13:21,780 --> 01:13:24,270
And now I can get rid of this code down here.

1110
01:13:24,270 --> 01:13:32,340
And let me go ahead and say, vertical bar twice c equals quote/unquote N in all caps.

1111
01:13:32,340 --> 01:13:36,870
And now my program's roughly a third smaller, which is good.

1112
01:13:36,870 --> 01:13:38,140
There's less redundancy.

1113
01:13:38,140 --> 01:13:49,860
And if I reopen my terminal window, rerun make of agree, ./agree, now I can type little y or big Y and same thing for lowercase and uppercase

1114
01:13:49,860 --> 01:13:56,407
N. Any questions then on this syntax, whereby now you can combine thoughts and just tighten things up?

1115
01:13:56,407 --> 01:13:57,990
And there'll be other such tricks too.

1116
01:13:57,990 --> 01:13:58,942
Yeah?

1117
01:13:58,942 --> 01:14:01,615
AUDIENCE: Is there not a function to just ignore the case?

1118
01:14:01,615 --> 01:14:03,240
DAVID J. MALAN: A really good question.

1119
01:14:03,240 --> 01:14:06,030
Is there not a function to just ignore the case?

1120
01:14:06,030 --> 01:14:07,890
Short answer, there is.

1121
01:14:07,890 --> 01:14:10,950
And we'll see how to do that in, actually, just about a week's time.

1122
01:14:10,950 --> 01:14:19,890
And in other languages, there's even more ways to just canonicalize the user's input, throwing away any space characters they might have accidentally hit, forcing everything to lowercase.

1123
01:14:19,890 --> 01:14:23,372
In C, It's going to be a little more work on our part to do that.

1124
01:14:23,372 --> 01:14:26,080
But in fact, as early as next week, we'll see how we can do that.

1125
01:14:26,080 --> 01:14:29,490
But for now we're comparing indeed just these literal values.

1126
01:14:29,490 --> 01:14:30,570
Other questions?

1127
01:14:30,570 --> 01:14:33,874
AUDIENCE: So we're assuming the user's putting in what they're suggesting.

1128
01:14:33,874 --> 01:14:37,618
How do you handle if they were to put in a number?

1129
01:14:37,618 --> 01:14:39,160
DAVID J. MALAN: Really good question.

1130
01:14:39,160 --> 01:14:45,360
So we are assuming, with this program and all of my last ones, that the human's cooperating and when I ask for their name, they typed in David

1131
01:14:45,360 --> 01:14:50,040
and not 123, or, in this case, they typed in a single character and not a full word.

1132
01:14:50,040 --> 01:14:53,520
So this is one of the features often of using a library.

1133
01:14:53,520 --> 01:15:01,330
So for instance, if I run agree again, and I say something like sure, Enter, it rejects it altogether.

1134
01:15:01,330 --> 01:15:01,830
Why?

1135
01:15:01,830 --> 01:15:05,850
Because s, u, r, e is a string of characters.

1136
01:15:05,850 --> 01:15:07,320
It's not a single character.

1137
01:15:07,320 --> 01:15:11,380
Now, I could just say something like x, which is neither y nor n, of course.

1138
01:15:11,380 --> 01:15:14,190
But it tolerates that because it's a single character.

1139
01:15:14,190 --> 01:15:19,210
But built in to CS50's library is some built-in rejections of inputs that's not expected.

1140
01:15:19,210 --> 01:15:26,940
So if you use get_int and the user types in not the number 1 or 2 but cat, C-A-T, it will just prompt them again, prompt them again.

1141
01:15:26,940 --> 01:15:34,068
And this is where, too, if you were to do this manually in C, you end up writing this much code just to check for all of these errors.

1142
01:15:34,068 --> 01:15:38,190
That's why we use these training wheels for a few weeks just to make the code more robust.

1143
01:15:38,190 --> 01:15:40,500
But in a few weeks' time, we'll take the liberty away.

1144
01:15:40,500 --> 01:15:44,970
And you'll see and understand how it's indeed doing all that.

1145
01:15:44,970 --> 01:15:46,750
All right, so how about this.

1146
01:15:46,750 --> 01:15:54,567
Let's now transition to something a little more Scratch-like, literally, by creating how about another program here called meow-- so meow.c.

1147
01:15:54,567 --> 01:15:56,650
We won't have any audio capabilities for this one.

1148
01:15:56,650 --> 01:15:57,750
We'll just rely on print.

1149
01:15:57,750 --> 01:16:03,000
And suppose that I wanted to write a program and see that just simulates a cat meowing.

1150
01:16:03,000 --> 01:16:04,960
So I don't need any user input just yet.

1151
01:16:04,960 --> 01:16:06,960
So I'm just going to use stdio.h.

1152
01:16:06,960 --> 01:16:09,940
I'm going to do my usual int main(void) up here.

1153
01:16:09,940 --> 01:16:13,710
And then I'm just going to go ahead and do printf meow backslash n.

1154
01:16:13,710 --> 01:16:16,650
And let's have this cat meow three times, like last week.

1155
01:16:16,650 --> 01:16:18,870
So I'm going to do meow, meow, meow.

1156
01:16:18,870 --> 01:16:22,350
Notice as an aside whenever you highlight the lines, you'll see little dots appear.

1157
01:16:22,350 --> 01:16:26,460
This is just a visual cue to you to let you figure out how many spaces you've indented.

1158
01:16:26,460 --> 01:16:30,133
VS Code, like a lot of editors, will automatically indent your code for you.

1159
01:16:30,133 --> 01:16:32,550
I've not been hitting the space bar four times every time.

1160
01:16:32,550 --> 01:16:34,020
I've not even been hitting Tab.

1161
01:16:34,020 --> 01:16:41,933
However, in C, the convention is indeed to indent lines where appropriate by four spaces-- so not three, not five.

1162
01:16:41,933 --> 01:16:45,850
And these dots help you see things so that they just line up as a matter of good style.

1163
01:16:45,850 --> 01:16:49,600
All right, so this program, I'm just going to stipulate right now, is indeed going to work.

1164
01:16:49,600 --> 01:16:52,560
Make meow-- which is kind of cute-- and now meow.

1165
01:16:52,560 --> 01:16:54,000
There, three times.

1166
01:16:54,000 --> 01:16:54,540
Correct.

1167
01:16:54,540 --> 01:16:55,500
It's meowing three times.

1168
01:16:55,500 --> 01:16:57,060
But of course, this is not well designed.

1169
01:16:57,060 --> 01:16:58,935
It wasn't well designed in Scratch last week.

1170
01:16:58,935 --> 01:17:00,480
Why?

1171
01:17:00,480 --> 01:17:03,130
What should I be doing differently?

1172
01:17:03,130 --> 01:17:03,630
Yeah?

1173
01:17:03,630 --> 01:17:04,120
AUDIENCE: A loop?

1174
01:17:04,120 --> 01:17:05,412
AUDIENCE: This could be a loop.

1175
01:17:05,412 --> 01:17:07,140
DAVID J. MALAN: Yeah.

1176
01:17:07,140 --> 01:17:09,310
It's a perfect opportunity for a loop.

1177
01:17:09,310 --> 01:17:09,810
Why?

1178
01:17:09,810 --> 01:17:18,390
Because if you wanted to change maybe the capitalization of these words, or you wanted to change the sound to like woof for a dog or something, you'd have to change it one, two, three places.

1179
01:17:18,390 --> 01:17:20,160
And that's just kind of stupid, right?

1180
01:17:20,160 --> 01:17:23,020
In code, you should ideally change things in one place.

1181
01:17:23,020 --> 01:17:24,880
So how might I do that?

1182
01:17:24,880 --> 01:17:27,120
Well, we could introduce a loop, yes.

1183
01:17:27,120 --> 01:17:32,710
But we're going to need another building block as well that we had in Scratch, namely those things called variables.

1184
01:17:32,710 --> 01:17:38,520
So recall that a variable, like an algebra-- x, y, z, whatever-- can store a value for you.

1185
01:17:38,520 --> 01:17:42,630
And a variable in Scratch might have looked like this.

1186
01:17:42,630 --> 01:17:46,890
You use this orange puzzle piece to set a variable of any name, not just x, y, or z.

1187
01:17:46,890 --> 01:17:51,840
But you could call it something more descriptive, like counter, and you can set it equal to some value.

1188
01:17:51,840 --> 01:17:57,570
In C, the way to do this is similar to spirit to some of the syntax we've seen thus far.

1189
01:17:57,570 --> 01:18:01,740
You start by saying the name of the variable you want, a single equal sign, and then the value.

1190
01:18:01,740 --> 01:18:05,470
You want to initialize it too, copying therefore from right to left.

1191
01:18:05,470 --> 01:18:05,970
Why?

1192
01:18:05,970 --> 01:18:09,570
Because the equal sign denotes, again, assignment from right to left.

1193
01:18:09,570 --> 01:18:10,740
This isn't enough though.

1194
01:18:10,740 --> 01:18:12,282
You might have the intuition already.

1195
01:18:12,282 --> 01:18:16,170
What's missing probably from this line of code just to create a variable?

1196
01:18:16,170 --> 01:18:16,767
AUDIENCE: Int.

1197
01:18:16,767 --> 01:18:20,610
DAVID J. MALAN: So we need int to make sure the computer knows that this is indeed an int.

1198
01:18:20,610 --> 01:18:23,802
And then lastly, semicolon as well.

1199
01:18:23,802 --> 01:18:25,260
And that now completes the thought.

1200
01:18:25,260 --> 01:18:28,660
So a little more annoying than Scratch, but we're starting to see patterns here.

1201
01:18:28,660 --> 01:18:30,810
So not every piece of syntax will be new.

1202
01:18:30,810 --> 01:18:33,480
All right, if you want to increment the counter by one,

1203
01:18:33,480 --> 01:18:37,480
Scratch uses the verb change, and they mean add the value to counter.

1204
01:18:37,480 --> 01:18:43,930
So if I want to increment an existing variable called counter, this syntax is a little more interesting.

1205
01:18:43,930 --> 01:18:48,690
It turns out the code looks like this, which almost seems like a paradox.

1206
01:18:48,690 --> 01:18:51,990
How can counter equal counter plus 1?

1207
01:18:51,990 --> 01:18:53,160
That's not how math works.

1208
01:18:53,160 --> 01:18:56,860
But again, a single equal sign is assignment from right to left.

1209
01:18:56,860 --> 01:19:03,930
So this is saying, take whatever the value of counter is, add 1 to it, and copy that value from right to left into counter itself.

1210
01:19:03,930 --> 01:19:13,330
You still need the semicolon, but I claim you do not need to mention the keyword int when updating an existing variable.

1211
01:19:13,330 --> 01:19:23,370
So only when you create a variable in C do you use the word string, or the word int, or any of the others we'll eventually see-- only when creating it or initializing it for the first time.

1212
01:19:23,370 --> 01:19:25,780
Thereafter if you want to change it, it just exists.

1213
01:19:25,780 --> 01:19:27,060
It's the word you gave it.

1214
01:19:27,060 --> 01:19:29,950
The computer is smart enough to at least remember what type it is.

1215
01:19:29,950 --> 01:19:32,100
So this line is now complete

1216
01:19:32,100 --> 01:19:37,740
Turns out, in code, as we'll see, it's pretty common to want to add things together, increment things by one.

1217
01:19:37,740 --> 01:19:40,710
So there's actually different syntax for the same idea.

1218
01:19:40,710 --> 01:19:43,290
The term of art here is syntactic sugar.

1219
01:19:43,290 --> 01:19:49,900
There's often in code many ways to do the same thing, even though, at the end of the day, they do exactly the same functionality.

1220
01:19:49,900 --> 01:19:57,765
So for instance, if, after a few days of CS50, you find this a little tedious to keep typing in some program, you can simplify it to just this.

1221
01:19:57,765 --> 01:19:59,340
This is the syntactic sugar.

1222
01:19:59,340 --> 01:20:06,480
You can use plus equals and only mention the variable name once on the left, and it just knows that means the previous thing.

1223
01:20:06,480 --> 01:20:10,420
It's just slightly more succinct.

1224
01:20:10,420 --> 01:20:12,900
This, too, is such a common thing to add 1 to a value.

1225
01:20:12,900 --> 01:20:13,800
And it doesn't have to be 1.

1226
01:20:13,800 --> 01:20:14,800
But in this case, it is.

1227
01:20:14,800 --> 01:20:20,550
But if it is indeed 1, you can further tighten the code up to just do this, counter++.

1228
01:20:20,550 --> 01:20:26,472
So any time in C you see ++, it means literally adding 1 to that particular variable.

1229
01:20:26,472 --> 01:20:28,680
There's other ways to do this in the other direction.

1230
01:20:28,680 --> 01:20:38,490
If you want to subtract 1 from a variable, you can use any of the previous syntax using a minus sign instead of plus, or you can more succinctly do counter--.

1231
01:20:38,490 --> 01:20:42,520
This is the way a typical C programmer would do this.

1232
01:20:42,520 --> 01:20:47,500
All right, so if we have no variables, let's go and solve the meowing with loop.

1233
01:20:47,500 --> 01:20:49,320
So in Scratch, we saw loops like this.

1234
01:20:49,320 --> 01:20:52,680
This, of course, had the cat meow three times.

1235
01:20:52,680 --> 01:20:54,480
How do we do this in C?

1236
01:20:54,480 --> 01:21:03,520
Now, this is where things get a little more involved code-wise. but if you understand each and every line, we'll follow logically what's going on.

1237
01:21:03,520 --> 01:21:12,330
So here, I claim, is one way to implement a loop that iterates three times in C. And this is kind of ridiculous, right?

1238
01:21:12,330 --> 01:21:18,990
We went from two super simple puzzle pieces like this to, my god, it's 1, 2, 3, 4, 5, 6 lines of code, all of which are pretty involved.

1239
01:21:18,990 --> 01:21:20,740
So that escalated quickly.

1240
01:21:20,740 --> 01:21:21,960
But what's each line doing?

1241
01:21:21,960 --> 01:21:24,120
And we'll see other ways to do this more simply.

1242
01:21:24,120 --> 01:21:28,710
So we're initializing a variable called counter to 3, just like before.

1243
01:21:28,710 --> 01:21:29,370
Why?

1244
01:21:29,370 --> 01:21:32,800
Well, what does it mean to loop or to repeat something three times?

1245
01:21:32,800 --> 01:21:41,080
Well, it's like doing something three times, and then do it, and then count down, and then do it, and then count down, and then do it, until you're all out of counts.

1246
01:21:41,080 --> 01:21:44,910
So this is declaring a variable called counter, setting it equal to 3.

1247
01:21:44,910 --> 01:21:52,440
Then I'm inducing a loop in C, which is similar in spirit to repeat 3, but you have to do more of the math yourself.

1248
01:21:52,440 --> 01:21:59,200
So I'm asking the question in parentheses, while count is greater than 0, what do I want to do?

1249
01:21:59,200 --> 01:22:04,080
Well, per the indentation inside the curly braces, I want to meow one time.

1250
01:22:04,080 --> 01:22:06,990
And then, to be clear, what's this last line of code doing?

1251
01:22:06,990 --> 01:22:12,120
If counter starts off at three, this makes it 2 by subtracting 1 from it.

1252
01:22:12,120 --> 01:22:13,320
Then what happens?

1253
01:22:13,320 --> 01:22:21,010
By nature of the loop, just like in Scratch, it knows to go back and forth. even though there's a nice, pretty arrow in Scratch, and there isn't here,

1254
01:22:21,010 --> 01:22:28,870
C knows to do this again, and again, and again, constantly asking this question and then updating this value at the end.

1255
01:22:28,870 --> 01:22:33,690
So if I highlight just a few of these steps, the variable starts off at 3.

1256
01:22:33,690 --> 01:22:35,100
And actually, let me simplify 2.

1257
01:22:35,100 --> 01:22:43,480
I claimed earlier that when using single variables, people very often just call it i for int, or c for char, or s for string unless you have multiple variables.

1258
01:22:43,480 --> 01:22:44,730
So let me tighten the code up.

1259
01:22:44,730 --> 01:22:47,220
And this already makes it look a little more tolerable.

1260
01:22:47,220 --> 01:22:50,320
Let me actually tighten it up further, add one more step.

1261
01:22:50,320 --> 01:22:54,653
So now this is about as tight, as succinct as you can make this code at the moment.

1262
01:22:54,653 --> 01:22:56,320
So what's actually going to happen here?

1263
01:22:56,320 --> 01:22:59,550
Well, the first line of code executes, and that initializes i to 3.

1264
01:22:59,550 --> 01:23:00,900
Then we check the condition.

1265
01:23:00,900 --> 01:23:03,840
While i is greater than 0, is i greater than 0?

1266
01:23:03,840 --> 01:23:05,580
Well, per my three fingers, obviously.

1267
01:23:05,580 --> 01:23:07,590
So we print out meow on the screen.

1268
01:23:07,590 --> 01:23:13,110
Then we subtract 1 from i, at which point now we have 2 as the value of i.

1269
01:23:13,110 --> 01:23:15,330
Then the code goes back to the condition.

1270
01:23:15,330 --> 01:23:17,580
And notice, the condition there is in parentheses.

1271
01:23:17,580 --> 01:23:19,420
That's another Boolean expression.

1272
01:23:19,420 --> 01:23:23,340
So loops can use Boolean expressions, just like conditionals use

1273
01:23:23,340 --> 01:23:24,990
Boolean expressions to make decisions.

1274
01:23:24,990 --> 01:23:31,330
The loop, though, is deciding not whether to do this thing or that but whether to do the same thing again, and again, and again.

1275
01:23:31,330 --> 01:23:40,450
And as it ticks through the code one line after the other, it's ultimately going to get down to 1, and then 0, and then stop.

1276
01:23:40,450 --> 01:23:51,570
So put another way-- came with some props here-- so suppose this ball here is your variable, and you initialize it to 3 with three stress balls, you can do something three times, right?

1277
01:23:51,570 --> 01:23:56,653
If I want to give out three stress balls-- here's your chance for free stress balls without having to answer any questions.

1278
01:23:56,653 --> 01:23:57,400
OK, there we go.

1279
01:23:57,400 --> 01:24:00,180
So here we go, subtracting 1 from my variable.

1280
01:24:00,180 --> 01:24:01,830
I'm left with two.

1281
01:24:01,830 --> 01:24:02,460
Oh my god.

1282
01:24:02,460 --> 01:24:04,845
All right, don't tell Sanders.

1283
01:24:04,845 --> 01:24:07,470
[GRUNTS] Oh, I'm sorry.

1284
01:24:07,470 --> 01:24:08,080
Oh.

1285
01:24:08,080 --> 01:24:08,580
[LAUGHTER]

1286
01:24:08,580 --> 01:24:10,350
OK, that ended poorly.

1287
01:24:10,350 --> 01:24:11,070
Apologies.

1288
01:24:11,070 --> 01:24:11,570
All right.

1289
01:24:11,570 --> 01:24:17,037
But now the educational point, though, is that my variable has been decrement did further to just have--

1290
01:24:17,037 --> 01:24:18,370
I'm not throwing that far again.

1291
01:24:18,370 --> 01:24:19,620
I can't do this.

1292
01:24:19,620 --> 01:24:20,143
Here we go.

1293
01:24:20,143 --> 01:24:21,060
All right, here we go.

1294
01:24:21,060 --> 01:24:22,740
And one final subtraction.

1295
01:24:22,740 --> 01:24:24,880
And now our variable is left empty.

1296
01:24:24,880 --> 01:24:28,380
So we had three stress balls there, and that's all a variable is.

1297
01:24:28,380 --> 01:24:29,475
It's some kind of storage.

1298
01:24:29,475 --> 01:24:32,100
It's actually, of course, implemented in the computer's memory.

1299
01:24:32,100 --> 01:24:35,860
But metaphorically, it's really just a bowl with some values.

1300
01:24:35,860 --> 01:24:39,840
And every time you or, in this case, subtract, you're just changing the value of that variable.

1301
01:24:39,840 --> 01:24:44,610
And then the code, meanwhile, of course, in parentheses, is just checking, is the bowl empty?

1302
01:24:44,610 --> 01:24:46,570
Is the bowl empty?

1303
01:24:46,570 --> 01:24:50,350
AKA, is i greater than 0 or not?

1304
01:24:50,350 --> 01:24:55,210
Any questions on how we've implemented loops in this way?

1305
01:24:55,210 --> 01:24:58,080
And I owe you a stress ball after class.

1306
01:24:58,080 --> 01:24:59,820
Questions on loops?

1307
01:24:59,820 --> 01:25:03,240
All right, so it turns out, this is kind of ugly.

1308
01:25:03,240 --> 01:25:09,422
And this really starts to take the fun out of programming when you have to write out this sequence of steps.

1309
01:25:09,422 --> 01:25:11,380
So it turns out, there's other ways to do this.

1310
01:25:11,380 --> 01:25:16,410
But first, let's see, logically, how else you might express this because it's a little weird that we keep using zero.

1311
01:25:16,410 --> 01:25:19,890
So the one other way to do this would be to invert the logic.

1312
01:25:19,890 --> 01:25:23,820
You could absolutely start with your variable, call it i equal to 1.

1313
01:25:23,820 --> 01:25:28,290
And then you could ask the question, is i less than or equal to 3?

1314
01:25:28,290 --> 01:25:30,210
And notice a bit of new syntax here.

1315
01:25:30,210 --> 01:25:37,870
On your typical keyboard, there is number less than or equal sign or greater than or equal sign like you would write in math class with 1 over the other.

1316
01:25:37,870 --> 01:25:45,360
And so in C, you use two characters, less than followed by an equal sign or, if appropriate, greater than followed by in equal sign.

1317
01:25:45,360 --> 01:25:47,370
And that logically captures that idea.

1318
01:25:47,370 --> 01:25:50,580
So notice that I'm changing my questions.

1319
01:25:50,580 --> 01:25:55,830
I'm initializing i to 1, and then I'm going to increment it ultimately to 2 and then 3.

1320
01:25:55,830 --> 01:26:00,340
But because I'm doing less than or equal to, it's still going to go from 1, 2, 3.

1321
01:26:00,340 --> 01:26:01,530
So that works too.

1322
01:26:01,530 --> 01:26:03,810
We could similarly do this yet another way.

1323
01:26:03,810 --> 01:26:11,640
We could initialize i to 0, and then we could say, well, i is less than 3 and keep incrementing it.

1324
01:26:11,640 --> 01:26:14,940
And I showed this last form is actually the most canonical.

1325
01:26:14,940 --> 01:26:18,420
It might be the most human-like to think in terms of 1 to 3.

1326
01:26:18,420 --> 01:26:23,740
It might be the most stressball-like to think in terms of 3 to 0, counting down.

1327
01:26:23,740 --> 01:26:35,610
But typically, the go-to syntax for most programmers once you get comfortable counting from 0 is to always start counting from 0 and count up to less than the value you're counting up to.

1328
01:26:35,610 --> 01:26:40,043
So it would be incorrect, why, to change this to less than or equal to 3 here?

1329
01:26:40,043 --> 01:26:42,960
What would happen if I changed the less than to less than or equal to?

1330
01:26:42,960 --> 01:26:44,340
AUDIENCE: It'll only meow twice.

1331
01:26:44,340 --> 01:26:47,780
DAVID J. MALAN: Yeah, it'll meow an extra-- a fourth time, in fact, total, right?

1332
01:26:47,780 --> 01:26:51,150
Because you'll start at 0, then 1, then 2, then 3.

1333
01:26:51,150 --> 01:26:53,220
And less than or equal to 3-- sorry--

1334
01:26:53,220 --> 01:26:55,420
3 will give you the fourth time.

1335
01:26:55,420 --> 01:26:58,650
So we do want indeed to be just a single less than.

1336
01:26:58,650 --> 01:27:02,490
All right, so now that we have those options, let me just give you one other.

1337
01:27:02,490 --> 01:27:07,210
And this one takes a little more, getting used to as well, but it's probably the more common way to write this.

1338
01:27:07,210 --> 01:27:11,590
Let me go ahead and propose that we implement this as follows.

1339
01:27:11,590 --> 01:27:13,390
Let me go back to my code here.

1340
01:27:13,390 --> 01:27:21,000
Let me go into my several printfs, getting rid of all but one of them ultimately.

1341
01:27:21,000 --> 01:27:22,750
And let's implement this in code.

1342
01:27:22,750 --> 01:27:36,930
So let's do int i get 0, how about then while i is less than 3, then let's go ahead and say printf quote/unquote meow-- melow-- meow backslash n.

1343
01:27:36,930 --> 01:27:41,310
And then we have to do i minus minus or plus plus?

1344
01:27:41,310 --> 01:27:42,237
AUDIENCE: Plus plus.

1345
01:27:42,237 --> 01:27:47,120
DAVID J. MALAN: So plus plus because we're starting at 0 and going up to but not through 3.

1346
01:27:47,120 --> 01:27:52,970
So let me go ahead now and make meow after clearing my terminal, ./meow, and it's still just as correct.

1347
01:27:52,970 --> 01:27:56,730
But it's a little more-- it's a little better designed.

1348
01:27:56,730 --> 01:27:57,230
Why?

1349
01:27:57,230 --> 01:28:00,770
Because now if I want to change it from 3 to 30 times, for instance,

1350
01:28:00,770 --> 01:28:01,850
I can change it there.

1351
01:28:01,850 --> 01:28:03,770
I can recompile my code.

1352
01:28:03,770 --> 01:28:06,020
I can do ./meow, and done.

1353
01:28:06,020 --> 01:28:09,450
I don't have to copy and paste it 27 more times to get that effect.

1354
01:28:09,450 --> 01:28:13,400
And I can even change what the word is by changing it in just one location.

1355
01:28:13,400 --> 01:28:15,920
But it turns out, there's other ways to do this too.

1356
01:28:15,920 --> 01:28:20,502
And let me propose that we introduce you to what's called a for loop as well.

1357
01:28:20,502 --> 01:28:27,500
So if you want to repeat something three times, you can absolutely take the while loop approach that we just saw, or you can do this.

1358
01:28:27,500 --> 01:28:34,200
And this one takes a little more, getting used to, but it kind of consolidates into one line all of the same logic.

1359
01:28:34,200 --> 01:28:36,830
So notice, we have the keyword for here.

1360
01:28:36,830 --> 01:28:42,110
And for is just a preposition in this case that generally implies, here comes a loop.

1361
01:28:42,110 --> 01:28:46,097
Inside of parentheses here is not just a Boolean expression.

1362
01:28:46,097 --> 01:28:47,930
And this is where things get a little weird.

1363
01:28:47,930 --> 01:28:54,230
There's three things-- to the left of the semicolon, in the middle of the two semicolons, and to the right of the semicolon.

1364
01:28:54,230 --> 01:28:58,198
This is really the only other context we'll see semicolons, and it's weird.

1365
01:28:58,198 --> 01:28:59,990
Normally, it's been at the end of the line.

1366
01:28:59,990 --> 01:29:04,920
Now it's two of them in the middle of the line, but this is the way humans decided years ago to do it.

1367
01:29:04,920 --> 01:29:06,080
So what is this doing?

1368
01:29:06,080 --> 01:29:07,850
Almost the same thing.

1369
01:29:07,850 --> 01:29:12,320
It is going to initialize a variable called i to 0.

1370
01:29:12,320 --> 01:29:14,240
It's going to then check.

1371
01:29:14,240 --> 01:29:22,980
If it's less than 3, it's then going to do whatever's in the curly braces, and it's lastly going to increment i and repeat.

1372
01:29:22,980 --> 01:29:28,340
So just highlighting those in turn, at first, i is initialized to 0, just like before.

1373
01:29:28,340 --> 01:29:30,170
Then this condition is checked.

1374
01:29:30,170 --> 01:29:32,150
This is a Boolean expression.

1375
01:29:32,150 --> 01:29:34,610
Yes or no, true or false will be its answer.

1376
01:29:34,610 --> 01:29:40,550
And if i is less than 3, which it should be once it starts at 0, well, then we're going to go ahead and print out meow.

1377
01:29:40,550 --> 01:29:42,350
Then i is going to get incremented.

1378
01:29:42,350 --> 01:29:43,580
So it starts at 0.

1379
01:29:43,580 --> 01:29:45,170
It goes now to 1.

1380
01:29:45,170 --> 01:29:48,150
At that point, the Boolean expression is checked again.

1381
01:29:48,150 --> 01:29:50,840
So you don't keep changing i back to 0.

1382
01:29:50,840 --> 01:29:53,210
That first step happens only once.

1383
01:29:53,210 --> 01:29:56,270
But now you repeat through those three other highlights.

1384
01:29:56,270 --> 01:29:57,770
I check if i is less than 3.

1385
01:29:57,770 --> 01:29:58,320
It is.

1386
01:29:58,320 --> 01:29:59,600
So I print out meow.

1387
01:29:59,600 --> 01:30:00,875
It then increments i.

1388
01:30:00,875 --> 01:30:03,410
I check if i, now 2, is less than 3.

1389
01:30:03,410 --> 01:30:03,980
It is.

1390
01:30:03,980 --> 01:30:06,380
I print out meow. i gets incremented.

1391
01:30:06,380 --> 01:30:07,100
I now check.

1392
01:30:07,100 --> 01:30:08,120
Is i less than 3?

1393
01:30:08,120 --> 01:30:11,360
No, it's not, because 3 is not less than 3.

1394
01:30:11,360 --> 01:30:12,800
And so the whole thing stops.

1395
01:30:12,800 --> 01:30:17,420
And whatever code is below this curly brace, if any, starts executing instead.

1396
01:30:17,420 --> 01:30:22,610
Just like in Scratch, you break out of the loop and the puzzle pieces being hugged.

1397
01:30:22,610 --> 01:30:31,520
Questions, then, about this alternative syntax for loops, AKA, a for loop?

1398
01:30:31,520 --> 01:30:34,195
AUDIENCE: Can you explain again why it doesn't go back to 0?

1399
01:30:34,195 --> 01:30:35,570
DAVID J. MALAN: Sorry, say again?

1400
01:30:35,570 --> 01:30:37,400
AUDIENCE: Can you explain again why it doesn't reset to 0?

1401
01:30:37,400 --> 01:30:38,275
DAVID J. MALAN: Yeah.

1402
01:30:38,275 --> 01:30:40,400
Can I explain again why it doesn't reset to 0?

1403
01:30:40,400 --> 01:30:41,690
Honestly, just because.

1404
01:30:41,690 --> 01:30:43,490
This was the syntax they chose.

1405
01:30:43,490 --> 01:30:47,660
This first part before the first semicolon is only executed once just because.

1406
01:30:47,660 --> 01:30:48,740
That's how it's designed.

1407
01:30:48,740 --> 01:30:51,660
Everything else cycles again and again.

1408
01:30:51,660 --> 01:30:55,610
And this is just an alternative syntax to using the slightly more lines of code.

1409
01:30:55,610 --> 01:30:57,818
It was, like, six lines of code using the while loop.

1410
01:30:57,818 --> 01:30:59,387
Logically, it's the same thing.

1411
01:30:59,387 --> 01:31:05,240
Programmers, once they get more comfortable, tend to prefer this because it just expresses all your same thoughts more succinctly.

1412
01:31:05,240 --> 01:31:06,380
That's all.

1413
01:31:06,380 --> 01:31:06,890
Yeah?

1414
01:31:06,890 --> 01:31:07,620
AUDIENCE: That was my question.

1415
01:31:07,620 --> 01:31:08,412
DAVID J. MALAN: OK.

1416
01:31:08,412 --> 01:31:11,210
So let's just work this into my meow example.

1417
01:31:11,210 --> 01:31:12,590
Let me go back to the code here.

1418
01:31:12,590 --> 01:31:14,898
And notice, indeed, if I highlight all these lines,

1419
01:31:14,898 --> 01:31:16,190
I think we can tighten this up.

1420
01:31:16,190 --> 01:31:21,350
Let me get rid of all of those and instead do for int i equals 0.

1421
01:31:21,350 --> 01:31:22,790
And I'm saying equals.

1422
01:31:22,790 --> 01:31:24,260
Most programmers would say gets.

1423
01:31:24,260 --> 01:31:28,130
So int i gets 0 means assignment-- the word get.

1424
01:31:28,130 --> 01:31:32,360
Now I'm going to do i is less than 3 i++.

1425
01:31:32,360 --> 01:31:37,670
Now in here I'm going to do my printf quote/unquote meow backslash n.

1426
01:31:37,670 --> 01:31:39,450
And so it's indeed a little tighter.

1427
01:31:39,450 --> 01:31:41,408
I mean, two of the lines are just curly braces.

1428
01:31:41,408 --> 01:31:43,580
There's really only two juicy lines of code now.

1429
01:31:43,580 --> 01:31:47,460
Let me go ahead and do make meow, ./meow.

1430
01:31:47,460 --> 01:31:51,680
And again, we're back in business with three of them printing only.

1431
01:31:51,680 --> 01:31:56,330
All right, there's one last structure we should explore just because it's sometimes useful.

1432
01:31:56,330 --> 01:31:58,010
This was a forever block.

1433
01:31:58,010 --> 01:32:02,750
And this would be a little weird in Scratch to just say meow forever, or at least without waiting.

1434
01:32:02,750 --> 01:32:07,490
But there is indeed a forever block in Scratch, which means do the following, forever.

1435
01:32:07,490 --> 01:32:11,360
And I proposed, I think, verbally last week at least one example where this is useful.

1436
01:32:11,360 --> 01:32:13,040
Meowing forever, a little annoying.

1437
01:32:13,040 --> 01:32:19,100
But can you think of common cases where you might want to write code or use a program that loops forever?

1438
01:32:19,100 --> 01:32:19,657
Yeah?

1439
01:32:19,657 --> 01:32:21,740
AUDIENCE: Playing music throughout an entire game.

1440
01:32:21,740 --> 01:32:22,970
DAVID J. MALAN: Yeah, playing music.

1441
01:32:22,970 --> 01:32:26,495
Like Spotify playlists, just repeating again and again would be some kind of loop.

1442
01:32:26,495 --> 01:32:28,310
AUDIENCE: Checking for collisions.

1443
01:32:28,310 --> 01:32:32,548
DAVID J. MALAN: Checking for collisions in Scratch, so seeing if something's bouncing off the wall or another sprite.

1444
01:32:32,548 --> 01:32:33,590
Yeah?

1445
01:32:33,590 --> 01:32:36,512
AUDIENCE: Oh, checking for input.

1446
01:32:36,512 --> 01:32:37,970
DAVID J. MALAN: Checking for input.

1447
01:32:37,970 --> 01:32:43,300
So yeah, get_string is essentially just waiting there forever for me to type in some input until I do.

1448
01:32:43,300 --> 01:32:44,470
AUDIENCE: Checking the time.

1449
01:32:44,470 --> 01:32:47,860
DAVID J. MALAN: Checking the time and actually maintaining human time, like a wall clock.

1450
01:32:47,860 --> 01:32:48,550
Behind you?

1451
01:32:48,550 --> 01:32:49,420
Is that the same?

1452
01:32:49,420 --> 01:32:50,590
AUDIENCE: I was going to say checking the time.

1453
01:32:50,590 --> 01:32:52,173
DAVID J. MALAN: OK, checking the time.

1454
01:32:52,173 --> 01:32:52,900
And one more?

1455
01:32:52,900 --> 01:32:53,995
Detecting a key press too.

1456
01:32:53,995 --> 01:32:58,182
Like in Scratch, just waiting for some kind of event to happen, just like on a phone or a browser.

1457
01:32:58,182 --> 01:33:04,520
And so there's so many examples where you might want to do something forever-- just so you've seen the corresponding C building block.

1458
01:33:04,520 --> 01:33:14,950
It's a little weird, but this is probably the most canonical way to do it in C. If you want to print meow forever-- which would be a little crazy because it would literally print and take over

1459
01:33:14,950 --> 01:33:18,850
your computer printing forever meow-- you would generally do it like this.

1460
01:33:18,850 --> 01:33:19,490
Why?

1461
01:33:19,490 --> 01:33:26,020
Well, a while loop expects in parentheses a Boolean expression, and a Boolean expression is, again, a yes/no, a true/false question.

1462
01:33:26,020 --> 01:33:35,950
But if you want the answer to that question always to be yes-- or really, always to be true, turns out in C and a lot of languages will then just say true because true--

1463
01:33:35,950 --> 01:33:38,800
T-R-U-E-- is never going to change magically to false.

1464
01:33:38,800 --> 01:33:41,570
I mean, it's just a special word in the programming language.

1465
01:33:41,570 --> 01:33:45,680
So by saying while true, it just means do the following forever.

1466
01:33:45,680 --> 01:33:54,220
Another common paradigm before true and false became commonplace would be to do this instead-- change while 1.

1467
01:33:54,220 --> 01:33:59,770
You might see in online examples and texts and the like, while 1 is really the same thing.

1468
01:33:59,770 --> 01:34:04,840
Any value that is 0 is generally interpreted as false by a computer.

1469
01:34:04,840 --> 01:34:11,210
Any value that is 1 or any other non-zero value is generally interpreted as true.

1470
01:34:11,210 --> 01:34:15,400
And so this, too, would have the same effect, saying while true or while 1.

1471
01:34:15,400 --> 01:34:18,700
Generally speaking, while true is perhaps a little clearer these days.

1472
01:34:18,700 --> 01:34:20,650
Now, meowing forever is not a good thing.

1473
01:34:20,650 --> 01:34:23,770
But suppose I did that by intent or by accident.

1474
01:34:23,770 --> 01:34:24,950
Well, let's try this.

1475
01:34:24,950 --> 01:34:26,570
So here I'll go into my code.

1476
01:34:26,570 --> 01:34:32,180
I'm going to get rid of for loop and change my while loop to, how about, true.

1477
01:34:32,180 --> 01:34:36,100
And in this case here, well, we'll keep it-- let's do this.

1478
01:34:36,100 --> 01:34:38,230
Make meow, Enter.

1479
01:34:38,230 --> 01:34:41,840
And you'll see this, use of undeclared identifier true.

1480
01:34:41,840 --> 01:34:46,360
This is actually hinting at my mention that the old way was 0 and 1.

1481
01:34:46,360 --> 01:34:48,220
Nowadays, you could say true or false.

1482
01:34:48,220 --> 01:34:53,560
But true and false are themselves special words that you have to include.

1483
01:34:53,560 --> 01:35:03,640
And it turns out, if you want to use special Boolean values like this, there's another header file we haven't seen called stdbool that essentially creates true and false as keywords.

1484
01:35:03,640 --> 01:35:06,550
Alternatively, CS50 includes that same file.

1485
01:35:06,550 --> 01:35:08,980
So it's more common in CS50 is to see it like this.

1486
01:35:08,980 --> 01:35:13,360
Now if I clear my terminal window and do make meow and then ./meow and hit

1487
01:35:13,360 --> 01:35:21,350
Enter, well, unfortunately, this isn't the best thing to do infinitely when you're in the cloud using a browser.

1488
01:35:21,350 --> 01:35:24,970
This is indeed a browser, just full-screened here.

1489
01:35:24,970 --> 01:35:29,462
This means I'm sending millions of meows over the internet to my computer here.

1490
01:35:29,462 --> 01:35:32,170
So this will happen to you at some point, probably not with meow.

1491
01:35:32,170 --> 01:35:34,150
But you'll lose control over your terminal window.

1492
01:35:34,150 --> 01:35:34,420
Why?

1493
01:35:34,420 --> 01:35:35,170
Because you screwed up.

1494
01:35:35,170 --> 01:35:36,250
And you have an infinite loop.

1495
01:35:36,250 --> 01:35:37,090
You didn't really intend it.

1496
01:35:37,090 --> 01:35:37,690
Or maybe you did.

1497
01:35:37,690 --> 01:35:39,232
You were curious to see what happens.

1498
01:35:39,232 --> 01:35:41,590
What do you do?

1499
01:35:41,590 --> 01:35:43,930
When does the meowing stop?

1500
01:35:43,930 --> 01:35:45,910
What recourse do we have here?

1501
01:35:45,910 --> 01:35:48,550
Well, Control-C will be your friend.

1502
01:35:48,550 --> 01:35:51,070
Sometimes you have to hit it a bunch in a cloud environment.

1503
01:35:51,070 --> 01:35:55,540
But Control-C for cancel will interrupt a program that's running.

1504
01:35:55,540 --> 01:36:02,560
And I promise that almost all of you will at some point accidentally introduce an infinite loop because your math is slightly off.

1505
01:36:02,560 --> 01:36:09,545
When in doubt, click in the terminal window and hit Control-C-- sometimes multiple times-- and that will indeed cancel whatever is happening there.

1506
01:36:09,545 --> 01:36:11,170
In this case, I might have intended it.

1507
01:36:11,170 --> 01:36:14,330
But sometimes it's not, in fact, intended.

1508
01:36:14,330 --> 01:36:23,890
All right, so we've been taking for granted this whole graphical user interface for some time and, indeed, the commands that I'm typing and the buttons on I'm clicking.

1509
01:36:23,890 --> 01:36:31,630
And let me just give you a better sense of what it is we are using underneath the hood this whole time, namely an operating system called Linux.

1510
01:36:31,630 --> 01:36:38,680
So I keep alluding verbally, of course, to Macs and PCs because almost all of us are running macOS or Windows on our desktops or laptops nowadays.

1511
01:36:38,680 --> 01:36:43,330
But there's lots of other operating systems out there, and one of the most popular one is called Linux.

1512
01:36:43,330 --> 01:36:51,610
And Linux is very often used on servers nowadays-- companies that host email, companies that host websites or apps, more generally.

1513
01:36:51,610 --> 01:36:56,950
Certain computer scientists or computer science students often like to brag that they run Linux just because that's a thing.

1514
01:36:56,950 --> 01:37:07,480
But it is really just an alternative to macOS or Windows that provides you with both a GUI, if you want it, but also an especially a command line environment.

1515
01:37:07,480 --> 01:37:12,550
Now, fun fact-- Windows and macOS do have terminal windows or the equivalent thereof.

1516
01:37:12,550 --> 01:37:16,150
And eventually, you might use it on your own Mac or PC to solve some problem.

1517
01:37:16,150 --> 01:37:26,500
But Linux is really known for, along with other operating systems, its command line environment, which, again, I distinguished earlier from GUI as a Command Line Interface, or CLI.

1518
01:37:26,500 --> 01:37:29,450
And that refers, really, to the terminal window.

1519
01:37:29,450 --> 01:37:39,640
So if I go back to VS Code here, and let me, in fact, go ahead and close my tab and focus entirely on the terminal window, this terminal window is really just your command line interface

1520
01:37:39,640 --> 01:37:42,390
to your very own server in the cloud.

1521
01:37:42,390 --> 01:37:51,430
The term of art here is you each will have your own container in the cloud, which is like your own computer running somewhere on the internet with your own username and password

1522
01:37:51,430 --> 01:37:57,430
to which you have access and your own hard drive, if you will, your own home folder that has all of your files for the class.

1523
01:37:57,430 --> 01:38:01,390
And it's only accessible to you unless you enable live sharing thereof.

1524
01:38:01,390 --> 01:38:06,400
So when you're typing commands here, it looks like you're typing them, of course, on your own Mac or PC.

1525
01:38:06,400 --> 01:38:15,830
But they're actually being sent over the browser to some server in the cloud where you are controlling, really, your own account therein.

1526
01:38:15,830 --> 01:38:19,390
So it turns out that there are other commands that are worth knowing.

1527
01:38:19,390 --> 01:38:21,292
And we'll give you just a few of these today.

1528
01:38:21,292 --> 01:38:24,710
And over the coming weeks will you have opportunities to play with others as well.

1529
01:38:24,710 --> 01:38:26,260
But these are some of the basics.

1530
01:38:26,260 --> 01:38:33,640
And they're all incredibly succinct because, indeed, for things you're typing at the command line, humans generally have not wanted to type out long commands.

1531
01:38:33,640 --> 01:38:35,890
So a lot of these are abbreviations here.

1532
01:38:35,890 --> 01:38:44,480
Now, perhaps the most common one I'll start with first is ls, a lowercase l and a lowercase s that stands for, succinctly, list.

1533
01:38:44,480 --> 01:38:47,380
So if I go to my terminal window now where up until now,

1534
01:38:47,380 --> 01:38:56,110
I've only typed code, which is a VS Code thing for creating an opening files, and make, which triggers the compilation of my code, what if I now type ls?

1535
01:38:56,110 --> 01:39:02,000
This will list all of the files in my current folder-- my hard drive in the cloud, if you will.

1536
01:39:02,000 --> 01:39:05,780
So if I hit Enter, you'll see a whole bunch of results.

1537
01:39:05,780 --> 01:39:07,240
Now, they're color coded too.

1538
01:39:07,240 --> 01:39:09,910
The white ones here end in .c.

1539
01:39:09,910 --> 01:39:15,790
Those are the source code files I've written during class today-- agree.c, compare.c, hello.c, and meow.c.

1540
01:39:15,790 --> 01:39:24,382
And you can perhaps guess, the green ones here that just by convention have an asterisk on the end to denote that they're special represent what?

1541
01:39:24,382 --> 01:39:25,340
One of the four others.

1542
01:39:25,340 --> 01:39:26,315
Yeah?

1543
01:39:26,315 --> 01:39:27,800
AUDIENCE: The machine code?

1544
01:39:27,800 --> 01:39:29,520
DAVID J. MALAN: Yeah, the machine code.

1545
01:39:29,520 --> 01:39:34,340
So those are my actual programs that are identically named minus the .c extension.

1546
01:39:34,340 --> 01:39:36,830
And the asterisk means that they're executable.

1547
01:39:36,830 --> 01:39:39,582
That is in the world of macOS or Windows, you would double click.

1548
01:39:39,582 --> 01:39:47,400
But in the world of a command line environment, that means you do ./ and then the name without the asterisk to execute or run the code therein.

1549
01:39:47,400 --> 01:39:54,990
So if I open up my File Explorer-- and I'm hitting Command-B on my computer here just as a keyboard shortcut-- you'll see the exact same thing.

1550
01:39:54,990 --> 01:39:59,210
So ls is the command line interface for listing the files in your account.

1551
01:39:59,210 --> 01:40:03,060
But here, because I'm using VS Code or any program like it,

1552
01:40:03,060 --> 01:40:06,213
I also get a graphical user interface as well.

1553
01:40:06,213 --> 01:40:07,880
So it's just two different places to be.

1554
01:40:07,880 --> 01:40:09,680
You're welcome to use whatever you're comfortable with.

1555
01:40:09,680 --> 01:40:14,720
But over time will you naturally get more comfortable and capable with the terminal window alone.

1556
01:40:14,720 --> 01:40:16,773
Well, what else is on this list here?

1557
01:40:16,773 --> 01:40:23,330
Well, during the break, I saw that in at least one of you, for instance, had created a file called hello instead of hello.c.

1558
01:40:23,330 --> 01:40:27,230
So you were in a situation where you did this accidentally and hit Enter.

1559
01:40:27,230 --> 01:40:30,420
And then you went ahead and typed in all of your code like this.

1560
01:40:30,420 --> 01:40:34,760
And then down in your terminal window, you were trying to do make hello, Enter.

1561
01:40:34,760 --> 01:40:38,960
And this now didn't actually do anything.

1562
01:40:38,960 --> 01:40:40,820
I can't-- I'm hitting--

1563
01:40:40,820 --> 01:40:42,380
I'm trying to run the command.

1564
01:40:42,380 --> 01:40:44,690
I got permission denied, as at least one of you did.

1565
01:40:44,690 --> 01:40:45,433
Now, why is that?

1566
01:40:45,433 --> 01:40:46,850
Well, let's just do a quick check.

1567
01:40:46,850 --> 01:40:53,180
If I do ls, I see now hello, but hello has no asterisk next to it, which means it's not executable.

1568
01:40:53,180 --> 01:40:53,930
That's my code.

1569
01:40:53,930 --> 01:40:54,470
Why?

1570
01:40:54,470 --> 01:40:57,540
Well, notice the top of my tab confirms, oh, I screwed up.

1571
01:40:57,540 --> 01:41:00,740
I didn't name my file hello.c, which it just has to be.

1572
01:41:00,740 --> 01:41:01,920
So what do you do?

1573
01:41:01,920 --> 01:41:05,810
Well, you could very hackishly copy this, create a new file, paste it in.

1574
01:41:05,810 --> 01:41:06,770
Or no, no, no.

1575
01:41:06,770 --> 01:41:09,890
We know how to rename things now here because that's one of our options.

1576
01:41:09,890 --> 01:41:11,100
Let me do this.

1577
01:41:11,100 --> 01:41:17,600
Let me do mv for move, hello, and then hello.c, and hit Enter.

1578
01:41:17,600 --> 01:41:20,250
You'll see the tab closes because hello no longer exists.

1579
01:41:20,250 --> 01:41:25,130
But if I now type ls, you'll see, ah, there is hello.c.

1580
01:41:25,130 --> 01:41:28,910
And if I open that file now, whew, there's all of my same code.

1581
01:41:28,910 --> 01:41:37,350
And now if I do make hello-- make hello-- now I do get an executable file where in the world is restored.

1582
01:41:37,350 --> 01:41:43,020
So mv, it's just a command not just for renaming, but it also turns out, eventually for moving files as well.

1583
01:41:43,020 --> 01:41:45,230
You can also create directories or folders.

1584
01:41:45,230 --> 01:41:48,950
So for instance, if I go into VS Code again, and suppose

1585
01:41:48,950 --> 01:41:52,760
I hover over here and click not on the plus file icon but plus folder,

1586
01:41:52,760 --> 01:41:57,620
I can create a folder called, for instance, pset1 for problem set 1 in the class.

1587
01:41:57,620 --> 01:42:02,840
And you'll see now that it's empty because all of my other files are in the default folder of my account.

1588
01:42:02,840 --> 01:42:05,460
But I could also go in there like this.

1589
01:42:05,460 --> 01:42:13,430
And I could click on File, and now I can create a new file called mario.c, which is one of the first problems, for instance.

1590
01:42:13,430 --> 01:42:18,960
But you'll notice now that mario.c is inside of the pset1 folder.

1591
01:42:18,960 --> 01:42:23,300
So if I zoom out and I type ls at my terminal window,

1592
01:42:23,300 --> 01:42:26,720
I won't see mario.c anywhere.

1593
01:42:26,720 --> 01:42:28,688
But I do see a pset1 folder.

1594
01:42:28,688 --> 01:42:31,730
And it's in light blue followed by a slash, which you don't have to type.

1595
01:42:31,730 --> 01:42:33,300
It just indicates that's a folder.

1596
01:42:33,300 --> 01:42:37,640
Now, I can visually at top left obviously see pwet1 contains mario.c.

1597
01:42:37,640 --> 01:42:42,800
But if I try to do something like make mario here, no rule to make target mario.

1598
01:42:42,800 --> 01:42:44,510
It just doesn't seem to exist.

1599
01:42:44,510 --> 01:42:46,650
And that's because you're in the wrong directory.

1600
01:42:46,650 --> 01:42:51,560
So in a command line interface, it's not quite as simple as just clicking on a folder, and voila, it opens.

1601
01:42:51,560 --> 01:42:55,250
You have to change into the directory or folder.

1602
01:42:55,250 --> 01:42:57,660
And cd is going to be the command there.

1603
01:42:57,660 --> 01:43:00,600
So if I want to actually change into that directory,

1604
01:43:00,600 --> 01:43:04,070
I can do cd, space, pset1, Enter.

1605
01:43:04,070 --> 01:43:05,960
And now you'll see my prompt changes.

1606
01:43:05,960 --> 01:43:09,200
And this is just a common convention, but it's not the only one out there.

1607
01:43:09,200 --> 01:43:12,470
Now I still have a dollar sign, which indicates where I can type commands.

1608
01:43:12,470 --> 01:43:16,520
But before it, I see a reminder constantly what folder I'm in.

1609
01:43:16,520 --> 01:43:26,120
And we put that there deliberately, like a lot of Linux users do just to remind themselves where they are because unlike macOS or Windows, where you have a nice, big window telling you where you are,

1610
01:43:26,120 --> 01:43:29,000
at the command line, you need to be reminded textually.

1611
01:43:29,000 --> 01:43:33,350
But now if I type ls and hit Enter, what should I see?

1612
01:43:33,350 --> 01:43:34,340
AUDIENCE: Mario.c

1613
01:43:34,340 --> 01:43:36,170
DAVID J. MALAN: Yeah, mario.c.

1614
01:43:36,170 --> 01:43:43,940
And now if I want to open it-- if I want to actually compile it, I can run make mario in this directory once I actually type out all of the code.

1615
01:43:43,940 --> 01:43:50,810
Rest assured that in problem sets and labs, we'll almost always-- certainly, in the first weeks of the class-- give you exactly the commands to type.

1616
01:43:50,810 --> 01:43:55,100
Odds are because it's new to many of you, you will accidentally type the wrong commands.

1617
01:43:55,100 --> 01:43:56,000
No big deal.

1618
01:43:56,000 --> 01:43:58,850
Just remember that you have different ways to solve these problems.

1619
01:43:58,850 --> 01:44:02,198
You've got the graphical File Explorer, which should feel a little more familiar.

1620
01:44:02,198 --> 01:44:14,420
But in time you'll start to know and, honestly, probably prefer commands like these-- so cd for Change Directory, cp for copy a file, ls for list, mkdir to make a directory--

1621
01:44:14,420 --> 01:44:21,924
create a new folder at the command line instead of with the button-- mv for move or rename, rm for--

1622
01:44:21,924 --> 01:44:22,770
AUDIENCE: Remove.

1623
01:44:22,770 --> 01:44:23,728
DAVID J. MALAN: Remove.

1624
01:44:23,728 --> 01:44:24,960
So be careful with that one.

1625
01:44:24,960 --> 01:44:26,520
Rmdir, remove directory.

1626
01:44:26,520 --> 01:44:28,860
And there's dozens, hundreds of other commands.

1627
01:44:28,860 --> 01:44:33,310
You won't need many of them, but we'll start to scratch the surface all the more over time.

1628
01:44:33,310 --> 01:44:40,380
But ultimately, this command line interface is going to be a more powerful mechanism, a more capable mechanism, and ultimately, a more efficient mechanism

1629
01:44:40,380 --> 01:44:51,880
for writing code, running commands, solving problems, analyzing data more generally, even though know there's going to be some growing pains early on just because it's probably so new for many of you.

1630
01:44:51,880 --> 01:44:56,475
So with that said, we have some problems still to solve, but we promised cookies today.

1631
01:44:56,475 --> 01:44:58,350
So let's go ahead and take a 10-minute break.

1632
01:44:58,350 --> 01:45:00,150
Cookies are now served in the transept.

1633
01:45:00,150 --> 01:45:02,910
And we'll be back here in 10.

1634
01:45:02,910 --> 01:45:04,740
All right, we are back.

1635
01:45:04,740 --> 01:45:10,740
And up until now, each of the code examples in C we've done have been designed to show one specific topic.

1636
01:45:10,740 --> 01:45:17,880
But we thought we'd try to take a step back and solve a more general problem and give you a sense of when given a problem set, for instance, or just

1637
01:45:17,880 --> 01:45:25,260
a programming problem more generally, where you even begin and how you go about approaching it when it's not obvious what the point of the exercise is.

1638
01:45:25,260 --> 01:45:31,500
So one of my favorite games from yesteryear is this one here, "Super Mario Brothers" that has come in so many different forms since.

1639
01:45:31,500 --> 01:45:37,450
But in this original two-dimensional side scroller game, there was a lot of artwork like this.

1640
01:45:37,450 --> 01:45:40,260
So for instance, up here in the sky were four question marks.

1641
01:45:40,260 --> 01:45:49,920
And we'll find that in C and a lot of programming languages initially, it's a lot easier, a lot more accessible to focus really on black and white type interactive programs textually as opposed

1642
01:45:49,920 --> 01:45:55,830
to full-fledged graphics and the like, but more on the more graphical acoustic type of programs before long.

1643
01:45:55,830 --> 01:46:00,720
But for now let me go over and propose that we try to just implement in ASCII art--

1644
01:46:00,720 --> 01:46:09,120
ASCII, again, being the code that maps numbers to letters, at least for English, into a textual version of these for question marks in the sky.

1645
01:46:09,120 --> 01:46:11,130
So for this, let me go over to VS Code.

1646
01:46:11,130 --> 01:46:16,923
I'll create my own version of mario.c that will be different from the one you're challenged with in problem set 1.

1647
01:46:16,923 --> 01:46:24,810
Indeed, in problem set 1, you'll be challenged to build a little something like this, albeit with hashtags for ASCII art instead of graphics.

1648
01:46:24,810 --> 01:46:28,120
And in mario.c, I want to just solve this simple problem first.

1649
01:46:28,120 --> 01:46:29,710
So it's all involving output.

1650
01:46:29,710 --> 01:46:33,090
So I'll do include stdio.h so I can use printf.

1651
01:46:33,090 --> 01:46:37,043
I'll do my int main(void)-- more on why we keep doing that in future weeks.

1652
01:46:37,043 --> 01:46:42,210
And I'm just going to do something simple initially, like 1, 2, 3, 4, backslash n.

1653
01:46:42,210 --> 01:46:50,410
This is about the simplest way I can implement four question marks in the sky like these here using pure text like this.

1654
01:46:50,410 --> 01:46:54,180
So let me go ahead and do make mario, ./mario, and voila.

1655
01:46:54,180 --> 01:46:55,830
We have those four question marks.

1656
01:46:55,830 --> 01:46:58,830
But we've seen, of course, that there are better ways to do this.

1657
01:46:58,830 --> 01:47:03,150
And if you wanted to generalize this to be five question marks, six,

1658
01:47:03,150 --> 01:47:08,100
60 different question marks, loop was always the answer for not repeating ourselves.

1659
01:47:08,100 --> 01:47:17,100
So maybe I should rewrite this a little bit more flexibly and say something like this, for in i get 0, i less than 4, i++.

1660
01:47:17,100 --> 01:47:25,800
And then inside of a for loop, now I can just do a single question mark, but I don't think what I've just done is correct.

1661
01:47:25,800 --> 01:47:29,280
Any one spot the aesthetic bug already?

1662
01:47:29,280 --> 01:47:34,200
Yeah, why is this wrong if I want to print the same thing?

1663
01:47:34,200 --> 01:47:34,710
Yeah?

1664
01:47:34,710 --> 01:47:38,275
AUDIENCE: The backslash n, you said to use it into [INAUDIBLE]..

1665
01:47:38,275 --> 01:47:39,150
DAVID J. MALAN: Yeah.

1666
01:47:39,150 --> 01:47:44,760
So I don't think I want a backslash n after every question mark because the goal is, again, this row of question marks in the sky.

1667
01:47:44,760 --> 01:47:50,700
So if I now recompile this, make mario, ./mario, OK, it's almost there.

1668
01:47:50,700 --> 01:47:54,820
But now I have that regression to where the dollar sign is not on its own line.

1669
01:47:54,820 --> 01:47:59,890
So I think I need a new line, but I don't think I want it here because that was not going to end well.

1670
01:47:59,890 --> 01:48:01,015
Where do I want to instead?

1671
01:48:03,310 --> 01:48:03,960
Any instinct?

1672
01:48:03,960 --> 01:48:05,610
Yeah?

1673
01:48:05,610 --> 01:48:07,380
Yeah, so outside for loop.

1674
01:48:07,380 --> 01:48:11,640
So indeed, I can just go below line 8 and above line 9, creating a new one.

1675
01:48:11,640 --> 01:48:15,273
And now it's totally fine to just print a new line like that.

1676
01:48:15,273 --> 01:48:17,190
You don't have to print anything else with it.

1677
01:48:17,190 --> 01:48:18,970
It's indeed a character unto itself.

1678
01:48:18,970 --> 01:48:21,900
So let's do make mario one last time, ./mario.

1679
01:48:21,900 --> 01:48:24,010
OK, so now we're back in business there.

1680
01:48:24,010 --> 01:48:31,380
Well, what if we wanted to do some other scene from "Mario," such as this one here where there's a lot of vertical obstacles like these bricks here?

1681
01:48:31,380 --> 01:48:38,160
If I wanted to print out now a column of three bricks-- and I'll use hashtags for these instead of anything graphical-- well,

1682
01:48:38,160 --> 01:48:40,650
I think we're almost there, right?

1683
01:48:40,650 --> 01:48:44,080
I think I can now-- it's almost maybe a little easier.

1684
01:48:44,080 --> 01:48:49,050
I can go back here, change the question mark to something that looks more like a brick, like this hash symbol.

1685
01:48:49,050 --> 01:48:56,368
And I think now I do want the new line character because when I now do make mario, ./mario, OK, there's my wall of four.

1686
01:48:56,368 --> 01:48:56,910
Oh, but wait.

1687
01:48:56,910 --> 01:48:58,050
I didn't want four.

1688
01:48:58,050 --> 01:49:02,320
I wanted to be consistent just with this particular scene here, so I just want three.

1689
01:49:02,320 --> 01:49:04,780
So I can still change it in one place.

1690
01:49:04,780 --> 01:49:06,330
And here, again, is that paradigm.

1691
01:49:06,330 --> 01:49:15,870
Even whether you're using 4 or 3, if you get into the habit of starting counting from 0, you go on up to but not through the value you want to count up to.

1692
01:49:15,870 --> 01:49:20,055
So that's why I'm using less than instead of less than or equal to there.

1693
01:49:20,055 --> 01:49:25,360
So this would be the common paradigm, though you could count it like we saw earlier in different ways.

1694
01:49:25,360 --> 01:49:27,965
But what if things escalate one level further?

1695
01:49:27,965 --> 01:49:35,400
And when you're in the underground version of "Super Mario Brothers," there's a lot of these underground obstructions, including grids of bricks like this.

1696
01:49:35,400 --> 01:49:45,400
And let me conjecture that if you slice this up, it's roughly a 3 by 3 grid of bricks that all interlock prettily to give us just one big, large brick like this.

1697
01:49:45,400 --> 01:49:56,580
So if I want to print out a 3 by 3 grid, now things are getting a little more interesting because up until now, I've printed either one row horizontally or one column vertically.

1698
01:49:56,580 --> 01:49:58,380
But we haven't really seen any code where

1699
01:49:58,380 --> 01:50:02,670
I'm printing or living in two different dimensions like the game would imply.

1700
01:50:02,670 --> 01:50:05,560
But let me propose that we could do this.

1701
01:50:05,560 --> 01:50:10,500
Let me go ahead and say, all right, suppose I want to print a 3 by 3 grid of bricks.

1702
01:50:10,500 --> 01:50:16,590
It's really that I want to print, what, three rows of bricks.

1703
01:50:16,590 --> 01:50:18,063
A grid is three rows.

1704
01:50:18,063 --> 01:50:22,345
So if I take the high-level idea and reduce it to something a little simpler, how do I do that?

1705
01:50:22,345 --> 01:50:24,720
Well, let me get rid of the printf for a moment as I did.

1706
01:50:24,720 --> 01:50:33,390
And let me just stipulate that this for loop, even though it doesn't do anything useful yet, will do something how many times just by design?

1707
01:50:33,390 --> 01:50:34,530
All right, three times.

1708
01:50:34,530 --> 01:50:35,850
This for loop is good to go.

1709
01:50:35,850 --> 01:50:39,390
It will do something three times by just using i to do the counting.

1710
01:50:39,390 --> 01:50:51,090
All right, well, if I want to print out now a row of three bricks all on the same line, that's pretty similar to what we did earlier when I just wanted to print out four question marks in the sky.

1711
01:50:51,090 --> 01:50:52,960
So we've seen a solution there.

1712
01:50:52,960 --> 01:50:55,450
And I daresay we can compose one into the other.

1713
01:50:55,450 --> 01:50:58,590
So if I want to print out a row of bricks,

1714
01:50:58,590 --> 01:51:11,700
I could just do this for in i get 0 i less than 3 i++, and then inside of this inner loop, if you will, let me print out a single brick like this.

1715
01:51:11,700 --> 01:51:17,820
And then I don't like where this is going but, I think I've taken two ideas and I've combined them.

1716
01:51:17,820 --> 01:51:23,080
But what might be problematic about lines 5 and 7 at the moment?

1717
01:51:23,080 --> 01:51:24,700
What might be bad here?

1718
01:51:24,700 --> 01:51:25,345
Yeah, in back?

1719
01:51:25,345 --> 01:51:27,665
AUDIENCE: You used the same integer i.

1720
01:51:27,665 --> 01:51:30,040
DAVID J. MALAN: Yeah, I'm using the same integer i, which

1721
01:51:30,040 --> 01:51:32,080
I feel like could get me into trouble.

1722
01:51:32,080 --> 01:51:38,470
If I'm trying to count three things here, but then I'm hijacking this variable and using it inside of the loop,

1723
01:51:38,470 --> 01:51:41,560
I feel like I should avoid this collision of names.

1724
01:51:41,560 --> 01:51:43,930
And so what's a good alternative to i?

1725
01:51:43,930 --> 01:51:47,980
Well, a programmer, if nesting loops in this way, would pretty commonly go with j.

1726
01:51:47,980 --> 01:51:52,600
You could certainly change this to be rows and columns if you want more descriptive variables.

1727
01:51:52,600 --> 01:51:54,940
But i and j is pretty canonical.

1728
01:51:54,940 --> 01:51:59,020
So I'm going to go ahead and do this, j++ instead of i++ everywhere.

1729
01:51:59,020 --> 01:52:00,280
And let me try compiling this.

1730
01:52:00,280 --> 01:52:04,330
So make mario, Enter, ./mario.

1731
01:52:04,330 --> 01:52:06,560
OK, so a couple of things are wrong here.

1732
01:52:06,560 --> 01:52:08,480
This is not a 3 by 3 grid.

1733
01:52:08,480 --> 01:52:12,855
But if you count these things, how many did I indeed print at least?

1734
01:52:12,855 --> 01:52:14,485
You can probably just guess logically.

1735
01:52:14,485 --> 01:52:15,110
AUDIENCE: Nine.

1736
01:52:15,110 --> 01:52:17,110
DAVID J. MALAN: Yeah, there's nine hashes there.

1737
01:52:17,110 --> 01:52:21,340
Unfortunately, they're all on the same line instead of on three different lines.

1738
01:52:21,340 --> 01:52:24,910
So where logically can I fix this?

1739
01:52:24,910 --> 01:52:26,535
I'm definitely printing all the bricks.

1740
01:52:26,535 --> 01:52:28,077
They're just not on the right levels.

1741
01:52:28,077 --> 01:52:28,646
Yeah?

1742
01:52:28,646 --> 01:52:32,620
AUDIENCE: If you put a new line at the first loop, then you'll get three separate lines.

1743
01:52:32,620 --> 01:52:33,495
DAVID J. MALAN: Yeah.

1744
01:52:33,495 --> 01:52:38,000
So put a new line after the first loop, this inner loop, if you will, the nested loop, if you will.

1745
01:52:38,000 --> 01:52:41,030
So let me go ahead and print out just a backslash n here.

1746
01:52:41,030 --> 01:52:42,073
And what's this doing?

1747
01:52:42,073 --> 01:52:47,270
Well, I think that's going to solve it by just moving the cursor to the next line after you've done one row.

1748
01:52:47,270 --> 01:52:52,070
So let me go ahead and do make mario, Enter, ./mario, and now we're in business.

1749
01:52:52,070 --> 01:52:59,350
So it's a very simplistic version of this same graphic, but I'm leveraging two different ideas now-- or the same idea twice rather now.

1750
01:52:59,350 --> 01:53:03,970
I'm using one loop to control my cursor going row, by row, by row.

1751
01:53:03,970 --> 01:53:10,960
But then within that loop, I'm doing left to right, dot, dot, dot, dot, dot, with printing out each of these individual bricks like this.

1752
01:53:10,960 --> 01:53:13,600
Now, there's a little sloppiness here still.

1753
01:53:13,600 --> 01:53:26,420
If I want this to always be a square just because that's what it looks like in the game, well, I could change it to be a 4 by 4 square by doing this or a 5 by 5 grid-- whoops-- by doing this.

1754
01:53:26,420 --> 01:53:30,010
Why is this perhaps not the best design to just keep changing the numbers when

1755
01:53:30,010 --> 01:53:33,330
I want to change the size?

1756
01:53:33,330 --> 01:53:34,440
Where could this go awry?

1757
01:53:34,440 --> 01:53:35,010
Yeah?

1758
01:53:35,010 --> 01:53:38,255
AUDIENCE: If it's a square, [INAUDIBLE]

1759
01:53:38,255 --> 01:53:39,130
DAVID J. MALAN: Yeah.

1760
01:53:39,130 --> 01:53:43,060
If it's always going to be a square and height is going to be the same as width, I'm just inviting trouble here, right?

1761
01:53:43,060 --> 01:53:44,110
Eventually, I'm going to screw up.

1762
01:53:44,110 --> 01:53:45,680
I'm going to change one but not the other.

1763
01:53:45,680 --> 01:53:48,070
Then it's going to come out to be a rectangle instead of a proper square.

1764
01:53:48,070 --> 01:53:50,410
So I should probably solve this a little differently.

1765
01:53:50,410 --> 01:53:51,160
So let me do that.

1766
01:53:51,160 --> 01:54:01,000
At the top of my main function here, let me go ahead and give myself a variable called maybe n for the number of bricks I want horizontally and vertically.

1767
01:54:01,000 --> 01:54:03,550
And I'll just initialize that to 3 initially.

1768
01:54:03,550 --> 01:54:06,610
And instead of putting 3 here, I'll literally just use n.

1769
01:54:06,610 --> 01:54:13,000
But I'll do it in both places so that now, henceforth, if I ever want to change this and change it to 4, or 5, or anything else,

1770
01:54:13,000 --> 01:54:13,845
I'm all done.

1771
01:54:13,845 --> 01:54:16,720
It's better designed because there's a lower probability of mistakes.

1772
01:54:16,720 --> 01:54:19,840
But I could technically still screw up somehow.

1773
01:54:19,840 --> 01:54:28,985
I could technically accidentally write a line of code like n++, or I could just change the value of that variable even though I don't want it to ever change.

1774
01:54:28,985 --> 01:54:31,693
And maybe it's because I'm a bad programmer, I copy/pasted wrong,

1775
01:54:31,693 --> 01:54:34,240
I'm working with someone who doesn't know what n represents,

1776
01:54:34,240 --> 01:54:41,020
I can defend myself and my code against human error like that by going up here to line 5.

1777
01:54:41,020 --> 01:54:44,170
And instead of just declaring a simple variable like we did in Scratch,

1778
01:54:44,170 --> 01:54:50,740
I can further harden my code, so to speak, by declaring it to be a constant using the keyword const.

1779
01:54:50,740 --> 01:55:02,320
Now, this is just a feature of C and some other languages to protect you against yourself by proactively saying, n is a constant, specifically the number 5 or, previously, the number 3.

1780
01:55:02,320 --> 01:55:05,530
You cannot accidentally write code elsewhere that changes it.

1781
01:55:05,530 --> 01:55:08,420
The computer will throw an error and catch that error.

1782
01:55:08,420 --> 01:55:12,160
So it's just a way of programming a little more defensively.

1783
01:55:12,160 --> 01:55:13,235
Some languages have this.

1784
01:55:13,235 --> 01:55:14,110
Some languages don't.

1785
01:55:14,110 --> 01:55:15,970
But in general, it's a good practice.

1786
01:55:15,970 --> 01:55:23,570
It makes your code better designed because it's just as less vulnerable to mistakes by you, colleagues, or anyone else using the code.

1787
01:55:23,570 --> 01:55:26,420
So let me change this back to 3 just to be our default.

1788
01:55:26,420 --> 01:55:28,580
But now I'm using n in both places.

1789
01:55:28,580 --> 01:55:33,250
And if I do make mario, ./mario, we're back to where we originally started.

1790
01:55:33,250 --> 01:55:35,560
But the code is a little more better designed.

1791
01:55:35,560 --> 01:55:37,330
And let me note this too.

1792
01:55:37,330 --> 01:55:40,720
All this time, I've been mentioning that correctness is important.

1793
01:55:40,720 --> 01:55:41,740
Design is important.

1794
01:55:41,740 --> 01:55:43,700
There is also this matter of style.

1795
01:55:43,700 --> 01:55:48,940
I've been very deliberately writing pretty code, if you will-- not just the syntax highlighting, which, is automatic.

1796
01:55:48,940 --> 01:55:52,060
But notice that I keep indenting everything nicely.

1797
01:55:52,060 --> 01:55:57,400
Any time I have curly braces, like on lines 4 and 14, everything is indented one level.

1798
01:55:57,400 --> 01:56:04,520
When I have additional curly braces on lines 7 and 13, everything is nicely indented as well.

1799
01:56:04,520 --> 01:56:10,090
Technically speaking, the computer does not care about that kind of whitespace, so to speak.

1800
01:56:10,090 --> 01:56:17,080
And you could really make a mess of things like this because you have a strange sense of style or just because you're being a little sloppy.

1801
01:56:17,080 --> 01:56:20,170
But this code is actually still correct.

1802
01:56:20,170 --> 01:56:28,270
If I recompile it-- let me open up my terminal window-- make mario, no errors, ./mario, it works perfectly fine.

1803
01:56:28,270 --> 01:56:36,860
But you can imagine just how annoying this now is to read, certainly for a TA, but certainly for you the next day, certainly for a colleague who has to read your code.

1804
01:56:36,860 --> 01:56:38,020
This is just bad style.

1805
01:56:38,020 --> 01:56:44,230
It still works, and it's well designed in that you're writing code defensively, you're using a constant.

1806
01:56:44,230 --> 01:56:46,420
But, my god, the style is atrocious.

1807
01:56:46,420 --> 01:56:53,710
Now, you'll often find that there's tools that can help you format your code for you in a manner consistent with a courses or a company's style.

1808
01:56:53,710 --> 01:56:57,220
But this is the kind of muscle memory you'll want to develop over time too.

1809
01:56:57,220 --> 01:57:03,565
Take these VS Code suggestions as it's outputting lines of code for you because it's trying to format your code in a readable way.

1810
01:57:03,565 --> 01:57:11,800
And, oh, my god, if and when you do have bugs in your code and things aren't even indented properly, there's no way you the human are going to be able to wrap your mind around

1811
01:57:11,800 --> 01:57:13,690
what's happening and where.

1812
01:57:13,690 --> 01:57:16,060
You're just making the problem harder for yourself.

1813
01:57:16,060 --> 01:57:21,190
So do get into this habit too of manifesting good style as well.

1814
01:57:21,190 --> 01:57:24,880
All right, well, let me propose that we don't only want a 3 by 3 grid.

1815
01:57:24,880 --> 01:57:26,840
We want this to be a little more dynamic.

1816
01:57:26,840 --> 01:57:32,020
So suppose we moved away from a constant to just using an integer called n.

1817
01:57:32,020 --> 01:57:38,320
And let's ask the user for the size of this grid as by prompting them with get_int, as we've done before.

1818
01:57:38,320 --> 01:57:40,150
And I'll store it in n here.

1819
01:57:40,150 --> 01:57:46,450
And then I can go ahead and, more dynamically, run make mario to compile it-- whoops.

1820
01:57:46,450 --> 01:57:49,930
Oh, I screwed up accidentally.

1821
01:57:49,930 --> 01:57:53,785
What is it suggesting I do, albeit cryptically?

1822
01:57:53,785 --> 01:57:56,660
AUDIENCE: You have to include the cs50.h.

1823
01:57:56,660 --> 01:57:59,930
DAVID J. MALAN: Yeah, I forgot to include the CS50 header file up top.

1824
01:57:59,930 --> 01:58:03,420
And that's why it doesn't know that get_int is, in fact, valid.

1825
01:58:03,420 --> 01:58:04,880
So that's an easy fix.

1826
01:58:04,880 --> 01:58:07,730
I'm just going to go up here and include cs50.h.

1827
01:58:07,730 --> 01:58:10,790
Now I'm going to clear my terminal and rerun make mario.

1828
01:58:10,790 --> 01:58:12,800
Now we're good-- ./mario.

1829
01:58:12,800 --> 01:58:14,550
And now notice I'm prompted for size.

1830
01:58:14,550 --> 01:58:16,490
So if I type in 3, it's the same as before.

1831
01:58:16,490 --> 01:58:20,900
If I type in 10, it's even bigger, but it happens all now automatically.

1832
01:58:20,900 --> 01:58:23,360
But there are some things that we're not detecting.

1833
01:58:23,360 --> 01:58:25,940
For instance, suppose I type in cat.

1834
01:58:25,940 --> 01:58:28,770
Well, that's handled by the get_int function, as I claimed earlier.

1835
01:58:28,770 --> 01:58:30,687
That's one of the features of using a library.

1836
01:58:30,687 --> 01:58:32,570
You don't have to deal with erroneous input.

1837
01:58:32,570 --> 01:58:36,200
But we only designed a function called get_int to get you an integer.

1838
01:58:36,200 --> 01:58:40,680
We don't know if you want it to be positive, negative, zero, or some combination thereof.

1839
01:58:40,680 --> 01:58:48,440
And it's kind of weird to allow the user to type in negative 1 for the size of the grid or negative 3 for the size of the grid.

1840
01:58:48,440 --> 01:58:51,230
And indeed, your code does nothing, so at least it's not crashing.

1841
01:58:51,230 --> 01:58:52,730
But that's kind of stupid, right?

1842
01:58:52,730 --> 01:58:57,150
It'd be nice to force the user if they want a grid to give us a positive value.

1843
01:58:57,150 --> 01:58:58,530
So how could we do this?

1844
01:58:58,530 --> 01:59:08,190
Well, I could go up here and I could say something like if n is less than 1-- so if it's 0 or negative, which I don't want, what could I do?

1845
01:59:08,190 --> 01:59:12,380
Well, I could say, well, prompt the user again for the size.

1846
01:59:12,380 --> 01:59:18,530
And now notice, I'm not declaring n again because once it exists, you don't have to mention the data type again.

1847
01:59:18,530 --> 01:59:19,790
We said that earlier.

1848
01:59:19,790 --> 01:59:21,510
But this is kind of stupid.

1849
01:59:21,510 --> 01:59:22,010
Why?

1850
01:59:22,010 --> 01:59:25,190
Because now when you've given the user a second chance, OK, now maybe

1851
01:59:25,190 --> 01:59:33,020
I'll do-- all right, if this version of n is less than 1, well, let's just go and prompt the user a third time.

1852
01:59:33,020 --> 01:59:35,240
I mean, you can see where this is stupidly going.

1853
01:59:35,240 --> 01:59:39,860
This can't be the right solution to keep typing recursively the same thing again and again.

1854
01:59:39,860 --> 01:59:40,790
Where would it stop?

1855
01:59:40,790 --> 01:59:44,810
You'd have to give them a finite number of chances or just make a mess of your code.

1856
01:59:44,810 --> 01:59:48,170
So what would be intuitively a better solution here?

1857
01:59:48,170 --> 01:59:49,128
AUDIENCE: A while loop.

1858
01:59:49,128 --> 01:59:50,920
DAVID J. MALAN: Yeah, so some kind of loop.

1859
01:59:50,920 --> 01:59:52,160
We've seen a while loop.

1860
01:59:52,160 --> 01:59:54,240
We've seen a for loop, so maybe one of those.

1861
01:59:54,240 --> 01:59:55,290
So let me try this.

1862
01:59:55,290 --> 01:59:58,760
Let me delete this messiness and just go back to the first question.

1863
01:59:58,760 --> 01:59:59,790
And let me do this.

1864
01:59:59,790 --> 02:00:09,560
So while n is less than 1-- so while the number is not what we want-- let's just prompt the user in a loop this time for the size again.

1865
02:00:09,560 --> 02:00:15,470
Now, here too, this is better because it's only two requests for information.

1866
02:00:15,470 --> 02:00:19,640
But clearly, lines 6 and 9 are pretty much identical other than the int.

1867
02:00:19,640 --> 02:00:26,300
And if I went in and changed the size, if I add this, if I change the wording here, change it to a different language,

1868
02:00:26,300 --> 02:00:27,350
I have to change it in two places.

1869
02:00:27,350 --> 02:00:27,850
That's bad.

1870
02:00:27,850 --> 02:00:29,330
Copy/paste, bad.

1871
02:00:29,330 --> 02:00:31,040
So what might be better?

1872
02:00:31,040 --> 02:00:37,730
Well, it turns out, there's another paradigm in C that you can use that gets around this problem, this duplication of code.

1873
02:00:37,730 --> 02:00:41,210
It would be much nicer if I just write the code once.

1874
02:00:41,210 --> 02:00:45,510
And I can do that using a third type of loop called a do while loop.

1875
02:00:45,510 --> 02:00:48,000
So it turns out, in C, you can do this.

1876
02:00:48,000 --> 02:00:53,370
If you want to get the value of a variable like n, first just to create the variable without an initial value.

1877
02:00:53,370 --> 02:00:56,870
So int n semicolon means we don't know what value it has, yes.

1878
02:00:56,870 --> 02:00:57,590
But that's OK.

1879
02:00:57,590 --> 02:00:59,840
We're going to add a value to it eventually.

1880
02:00:59,840 --> 02:01:02,870
Then I'm going to say this, do, literally.

1881
02:01:02,870 --> 02:01:04,460
I'm going to open my curly braces.

1882
02:01:04,460 --> 02:01:05,930
And what do I want to do?

1883
02:01:05,930 --> 02:01:11,750
I want to assign to n the return value of get_int, prompting the user for size.

1884
02:01:11,750 --> 02:01:14,040
Well, when do you want to do that?

1885
02:01:14,040 --> 02:01:17,900
I want to do that while n is less than 1.

1886
02:01:17,900 --> 02:01:23,570
And this code now achieves the exact same goal, but by never repeating myself.

1887
02:01:23,570 --> 02:01:24,230
Why?

1888
02:01:24,230 --> 02:01:31,175
Well, notice on these lines of code now, I'm literally saying on line 6, give me a variable called n of type integer.

1889
02:01:31,175 --> 02:01:33,300
It doesn't have a value initially, but that's fine.

1890
02:01:33,300 --> 02:01:34,640
You can do that.

1891
02:01:34,640 --> 02:01:36,380
Line 7 says, do the following.

1892
02:01:36,380 --> 02:01:41,660
What do you want to do? get_int, prompting the user with the word size, and just store that value in n.

1893
02:01:41,660 --> 02:01:53,670
But because C code runs top to bottom, left to right, now it's reasonable on line 11 to ask that question, OK, is the current value of n, which it definitely got on line 8, less than 1?

1894
02:01:53,670 --> 02:01:58,400
And if the user didn't cooperate-- they typed in 0, or negative 1, or negative 3-- what's going to happen?

1895
02:01:58,400 --> 02:02:04,530
It's going to go back up here and repeat, repeat, repeat everything in the do while loop.

1896
02:02:04,530 --> 02:02:08,480
So a do while loop in C-- which is not something some other languages have.

1897
02:02:08,480 --> 02:02:10,730
Python, if you know it, does not have a do while loop.

1898
02:02:10,730 --> 02:02:20,570
This is perhaps the cleanest way to achieve this, even though it's a little weird that you have to declare your variable, create your variable up top, and then check it down below.

1899
02:02:20,570 --> 02:02:22,980
But otherwise, it's similar to a while loop.

1900
02:02:22,980 --> 02:02:26,150
It just flips the order in which you're asking the question.

1901
02:02:26,150 --> 02:02:28,820
Any questions on this construct?

1902
02:02:28,820 --> 02:02:35,640
And do while, in general, is super useful when you want to get input from the user and make sure it meets certain requirements.

1903
02:02:35,640 --> 02:02:39,530
So all right, so now that we have this building block after that interlude.

1904
02:02:39,530 --> 02:02:41,750
How can I go about cleaning up this code?

1905
02:02:41,750 --> 02:02:47,720
And then let's conclude by taking a look at things that our code can't do or can't do very well or correctly.

1906
02:02:47,720 --> 02:02:53,520
Let me propose that in a final version of Mario, let me just add what are called now some comments.

1907
02:02:53,520 --> 02:02:59,173
So it turns out, in code in C, you can define what are called comments, which are just notes to self.

1908
02:02:59,173 --> 02:03:00,840
Some of you discovered these in Scratch.

1909
02:03:00,840 --> 02:03:04,680
There's little yellow sticky notes you can use to add citations or explanations.

1910
02:03:04,680 --> 02:03:07,020
In C, there's a couple of ways to write comments.

1911
02:03:07,020 --> 02:03:13,860
And in general, comments are notes for yourself, for your TA, for your colleague as to what your code is doing and why or how.

1912
02:03:13,860 --> 02:03:17,860
It's a little explanatory note in English or whatever your human language might be.

1913
02:03:17,860 --> 02:03:27,870
So for instance, what I might do here in my implementation of this version of mario, I might first ask myself a question like--

1914
02:03:27,870 --> 02:03:34,350
I might first make a note to self like this on a new line, above this first block of code, Get size of grid.

1915
02:03:34,350 --> 02:03:43,560
It's just an explanatory remark in any terse English that generally explains the next six or so lines, the next chunk or block of code, if you will.

1916
02:03:43,560 --> 02:03:46,500
It would be a little excessive to comment every single line.

1917
02:03:46,500 --> 02:03:49,680
At some point, the programmer should know what individual lines of code do.

1918
02:03:49,680 --> 02:03:58,110
But it's nice to be able to glance at this comment on line 6 that starts with two slashes, and it gets grayed out because of syntax highlighting.

1919
02:03:58,110 --> 02:03:59,070
It's not logic.

1920
02:03:59,070 --> 02:04:00,440
It's just a note to self.

1921
02:04:00,440 --> 02:04:05,160
It generally gives me a little cheat sheet as to what the following lines of code should be doing and/or why.

1922
02:04:05,160 --> 02:04:08,910
And then down here, well, there's a second block of code that's a bunch of lines.

1923
02:04:08,910 --> 02:04:14,130
But together, this just, what, prints grid of bricks.

1924
02:04:14,130 --> 02:04:23,760
And so it's another comment to myself that just makes it a little more understandable what these 20-some-odd lines of code are doing by adding some English explanations thereof.

1925
02:04:23,760 --> 02:04:33,600
But now that I have these, wouldn't it be nice if I could abstract these pieces of functionality away, this getting of the size and this printing of the grid?

1926
02:04:33,600 --> 02:04:37,590
In other words, suppose that you didn't know where to begin with this problem.

1927
02:04:37,590 --> 02:04:43,530
And the problem at hand were literally implement a program that prints a grid of bricks of some variable size--

1928
02:04:43,530 --> 02:04:46,440
3, or 4, or 5, or whatever the human types in.

1929
02:04:46,440 --> 02:04:56,310
If you have really no idea where to start, comments are actually a good way of getting started because comments can be an approximation of what we call last week pseudocode.

1930
02:04:56,310 --> 02:05:02,080
Pseudocode is terse English that gets your point across, like for the phone book searching like last time.

1931
02:05:02,080 --> 02:05:06,910
So if you didn't really know where to begin, you could do something like this.

1932
02:05:06,910 --> 02:05:14,610
I could, for instance, just say, Get size of grid as my first step and then Print grid of bricks as my second step.

1933
02:05:14,610 --> 02:05:16,410
And that's it for my program thus far.

1934
02:05:16,410 --> 02:05:18,690
This is now implemented in pseudocode.

1935
02:05:18,690 --> 02:05:20,910
I have some massive placeholders there.

1936
02:05:20,910 --> 02:05:22,380
I still have work to be done.

1937
02:05:22,380 --> 02:05:26,050
But at least I have a high-level solution to the problem in comments.

1938
02:05:26,050 --> 02:05:28,230
And now I can even go this far.

1939
02:05:28,230 --> 02:05:34,650
I could say, well, let's suppose that there's just a function already that exists called get size.

1940
02:05:34,650 --> 02:05:36,220
I could do something like this.

1941
02:05:36,220 --> 02:05:38,790
I could do int n equals get_size.

1942
02:05:38,790 --> 02:05:43,000
And now I just have to assume for the moment that some abstraction called get_size exists.

1943
02:05:43,000 --> 02:05:43,500
It doesn't.

1944
02:05:43,500 --> 02:05:45,420
This does not come with the CS50 library.

1945
02:05:45,420 --> 02:05:47,520
But I could invent it, I bet.

1946
02:05:47,520 --> 02:05:49,110
How else might I proceed?

1947
02:05:49,110 --> 02:05:57,060
Well, let's just assume for the moment that there's also a function called print_grid that just prints a grid of that size n.

1948
02:05:57,060 --> 02:05:58,950
So here too is an abstraction.

1949
02:05:58,950 --> 02:06:00,330
These puzzle pieces don't exist.

1950
02:06:00,330 --> 02:06:01,800
These functions don't yet exist.

1951
02:06:01,800 --> 02:06:06,240
But in C, just like in Scratch, I can create my own functions.

1952
02:06:06,240 --> 02:06:07,600
How do I do that?

1953
02:06:07,600 --> 02:06:09,630
Well, let me go down later in the file.

1954
02:06:09,630 --> 02:06:12,810
And by convention, you generally want to leave main at the top of your code.

1955
02:06:12,810 --> 02:06:13,110
Why?

1956
02:06:13,110 --> 02:06:18,090
Because it's the main function, and it's just where the human eye is going to look to see what some file of code does.

1957
02:06:18,090 --> 02:06:19,360
And let me do this.

1958
02:06:19,360 --> 02:06:26,010
I want to create a function of my own called get_size whose purpose in life is to get the size that the user wants.

1959
02:06:26,010 --> 02:06:28,380
I want this function to return an integer.

1960
02:06:28,380 --> 02:06:34,920
And the syntax for doing that is this, right, similar to a variable, the data type that this function returns.

1961
02:06:34,920 --> 02:06:37,450
I don't need this function to take any inputs.

1962
02:06:37,450 --> 02:06:45,810
And so I'm going to use a new keyword that we've actually been using thus far-- more on it another time-- just called void, which just means this get_size function does not take any inputs.

1963
02:06:45,810 --> 02:06:46,950
It does have an output.

1964
02:06:46,950 --> 02:06:48,138
It outputs an int.

1965
02:06:48,138 --> 02:06:50,430
And this is just the weird order in which you write it.

1966
02:06:50,430 --> 02:06:55,920
You write the output format, the name of the function, and then the inputs, if any, inside of parentheses.

1967
02:06:55,920 --> 02:06:57,727
And now I can implement get_size.

1968
02:06:57,727 --> 02:06:59,310
But I've already implemented get_size.

1969
02:06:59,310 --> 02:07:01,140
Or at least now at this point in the story,

1970
02:07:01,140 --> 02:07:03,180
I at least know concretely what to do.

1971
02:07:03,180 --> 02:07:12,270
And I could figure out eventually, with some trial and error perhaps, all right, if I declare a variable and I do the following n equals get_int, prompting the user for size,

1972
02:07:12,270 --> 02:07:22,830
and I keep doing that while n is less than 1, once that block of code is done, here is a new keyword in C where you can return that value n.

1973
02:07:22,830 --> 02:07:27,330
So I keep referring to these values that some functions return as return values.

1974
02:07:27,330 --> 02:07:36,970
In C, there's literally a keyword called return that will hand back to any function that uses that function the value in question.

1975
02:07:36,970 --> 02:07:47,280
So in a nutshell, between lines 15 and 21 now, here is some code identical to our solution earlier that gets a value n from the user that is positive.

1976
02:07:47,280 --> 02:07:48,720
It's 1, or 2, or higher.

1977
02:07:48,720 --> 02:07:51,180
It's not 0, or it's not less than 1.

1978
02:07:51,180 --> 02:07:56,360
And as soon as we've got that value, we hand it back as a return value.

1979
02:07:56,360 --> 02:07:58,990
Notice how I'm using this function on line 7.

1980
02:07:58,990 --> 02:08:01,630
Just like with get_int, just like with get_string,

1981
02:08:01,630 --> 02:08:04,650
I'm calling the function-- nothing in the parentheses in this case.

1982
02:08:04,650 --> 02:08:09,970
But then I'm using the assignment operator to copy whatever its return value is into my variable n.

1983
02:08:09,970 --> 02:08:19,090
And so now I have a function that didn't use to exist called get_size that gets me a positive integer no matter what.

1984
02:08:19,090 --> 02:08:21,710
And now for the grid, how do I do this?

1985
02:08:21,710 --> 02:08:27,160
How do I invent a function called print_grid that takes a single argument, a number and prints a grid of that size?

1986
02:08:27,160 --> 02:08:29,180
Well, let's go down here.

1987
02:08:29,180 --> 02:08:32,050
I'm going to write the name of this function print_grid.

1988
02:08:32,050 --> 02:08:33,590
This function just needs to print.

1989
02:08:33,590 --> 02:08:35,440
It has a side effect, as we keep saying.

1990
02:08:35,440 --> 02:08:38,230
So I'm just going to say it has no return value.

1991
02:08:38,230 --> 02:08:39,040
It's just void.

1992
02:08:39,040 --> 02:08:40,820
It doesn't have an output, per se.

1993
02:08:40,820 --> 02:08:42,670
It's just an aesthetic side effect.

1994
02:08:42,670 --> 02:08:44,660
But it does take in an argument.

1995
02:08:44,660 --> 02:08:52,337
An argument is an input, and the syntax for this in C is to name the type of the input it takes and the name of the variable.

1996
02:08:52,337 --> 02:08:53,920
And I could call this anything I want.

1997
02:08:53,920 --> 02:08:54,940
I'll call it size.

1998
02:08:54,940 --> 02:08:56,140
I could call it n.

1999
02:08:56,140 --> 02:09:01,030
And it's OK to use the same variable in different functions, but I'll call it size just to be distinct.

2000
02:09:01,030 --> 02:09:18,790
And then in this function, I'm just going to copy from memory the same code is before. for int i get 0, i less than size-- instead of 3-- i++, inside of this, for int j gets 0, j is less than size j++,

2001
02:09:18,790 --> 02:09:28,660
and inside of that, print out with printf a single hash, print out after that loop a single new line, and that's it.

2002
02:09:28,660 --> 02:09:30,370
Now, I did this fast, admittedly.

2003
02:09:30,370 --> 02:09:32,860
But it's the same code that I wrote earlier.

2004
02:09:32,860 --> 02:09:39,190
But now, just like I did with Scratch, let me just arbitrarily hit Enter a bunch of times to move the code out of sight, out of mind.

2005
02:09:39,190 --> 02:09:40,900
Now I have abstractions.

2006
02:09:40,900 --> 02:09:48,160
I have puzzle pieces that now exist called get_size and print_grid, syntax for which takes some getting used to, but they now just exist.

2007
02:09:48,160 --> 02:09:50,590
Except I do need to do one thing.

2008
02:09:50,590 --> 02:09:59,500
Because C is a little naive, if I try to do make mario now and hit Enter, implicit declaration of function get_size is invalid.

2009
02:09:59,500 --> 02:10:03,460
And we've seen that before when I hadn't included a file.

2010
02:10:03,460 --> 02:10:06,362
When I hadn't included CS50 library, get_int didn't work.

2011
02:10:06,362 --> 02:10:09,070
But that's not the issue here because this is not from a library.

2012
02:10:09,070 --> 02:10:10,270
I just invented this.

2013
02:10:10,270 --> 02:10:12,580
C takes you literally.

2014
02:10:12,580 --> 02:10:18,910
And if you define these functions at the bottom of your file, they don't exist on line 7 or 10.

2015
02:10:18,910 --> 02:10:20,690
So I could do this.

2016
02:10:20,690 --> 02:10:26,342
I could, all right, fine, well, let me just highlight all of this, cut to my clipboard, and paste it up here.

2017
02:10:26,342 --> 02:10:27,550
This would solve the problem.

2018
02:10:27,550 --> 02:10:30,280
I could just move all of those functions at the top of my file.

2019
02:10:30,280 --> 02:10:33,380
That's annoying because now main is at the bottom of the file.

2020
02:10:33,380 --> 02:10:34,930
It's going to take longer to find it.

2021
02:10:34,930 --> 02:10:36,560
That's not a clean solution.

2022
02:10:36,560 --> 02:10:39,170
So let me put it back where it was at the bottom.

2023
02:10:39,170 --> 02:10:40,730
And let me do this.

2024
02:10:40,730 --> 02:10:46,060
This is the only time in CS50 and, really in C programming where copy/paste is reasonable.

2025
02:10:46,060 --> 02:10:58,270
If you copy and paste the first line of code from each function and then end it with a semicolon, you can tease the compiler by giving it just enough of a hint at the top of the file

2026
02:10:58,270 --> 02:11:01,010
that, OK, these functions don't exist till down later.

2027
02:11:01,010 --> 02:11:03,190
But here's a hint that they will exist.

2028
02:11:03,190 --> 02:11:07,660
This is how you can convince the compiler to trust you.

2029
02:11:07,660 --> 02:11:11,830
So those other functions can still be lower in the file, below main.

2030
02:11:11,830 --> 02:11:15,190
But now when I do make mario-- oh, damn it.

2031
02:11:15,190 --> 02:11:17,260
Oh, I said print instead of printf.

2032
02:11:17,260 --> 02:11:20,860
That's my bad-- printf.

2033
02:11:20,860 --> 02:11:27,790
So if I do make mario, ./mario, now I can type in 3, and we're back in business.

2034
02:11:27,790 --> 02:11:32,800
Now, this was a very heavy-handed way in long way to get to a much more complicated solution.

2035
02:11:32,800 --> 02:11:35,240
But this solution, in some sense, is better designed.

2036
02:11:35,240 --> 02:11:35,740
Why?

2037
02:11:35,740 --> 02:11:38,050
Because now, especially without the comments,

2038
02:11:38,050 --> 02:11:40,060
I mean, look how short my code is.

2039
02:11:40,060 --> 02:11:42,430
My main function is literally two lines of code.

2040
02:11:42,430 --> 02:11:42,940
Why?

2041
02:11:42,940 --> 02:11:46,338
Well, I factored out the juicy stuff into its own functions.

2042
02:11:46,338 --> 02:11:54,380
And now, especially if I'm working with colleagues or others, you could imagine splitting up large programs into smaller parts, having different people implement different parts,

2043
02:11:54,380 --> 02:12:00,410
so long as you all agree in advance on what those inputs and those outputs actually are.

2044
02:12:00,410 --> 02:12:04,300
All right, so let's now consider what computers can do well and not so well.

2045
02:12:04,300 --> 02:12:10,610
C indeed supports a whole bunch of operators, mathematically, via which we can do addition, and subtraction, multiplication, division,

2046
02:12:10,610 --> 02:12:14,025
and even calculate the remainder when you divide one number by another.

2047
02:12:14,025 --> 02:12:19,130
In fact, why don't we go ahead and use these in a very simple program and make our very own calculator?

2048
02:12:19,130 --> 02:12:21,400
So let me go over here to VS Code.

2049
02:12:21,400 --> 02:12:25,030
Let me go ahead and create a new file called calculator.c.

2050
02:12:25,030 --> 02:12:33,670
And in this file, let's go ahead and first include a couple of now familiar header files-- cs50.h as well as stdio.h.

2051
02:12:33,670 --> 02:12:37,540
Let's go ahead then and declare main with int main(void).

2052
02:12:37,540 --> 02:12:40,250
And then inside of main, let's do something relatively simple.

2053
02:12:40,250 --> 02:12:48,040
Let's declare an int and call it x, and set it equal to whatever the return value is of get int, prompting the user for a value for x.

2054
02:12:48,040 --> 02:12:50,240
Let's then give ourselves a second variable.

2055
02:12:50,240 --> 02:12:51,490
We'll call it, say, y.

2056
02:12:51,490 --> 02:12:57,780
Set that equal to the return value of another call to get_int, prompting the user this time for that value y.

2057
02:12:57,780 --> 02:13:05,080
And then let's very simply go ahead at the very end and just print out, say, the sum of x plus y, a super simple calculator.

2058
02:13:05,080 --> 02:13:10,930
So I'll use printf, quote/unquote, %i for integer, backslash n to give me the new line.

2059
02:13:10,930 --> 02:13:14,640
Then I'm going to go ahead and do x plus y to indeed print out the sum.

2060
02:13:14,640 --> 02:13:16,710
Let me go down to my terminal window now.

2061
02:13:16,710 --> 02:13:20,340
Let me do make calculator in order to compile the code.

2062
02:13:20,340 --> 02:13:22,080
No error messages, so that's good.

2063
02:13:22,080 --> 02:13:23,880
Let me do ./calculator.

2064
02:13:23,880 --> 02:13:28,500
And let's do something like 2 plus 2, which, of course, should equal 4.

2065
02:13:28,500 --> 02:13:29,340
And it does.

2066
02:13:29,340 --> 02:13:34,677
But it turns out that sometimes there are going to be limitations that we bump up against.

2067
02:13:34,677 --> 02:13:36,510
And let me get a little more ambitious here.

2068
02:13:36,510 --> 02:13:37,890
Let me clear my terminal window.

2069
02:13:37,890 --> 02:13:39,990
And let me go ahead and rerun calculator again.

2070
02:13:39,990 --> 02:13:47,280
And this time, let's, oh, 2 billion for x, and let's type in the same for y.

2071
02:13:47,280 --> 02:13:52,560
And, of course, now the answer of 2 billion plus 2 billion should, of course, be 4 billion.

2072
02:13:52,560 --> 02:13:53,970
And yet, it's not.

2073
02:13:53,970 --> 02:14:02,070
So curiously, we see, of all things, a negative number here, which suggests that somehow the plus operator doesn't quite work as well as we might like.

2074
02:14:02,070 --> 02:14:04,240
Now, why might this actually be?

2075
02:14:04,240 --> 02:14:07,770
Well, it turns out that inside of your computer is, of course, memory, or RAM,

2076
02:14:07,770 --> 02:14:08,850
Random Access Memory.

2077
02:14:08,850 --> 02:14:15,930
And depending on the size of your computer and the type of computer, it might very well look a little something like this-- a little circuit board with these black little modules on it

2078
02:14:15,930 --> 02:14:19,320
that actually contain all of the bytes of your computer's memory.

2079
02:14:19,320 --> 02:14:29,670
Unfortunately, you and I only have a finite amount of this memory inside of our computers, which means no matter how high we want to count, there's ultimately going to be a limitation on how high we

2080
02:14:29,670 --> 02:14:32,790
can count because we only have a finite amount of memory.

2081
02:14:32,790 --> 02:14:35,800
We don't have an infinite number of zeros and ones to play with.

2082
02:14:35,800 --> 02:14:38,640
We have to actually be bounded ultimately.

2083
02:14:38,640 --> 02:14:40,072
So what's the implication of this?

2084
02:14:40,072 --> 02:14:48,120
Well, it turns out that computers typically use as many as 32 bits in zeros or ones to represent something like an integer, or in C, in int.

2085
02:14:48,120 --> 02:14:55,020
So for instance, the smallest number we could represent using 32 ints, of course, using 32 bits, of course, would be zero--

2086
02:14:55,020 --> 02:14:56,970
32 zeros like this here.

2087
02:14:56,970 --> 02:15:07,200
And the biggest number we could represent is by changing all of those zeros to ones, which, in this case, will ideally give us a number that equals roughly 4 billion in total.

2088
02:15:07,200 --> 02:15:17,160
It's actually 4,294,967,295 maximally if you set all 32 of those bits to ones and then do out the actual math.

2089
02:15:17,160 --> 02:15:24,730
The catch, though, is that we humans and computers in general also sometimes want to and need to be able to represent negative numbers.

2090
02:15:24,730 --> 02:15:33,360
So if you want to represent negative numbers as well as positive numbers in 0, you can't really just start counting at 0 and go all the way up to roughly 4 billion.

2091
02:15:33,360 --> 02:15:41,890
You've got to split the difference and maybe allocate half of those patterns of zeros and ones two negative numbers and the other half roughly to positive numbers.

2092
02:15:41,890 --> 02:15:52,500
So in fact, in practice, when you're using even as many as 32 bits, the highest most computers could count, certainly in a program like this in C using an int, would be roughly 2 billion.

2093
02:15:52,500 --> 02:15:57,180
That is 2,147,483,647.

2094
02:15:57,180 --> 02:16:06,630
But the flip side of that is that we could also now, using different patterns of bits, represent negative numbers as low as negative 2 billion, give or take.

2095
02:16:06,630 --> 02:16:16,360
But the implication then, of course, is that if we only have a finite number of bits and can only count so high, at some point, we're going to run out of bits, so to speak.

2096
02:16:16,360 --> 02:16:23,080
In other words, we encounter what's generally known as integer overflow where you want to use more bits than you have available.

2097
02:16:23,080 --> 02:16:26,767
And as a result, you overflow the available space.

2098
02:16:26,767 --> 02:16:28,600
What does this mean, in fact, in real terms?

2099
02:16:28,600 --> 02:16:37,080
Well, let's suppose that you only have three bits, but I'm going to gray out a fourth bit just to convey where we'd like to put an additional bit ultimately.

2100
02:16:37,080 --> 02:16:45,360
If this of course, is 0, per week 0's discussion, this is 1, 2, 3, 4, 5, 6, 7.

2101
02:16:45,360 --> 02:16:56,250
Now, ideally, in binary, if you want to add one more to this value 7, you're going to have to carry the 1 mathematically, and that would ideally give 1000.

2102
02:16:56,250 --> 02:17:07,799
But if you don't have four bits and your computer is only sophisticated enough to have three bits, not even 32, but three, the implication is that you're effectively representing not 1000,

2103
02:17:07,799 --> 02:17:10,620
but rather, 000.

2104
02:17:10,620 --> 02:17:17,850
There's just no room to store that fourth bit that I've grayed out here, which is to say that your integer might overflow.

2105
02:17:17,850 --> 02:17:27,129
And as soon as you get to 7, the next number once you add 1 is actually going to be 0, or worse, as we've seen here in my code, a negative value instead.

2106
02:17:27,129 --> 02:17:30,209
So what could we do to perhaps address this kind of concern?

2107
02:17:30,209 --> 02:17:32,490
Well, C does not have just integers or ints.

2108
02:17:32,490 --> 02:17:38,468
It also has longs, which, as the name suggests, are just longer integers, which means they have more bits available to them.

2109
02:17:38,468 --> 02:17:40,079
So let me go back into my code here.

2110
02:17:40,080 --> 02:17:41,430
I'll clear the terminal window.

2111
02:17:41,430 --> 02:17:47,010
And let me go ahead and change my integers to literally long here, long here.

2112
02:17:47,010 --> 02:17:53,227
I'm going to have to change my function in CS50's library to be not get_int, but get_long.

2113
02:17:53,227 --> 02:17:55,769
And that's indeed another function we provide in the library.

2114
02:17:55,770 --> 02:17:57,808
Let me change this get_int to get_long as well.

2115
02:17:57,808 --> 02:18:01,479
I'll keep my variable names the same, but I do need to make one other change.

2116
02:18:01,480 --> 02:18:09,629
It turns out that printf also supports other format codes-- so not just %i for integers or %s for strings, but also, for instance,

2117
02:18:09,629 --> 02:18:16,379
%li for a long integer, as well as %f for floating-point values with decimals.

2118
02:18:16,379 --> 02:18:21,690
So with that said, let's go ahead and change my printf line to be not %i, but %li.

2119
02:18:21,690 --> 02:18:29,159
Now let me go ahead and do make calculator again, Enter-- no apparent errors now-- ./calculator.

2120
02:18:29,160 --> 02:18:31,740
And 2 plus 2 still equals 4 as before.

2121
02:18:31,740 --> 02:18:44,629
But now if I do calculator again, and let's do 2 billion again as well as 2 billion for y, previously, we overflowed the size of an integer and got some weird negative number

2122
02:18:44,629 --> 02:18:48,340
because the pattern was misinterpreted, if you will, as a negative number instead.

2123
02:18:48,340 --> 02:18:57,850
But a long, instead of using 32 bits, conventionally uses 64 bits, which means we have more than enough spare bits to go when we add 2 billion plus 2 billion.

2124
02:18:57,850 --> 02:19:04,840
And now, in fact, we get the correct answer of 4 billion, which does fit inside of the size of a long.

2125
02:19:04,840 --> 02:19:07,459
Now, a long can count up quite high.

2126
02:19:07,459 --> 02:19:12,340
And, in fact, it can count as high as this, 9 quintillion.

2127
02:19:12,340 --> 02:19:14,888
And so that will give us quite a bit more runway.

2128
02:19:14,888 --> 02:19:17,836
But, of course, it too is ultimately going to be finite.

2129
02:19:17,837 --> 02:19:22,930
So if you have numbers that need to go bigger than that, you might still very well have a problem.

2130
02:19:22,930 --> 02:19:25,430
Now, there's another problem that we might run into as well.

2131
02:19:25,430 --> 02:19:28,660
And we can see it in the context of even this simple calculator.

2132
02:19:28,660 --> 02:19:35,770
Computers also suffer from potentially what's called truncation, where especially when you're doing math involving floating-point values-- that

2133
02:19:35,770 --> 02:19:43,610
is numbers with decimals-- you might accidentally unknowingly truncate the value-- that is lose everything after the decimal point.

2134
02:19:43,610 --> 02:19:45,549
So in fact, let me go back to VS Code here.

2135
02:19:45,549 --> 02:19:46,900
I'll clear my terminal window.

2136
02:19:46,900 --> 02:19:52,520
And let's still use longs, but let's go ahead and use division instead of addition here.

2137
02:19:52,520 --> 02:19:55,090
So let me change this plus to a divide operator.

2138
02:19:55,090 --> 02:19:59,020
Let me go ahead and recompile the code down here with make calculator.

2139
02:19:59,020 --> 02:20:06,370
Let me go ahead and run ./calculator, and let me go ahead and do something like 1 for x and 3 for y.

2140
02:20:06,370 --> 02:20:08,380
And we'll see that-- well, wait a minute.

2141
02:20:08,380 --> 02:20:11,500
1 divided by 3, I learned, should be 1/3.

2142
02:20:11,500 --> 02:20:21,890
But in a floating-point value, that should 0.33333, maybe with a little line over it in grade school, but, really, an infinite number of threes.

2143
02:20:21,890 --> 02:20:30,040
And yet, we seem to have lost even one of those threes after the decimal point because the answer is coming back here as just 0.

2144
02:20:30,040 --> 02:20:31,700
So why might that be?

2145
02:20:31,700 --> 02:20:42,640
Well, if I know that two integers, when divided one by the other, is supposed to give me a fraction, a floating-point value with a decimal point, I can't continue to use integers or even,

2146
02:20:42,640 --> 02:20:46,370
in this case, longs, which do not have support for decimal points.

2147
02:20:46,370 --> 02:20:56,560
So let me go ahead and change this format code here from %li to %f, which is, again, going to represent a floating-point value instead of a long integer or even an integer.

2148
02:20:56,560 --> 02:21:04,100
And let me go ahead further and define maybe a third variable, z, as a float itself.

2149
02:21:04,100 --> 02:21:07,300
So I'll give myself a variable z equals x divided by y.

2150
02:21:07,300 --> 02:21:10,720
And now rather than print x divided by y, let's just go ahead and print z.

2151
02:21:10,720 --> 02:21:20,260
So now I'm operating in a world of floating-point values because I proactively that a long or an int divided by another such value, if it's meant to have a fraction,

2152
02:21:20,260 --> 02:21:24,710
needs to be stored in a floating-point value, something with a decimal point.

2153
02:21:24,710 --> 02:21:34,180
Well, let me go down to my terminal window here and rerun make of calculator-- seems to work OK-- ./calculator, and let's do 1 divided by 3 again.

2154
02:21:34,180 --> 02:21:36,868
And still here, we see all zeros.

2155
02:21:36,868 --> 02:21:41,350
So we do at least see a decimal point, so we've made some progress Thanks to the %f and the float.

2156
02:21:41,350 --> 02:21:46,570
But it seems that we've already truncated the value 1 divided by 3.

2157
02:21:46,570 --> 02:21:48,520
So how do we actually get around this issue?

2158
02:21:48,520 --> 02:21:57,340
Well, if you the programmer know that you're dealing in a world that's going to give you floating point values with decimal points, you might very well need to use what's called a feature known

2159
02:21:57,340 --> 02:22:04,390
as typecasting-- that is convert one data type to another by explicitly telling the compiler that you want to do so.

2160
02:22:04,390 --> 02:22:05,480
Now, how do I do this?

2161
02:22:05,480 --> 02:22:07,100
Well, let's go back to my code here.

2162
02:22:07,100 --> 02:22:18,310
And if the issue fundamentally is that C is still treating x and y as integers-- or technically, longs with no decimal point-- and dividing one by the other,

2163
02:22:18,310 --> 02:22:24,830
therefore has no room, so to speak, for any numbers after a decimal point, why don't I proactively do this?

2164
02:22:24,830 --> 02:22:33,910
Let me, using a slightly new syntax with parentheses, specify that I want to convert x proactively from a long to a float.

2165
02:22:33,910 --> 02:22:39,950
Let me specify proactively that I want to convert y from a long to a float as well.

2166
02:22:39,950 --> 02:22:49,330
And now let me go ahead and trust that nz should be the result of dividing not a long by a long or an int by an int, but rather, a float by a float.

2167
02:22:49,330 --> 02:22:55,300
Let me clear my terminal window, run make calculator again-- seems to work OK-- ./calculator.

2168
02:22:55,300 --> 02:23:05,380
And now 1, 3, and hopefully now we actually see that my code has outputted 0.333333.

2169
02:23:05,380 --> 02:23:11,710
And I think if we kept showing more numbers after the decimal point, we'd theoretically see as many of those threes as we want.

2170
02:23:11,710 --> 02:23:13,900
But there is still one more catch.

2171
02:23:13,900 --> 02:23:22,180
And especially when we're manipulating numbers in this way in a computer using a finite amount of memory, another challenge we might run up against-- besides integer

2172
02:23:22,180 --> 02:23:27,100
overflow, besides truncation-- is this known as floating-point imprecision.

2173
02:23:27,100 --> 02:23:34,060
Just as we can't represent as big of an integer as we want using int or long alone because there is going to be an upper bound,

2174
02:23:34,060 --> 02:23:39,220
there's similarly going to be a bound on just how precise our numbers can be.

2175
02:23:39,220 --> 02:23:41,560
And indeed, let's go back to VS Code here.

2176
02:23:41,560 --> 02:23:43,430
I'll clear my terminal window yet again.

2177
02:23:43,430 --> 02:23:52,250
And this time, let me use some slightly unlikely syntax to specify that I don't want to see the default number of numbers after the decimal point, which %f gives us automatically.

2178
02:23:52,250 --> 02:23:57,520
Let's go ahead and show me 20 decimal point numbers after the decimal point.

2179
02:23:57,520 --> 02:24:08,440
And the weird syntax for this is to do not %f, but %.20 to indicate to see that I want to see 20 digits, not the default after, now, the decimal point.

2180
02:24:08,440 --> 02:24:10,390
Let me rerun make calculator.

2181
02:24:10,390 --> 02:24:12,550
Let me do ./calculator again.

2182
02:24:12,550 --> 02:24:14,890
And let's do 1, let's do 3.

2183
02:24:14,890 --> 02:24:17,560
And now this is even weirder, right?

2184
02:24:17,560 --> 02:24:21,580
From grade school, you presumably learned that 1 divided by 3 is, of course, 1/3.

2185
02:24:21,580 --> 02:24:28,180
But that should be 0.33333, infinitely many times, or, on paper, with a little line over it.

2186
02:24:28,180 --> 02:24:31,660
But the computer is doing some weird approximation here.

2187
02:24:31,660 --> 02:24:37,480
It's a whole bunch of 3's and then 4326744079590.

2188
02:24:37,480 --> 02:24:42,100
Well, what's really happening under the hood, well, again, is this issue of floating-point imprecision.

2189
02:24:42,100 --> 02:24:52,300
If you only have a finite number of bits and, in turn, a finite amount of memory, the computer can really only be so precise intuitively.

2190
02:24:52,300 --> 02:24:57,190
Equivalently, the computer is decided on some way of representing floating-point values.

2191
02:24:57,190 --> 02:25:07,040
But the catch is, per grade school math, there's an infinite number of numbers out there and an infinite number of floating-point values because you can keep adding more and more digits if you want.

2192
02:25:07,040 --> 02:25:14,500
So the computer, given the way it's implementing these floating point values, is essentially giving us the closest approximation that it can.

2193
02:25:14,500 --> 02:25:17,740
Now, how can we go about improving the situation?

2194
02:25:17,740 --> 02:25:19,180
Well, there is one alternative.

2195
02:25:19,180 --> 02:25:24,760
Instead of using float, I can use something called a double, which, as the name suggests, uses twice as many bits as a float.

2196
02:25:24,760 --> 02:25:27,820
So instead of 32 typically, it will use 64.

2197
02:25:27,820 --> 02:25:31,570
And that's just like the difference between a long and an int, which gave us more bits.

2198
02:25:31,570 --> 02:25:34,480
But in this case, this will be used for more precision.

2199
02:25:34,480 --> 02:25:36,850
Let's go ahead and cast x to a double.

2200
02:25:36,850 --> 02:25:38,740
Let's cast y to a double.

2201
02:25:38,740 --> 02:25:41,530
And now let's go ahead and, using the same format code--

2202
02:25:41,530 --> 02:25:45,220
%.20f is still OK for doubles.

2203
02:25:45,220 --> 02:25:46,990
Let me do make calculator.

2204
02:25:46,990 --> 02:25:48,970
Let me do ./calculator.

2205
02:25:48,970 --> 02:25:51,460
And now let me do 1 divided by 3.

2206
02:25:51,460 --> 02:25:53,770
And we still have some of that imprecision.

2207
02:25:53,770 --> 02:25:56,590
And it's even more of it if we looked at more than just 20 digits.

2208
02:25:56,590 --> 02:25:59,900
But now we have more threes after the decimal point.

2209
02:25:59,900 --> 02:26:03,640
So it's at least more, and more, and more precise, but it's not perfect.

2210
02:26:03,640 --> 02:26:06,520
But it's at least more precise.

2211
02:26:06,520 --> 02:26:14,980
So these kinds of issues, then, are going to be necessary to keep in mind any time you do something numerically, scientifically, at least with a language C where you're going to bump up

2212
02:26:14,980 --> 02:26:18,910
against these real-world limitations of hardware and, in turn, language.

2213
02:26:18,910 --> 02:26:21,952
Now, later in the semester, we'll transition to a language called Python.

2214
02:26:21,952 --> 02:26:29,470
And that's actually going to solve at least one of these problems for us by just automatically giving us more bits, so to speak, as we need them, at least for integers.

2215
02:26:29,470 --> 02:26:33,140
But even the issue of floating-point imprecision is going to remain.

2216
02:26:33,140 --> 02:26:35,170
Now, just how real-world are these issues?

2217
02:26:35,170 --> 02:26:45,010
Well, back in the year 1999, we got a taste of this when the world realized in the years leading up to that date that it might not have been the best idea to implement computers

2218
02:26:45,010 --> 02:26:48,910
and software therein by storing gears using just two digits.

2219
02:26:48,910 --> 02:27:01,400
Like, instead of storing 1999 to represent the year 1999, a lot of computers, for reasons of space and cost, were in the habit of cutting a corner and just using two digits to keep track of the year.

2220
02:27:01,400 --> 02:27:14,290
The problem with that is that if systems were not updated by the year 1999 to support the year 2000, 2001, and so forth, is that, just like before with integer overflow, some computers might

2221
02:27:14,290 --> 02:27:16,990
add 1 to the year in their memory, '99.

2222
02:27:16,990 --> 02:27:28,390
It should be the year 2000, but if they're only using two digits to represent years, they might mistake the year-- as some systems may very well have-- for the year 1900 instead, taking literally

2223
02:27:28,390 --> 02:27:30,740
a big step backwards, if you will.

2224
02:27:30,740 --> 02:27:37,240
Now, you'd like to think that kind of issue is behind us, especially as we understand all the more about the limitations of code and computing.

2225
02:27:37,240 --> 02:27:42,160
But we're actually going to run up against this very same type of issue again in just a few years.

2226
02:27:42,160 --> 02:27:50,800
On January 19 in the year 2038, we will have run out of bits in most computers right now to keep track of time.

2227
02:27:50,800 --> 02:27:58,870
It turns out, years ago, humans decided to use a 32-bit integer to keep track of how many seconds had elapsed over time.

2228
02:27:58,870 --> 02:28:01,090
They chose a somewhat arbitrary date in the past--

2229
02:28:01,090 --> 02:28:03,350
January 1, 1970--

2230
02:28:03,350 --> 02:28:06,860
And they just started counting seconds from there on out.

2231
02:28:06,860 --> 02:28:14,710
And so if a computer stores some number of seconds, that tells the computer how many seconds have passed since that particular date, January 1, 1970.

2232
02:28:14,710 --> 02:28:23,470
Unfortunately, using a 32-bit integer, as we've seen, you can only count so high, at which point, you overflow the size of that variable.

2233
02:28:23,470 --> 02:28:32,080
And so potentially, if we don't get ahead of this as humans, as a society, as computer scientists, on the date January 19, 2038,

2234
02:28:32,080 --> 02:28:42,460
that bit might flip over, thereby overflowing the size of those integers, bringing us back computationally to December 13, 1901.

2235
02:28:42,460 --> 02:28:48,560
So this is to say now, with all of this computational ability and code comes a responsibility to actually write correct code.

2236
02:28:48,560 --> 02:28:50,560
Next week, we'll peel back some of these layers.

2237
02:28:50,560 --> 02:28:54,550
But for now, this was week 1, and best of luck on problem set 1.

2238
02:28:54,550 --> 02:28:57,850
[APPLAUSE]

2239
02:28:57,850 --> 02:29:01,500
[MUSIC PLAYING]

3
00:01:13,350 --> 00:01:16,090
-J- CS50

4
00:01:16,090 --> 00:01:25,060
 Scratch 

5
00:01:25,060 --> 00:01:31,750
 Scratch

6
00:01:31,750 --> 00:01:36,410


7
00:01:36,410 --> 00:01:44,980
 C 

8
00:01:44,980 --> 00:01:52,670


9
00:01:52,670 --> 00:02:02,350
 "Hello World " "Hello World "

10
00:02:02,350 --> 00:02:04,350


11
00:02:04,350 --> 00:02:11,578


12
00:02:11,578 --> 00:02:15,370
 Scratch  ""

13
00:02:15,370 --> 00:02:19,610


14
00:02:19,610 --> 00:02:24,040


15
00:02:24,040 --> 00:02:27,908


16
00:02:27,908 --> 00:02:29,200
 Scratch 

17
00:02:29,200 --> 00:02:32,370
 C  Python 

18
00:02:32,370 --> 00:02:37,330


19
00:02:37,330 --> 00:02:42,190


20
00:02:42,190 --> 00:02:47,200
 Scratch  C 

21
00:02:47,200 --> 00:02:49,870


22
00:02:49,870 --> 00:02:50,650


23
00:02:50,650 --> 00:02:51,525


24
00:02:51,525 --> 00:02:53,080
0  1

25
00:02:53,080 --> 00:02:56,470


26
00:02:56,470 --> 00:03:04,810
 "0 " "1 " "0 " "1 "

27
00:03:04,810 --> 00:03:12,880


28
00:03:12,880 --> 00:03:18,860


29
00:03:18,860 --> 00:03:28,600
 0  1 

30
00:03:28,600 --> 00:03:29,530


31
00:03:29,530 --> 00:03:36,430
--

32
00:03:36,430 --> 00:03:44,740
MacPC  0  1  "0 " "1 "

33
00:03:44,740 --> 00:03:49,200


34
00:03:49,200 --> 00:03:52,575


35
00:03:52,575 --> 00:03:58,910


36
00:03:58,910 --> 00:04:07,120


37
00:04:07,120 --> 00:04:11,230


38
00:04:11,230 --> 00:04:15,430
 0  1 

39
00:04:15,430 --> 00:04:21,730
 MacPC 

40
00:04:21,730 --> 00:04:28,690
--

41
00:04:28,690 --> 00:04:32,320


42
00:04:32,320 --> 00:04:36,050


43
00:04:36,050 --> 00:04:39,400


44
00:04:39,400 --> 00:04:40,810


45
00:04:40,810 --> 00:04:48,805
 C  0  1

46
00:04:48,805 --> 00:04:50,680
 Scratch 

47
00:04:50,680 --> 00:04:57,280
 Scratch 

48
00:04:57,280 --> 00:05:00,760


49
00:05:00,760 --> 00:05:06,550


50
00:05:06,550 --> 00:05:09,340


51
00:05:09,340 --> 00:05:19,973


52
00:05:19,973 --> 00:05:21,640


53
00:05:21,640 --> 00:05:25,810


54
00:05:25,810 --> 00:05:29,370


55
00:05:29,370 --> 00:05:32,930


56
00:05:32,930 --> 00:05:35,180


57
00:05:35,180 --> 00:05:35,870


58
00:05:35,870 --> 00:05:36,620


59
00:05:36,620 --> 00:05:41,050


60
00:05:41,050 --> 00:05:49,360
 CS50 

61
00:05:49,360 --> 00:05:51,040


62
00:05:51,040 --> 00:05:52,810


63
00:05:52,810 --> 00:05:55,835


64
00:05:55,835 --> 00:05:59,350


65
00:05:59,350 --> 00:06:00,820


66
00:06:00,820 --> 00:06:07,030
 MacPC 

67
00:06:07,030 --> 00:06:10,060


68
00:06:10,060 --> 00:06:13,930


69
00:06:13,930 --> 00:06:24,170


70
00:06:24,170 --> 00:06:26,080


71
00:06:26,080 --> 00:06:32,882


72
00:06:32,882 --> 00:06:40,090


73
00:06:40,090 --> 00:06:41,530


74
00:06:41,530 --> 00:06:49,438


75
00:06:49,438 --> 00:06:50,900


76
00:06:50,900 --> 00:06:54,490


77
00:06:54,490 --> 00:06:57,523


78
00:06:57,523 --> 00:06:59,690


79
00:06:59,690 --> 00:07:10,750


80
00:07:10,750 --> 00:07:13,150


81
00:07:13,150 --> 00:07:16,390


82
00:07:16,390 --> 00:07:17,817


83
00:07:17,817 --> 00:07:21,560


84
00:07:21,560 --> 00:07:25,520


85
00:07:25,520 --> 00:07:27,280


86
00:07:27,280 --> 00:07:28,940


87
00:07:28,940 --> 00:07:39,280
 C  Visual Studio Code VS Code

88
00:07:39,280 --> 00:07:45,970
 C  C++PythonJava 

89
00:07:45,970 --> 00:07:49,270


90
00:07:49,270 --> 00:07:52,150


91
00:07:52,150 --> 00:07:54,907
/

92
00:07:54,907 --> 00:07:59,532


93
00:07:59,532 --> 00:08:02,532


94
00:08:02,532 --> 00:08:07,240
 Microsoft WordNotepad.exe  Mac  Text Edit 

95
00:08:07,240 --> 00:08:15,250


96
00:08:15,250 --> 00:08:22,240
VS Code --

97
00:08:22,240 --> 00:08:29,110


98
00:08:29,110 --> 00:08:34,780
 code.cs50.io  VS Code 

99
00:08:34,780 --> 00:08:36,580


100
00:08:36,580 --> 00:08:46,090
 Mac  PC  CS50  CS 

101
00:08:46,090 --> 00:08:55,760
 CS50 

102
00:08:55,760 --> 00:08:59,020
VS Code  Mac 

103
00:08:59,020 --> 00:09:00,990


104
00:09:00,990 --> 00:09:02,990


105
00:09:02,990 --> 00:09:05,657


106
00:09:05,657 --> 00:09:10,335
 C 

107
00:09:10,335 --> 00:09:12,460


108
00:09:12,460 --> 00:09:15,440


109
00:09:15,440 --> 00:09:21,160


110
00:09:21,160 --> 00:09:24,940
 Google Docs  Microsoft Word 

111
00:09:24,940 --> 00:09:30,830
 VS Code 

112
00:09:30,830 --> 00:09:34,480
 hello.c 

113
00:09:34,480 --> 00:09:38,020


114
00:09:38,020 --> 00:09:41,920


115
00:09:41,920 --> 00:09:44,170


116
00:09:44,170 --> 00:09:47,920


117
00:09:47,920 --> 00:09:49,720
 CLI

118
00:09:49,720 --> 00:09:53,680
GUI

119
00:09:53,680 --> 00:09:57,760


120
00:09:57,760 --> 00:10:01,420


121
00:10:01,420 --> 00:10:06,380


122
00:10:06,380 --> 00:10:14,620
 --  CLI

123
00:10:14,620 --> 00:10:20,650


125
00:10:21,250 --> 00:10:26,260


126
00:10:26,260 --> 00:10:29,530


127
00:10:29,530 --> 00:10:32,330


128
00:10:32,330 --> 00:10:40,390


129
00:10:40,390 --> 00:10:45,800


130
00:10:45,800 --> 00:10:47,890


131
00:10:47,890 --> 00:10:51,820


132
00:10:51,820 --> 00:11:02,110
 VS Code  ""File Explorer Mac  PC 

133
00:11:02,110 --> 00:11:06,140
 hello.c

134
00:11:06,140 --> 00:11:12,260
 ""

135
00:11:12,260 --> 00:11:16,250
VS Code  CLI

136
00:11:16,250 --> 00:11:22,250
 CLI

137
00:11:22,250 --> 00:11:28,380


138
00:11:28,380 --> 00:11:32,878
 VS Code 

139
00:11:32,878 --> 00:11:34,670
 " "

140
00:11:34,670 --> 00:11:36,470


141
00:11:36,470 --> 00:11:42,840


142
00:11:42,840 --> 00:11:45,260


143
00:11:45,260 --> 00:11:47,160


144
00:11:47,160 --> 00:11:51,230


145
00:11:51,230 --> 00:11:55,490


146
00:11:55,490 --> 00:11:58,020


147
00:11:58,020 --> 00:12:08,870
 VS CodeVS -- MacPC  1 --

148
00:12:08,870 --> 00:12:10,610


149
00:12:10,610 --> 00:12:15,200


150
00:12:15,200 --> 00:12:18,838
 .c 

151
00:12:18,838 --> 00:12:21,380


152
00:12:21,380 --> 00:12:22,672


153
00:12:22,672 --> 00:12:24,140
 "H"

154
00:12:24,140 --> 00:12:27,260
 C

155
00:12:27,260 --> 00:12:31,100


156
00:12:31,100 --> 00:12:35,540


157
00:12:35,540 --> 00:12:40,100
 C 

158
00:12:40,100 --> 00:12:45,992
 Scratch " "

159
00:12:45,992 --> 00:12:47,450


160
00:12:47,450 --> 00:12:49,970


161
00:12:49,970 --> 00:12:53,720
 stdio.h 

162
00:12:53,720 --> 00:12:57,230
 int main void

163
00:12:57,230 --> 00:13:01,190


164
00:13:01,190 --> 00:13:12,800
 printf helloworld n

165
00:13:12,800 --> 00:13:14,280


166
00:13:14,280 --> 00:13:19,010


167
00:13:19,010 --> 00:13:21,710


168
00:13:21,710 --> 00:13:23,857


169
00:13:23,857 --> 00:13:29,840


170
00:13:29,840 --> 00:13:37,408
 Mac  PC

171
00:13:37,408 --> 00:13:38,450


172
00:13:38,450 --> 00:13:39,930


173
00:13:39,930 --> 00:13:42,380


174
00:13:42,380 --> 00:13:47,880


175
00:13:47,880 --> 00:13:59,360
 make

176
00:13:59,360 --> 00:14:05,870
-- .c hello

177
00:14:05,870 --> 00:14:07,400
 make hello.c

178
00:14:07,400 --> 00:14:08,780
 " "

179
00:14:08,780 --> 00:14:13,040
 make 

180
00:14:13,040 --> 00:14:17,580


181
00:14:17,580 --> 00:14:20,180
 " "

182
00:14:20,180 --> 00:14:30,690
 hello.c  C  0  1 

183
00:14:30,690 --> 00:14:37,170
Enter 

184
00:14:37,170 --> 00:14:38,210


185
00:14:38,210 --> 00:14:41,862


186
00:14:41,862 --> 00:14:43,070


187
00:14:43,070 --> 00:14:43,880


188
00:14:43,880 --> 00:14:45,000


189
00:14:45,000 --> 00:14:46,590


190
00:14:46,590 --> 00:14:47,942


191
00:14:47,942 --> 00:14:52,110


192
00:14:52,110 --> 00:14:55,400
 ./hello

193
00:14:55,400 --> 00:14:58,798


194
00:14:58,798 --> 00:15:07,730
 hello 

195
00:15:07,730 --> 00:15:10,430


197
00:15:12,110 --> 00:15:15,950
 C hello, world

198
00:15:15,950 --> 00:15:21,292


199
00:15:21,292 --> 00:15:23,750


200
00:15:23,750 --> 00:15:28,250


201
00:15:28,250 --> 00:15:35,270
 Mac  PC  hello.c

202
00:15:35,270 --> 00:15:37,520


203
00:15:37,520 --> 00:15:40,970
 ""

204
00:15:40,970 --> 00:15:42,690


205
00:15:42,690 --> 00:15:46,100
 Mac  PC

206
00:15:46,100 --> 00:15:48,162


207
00:15:48,162 --> 00:15:49,370


208
00:15:49,370 --> 00:15:50,453


209
00:15:50,453 --> 00:15:56,240
 hello.c 

210
00:15:56,240 --> 00:16:01,970


213
00:16:04,950 --> 00:16:13,950


214
00:16:13,950 --> 00:16:19,320


215
00:16:19,320 --> 00:16:23,790
 io -- stdio.h

216
00:16:23,790 --> 00:16:25,890
 studio.h

217
00:16:25,890 --> 00:16:30,600


218
00:16:30,600 --> 00:16:32,280
 studio.h

219
00:16:32,280 --> 00:16:34,560
 stdio.h--

220
00:16:34,560 --> 00:16:41,730


221
00:16:41,730 --> 00:16:49,110


222
00:16:49,110 --> 00:16:50,950


223
00:16:50,950 --> 00:16:55,890
 studio.h

224
00:16:55,890 --> 00:16:58,182


225
00:16:58,182 --> 00:16:59,740


227
00:17:00,240 --> 00:17:02,540


228
00:17:02,540 --> 00:17:03,799


229
00:17:03,799 --> 00:17:04,400


230
00:17:04,400 --> 00:17:06,400


231
00:17:06,400 --> 00:17:10,520
 hello.c 

232
00:17:10,520 --> 00:17:17,040
 make hello 

233
00:17:17,040 --> 00:17:25,700
 hello  0  1

234
00:17:25,700 --> 00:17:27,200


235
00:17:27,200 --> 00:17:29,710
[]

236
00:17:29,710 --> 00:17:38,230
-J- hello  VS /

237
00:17:38,230 --> 00:17:41,437
 0  1

238
00:17:41,437 --> 00:17:42,520


239
00:17:42,520 --> 00:17:43,660
 0  1

240
00:17:43,660 --> 00:17:47,680
 0  1

241
00:17:47,680 --> 00:17:50,320


242
00:17:50,320 --> 00:17:53,165
VS Code 

243
00:17:53,165 --> 00:17:56,290


244
00:17:56,290 --> 00:18:00,190


245
00:18:00,190 --> 00:18:01,900


246
00:18:01,900 --> 00:18:06,700


247
00:18:06,700 --> 00:18:08,440


248
00:18:08,440 --> 00:18:09,460


249
00:18:09,460 --> 00:18:17,740


250
00:18:17,740 --> 00:18:22,510


251
00:18:22,510 --> 00:18:29,600
VS Code 

252
00:18:29,600 --> 00:18:36,760


253
00:18:36,760 --> 00:18:47,570
----

255
00:18:48,070 --> 00:18:51,430


256
00:18:51,430 --> 00:18:53,890
Int  void  include 

257
00:18:53,890 --> 00:18:55,630


258
00:18:55,630 --> 00:18:57,390


259
00:18:57,390 --> 00:18:59,290


260
00:18:59,290 --> 00:19:04,870
 1 

261
00:19:04,870 --> 00:19:07,190
 VS 

262
00:19:07,190 --> 00:19:09,820


263
00:19:09,820 --> 00:19:13,480
 Scratch 

264
00:19:13,480 --> 00:19:16,485


265
00:19:16,485 --> 00:19:20,830


266
00:19:20,830 --> 00:19:25,510


267
00:19:25,510 --> 00:19:28,790


268
00:19:28,790 --> 00:19:32,500
 Scratch 

269
00:19:32,500 --> 00:19:45,070
 Scratch  hello, world-- say 

270
00:19:45,070 --> 00:19:50,950
 C  Scratch 

271
00:19:50,950 --> 00:19:53,090


272
00:19:53,090 --> 00:20:03,190
 say 

273
00:20:03,190 --> 00:20:08,480


274
00:20:08,480 --> 00:20:18,790
 say  hello, world  hello, world

275
00:20:18,790 --> 00:20:23,230
 VS 

276
00:20:23,230 --> 00:20:25,900


277
00:20:25,900 --> 00:20:38,350
 Scratch  say  C 

278
00:20:38,350 --> 00:20:44,830
 say  C. 

279
00:20:44,830 --> 00:20:48,520
--

280
00:20:48,520 --> 00:20:50,440
 printf 

281
00:20:50,440 --> 00:20:52,030
Printf 

282
00:20:52,030 --> 00:20:55,360


283
00:20:55,360 --> 00:20:58,570
C  say  printf 

284
00:20:58,570 --> 00:21:08,050
 printf  say

285
00:21:08,050 --> 00:21:16,250
 Scratch  C 

286
00:21:16,250 --> 00:21:23,510


287
00:21:23,510 --> 00:21:31,240
 printf 

288
00:21:31,240 --> 00:21:37,460
-- ""

289
00:21:37,460 --> 00:21:42,160
 C 

290
00:21:42,160 --> 00:21:52,100


291
00:21:52,100 --> 00:21:54,520


292
00:21:54,520 --> 00:22:01,660
-- n

293
00:22:01,660 --> 00:22:05,480


294
00:22:05,480 --> 00:22:08,890
 Scratch 

295
00:22:08,890 --> 00:22:10,960


296
00:22:10,960 --> 00:22:16,630
 C printf n

297
00:22:16,630 --> 00:22:18,970


298
00:22:18,970 --> 00:22:21,290


299
00:22:21,290 --> 00:22:27,130


300
00:22:27,130 --> 00:22:33,380


301
00:22:33,380 --> 00:22:34,190


302
00:22:34,190 --> 00:22:37,070
 VS 

303
00:22:37,070 --> 00:22:40,910
 5 

304
00:22:40,910 --> 00:22:42,910
 " "

305
00:22:42,910 --> 00:22:46,090


306
00:22:46,090 --> 00:22:49,930
20 

307
00:22:49,930 --> 00:22:52,180


308
00:22:52,180 --> 00:22:53,380


309
00:22:53,380 --> 00:22:54,910


310
00:22:54,910 --> 00:22:59,920


311
00:22:59,920 --> 00:23:02,590


312
00:23:02,590 --> 00:23:06,460


313
00:23:06,460 --> 00:23:09,940
 ""

314
00:23:09,940 --> 00:23:13,690


315
00:23:13,690 --> 00:23:14,950


316
00:23:14,950 --> 00:23:16,060


317
00:23:16,060 --> 00:23:18,670
 0  1 

318
00:23:18,670 --> 00:23:21,980


319
00:23:21,980 --> 00:23:22,580


320
00:23:22,580 --> 00:23:24,830


321
00:23:24,830 --> 00:23:29,320


322
00:23:29,320 --> 00:23:29,980


323
00:23:29,980 --> 00:23:33,700


324
00:23:33,700 --> 00:23:35,770


325
00:23:35,770 --> 00:23:42,760


326
00:23:42,760 --> 00:23:47,750


327
00:23:47,750 --> 00:23:49,090


328
00:23:49,090 --> 00:23:51,220


329
00:23:51,220 --> 00:23:57,010
hello.c529

330
00:23:57,010 --> 00:23:58,420


331
00:23:58,420 --> 00:24:03,460
 5  29 

332
00:24:03,460 --> 00:24:07,448


333
00:24:07,448 --> 00:24:08,630
 5 

335
00:24:09,130 --> 00:24:11,660
 5 

337
00:24:12,160 --> 00:24:13,360


338
00:24:13,360 --> 00:24:16,242


339
00:24:16,242 --> 00:24:20,103


340
00:24:20,103 --> 00:24:21,520


341
00:24:21,520 --> 00:24:30,550
 ASCII ----

342
00:24:30,550 --> 00:24:33,850
 1 --

343
00:24:33,850 --> 00:24:36,340


344
00:24:36,340 --> 00:24:39,470


345
00:24:39,470 --> 00:24:40,360


346
00:24:40,360 --> 00:24:45,470


347
00:24:45,470 --> 00:24:48,760
 make hello --

348
00:24:48,760 --> 00:24:52,990
--

349
00:24:52,990 --> 00:24:55,550


350
00:24:55,550 --> 00:25:02,240


351
00:25:02,240 --> 00:25:04,460


353
00:25:04,960 --> 00:25:08,848


354
00:25:08,848 --> 00:25:10,390
-J-

355
00:25:10,390 --> 00:25:12,960


356
00:25:12,960 --> 00:25:14,022


357
00:25:14,022 --> 00:25:18,240


358
00:25:18,240 --> 00:25:22,810


359
00:25:22,810 --> 00:25:25,230


360
00:25:25,230 --> 00:25:25,950


361
00:25:25,950 --> 00:25:29,230


362
00:25:29,230 --> 00:25:34,830


363
00:25:34,830 --> 00:25:37,650
" "

364
00:25:37,650 --> 00:25:39,750


365
00:25:39,750 --> 00:25:46,980


366
00:25:46,980 --> 00:25:51,600


369
00:25:55,170 --> 00:25:56,170
-J-

370
00:25:56,170 --> 00:25:58,950
 5 

371
00:25:58,950 --> 00:26:02,250
 29  29 

372
00:26:02,250 --> 00:26:04,800


373
00:26:04,800 --> 00:26:09,750


374
00:26:09,750 --> 00:26:13,260


376
00:26:14,170 --> 00:26:16,930
 hello.c 

377
00:26:16,930 --> 00:26:22,940
-J-hello.c make hello

378
00:26:22,940 --> 00:26:24,180


379
00:26:24,180 --> 00:26:31,280
hello.c  VS Code  hello.c 

380
00:26:31,280 --> 00:26:34,910
 Mac  PC  """ "

381
00:26:34,910 --> 00:26:42,560
 Command-S  Control-S 

382
00:26:42,560 --> 00:26:46,110
 make hello 

383
00:26:46,110 --> 00:26:54,020
hello.c

384
00:26:54,020 --> 00:26:57,200


385
00:26:57,200 --> 00:26:58,790


386
00:26:58,790 --> 00:27:03,380
 Control-L 

387
00:27:03,380 --> 00:27:11,460
 n 

388
00:27:11,460 --> 00:27:20,450


389
00:27:20,450 --> 00:27:25,130
 n

390
00:27:25,130 --> 00:27:28,390


391
00:27:28,390 --> 00:27:29,920


392
00:27:29,920 --> 00:27:34,190
 " "

393
00:27:34,190 --> 00:27:35,190
-J-

394
00:27:35,190 --> 00:27:38,740
 " "

395
00:27:38,740 --> 00:27:40,564


396
00:27:40,564 --> 00:27:43,010
 n 

397
00:27:43,010 --> 00:27:44,010
-J-

398
00:27:44,010 --> 00:27:48,060
 n 

399
00:27:48,060 --> 00:27:55,420
 hello, Enter -- 

400
00:27:55,420 --> 00:27:57,180
 n

401
00:27:57,180 --> 00:27:58,800


402
00:27:58,800 --> 00:28:03,510
 n ./hello 

403
00:28:03,510 --> 00:28:07,230
 """"""

404
00:28:07,230 --> 00:28:08,460


405
00:28:08,460 --> 00:28:12,270


406
00:28:12,270 --> 00:28:13,710


407
00:28:13,710 --> 00:28:18,240
 ./hello 

408
00:28:18,240 --> 00:28:24,460


409
00:28:24,460 --> 00:28:34,980
 n C 

410
00:28:34,980 --> 00:28:39,640
Python 

411
00:28:39,640 --> 00:28:44,850


412
00:28:44,850 --> 00:28:47,220


413
00:28:47,220 --> 00:28:49,020
 n

414
00:28:49,020 --> 00:28:52,860
 Word 

415
00:28:52,860 --> 00:28:55,107


416
00:28:55,107 --> 00:28:56,940


417
00:28:56,940 --> 00:29:02,220
 hello, world

419
00:29:02,790 --> 00:29:07,290
 make hello now C 

420
00:29:07,290 --> 00:29:17,070
 5  12 --

421
00:29:17,070 --> 00:29:21,900
--

422
00:29:21,900 --> 00:29:23,470


423
00:29:23,470 --> 00:29:25,320


424
00:29:25,320 --> 00:29:26,190


425
00:29:26,190 --> 00:29:31,380
 C 

426
00:29:31,380 --> 00:29:32,760


427
00:29:32,760 --> 00:29:36,150


428
00:29:36,150 --> 00:29:38,220


429
00:29:38,220 --> 00:29:43,958
 n 

430
00:29:43,958 --> 00:29:45,250


431
00:29:45,250 --> 00:29:46,710


432
00:29:46,710 --> 00:29:48,720


433
00:29:48,720 --> 00:29:50,080


434
00:29:50,080 --> 00:29:54,090
 make hello-- ./hello

436
00:29:54,900 --> 00:29:57,780


437
00:29:57,780 --> 00:30:04,920
 " "

438
00:30:04,920 --> 00:30:10,145
 int main(void) 

439
00:30:10,145 --> 00:30:12,520


440
00:30:12,520 --> 00:30:19,180
 int main(void)  C 

442
00:30:19,680 --> 00:30:20,638


443
00:30:20,638 --> 00:30:22,320


444
00:30:22,320 --> 00:30:26,340


445
00:30:26,340 --> 00:30:28,950


446
00:30:28,950 --> 00:30:33,990
 stdio.h S-T-D-I-O dot H

447
00:30:33,990 --> 00:30:37,500


448
00:30:37,500 --> 00:30:40,290


449
00:30:40,290 --> 00:30:45,165


450
00:30:45,165 --> 00:30:46,360


451
00:30:46,360 --> 00:30:50,160
 make hello

452
00:30:50,160 --> 00:30:53,290


454
00:30:53,790 --> 00:30:56,340


455
00:30:56,340 --> 00:31:09,150
hello.c  5  5 -- int  printf dotdotdot

456
00:31:09,150 --> 00:31:14,490
 printf -- 

457
00:31:14,490 --> 00:31:16,920


458
00:31:16,920 --> 00:31:22,620
 stdio.h  include 

460
00:31:23,820 --> 00:31:33,330


461
00:31:33,330 --> 00:31:35,370


462
00:31:35,370 --> 00:31:37,290
[]

463
00:31:37,290 --> 00:31:38,290
-J-

464
00:31:38,290 --> 00:31:42,137


465
00:31:42,137 --> 00:31:45,220
 Scratch 

466
00:31:45,220 --> 00:31:47,950
 0 

467
00:31:47,950 --> 00:31:59,170
 Scratch 

468
00:31:59,170 --> 00:32:00,100


469
00:32:00,100 --> 00:32:04,390
--

470
00:32:04,390 --> 00:32:06,550


471
00:32:06,550 --> 00:32:08,380


473
00:32:09,250 --> 00:32:13,900
 C  printf

474
00:32:13,900 --> 00:32:20,020


475
00:32:20,020 --> 00:32:22,570


476
00:32:22,570 --> 00:32:30,610


477
00:32:30,610 --> 00:32:34,690


478
00:32:34,690 --> 00:32:42,680
/

479
00:32:42,680 --> 00:32:50,350
 I/O 

480
00:32:50,350 --> 00:32:53,450
 I/O 

481
00:32:53,450 --> 00:32:54,700


482
00:32:54,700 --> 00:32:57,010


483
00:32:57,010 --> 00:33:01,310
--

484
00:33:01,310 --> 00:33:07,630
 C 

485
00:33:07,630 --> 00:33:11,350


486
00:33:11,350 --> 00:33:18,320
 I/O  printf

487
00:33:18,320 --> 00:33:24,040
 printf 

488
00:33:24,040 --> 00:33:27,970


489
00:33:27,970 --> 00:33:37,590


490
00:33:37,590 --> 00:33:40,890


491
00:33:40,890 --> 00:33:43,990


492
00:33:43,990 --> 00:33:48,720
C 

493
00:33:48,720 --> 00:33:52,770


494
00:33:52,770 --> 00:34:01,680
 C  manual.cs50.io

495
00:34:01,680 --> 00:34:06,150
 C 

496
00:34:06,150 --> 00:34:14,560


497
00:34:14,560 --> 00:34:24,074


498
00:34:24,074 --> 00:34:27,713


499
00:34:27,713 --> 00:34:30,630


500
00:34:30,630 --> 00:34:39,969


501
00:34:39,969 --> 00:34:52,830
 stdio.h  URL manual.cs50.io 

502
00:34:52,830 --> 00:34:58,350


503
00:34:58,350 --> 00:35:04,110
 URL printf 

504
00:35:04,110 --> 00:35:07,560
 ""

505
00:35:07,560 --> 00:35:09,450


506
00:35:09,450 --> 00:35:18,160
 ""

507
00:35:18,160 --> 00:35:25,980
CS50  cs50.h 

508
00:35:25,980 --> 00:35:34,110
 C 

509
00:35:34,110 --> 00:35:36,670


510
00:35:36,670 --> 00:35:41,100
 Python 

511
00:35:41,100 --> 00:35:42,540
 Java 

512
00:35:42,540 --> 00:35:46,312


513
00:35:46,312 --> 00:35:56,430
 " " cs50.h 

514
00:35:56,430 --> 00:35:59,220
 URL 

515
00:35:59,220 --> 00:36:01,230


516
00:36:01,230 --> 00:36:11,790
 CS50  get_char get_int 

517
00:36:11,790 --> 00:36:16,930
get_string

518
00:36:16,930 --> 00:36:26,710
 Scratch 

519
00:36:26,710 --> 00:36:28,830
Scratch  hello, world

520
00:36:28,830 --> 00:36:31,200


521
00:36:31,200 --> 00:36:33,180
 2 

522
00:36:33,180 --> 00:36:35,190


523
00:36:35,190 --> 00:36:40,870
 ""

524
00:36:40,870 --> 00:36:46,420
 " " " "

525
00:36:46,420 --> 00:36:48,420


526
00:36:48,420 --> 00:36:49,560


527
00:36:49,560 --> 00:36:54,480


528
00:36:54,480 --> 00:37:00,000


529
00:37:00,000 --> 00:37:03,580


530
00:37:03,580 --> 00:37:08,490


531
00:37:08,490 --> 00:37:12,420


532
00:37:12,420 --> 00:37:14,670


533
00:37:14,670 --> 00:37:17,550
 MIT 

534
00:37:17,550 --> 00:37:22,300
 C 

535
00:37:22,300 --> 00:37:24,100


536
00:37:24,100 --> 00:37:28,980


537
00:37:28,980 --> 00:37:34,020


538
00:37:34,020 --> 00:37:38,400
 Scratch  C 

539
00:37:38,400 --> 00:37:42,580


540
00:37:42,580 --> 00:37:45,600
 CS50  get_string

541
00:37:45,600 --> 00:37:49,950


542
00:37:49,950 --> 00:37:54,300
--/

543
00:37:54,300 --> 00:37:57,150
 C 

544
00:37:57,150 --> 00:37:59,220


545
00:37:59,220 --> 00:38:08,998


546
00:38:08,998 --> 00:38:11,790
 Scratch 

547
00:38:11,790 --> 00:38:19,800


548
00:38:19,800 --> 00:38:27,180
 Scratch  " "

549
00:38:27,180 --> 00:38:30,270
 C 

550
00:38:30,270 --> 00:38:40,420
 C  get_string

551
00:38:40,420 --> 00:38:42,280


552
00:38:42,280 --> 00:38:44,290
--XYZ

553
00:38:44,290 --> 00:38:47,470
 " " " " ""

554
00:38:47,470 --> 00:38:48,880
 Scratch 

555
00:38:48,880 --> 00:38:53,090


556
00:38:53,090 --> 00:38:55,640


557
00:38:55,640 --> 00:39:03,590
 C --

558
00:39:03,590 --> 00:39:05,390


559
00:39:05,390 --> 00:39:14,750
 get_string  "/ "

560
00:39:14,750 --> 00:39:17,960
 C 

561
00:39:17,960 --> 00:39:21,520


562
00:39:21,520 --> 00:39:27,340


563
00:39:27,340 --> 00:39:28,450


564
00:39:28,450 --> 00:39:29,700


565
00:39:29,700 --> 00:39:34,570


566
00:39:34,570 --> 00:39:37,040
 C 

567
00:39:37,040 --> 00:39:43,330
 Python 

568
00:39:43,330 --> 00:39:48,670
 C 

569
00:39:48,670 --> 00:39:55,270


570
00:39:55,270 --> 00:39:59,270
 --

571
00:39:59,270 --> 00:40:04,250
 C

572
00:40:04,250 --> 00:40:06,267


573
00:40:06,267 --> 00:40:07,600


574
00:40:07,600 --> 00:40:12,760


575
00:40:12,760 --> 00:40:19,210


576
00:40:19,210 --> 00:40:20,470


578
00:40:21,070 --> 00:40:21,970


579
00:40:21,970 --> 00:40:23,178
-J-

580
00:40:23,178 --> 00:40:24,230


581
00:40:24,230 --> 00:40:27,040


582
00:40:27,040 --> 00:40:31,680
 " "

583
00:40:31,680 --> 00:40:35,720


584
00:40:35,720 --> 00:40:40,250
 VS  0 

585
00:40:40,250 --> 00:40:51,370
 hello.c  include cs50.h get_string 

586
00:40:51,370 --> 00:40:56,710


587
00:40:56,710 --> 00:41:04,847
-- answer  get_stringquote/unquotewhat's your name

588
00:41:04,847 --> 00:41:07,180


589
00:41:07,180 --> 00:41:10,430


590
00:41:10,430 --> 00:41:14,260


591
00:41:14,260 --> 00:41:19,840
 hello, world  hello, comma, answer

592
00:41:19,840 --> 00:41:24,520


593
00:41:24,520 --> 00:41:26,980


594
00:41:26,980 --> 00:41:27,970


595
00:41:27,970 --> 00:41:29,120


596
00:41:29,120 --> 00:41:30,140


597
00:41:30,140 --> 00:41:34,000
 ./hello

598
00:41:34,000 --> 00:41:35,650
 

599
00:41:35,650 --> 00:41:43,600


600
00:41:43,600 --> 00:41:44,530


601
00:41:44,530 --> 00:41:48,340


602
00:41:48,340 --> 00:41:51,240


603
00:41:51,240 --> 00:41:52,240


604
00:41:52,240 --> 00:41:53,115


605
00:41:53,115 --> 00:41:54,280


607
00:41:54,730 --> 00:41:56,855


608
00:41:56,855 --> 00:41:59,020
 ""

609
00:41:59,020 --> 00:42:03,260


610
00:42:03,260 --> 00:42:08,530


611
00:42:08,530 --> 00:42:14,140
 say 

612
00:42:14,140 --> 00:42:15,670


613
00:42:15,670 --> 00:42:22,900
 C 

614
00:42:22,900 --> 00:42:27,610


615
00:42:27,610 --> 00:42:32,350
 Scratch 

616
00:42:32,350 --> 00:42:36,550
 say  printf 

617
00:42:36,550 --> 00:42:43,340
 Scratch  hello

618
00:42:43,340 --> 00:42:45,790
 C 

619
00:42:45,790 --> 00:42:47,830


620
00:42:47,830 --> 00:42:53,530
 printf  say 

621
00:42:53,530 --> 00:42:55,240


622
00:42:55,240 --> 00:42:58,330


623
00:42:58,330 --> 00:43:00,290


624
00:43:00,290 --> 00:43:03,430
 hello

625
00:43:03,430 --> 00:43:07,810
 C  printf

626
00:43:07,810 --> 00:43:11,350


627
00:43:11,350 --> 00:43:12,740


628
00:43:12,740 --> 00:43:23,903
 %s%s 

629
00:43:23,903 --> 00:43:25,570


630
00:43:25,570 --> 00:43:32,460


631
00:43:32,460 --> 00:43:37,870
 n

632
00:43:37,870 --> 00:43:45,120
C  hello 

633
00:43:45,120 --> 00:43:51,000
 printf

634
00:43:51,000 --> 00:43:53,820
/

635
00:43:53,820 --> 00:44:02,760
 printf  %s 

636
00:44:02,760 --> 00:44:04,410
 printf 

637
00:44:04,410 --> 00:44:10,980
 %s 

638
00:44:10,980 --> 00:44:16,470
 %s 

639
00:44:16,470 --> 00:44:22,380
 %s  %s 

640
00:44:22,380 --> 00:44:24,750


641
00:44:24,750 --> 00:44:30,302
 C 

642
00:44:30,302 --> 00:44:32,760


643
00:44:32,760 --> 00:44:35,080


645
00:44:35,580 --> 00:44:39,725
 n

646
00:44:39,725 --> 00:44:41,600
-J-

647
00:44:41,600 --> 00:44:45,550
 n 

648
00:44:45,550 --> 00:44:48,280


649
00:44:48,280 --> 00:44:49,760


650
00:44:49,760 --> 00:44:54,460
 n

651
00:44:54,460 --> 00:44:57,400


652
00:44:57,400 --> 00:45:00,460


653
00:45:00,460 --> 00:45:04,030


654
00:45:04,030 --> 00:45:06,490


655
00:45:06,490 --> 00:45:07,490


656
00:45:07,490 --> 00:45:09,670


657
00:45:09,670 --> 00:45:10,210


659
00:45:10,660 --> 00:45:12,070
 %s 

660
00:45:12,070 --> 00:45:14,470
-J-%

662
00:45:15,250 --> 00:45:17,570
 VS 

663
00:45:17,570 --> 00:45:20,050


664
00:45:20,050 --> 00:45:21,170


665
00:45:21,170 --> 00:45:26,080


666
00:45:26,080 --> 00:45:27,490


667
00:45:27,490 --> 00:45:28,880


668
00:45:28,880 --> 00:45:41,720
 last  get_string-- S --/

669
00:45:41,720 --> 00:45:47,320
 %s  %s

670
00:45:47,320 --> 00:45:52,720


671
00:45:52,720 --> 00:45:55,240


672
00:45:55,240 --> 00:46:00,280
----./

673
00:46:00,280 --> 00:46:02,620


674
00:46:02,620 --> 00:46:04,240


676
00:46:05,650 --> 00:46:06,670
-

677
00:46:06,670 --> 00:46:08,440


678
00:46:08,440 --> 00:46:12,670
 Scratch --

679
00:46:12,670 --> 00:46:15,130


680
00:46:15,130 --> 00:46:17,800


681
00:46:17,800 --> 00:46:19,300


682
00:46:19,300 --> 00:46:21,520
 %s

683
00:46:21,520 --> 00:46:27,720
--

684
00:46:27,720 --> 00:46:29,220


685
00:46:29,220 --> 00:46:31,353
 7 

686
00:46:31,353 --> 00:46:33,270
-J-

687
00:46:33,270 --> 00:46:39,610
 0 

688
00:46:39,610 --> 00:46:42,750


689
00:46:42,750 --> 00:46:46,470


690
00:46:46,470 --> 00:46:47,950


691
00:46:47,950 --> 00:46:51,060


692
00:46:51,060 --> 00:46:56,740
./hello

693
00:46:56,740 --> 00:46:59,400
  

694
00:46:59,400 --> 00:47:02,220


697
00:47:04,608 --> 00:47:06,150
 --

698
00:47:06,150 --> 00:47:09,240
 - -  s

699
00:47:09,240 --> 00:47:23,400
 %s %s 

700
00:47:23,400 --> 00:47:30,300
 7 

701
00:47:30,300 --> 00:47:37,290
 printf 

702
00:47:37,290 --> 00:47:41,582


703
00:47:41,582 --> 00:47:45,700


704
00:47:45,700 --> 00:47:49,700


705
00:47:49,700 --> 00:47:50,700
-J-

706
00:47:50,700 --> 00:47:53,160


707
00:47:53,160 --> 00:47:55,240
 " " " "

708
00:47:55,240 --> 00:48:05,580
 VS Code 

709
00:48:05,580 --> 00:48:10,830
----

710
00:48:10,830 --> 00:48:13,150


712
00:48:13,650 --> 00:48:21,943


713
00:48:21,943 --> 00:48:23,360
-J-

714
00:48:23,360 --> 00:48:28,230


715
00:48:28,230 --> 00:48:29,980


716
00:48:29,980 --> 00:48:33,610


717
00:48:33,610 --> 00:48:35,830


718
00:48:35,830 --> 00:48:45,580
 hello./hello----helloDavid

719
00:48:45,580 --> 00:48:46,510
 printf 

720
00:48:46,510 --> 00:48:51,400
 %s 

721
00:48:51,400 --> 00:49:01,240


722
00:49:01,240 --> 00:49:11,680
 %s  printf 

723
00:49:11,680 --> 00:49:14,635


725
00:49:16,775 --> 00:49:17,650


726
00:49:17,650 --> 00:49:20,320


727
00:49:20,320 --> 00:49:23,245
 %s --  %

728
00:49:23,245 --> 00:49:29,650
printf 

729
00:49:29,650 --> 00:49:31,460


730
00:49:31,460 --> 00:49:34,690


731
00:49:34,690 --> 00:49:40,990
 100%

732
00:49:40,990 --> 00:49:43,480


733
00:49:43,480 --> 00:49:47,290
 100%

734
00:49:47,290 --> 00:49:50,860


735
00:49:50,860 --> 00:49:52,950


736
00:49:52,950 --> 00:49:57,410


737
00:49:57,410 --> 00:50:00,730


738
00:50:00,730 --> 00:50:01,615
 %

739
00:50:01,615 --> 00:50:04,990


740
00:50:04,990 --> 00:50:09,727
 make helloaha./hello 100% 

741
00:50:09,727 --> 00:50:15,190
 Google

742
00:50:15,190 --> 00:50:17,840


743
00:50:17,840 --> 00:50:19,930


745
00:50:21,230 --> 00:50:22,360


746
00:50:22,360 --> 00:50:23,060


748
00:50:23,560 --> 00:50:27,622
[]

749
00:50:27,622 --> 00:50:31,380
DAVID J. MALAN

750
00:50:31,380 --> 00:50:35,520
printf 

751
00:50:35,520 --> 00:50:41,207
 % 

752
00:50:41,207 --> 00:50:44,832


753
00:50:44,832 --> 00:50:47,130


755
00:50:48,220 --> 00:50:50,760


756
00:50:50,760 --> 00:50:52,453
%s 

757
00:50:52,453 --> 00:50:54,120
-J-

758
00:50:54,120 --> 00:50:59,070


759
00:50:59,070 --> 00:51:04,560
 printf --  printf  %s 

761
00:51:04,890 --> 00:51:05,490


762
00:51:05,490 --> 00:51:06,900


763
00:51:06,900 --> 00:51:10,110
 %s

764
00:51:10,110 --> 00:51:12,420
 %%

765
00:51:12,420 --> 00:51:24,960
 printf %s

766
00:51:24,960 --> 00:51:28,390


768
00:51:28,890 --> 00:51:30,870


769
00:51:30,870 --> 00:51:38,070
-J- D M  D J M

770
00:51:38,070 --> 00:51:44,310
 C 

771
00:51:44,310 --> 00:51:48,135
 C 

772
00:51:48,135 --> 00:51:52,560


773
00:51:52,560 --> 00:51:55,620


774
00:51:55,620 --> 00:51:58,860


775
00:51:58,860 --> 00:52:01,020


776
00:52:01,020 --> 00:52:05,868
printf 

777
00:52:05,868 --> 00:52:13,920
 CS50 

778
00:52:13,920 --> 00:52:17,722
 get_charget_int  get_string

779
00:52:17,722 --> 00:52:23,490
 ""

780
00:52:23,490 --> 00:52:26,070
 get_string

781
00:52:26,070 --> 00:52:29,880
 get_int

782
00:52:29,880 --> 00:52:38,400
---- C 

783
00:52:38,400 --> 00:52:48,420
 int

784
00:52:48,420 --> 00:52:51,030


785
00:52:51,030 --> 00:52:54,300


786
00:52:54,300 --> 00:52:54,988


787
00:52:54,988 --> 00:52:57,030


788
00:52:57,030 --> 00:52:57,680


789
00:52:57,680 --> 00:53:00,180


790
00:53:00,180 --> 00:53:02,097


791
00:53:05,640 --> 00:53:07,295


792
00:53:07,295 --> 00:53:11,587


793
00:53:11,587 --> 00:53:18,020


794
00:53:18,020 --> 00:53:25,730


795
00:53:25,730 --> 00:53:28,880


796
00:53:28,880 --> 00:53:31,460
 Scratch 

797
00:53:31,460 --> 00:53:43,370
 C  get_string  printf

798
00:53:43,370 --> 00:53:47,100


799
00:53:47,100 --> 00:53:50,780
 Scratch 

800
00:53:50,780 --> 00:53:56,360
 Scratch  x  y 

801
00:53:56,360 --> 00:54:01,020
 x  y x  y

802
00:54:01,020 --> 00:54:03,320
 C 

803
00:54:03,320 --> 00:54:09,530
 C  x  y --

804
00:54:09,530 --> 00:54:13,140


805
00:54:13,140 --> 00:54:20,390
 x  y 

806
00:54:20,390 --> 00:54:27,680
 "/""/ "

807
00:54:27,680 --> 00:54:29,310


808
00:54:29,310 --> 00:54:38,660
 printf  get_string 

809
00:54:38,660 --> 00:54:44,690
 if  if 

810
00:54:44,690 --> 00:54:49,070
 printf  get_string 

811
00:54:49,070 --> 00:54:55,970
-- " "

812
00:54:55,970 --> 00:55:02,360


813
00:55:02,360 --> 00:55:12,740
 C  x  y  x  y----

814
00:55:12,740 --> 00:55:14,820


815
00:55:14,820 --> 00:55:25,050
 "if "

816
00:55:25,050 --> 00:55:27,050
C 

817
00:55:27,050 --> 00:55:31,760


818
00:55:31,760 --> 00:55:41,430
 if 

819
00:55:41,430 --> 00:55:43,670


820
00:55:43,670 --> 00:55:46,040


821
00:55:46,040 --> 00:55:52,700
 Scratch --

822
00:55:52,700 --> 00:55:56,480
 x  y x  y

823
00:55:56,480 --> 00:56:01,190
x  y

824
00:56:01,190 --> 00:56:03,710


825
00:56:03,710 --> 00:56:14,690
 C  else MIT  Scratch  open  close

826
00:56:14,690 --> 00:56:17,150


827
00:56:17,150 --> 00:56:22,905
 x  y x  y

828
00:56:22,905 --> 00:56:25,280


829
00:56:25,280 --> 00:56:29,370
 Scratch 

830
00:56:29,370 --> 00:56:36,110
 Scratch  if x  y x  y

831
00:56:36,110 --> 00:56:40,760
 x  y x  y

832
00:56:40,760 --> 00:56:45,470
 x  y x  y

833
00:56:45,470 --> 00:56:48,770


834
00:56:48,770 --> 00:56:54,435
 C 

835
00:56:54,435 --> 00:56:55,310


836
00:56:55,310 --> 00:56:57,770
DAVID J. MALAN

837
00:56:57,770 --> 00:57:06,360
 Scratch  Scratch 

838
00:57:06,360 --> 00:57:09,050
 C 

839
00:57:09,050 --> 00:57:11,750
 C 

840
00:57:11,750 --> 00:57:14,210
 Scratch 

841
00:57:14,210 --> 00:57:20,780
 C 

842
00:57:20,780 --> 00:57:29,100
%%

843
00:57:29,100 --> 00:57:36,620
 "" "" ""

844
00:57:36,620 --> 00:57:47,090
 C ----

845
00:57:47,090 --> 00:57:53,640
 Scratch  C 

846
00:57:53,640 --> 00:57:58,400


847
00:57:58,400 --> 00:58:04,280
Scratch  C 

848
00:58:04,280 --> 00:58:06,200


849
00:58:06,200 --> 00:58:07,576


850
00:58:07,576 --> 00:58:12,930
[INNAUDIBLE]

851
00:58:12,930 --> 00:58:13,930
-J-

852
00:58:13,930 --> 00:58:22,510
 x  y x  y y

853
00:58:22,510 --> 00:58:26,170


854
00:58:26,170 --> 00:58:31,510


855
00:58:31,510 --> 00:58:33,220


856
00:58:33,220 --> 00:58:37,120
 x  y 

857
00:58:37,120 --> 00:58:38,350


858
00:58:38,350 --> 00:58:47,110
 Scratch  else  C  else ""

859
00:58:47,110 --> 00:58:52,400


860
00:58:52,400 --> 00:58:56,770


861
00:58:56,770 --> 00:58:59,030


862
00:58:59,030 --> 00:59:00,610
 VS 

863
00:59:00,610 --> 00:59:05,020
 hello.c

864
00:59:05,020 --> 00:59:11,440


865
00:59:11,440 --> 00:59:13,565
 compare.c

866
00:59:13,565 --> 00:59:17,740


867
00:59:17,740 --> 00:59:25,180
 Mac  PC 

868
00:59:25,180 --> 00:59:30,010


869
00:59:30,010 --> 00:59:34,120
 compare.c

870
00:59:34,120 --> 00:59:37,930


871
00:59:37,930 --> 00:59:42,820
GUI

872
00:59:42,820 --> 00:59:47,260


873
00:59:47,260 --> 00:59:58,930
--compare.c.

874
00:59:58,930 --> 01:00:00,340
 VS 

875
01:00:00,340 --> 01:00:02,140


876
01:00:02,140 --> 01:00:05,888


877
01:00:05,888 --> 01:00:08,930


878
01:00:08,930 --> 01:00:10,222


879
01:00:10,222 --> 01:00:15,340


880
01:00:15,340 --> 01:00:17,170


881
01:00:17,170 --> 01:00:23,260
 CS50 --cs50.h

882
01:00:23,260 --> 01:00:25,804
 stdio.h

884
01:00:26,668 --> 01:00:31,190
 get_stringget_int 

885
01:00:31,190 --> 01:00:35,560
 stdio.h  printf 

886
01:00:35,560 --> 01:00:40,310


887
01:00:40,310 --> 01:00:44,920
 Scratch 

888
01:00:44,920 --> 01:00:46,460


889
01:00:46,460 --> 01:00:51,713
_intX 

890
01:00:51,713 --> 01:00:53,380


891
01:00:53,380 --> 01:00:56,410


892
01:00:56,410 --> 01:00:59,710
 int 

893
01:00:59,710 --> 01:01:01,580


894
01:01:01,580 --> 01:01:06,040
 get_int 

895
01:01:06,040 --> 01:01:07,927


896
01:01:07,927 --> 01:01:09,760


897
01:01:09,760 --> 01:01:12,790


898
01:01:12,790 --> 01:01:14,410
 x

899
01:01:14,410 --> 01:01:19,870


900
01:01:19,870 --> 01:01:21,130


901
01:01:21,130 --> 01:01:22,410


902
01:01:22,410 --> 01:01:24,535
-J-

903
01:01:24,535 --> 01:01:26,010
int

904
01:01:26,010 --> 01:01:27,885
-J- int

905
01:01:27,885 --> 01:01:32,840


906
01:01:32,840 --> 01:01:35,750


907
01:01:35,750 --> 01:01:41,240
 Python 

908
01:01:41,240 --> 01:01:44,115
 int

909
01:01:44,115 --> 01:01:45,800


910
01:01:45,800 --> 01:01:50,990
 Python 

911
01:01:50,990 --> 01:01:54,530


912
01:01:54,530 --> 01:01:57,380


913
01:01:57,380 --> 01:01:58,440


914
01:01:58,440 --> 01:02:02,390
"Y "

915
01:02:02,390 --> 01:02:06,680


916
01:02:06,680 --> 01:02:18,950
 x  y/x  y  n

917
01:02:18,950 --> 01:02:20,600


918
01:02:20,600 --> 01:02:23,240


919
01:02:23,240 --> 01:02:25,610
 VS Code 

920
01:02:25,610 --> 01:02:29,720
 if

921
01:02:29,720 --> 01:02:33,630


922
01:02:33,630 --> 01:02:36,410


923
01:02:36,410 --> 01:02:37,980


925
01:02:38,480 --> 01:02:42,660


926
01:02:42,660 --> 01:02:45,750


927
01:02:45,750 --> 01:02:49,550
 VS Code 

928
01:02:49,550 --> 01:02:57,050
 printf x  y  n 

929
01:02:57,050 --> 01:03:02,000
--

930
01:03:02,000 --> 01:03:09,050
 make --  hello --  make compare compare.c Enter

931
01:03:09,050 --> 01:03:12,320


932
01:03:12,320 --> 01:03:16,580
 ./compare  ./hello

934
01:03:17,390 --> 01:03:18,410
1 

936
01:03:19,040 --> 01:03:19,840


937
01:03:19,840 --> 01:03:22,230
X  y

938
01:03:22,230 --> 01:03:23,387


939
01:03:23,387 --> 01:03:25,220


940
01:03:25,220 --> 01:03:26,360


941
01:03:26,360 --> 01:03:35,310
 VS  ./this  ./that

942
01:03:35,310 --> 01:03:37,940
 " "

943
01:03:37,940 --> 01:03:41,480


944
01:03:41,480 --> 01:03:46,550


945
01:03:46,550 --> 01:03:51,380
 ./compare

946
01:03:51,380 --> 01:03:52,670


947
01:03:52,670 --> 01:03:55,100
2  x1  y

948
01:03:55,100 --> 01:03:56,870


949
01:03:56,870 --> 01:04:00,170


950
01:04:00,170 --> 01:04:00,980


951
01:04:00,980 --> 01:04:12,350
Else --  VS Code  -- printf, quote/unquote, x is not less than y  n 

952
01:04:12,350 --> 01:04:16,430
-- ./compare

953
01:04:16,430 --> 01:04:19,100
2  x1  y

954
01:04:19,100 --> 01:04:22,990


955
01:04:22,990 --> 01:04:24,830


956
01:04:24,830 --> 01:04:27,050


958
01:04:27,550 --> 01:04:29,592


959
01:04:29,592 --> 01:04:30,690


960
01:04:30,690 --> 01:04:31,290
-J-

961
01:04:31,290 --> 01:04:34,415


962
01:04:34,415 --> 01:04:39,000
 0  1 

963
01:04:39,000 --> 01:04:41,040
 - -

964
01:04:41,040 --> 01:04:42,030


965
01:04:42,030 --> 01:04:45,420
./compare, 2, 1.

966
01:04:45,420 --> 01:04:47,320


967
01:04:47,320 --> 01:04:49,230
 x  y

968
01:04:49,230 --> 01:04:52,390


969
01:04:52,390 --> 01:04:55,650


970
01:04:55,650 --> 01:04:57,270


971
01:04:57,270 --> 01:05:03,780
 x  yx  y

972
01:05:03,780 --> 01:05:07,950
 x  y x else

973
01:05:07,950 --> 01:05:11,080


974
01:05:11,080 --> 01:05:12,810
 " "

975
01:05:12,810 --> 01:05:19,960
/x  y  n

976
01:05:19,960 --> 01:05:24,070


977
01:05:24,070 --> 01:05:28,680
 - make compare, ./compare.

978
01:05:28,680 --> 01:05:32,340
 1  2  y

979
01:05:32,340 --> 01:05:33,510


980
01:05:33,510 --> 01:05:36,690
2  1 -- x  y

981
01:05:36,690 --> 01:05:41,100
1  1x  y

982
01:05:41,100 --> 01:05:43,270


983
01:05:43,270 --> 01:05:47,700
 21 

984
01:05:47,700 --> 01:05:49,410


985
01:05:49,410 --> 01:06:01,810
 get_int  CS50  printf  stdio.h

986
01:06:01,810 --> 01:06:08,237
 C 

987
01:06:08,237 --> 01:06:08,820


989
01:06:09,320 --> 01:06:14,530
--

990
01:06:14,530 --> 01:06:15,190
-J-

991
01:06:15,190 --> 01:06:17,440


992
01:06:17,440 --> 01:06:18,610
 CS50 

993
01:06:18,610 --> 01:06:25,540


994
01:06:25,540 --> 01:06:29,290


995
01:06:29,290 --> 01:06:35,080


996
01:06:35,080 --> 01:06:38,410


997
01:06:38,410 --> 01:06:48,430
 Scratch 

998
01:06:48,430 --> 01:06:51,370


999
01:06:51,370 --> 01:06:59,420


1000
01:06:59,420 --> 01:07:03,670


1001
01:07:03,670 --> 01:07:05,030


1002
01:07:05,030 --> 01:07:07,900
 JavaScript 

1003
01:07:07,900 --> 01:07:16,210
/

1004
01:07:16,210 --> 01:07:21,140


1005
01:07:21,140 --> 01:07:28,360
 " " "" " " ""

1006
01:07:28,360 --> 01:07:30,280
Y ""N ""

1007
01:07:30,280 --> 01:07:33,195


1008
01:07:33,195 --> 01:07:34,070


1009
01:07:34,070 --> 01:07:37,810
 agree.c

1010
01:07:37,810 --> 01:07:41,230
 agree.c

1011
01:07:41,230 --> 01:07:44,230
 cs50.h 

1012
01:07:44,230 --> 01:07:46,480
 stdio.h

1013
01:07:46,480 --> 01:07:53,200
 int main(void)--/

1014
01:07:53,200 --> 01:08:00,520
 Y  N Yes  No

1015
01:08:00,520 --> 01:08:03,800


1016
01:08:03,800 --> 01:08:09,760
 get_char 

1017
01:08:09,760 --> 01:08:12,880


1018
01:08:12,880 --> 01:08:15,130


1019
01:08:15,130 --> 01:08:16,180
 int

1020
01:08:16,180 --> 01:08:17,380
 char

1021
01:08:17,380 --> 01:08:21,500
 C -H -A

1022
01:08:21,500 --> 01:08:27,040
 char  c

1023
01:08:27,040 --> 01:08:28,569
 int i

1024
01:08:28,569 --> 01:08:29,830
 s

1025
01:08:29,830 --> 01:08:32,590
 c

1026
01:08:32,590 --> 01:08:34,370


1027
01:08:34,370 --> 01:08:50,380
 c / y  n

1028
01:08:50,380 --> 01:08:51,880


1029
01:08:51,880 --> 01:09:03,609
/n/

1030
01:09:03,609 --> 01:09:07,060


1031
01:09:07,060 --> 01:09:11,830


1032
01:09:11,830 --> 01:09:15,760


1033
01:09:15,760 --> 01:09:19,720


1034
01:09:19,720 --> 01:09:20,380


1035
01:09:20,380 --> 01:09:22,625


1036
01:09:22,625 --> 01:09:23,500


1037
01:09:23,500 --> 01:09:30,590


1038
01:09:30,590 --> 01:09:41,380
 C 

1039
01:09:41,380 --> 01:09:42,399


1040
01:09:42,399 --> 01:09:49,819
 y  n

1042
01:09:50,319 --> 01:09:54,550


1043
01:09:54,550 --> 01:09:55,930


1044
01:09:55,930 --> 01:09:57,520


1045
01:09:57,520 --> 01:10:00,550


1046
01:10:00,550 --> 01:10:04,780
 make agree

1047
01:10:04,780 --> 01:10:08,770
 ./agree 

1048
01:10:08,770 --> 01:10:12,250
 y

1049
01:10:12,250 --> 01:10:13,090


1052
01:10:16,540 --> 01:10:17,470


1053
01:10:17,470 --> 01:10:18,580
 ./

1054
01:10:18,580 --> 01:10:20,170


1056
01:10:22,480 --> 01:10:25,720


1057
01:10:25,720 --> 01:10:28,480
YN

1058
01:10:28,480 --> 01:10:32,230
-J-

1060
01:10:32,730 --> 01:10:37,540


1061
01:10:37,540 --> 01:10:42,770


1062
01:10:42,770 --> 01:10:45,310


1063
01:10:45,310 --> 01:10:47,200


1064
01:10:47,200 --> 01:10:52,030
 ""

1065
01:10:52,030 --> 01:10:55,210
" " "n"

1066
01:10:55,210 --> 01:10:55,990


1067
01:10:55,990 --> 01:10:57,910


1068
01:10:57,910 --> 01:10:59,180


1069
01:10:59,180 --> 01:11:01,400


1070
01:11:01,400 --> 01:11:10,720
 c / Y printf agreed  n

1071
01:11:10,720 --> 01:11:20,980
 c  N

1072
01:11:20,980 --> 01:11:23,770


1073
01:11:23,770 --> 01:11:26,980
./

1074
01:11:26,980 --> 01:11:28,210


1075
01:11:28,210 --> 01:11:29,170


1076
01:11:29,170 --> 01:11:30,610


1077
01:11:30,610 --> 01:11:32,200


1078
01:11:32,200 --> 01:11:34,510


1079
01:11:34,510 --> 01:11:39,220


1080
01:11:39,220 --> 01:11:43,195


1081
01:11:46,250 --> 01:11:51,170
[SNIFFS]

1082
01:11:51,170 --> 01:11:52,450


1083
01:11:52,450 --> 01:11:54,100


1084
01:11:54,100 --> 01:11:55,930


1086
01:11:56,620 --> 01:11:57,894


1088
01:12:06,895 --> 01:12:07,770


1089
01:12:07,770 --> 01:12:09,370


1090
01:12:09,370 --> 01:12:10,530


1091
01:12:10,530 --> 01:12:17,080


1092
01:12:17,080 --> 01:12:26,875
 10  14  18  22  if  else if 

1093
01:12:26,875 --> 01:12:28,500
[

1094
01:12:28,500 --> 01:12:29,370


1096
01:12:29,820 --> 01:12:32,778
 Scratch 

1097
01:12:32,778 --> 01:12:37,120
/

1098
01:12:37,120 --> 01:12:42,760
 " " " "

1099
01:12:42,760 --> 01:12:44,170


1100
01:12:44,170 --> 01:12:47,160


1101
01:12:47,160 --> 01:12:49,470
 ""

1102
01:12:49,470 --> 01:12:54,325


1103
01:12:54,325 --> 01:13:02,350
 Scratch  " " " "

1104
01:13:02,350 --> 01:13:06,600


1105
01:13:06,600 --> 01:13:09,270
 C  ""

1106
01:13:09,270 --> 01:13:12,850


1107
01:13:12,850 --> 01:13:16,260


1108
01:13:16,260 --> 01:13:21,780
C / Y

1109
01:13:21,780 --> 01:13:24,270


1110
01:13:24,270 --> 01:13:32,340
 c / N

1111
01:13:32,340 --> 01:13:36,870


1112
01:13:36,870 --> 01:13:38,140


1113
01:13:38,140 --> 01:13:49,860
 make of agree./agree Y  Y

1114
01:13:49,860 --> 01:13:56,407
N.

1115
01:13:56,407 --> 01:13:57,990


1117
01:13:58,942 --> 01:14:01,615


1118
01:14:01,615 --> 01:14:03,240
-J-

1119
01:14:03,240 --> 01:14:06,030


1120
01:14:06,030 --> 01:14:07,890


1121
01:14:07,890 --> 01:14:10,950


1122
01:14:10,950 --> 01:14:19,890


1123
01:14:19,890 --> 01:14:23,372
 C 

1124
01:14:23,372 --> 01:14:26,080


1125
01:14:26,080 --> 01:14:29,490


1126
01:14:29,490 --> 01:14:30,570


1127
01:14:30,570 --> 01:14:33,874


1128
01:14:33,874 --> 01:14:37,618


1129
01:14:37,618 --> 01:14:39,160
-J-

1130
01:14:39,160 --> 01:14:45,360


1131
01:14:45,360 --> 01:14:50,040
 123

1132
01:14:50,040 --> 01:14:53,520


1133
01:14:53,520 --> 01:15:01,330
 "" """ "

1135
01:15:01,830 --> 01:15:05,850
 sure 

1136
01:15:05,850 --> 01:15:07,320


1137
01:15:07,320 --> 01:15:11,380
 x y  n

1138
01:15:11,380 --> 01:15:14,190


1139
01:15:14,190 --> 01:15:19,210
CS50 

1140
01:15:19,210 --> 01:15:26,940
 get_int 1  2 catC-A-T

1141
01:15:26,940 --> 01:15:34,068
 C 

1142
01:15:34,068 --> 01:15:38,190


1143
01:15:38,190 --> 01:15:40,500


1144
01:15:40,500 --> 01:15:44,970


1145
01:15:44,970 --> 01:15:46,750


1146
01:15:46,750 --> 01:15:54,567
 Scratch  meow  meow.c

1147
01:15:54,567 --> 01:15:56,650


1148
01:15:56,650 --> 01:15:57,750


1149
01:15:57,750 --> 01:16:03,000


1150
01:16:03,000 --> 01:16:04,960


1151
01:16:04,960 --> 01:16:06,960
 stdio.h

1152
01:16:06,960 --> 01:16:09,940
 int main(void)

1153
01:16:09,940 --> 01:16:13,710
 printf meow backslash n

1154
01:16:13,710 --> 01:16:16,650


1155
01:16:16,650 --> 01:16:18,870
 " "

1156
01:16:18,870 --> 01:16:22,350


1157
01:16:22,350 --> 01:16:26,460


1158
01:16:26,460 --> 01:16:30,133
VS Code 

1159
01:16:30,133 --> 01:16:32,550


1160
01:16:32,550 --> 01:16:34,020
 Tab 

1161
01:16:34,020 --> 01:16:41,933
 C --

1162
01:16:41,933 --> 01:16:45,850


1163
01:16:45,850 --> 01:16:49,600


1164
01:16:49,600 --> 01:16:52,560
----

1165
01:16:52,560 --> 01:16:54,000


1167
01:16:54,540 --> 01:16:55,500


1168
01:16:55,500 --> 01:16:57,060


1169
01:16:57,060 --> 01:16:58,935
 Scratch 

1171
01:17:00,480 --> 01:17:03,130


1173
01:17:03,630 --> 01:17:04,120


1174
01:17:04,120 --> 01:17:05,412


1175
01:17:05,412 --> 01:17:07,140


1176
01:17:07,140 --> 01:17:09,310


1178
01:17:09,810 --> 01:17:18,390
 " "

1179
01:17:18,390 --> 01:17:20,160


1180
01:17:20,160 --> 01:17:23,020


1181
01:17:23,020 --> 01:17:24,880


1182
01:17:24,880 --> 01:17:27,120


1183
01:17:27,120 --> 01:17:32,710
 Scratch 

1184
01:17:32,710 --> 01:17:38,520
--xyz--

1185
01:17:38,520 --> 01:17:42,630
Scratch 

1186
01:17:42,630 --> 01:17:46,890
 xy  z

1187
01:17:46,890 --> 01:17:51,840


1188
01:17:51,840 --> 01:17:57,570
 C 

1189
01:17:57,570 --> 01:18:01,740


1190
01:18:01,740 --> 01:18:05,470


1192
01:18:05,970 --> 01:18:09,570


1193
01:18:09,570 --> 01:18:10,740


1194
01:18:10,740 --> 01:18:12,282


1195
01:18:12,282 --> 01:18:16,170


1196
01:18:16,170 --> 01:18:16,767
 Int.

1197
01:18:16,767 --> 01:18:20,610
 int  int

1198
01:18:20,610 --> 01:18:23,802


1199
01:18:23,802 --> 01:18:25,260


1200
01:18:25,260 --> 01:18:28,660
 Scratch 

1201
01:18:28,660 --> 01:18:30,810


1202
01:18:30,810 --> 01:18:33,480
 1

1203
01:18:33,480 --> 01:18:37,480
Scratch  change

1204
01:18:37,480 --> 01:18:43,930
 counter 

1205
01:18:43,930 --> 01:18:48,690


1206
01:18:48,690 --> 01:18:51,990
 1

1207
01:18:51,990 --> 01:18:53,160


1208
01:18:53,160 --> 01:18:56,860


1209
01:18:56,860 --> 01:19:03,930
 1

1210
01:19:03,930 --> 01:19:13,330
 int

1211
01:19:13,330 --> 01:19:23,370
 C stringint --

1212
01:19:23,370 --> 01:19:25,780


1213
01:19:25,780 --> 01:19:27,060


1214
01:19:27,060 --> 01:19:29,950


1215
01:19:29,950 --> 01:19:32,100


1216
01:19:32,100 --> 01:19:37,740


1217
01:19:37,740 --> 01:19:40,710


1218
01:19:40,710 --> 01:19:43,290
 ""

1219
01:19:43,290 --> 01:19:49,900


1220
01:19:49,900 --> 01:19:57,765
 CS50 

1221
01:19:57,765 --> 01:19:59,340


1222
01:19:59,340 --> 01:20:06,480


1223
01:20:06,480 --> 01:20:10,420


1224
01:20:10,420 --> 01:20:12,900
 1 

1225
01:20:12,900 --> 01:20:13,800
 1

1226
01:20:13,800 --> 01:20:14,800


1227
01:20:14,800 --> 01:20:20,550
 1counter++

1228
01:20:20,550 --> 01:20:26,472
 C  ++ 1

1229
01:20:26,472 --> 01:20:28,680


1230
01:20:28,680 --> 01:20:38,490
 1--

1231
01:20:38,490 --> 01:20:42,520
 C 

1232
01:20:42,520 --> 01:20:47,500


1233
01:20:47,500 --> 01:20:49,320
 Scratch 

1234
01:20:49,320 --> 01:20:52,680


1235
01:20:52,680 --> 01:20:54,480
 C 

1236
01:20:54,480 --> 01:21:03,520


1237
01:21:03,520 --> 01:21:12,330
 C 

1238
01:21:12,330 --> 01:21:18,990
 123456 

1239
01:21:18,990 --> 01:21:20,740


1240
01:21:20,740 --> 01:21:21,960


1241
01:21:21,960 --> 01:21:24,120


1242
01:21:24,120 --> 01:21:28,710
 counter  3

1244
01:21:29,370 --> 01:21:32,800
" " " "

1245
01:21:32,800 --> 01:21:41,080


1246
01:21:41,080 --> 01:21:44,910
 counter  3

1247
01:21:44,910 --> 01:21:52,440
 C  3 

1248
01:21:52,440 --> 01:21:59,200
 0 

1249
01:21:59,200 --> 01:22:04,080


1250
01:22:04,080 --> 01:22:06,990


1251
01:22:06,990 --> 01:22:12,120
 3 1  2

1252
01:22:12,120 --> 01:22:13,320


1253
01:22:13,320 --> 01:22:21,010
 Scratch 

1254
01:22:21,010 --> 01:22:28,870
C 

1255
01:22:28,870 --> 01:22:33,690
 3

1256
01:22:33,690 --> 01:22:35,100
 2.

1257
01:22:35,100 --> 01:22:43,480
 i  int c  char s  string

1258
01:22:43,480 --> 01:22:44,730


1259
01:22:44,730 --> 01:22:47,220


1260
01:22:47,220 --> 01:22:50,320


1261
01:22:50,320 --> 01:22:54,653


1262
01:22:54,653 --> 01:22:56,320


1263
01:22:56,320 --> 01:22:59,550
i  3

1264
01:22:59,550 --> 01:23:00,900


1265
01:23:00,900 --> 01:23:03,840
 i  0 i  0

1266
01:23:03,840 --> 01:23:05,580


1267
01:23:05,580 --> 01:23:07,590


1268
01:23:07,590 --> 01:23:13,110
 i  1 i  2

1269
01:23:13,110 --> 01:23:15,330


1270
01:23:15,330 --> 01:23:17,580


1271
01:23:17,580 --> 01:23:19,420


1272
01:23:19,420 --> 01:23:23,340


1273
01:23:23,340 --> 01:23:24,990


1274
01:23:24,990 --> 01:23:31,330


1275
01:23:31,330 --> 01:23:40,450
 1 0

1276
01:23:40,450 --> 01:23:51,570
---- 3

1277
01:23:51,570 --> 01:23:56,653
--

1278
01:23:56,653 --> 01:23:57,400


1279
01:23:57,400 --> 01:24:00,180
 1

1280
01:24:00,180 --> 01:24:01,830


1282
01:24:02,460 --> 01:24:04,845
 

1283
01:24:04,845 --> 01:24:07,470
[

1286
01:24:08,580 --> 01:24:10,350


1289
01:24:11,570 --> 01:24:17,037
------------

1290
01:24:17,037 --> 01:24:18,370


1291
01:24:18,370 --> 01:24:19,620


1292
01:24:19,620 --> 01:24:20,143


1293
01:24:20,143 --> 01:24:21,060


1294
01:24:21,060 --> 01:24:22,740


1295
01:24:22,740 --> 01:24:24,880


1296
01:24:24,880 --> 01:24:28,380


1297
01:24:28,380 --> 01:24:29,475


1298
01:24:29,475 --> 01:24:32,100


1299
01:24:32,100 --> 01:24:35,860


1300
01:24:35,860 --> 01:24:39,840


1301
01:24:39,840 --> 01:24:44,610


1302
01:24:44,610 --> 01:24:46,570


1303
01:24:46,570 --> 01:24:50,350
i  0

1304
01:24:50,350 --> 01:24:55,210


1305
01:24:55,210 --> 01:24:58,080


1306
01:24:58,080 --> 01:24:59,820


1307
01:24:59,820 --> 01:25:03,240


1308
01:25:03,240 --> 01:25:09,422


1309
01:25:09,422 --> 01:25:11,380


1310
01:25:11,380 --> 01:25:16,410


1311
01:25:16,410 --> 01:25:19,890


1312
01:25:19,890 --> 01:25:23,820
 i  1

1313
01:25:23,820 --> 01:25:28,290
i  3

1314
01:25:28,290 --> 01:25:30,210


1315
01:25:30,210 --> 01:25:37,870
 1 

1316
01:25:37,870 --> 01:25:45,360
 C 

1317
01:25:45,360 --> 01:25:47,370


1318
01:25:47,370 --> 01:25:50,580


1319
01:25:50,580 --> 01:25:55,830
 i  1 2 3

1320
01:25:55,830 --> 01:26:00,340
 123 

1321
01:26:00,340 --> 01:26:01,530


1322
01:26:01,530 --> 01:26:03,810


1323
01:26:03,810 --> 01:26:11,640
 i  0i  3

1324
01:26:11,640 --> 01:26:14,940


1325
01:26:14,940 --> 01:26:18,420
 1  3 

1326
01:26:18,420 --> 01:26:23,740
 3  0

1327
01:26:23,740 --> 01:26:35,610
 0  0 

1328
01:26:35,610 --> 01:26:40,043
 3 

1329
01:26:40,043 --> 01:26:42,960


1330
01:26:42,960 --> 01:26:44,340


1331
01:26:44,340 --> 01:26:47,780
   ?

1332
01:26:47,780 --> 01:26:51,150
 0  123

1333
01:26:51,150 --> 01:26:53,220
 3 --  --

1334
01:26:53,220 --> 01:26:55,420
3 

1335
01:26:55,420 --> 01:26:58,650
 " "

1336
01:26:58,650 --> 01:27:02,490


1337
01:27:02,490 --> 01:27:07,210


1338
01:27:07,210 --> 01:27:11,590


1339
01:27:11,590 --> 01:27:13,390


1340
01:27:13,390 --> 01:27:21,000
 printfs

1341
01:27:21,000 --> 01:27:22,750


1342
01:27:22,750 --> 01:27:36,930
 int i  0 i  3  printf quote/unquote meow-- melow-- meow backslash n

1343
01:27:36,930 --> 01:27:41,310
 i  minus  plus plus

1344
01:27:41,310 --> 01:27:42,237
Plus plus.

1345
01:27:42,237 --> 01:27:47,120
-J- 0  3

1346
01:27:47,120 --> 01:27:52,970
./meow

1347
01:27:52,970 --> 01:27:56,730


1349
01:27:57,230 --> 01:28:00,770
 3  30 

1350
01:28:00,770 --> 01:28:01,850


1351
01:28:01,850 --> 01:28:03,770


1352
01:28:03,770 --> 01:28:06,020
 ./meow 

1353
01:28:06,020 --> 01:28:09,450
 27 

1354
01:28:09,450 --> 01:28:13,400


1355
01:28:13,400 --> 01:28:15,920


1356
01:28:15,920 --> 01:28:20,502
 for 

1357
01:28:20,502 --> 01:28:27,500
 while 

1358
01:28:27,500 --> 01:28:34,200


1359
01:28:34,200 --> 01:28:36,830


1360
01:28:36,830 --> 01:28:42,110
"for " ""

1361
01:28:42,110 --> 01:28:46,097


1362
01:28:46,097 --> 01:28:47,930


1363
01:28:47,930 --> 01:28:54,230
--

1364
01:28:54,230 --> 01:28:58,198


1365
01:28:58,198 --> 01:28:59,990


1366
01:28:59,990 --> 01:29:04,920


1367
01:29:04,920 --> 01:29:06,080


1368
01:29:06,080 --> 01:29:07,850


1369
01:29:07,850 --> 01:29:12,320
 i  0

1370
01:29:12,320 --> 01:29:14,240


1371
01:29:14,240 --> 01:29:22,980
 3 i 

1372
01:29:22,980 --> 01:29:28,340
i  0

1373
01:29:28,340 --> 01:29:30,170


1374
01:29:30,170 --> 01:29:32,150


1375
01:29:32,150 --> 01:29:34,610


1376
01:29:34,610 --> 01:29:40,550
 i  3 0  3

1377
01:29:40,550 --> 01:29:42,350
i 

1378
01:29:42,350 --> 01:29:43,580
 0 

1379
01:29:43,580 --> 01:29:45,170
 1

1380
01:29:45,170 --> 01:29:48,150


1381
01:29:48,150 --> 01:29:50,840
 i  0

1382
01:29:50,840 --> 01:29:53,210


1383
01:29:53,210 --> 01:29:56,270


1384
01:29:56,270 --> 01:29:57,770
 i  3

1386
01:29:58,320 --> 01:29:59,600


1387
01:29:59,600 --> 01:30:00,875
 i.

1388
01:30:00,875 --> 01:30:03,410
 i 2 3

1390
01:30:03,980 --> 01:30:06,380
 ""

1391
01:30:06,380 --> 01:30:07,100


1392
01:30:07,100 --> 01:30:08,120
i  3 

1393
01:30:08,120 --> 01:30:11,360
 3  3

1394
01:30:11,360 --> 01:30:12,800


1395
01:30:12,800 --> 01:30:17,420


1396
01:30:17,420 --> 01:30:22,610
 Scratch 

1397
01:30:22,610 --> 01:30:31,520
 for 

1398
01:30:31,520 --> 01:30:34,195
 0 

1399
01:30:34,195 --> 01:30:35,570
-J-

1400
01:30:35,570 --> 01:30:37,400
 0 

1401
01:30:37,400 --> 01:30:38,275


1402
01:30:38,275 --> 01:30:40,400
 0 

1403
01:30:40,400 --> 01:30:41,690


1404
01:30:41,690 --> 01:30:43,490


1405
01:30:43,490 --> 01:30:47,660


1406
01:30:47,660 --> 01:30:48,740


1407
01:30:48,740 --> 01:30:51,660


1408
01:30:51,660 --> 01:30:55,610


1409
01:30:55,610 --> 01:30:57,818
 while 

1410
01:30:57,818 --> 01:30:59,387


1411
01:30:59,387 --> 01:31:05,240


1412
01:31:05,240 --> 01:31:06,380


1414
01:31:06,890 --> 01:31:07,620


1415
01:31:07,620 --> 01:31:08,412
-J-

1416
01:31:08,412 --> 01:31:11,210


1417
01:31:11,210 --> 01:31:12,590


1418
01:31:12,590 --> 01:31:14,898


1419
01:31:14,898 --> 01:31:16,190


1420
01:31:16,190 --> 01:31:21,350
 for int i equals 0

1421
01:31:21,350 --> 01:31:22,790


1422
01:31:22,790 --> 01:31:24,260
 ""

1423
01:31:24,260 --> 01:31:28,130
int i gets 0 -- get

1424
01:31:28,130 --> 01:31:32,360
 i  3 i++

1425
01:31:32,360 --> 01:31:37,670
 printf quote/unquote meow backslash n

1426
01:31:37,670 --> 01:31:39,450


1427
01:31:39,450 --> 01:31:41,408


1428
01:31:41,408 --> 01:31:43,580


1429
01:31:43,580 --> 01:31:47,460
./

1430
01:31:47,460 --> 01:31:51,680


1431
01:31:51,680 --> 01:31:56,330


1432
01:31:56,330 --> 01:31:58,010


1433
01:31:58,010 --> 01:32:02,750
 Scratch  ""

1434
01:32:02,750 --> 01:32:07,490
Scratch 

1435
01:32:07,490 --> 01:32:11,360


1436
01:32:11,360 --> 01:32:13,040


1437
01:32:13,040 --> 01:32:19,100


1439
01:32:19,657 --> 01:32:21,740


1440
01:32:21,740 --> 01:32:22,970


1441
01:32:22,970 --> 01:32:26,495
 Spotify 

1442
01:32:26,495 --> 01:32:28,310


1443
01:32:28,310 --> 01:32:32,548
DAVID J. MALAN Scratch 

1445
01:32:33,590 --> 01:32:36,512
Oh, checking for input.

1446
01:32:36,512 --> 01:32:37,970


1447
01:32:37,970 --> 01:32:43,300
get_string 

1448
01:32:43,300 --> 01:32:44,470


1449
01:32:44,470 --> 01:32:47,860
-J-

1450
01:32:47,860 --> 01:32:48,550


1451
01:32:48,550 --> 01:32:49,420


1452
01:32:49,420 --> 01:32:50,590


1453
01:32:50,590 --> 01:32:52,173
-J-

1454
01:32:52,173 --> 01:32:52,900


1455
01:32:52,900 --> 01:32:53,995


1456
01:32:53,995 --> 01:32:58,182
 Scratch 

1457
01:32:58,182 --> 01:33:04,520
-- C 

1458
01:33:04,520 --> 01:33:14,950
 C 

1459
01:33:14,950 --> 01:33:18,850
 " "--

1461
01:33:19,490 --> 01:33:26,020
while  "/""/ "

1462
01:33:26,020 --> 01:33:35,950
 "" "" C  "" "

1463
01:33:35,950 --> 01:33:38,800
T-R-U-E--

1464
01:33:38,800 --> 01:33:41,570


1465
01:33:41,570 --> 01:33:45,680
 ""

1466
01:33:45,680 --> 01:33:54,220
 true  false -- while 1

1467
01:33:54,220 --> 01:33:59,770
 "1 "

1468
01:33:59,770 --> 01:34:04,840
 0 

1469
01:34:04,840 --> 01:34:11,210
 1  ""

1470
01:34:11,210 --> 01:34:15,400
 while true  while 1

1471
01:34:15,400 --> 01:34:18,700


1472
01:34:18,700 --> 01:34:20,650


1473
01:34:20,650 --> 01:34:23,770


1474
01:34:23,770 --> 01:34:24,950


1475
01:34:24,950 --> 01:34:26,570


1476
01:34:26,570 --> 01:34:32,180
 for  while  true 

1477
01:34:32,180 --> 01:34:36,100
 - 

1478
01:34:36,100 --> 01:34:38,230


1479
01:34:38,230 --> 01:34:41,840
 true

1480
01:34:41,840 --> 01:34:46,360
 0  1

1481
01:34:46,360 --> 01:34:48,220
 "" ""

1482
01:34:48,220 --> 01:34:53,560
" " " "

1483
01:34:53,560 --> 01:35:03,640
 stdbool true  false 

1484
01:35:03,640 --> 01:35:06,550
CS50 

1485
01:35:06,550 --> 01:35:08,980
 CS50 

1486
01:35:08,980 --> 01:35:13,360
 make meow ./meow 

1487
01:35:13,360 --> 01:35:21,350


1488
01:35:21,350 --> 01:35:24,970


1489
01:35:24,970 --> 01:35:29,462


1490
01:35:29,462 --> 01:35:32,170


1491
01:35:32,170 --> 01:35:34,150


1493
01:35:34,420 --> 01:35:35,170


1494
01:35:35,170 --> 01:35:36,250


1495
01:35:36,250 --> 01:35:37,090


1496
01:35:37,090 --> 01:35:37,690


1497
01:35:37,690 --> 01:35:39,232


1498
01:35:39,232 --> 01:35:41,590


1499
01:35:41,590 --> 01:35:43,930


1500
01:35:43,930 --> 01:35:45,910


1501
01:35:45,910 --> 01:35:48,550
Control-C 

1502
01:35:48,550 --> 01:35:51,070


1503
01:35:51,070 --> 01:35:55,540
 Control-C 

1504
01:35:55,540 --> 01:36:02,560


1505
01:36:02,560 --> 01:36:09,545
 Control-C ----

1506
01:36:09,545 --> 01:36:11,170


1507
01:36:11,170 --> 01:36:14,330


1508
01:36:14,330 --> 01:36:23,890


1509
01:36:23,890 --> 01:36:31,630
 Linux

1510
01:36:31,630 --> 01:36:38,680
 Mac  PC macOS  Windows

1511
01:36:38,680 --> 01:36:43,330
 Linux

1512
01:36:43,330 --> 01:36:51,610
Linux 

1513
01:36:51,610 --> 01:36:56,950
 Linux

1514
01:36:56,950 --> 01:37:07,480
 macOS  Windows 

1515
01:37:07,480 --> 01:37:12,550
--Windows  macOS 

1516
01:37:12,550 --> 01:37:16,150
 Mac  PC 

1517
01:37:16,150 --> 01:37:26,500
Linux GUICLI

1518
01:37:26,500 --> 01:37:29,450


1519
01:37:29,450 --> 01:37:39,640
 VS Code

1520
01:37:39,640 --> 01:37:42,390


1521
01:37:42,390 --> 01:37:51,430


1522
01:37:51,430 --> 01:37:57,430


1523
01:37:57,430 --> 01:38:01,390


1524
01:38:01,390 --> 01:38:06,400
 Mac  PC 

1525
01:38:06,400 --> 01:38:15,830


1526
01:38:15,830 --> 01:38:19,390


1527
01:38:19,390 --> 01:38:21,292


1528
01:38:21,292 --> 01:38:24,710


1529
01:38:24,710 --> 01:38:26,260


1530
01:38:26,260 --> 01:38:33,640


1531
01:38:33,640 --> 01:38:35,890


1532
01:38:35,890 --> 01:38:44,480
 ls l  s

1533
01:38:44,480 --> 01:38:47,380


1534
01:38:47,380 --> 01:38:56,110
 code  make VS  ls 

1535
01:38:56,110 --> 01:39:02,000


1536
01:39:02,000 --> 01:39:05,780


1537
01:39:05,780 --> 01:39:07,240


1538
01:39:07,240 --> 01:39:09,910
 .c 

1539
01:39:09,910 --> 01:39:15,790
-- agree.ccompare.chello.c  meow.c

1540
01:39:15,790 --> 01:39:24,382


1541
01:39:24,382 --> 01:39:25,340


1543
01:39:26,315 --> 01:39:27,800


1544
01:39:27,800 --> 01:39:29,520


1545
01:39:29,520 --> 01:39:34,340
 .c 

1546
01:39:34,340 --> 01:39:36,830


1547
01:39:36,830 --> 01:39:39,582
 macOS  Windows 

1548
01:39:39,582 --> 01:39:47,400
 ./ 

1549
01:39:47,400 --> 01:39:54,990
 --  Command-B  -- 

1550
01:39:54,990 --> 01:39:59,210
ls 

1551
01:39:59,210 --> 01:40:03,060
 VS Code 

1552
01:40:03,060 --> 01:40:06,213


1553
01:40:06,213 --> 01:40:07,880


1554
01:40:07,880 --> 01:40:09,680


1555
01:40:09,680 --> 01:40:14,720


1556
01:40:14,720 --> 01:40:16,773


1557
01:40:16,773 --> 01:40:23,330
 hello  hello.c

1558
01:40:23,330 --> 01:40:27,230


1559
01:40:27,230 --> 01:40:30,420


1560
01:40:30,420 --> 01:40:34,760
 make hello

1561
01:40:34,760 --> 01:40:38,960


1562
01:40:38,960 --> 01:40:40,820
 -  -

1563
01:40:40,820 --> 01:40:42,380


1564
01:40:42,380 --> 01:40:44,690


1565
01:40:44,690 --> 01:40:45,433


1566
01:40:45,433 --> 01:40:46,850


1567
01:40:46,850 --> 01:40:53,180
 ls  hello hello 

1568
01:40:53,180 --> 01:40:53,930


1570
01:40:54,470 --> 01:40:57,540


1571
01:40:57,540 --> 01:41:00,740
 hello.c

1572
01:41:00,740 --> 01:41:01,920


1573
01:41:01,920 --> 01:41:05,810


1574
01:41:05,810 --> 01:41:06,770


1575
01:41:06,770 --> 01:41:09,890


1576
01:41:09,890 --> 01:41:11,100


1577
01:41:11,100 --> 01:41:17,600
 mv hellohello.c

1578
01:41:17,600 --> 01:41:20,250
 hello 

1579
01:41:20,250 --> 01:41:25,130
 ls hello.c

1580
01:41:25,130 --> 01:41:28,910


1581
01:41:28,910 --> 01:41:37,350
 hello --  hello -- 

1582
01:41:37,350 --> 01:41:43,020
mv 

1583
01:41:43,020 --> 01:41:45,230


1584
01:41:45,230 --> 01:41:48,950
 VS 

1585
01:41:48,950 --> 01:41:52,760


1586
01:41:52,760 --> 01:41:57,620
 pset1  1

1587
01:41:57,620 --> 01:42:02,840


1588
01:42:02,840 --> 01:42:05,460


1589
01:42:05,460 --> 01:42:13,430
 "" mario.c 

1590
01:42:13,430 --> 01:42:18,960
mario.c  pset1 

1591
01:42:18,960 --> 01:42:23,300
 ls

1592
01:42:23,300 --> 01:42:26,720
 mario.c

1593
01:42:26,720 --> 01:42:28,688
 pset1 

1594
01:42:28,688 --> 01:42:31,730


1595
01:42:31,730 --> 01:42:33,300


1596
01:42:33,300 --> 01:42:37,640
 pwet1  mario.c

1597
01:42:37,640 --> 01:42:42,800


1598
01:42:42,800 --> 01:42:44,510


1599
01:42:44,510 --> 01:42:46,650


1600
01:42:46,650 --> 01:42:51,560


1601
01:42:51,560 --> 01:42:55,250


1602
01:42:55,250 --> 01:42:57,660
cd 

1603
01:42:57,660 --> 01:43:00,600


1604
01:43:00,600 --> 01:43:04,070
 cdpset1

1605
01:43:04,070 --> 01:43:05,960


1606
01:43:05,960 --> 01:43:09,200


1607
01:43:09,200 --> 01:43:12,470


1608
01:43:12,470 --> 01:43:16,520


1609
01:43:16,520 --> 01:43:26,120
 Linux  macOS  Windows

1610
01:43:26,120 --> 01:43:29,000


1611
01:43:29,000 --> 01:43:33,350
 ls 

1612
01:43:33,350 --> 01:43:34,340
.c

1613
01:43:34,340 --> 01:43:36,170
Mario.C

1614
01:43:36,170 --> 01:43:43,940
 --  make mario

1615
01:43:43,940 --> 01:43:50,810
----

1616
01:43:50,810 --> 01:43:55,100


1617
01:43:55,100 --> 01:43:56,000


1618
01:43:56,000 --> 01:43:58,850


1619
01:43:58,850 --> 01:44:02,198


1620
01:44:02,198 --> 01:44:14,420
 cd cp ls mkdir ------------------

1621
01:44:14,420 --> 01:44:21,924
--mv rm --

1622
01:44:21,924 --> 01:44:22,770


1623
01:44:22,770 --> 01:44:23,728
DAVID J. MALAN: 

1624
01:44:23,728 --> 01:44:24,960


1625
01:44:24,960 --> 01:44:26,520
Rmdir

1626
01:44:26,520 --> 01:44:28,860


1627
01:44:28,860 --> 01:44:33,310


1628
01:44:33,310 --> 01:44:40,380


1629
01:44:40,380 --> 01:44:51,880


1630
01:44:51,880 --> 01:44:56,475


1631
01:44:56,475 --> 01:44:58,350
 10 

1632
01:44:58,350 --> 01:45:00,150


1633
01:45:00,150 --> 01:45:02,910
10

1634
01:45:02,910 --> 01:45:04,740


1635
01:45:04,740 --> 01:45:10,740
 C 

1636
01:45:10,740 --> 01:45:17,880


1637
01:45:17,880 --> 01:45:25,260


1638
01:45:25,260 --> 01:45:31,500
 ""

1639
01:45:31,500 --> 01:45:37,450


1640
01:45:37,450 --> 01:45:40,260


1641
01:45:40,260 --> 01:45:49,920
 C 

1642
01:45:49,920 --> 01:45:55,830


1643
01:45:55,830 --> 01:46:00,720
 ASCII  --

1644
01:46:00,720 --> 01:46:09,120
ASCII

1645
01:46:09,120 --> 01:46:11,130
 VS Code

1646
01:46:11,130 --> 01:46:16,923
 mario.c 1 

1647
01:46:16,923 --> 01:46:24,810
 1  ASCII 

1648
01:46:24,810 --> 01:46:28,120
 mario.c 

1649
01:46:28,120 --> 01:46:29,710


1650
01:46:29,710 --> 01:46:33,090
 stdio.h printf

1651
01:46:33,090 --> 01:46:37,043
 int main(void)--

1652
01:46:37,043 --> 01:46:42,210
 1234 n

1653
01:46:42,210 --> 01:46:50,410


1654
01:46:50,410 --> 01:46:54,180
./

1655
01:46:54,180 --> 01:46:55,830


1656
01:46:55,830 --> 01:46:58,830


1657
01:46:58,830 --> 01:47:03,150


1658
01:47:03,150 --> 01:47:08,100
60 

1659
01:47:08,100 --> 01:47:17,100
 i  0i  4i++

1660
01:47:17,100 --> 01:47:25,800
 for 

1661
01:47:25,800 --> 01:47:29,280


1662
01:47:29,280 --> 01:47:34,200


1664
01:47:34,710 --> 01:47:38,275
 n n[INNAUDIBLE]. .

1665
01:47:38,275 --> 01:47:39,150


1666
01:47:39,150 --> 01:47:44,760
 n

1667
01:47:44,760 --> 01:47:50,700
 mario./marioOK

1668
01:47:50,700 --> 01:47:54,820


1669
01:47:54,820 --> 01:47:59,890


1670
01:47:59,890 --> 01:48:01,015


1671
01:48:03,310 --> 01:48:03,960


1673
01:48:05,610 --> 01:48:07,380


1674
01:48:07,380 --> 01:48:11,640
 8  9 

1675
01:48:11,640 --> 01:48:15,273


1676
01:48:15,273 --> 01:48:17,190


1677
01:48:17,190 --> 01:48:18,970


1678
01:48:18,970 --> 01:48:21,900
./

1679
01:48:21,900 --> 01:48:24,010


1680
01:48:24,010 --> 01:48:31,380
 " "

1681
01:48:31,380 --> 01:48:38,160
----

1682
01:48:38,160 --> 01:48:40,650


1683
01:48:40,650 --> 01:48:44,080


1684
01:48:44,080 --> 01:48:49,050


1685
01:48:49,050 --> 01:48:56,368
./OK

1686
01:48:56,368 --> 01:48:56,910


1687
01:48:56,910 --> 01:48:58,050


1688
01:48:58,050 --> 01:49:02,320


1689
01:49:02,320 --> 01:49:04,780


1690
01:49:04,780 --> 01:49:06,330


1691
01:49:06,330 --> 01:49:15,870
 4  3 0 

1692
01:49:15,870 --> 01:49:20,055
 less than  less than  equal to 

1693
01:49:20,055 --> 01:49:25,360


1694
01:49:25,360 --> 01:49:27,965


1695
01:49:27,965 --> 01:49:35,400
 " "

1696
01:49:35,400 --> 01:49:45,400
 3  3 

1697
01:49:45,400 --> 01:49:56,580
 3  3 

1698
01:49:56,580 --> 01:49:58,380


1699
01:49:58,380 --> 01:50:02,670


1700
01:50:02,670 --> 01:50:05,560


1701
01:50:05,560 --> 01:50:10,500
 3  3 

1702
01:50:10,500 --> 01:50:16,590


1703
01:50:16,590 --> 01:50:18,063


1704
01:50:18,063 --> 01:50:22,345


1705
01:50:22,345 --> 01:50:24,720
 printf 

1706
01:50:24,720 --> 01:50:33,390
 for 

1707
01:50:33,390 --> 01:50:34,530


1708
01:50:34,530 --> 01:50:35,850
 for 

1709
01:50:35,850 --> 01:50:39,390
 i 

1710
01:50:39,390 --> 01:50:51,090


1711
01:50:51,090 --> 01:50:52,960


1712
01:50:52,960 --> 01:50:55,450


1713
01:50:55,450 --> 01:50:58,590


1714
01:50:58,590 --> 01:51:11,700
for in i get 0 i less than 3 i++

1715
01:51:11,700 --> 01:51:17,820


1716
01:51:17,820 --> 01:51:23,080
 5  7 

1717
01:51:23,080 --> 01:51:24,700


1718
01:51:24,700 --> 01:51:25,345


1719
01:51:25,345 --> 01:51:27,665
 i

1720
01:51:27,665 --> 01:51:30,040
-J- i

1721
01:51:30,040 --> 01:51:32,080


1722
01:51:32,080 --> 01:51:38,470


1723
01:51:38,470 --> 01:51:41,560


1724
01:51:41,560 --> 01:51:43,930
 i 

1725
01:51:43,930 --> 01:51:47,980
 j

1726
01:51:47,980 --> 01:51:52,600


1727
01:51:52,600 --> 01:51:54,940
 i  j 

1728
01:51:54,940 --> 01:51:59,020
 j++  i++

1729
01:51:59,020 --> 01:52:00,280


1730
01:52:00,280 --> 01:52:04,330
./

1731
01:52:04,330 --> 01:52:06,560


1732
01:52:06,560 --> 01:52:08,480
 3  3 

1733
01:52:08,480 --> 01:52:12,855


1734
01:52:12,855 --> 01:52:14,485


1735
01:52:14,485 --> 01:52:15,110


1736
01:52:15,110 --> 01:52:17,110


1737
01:52:17,110 --> 01:52:21,340


1738
01:52:21,340 --> 01:52:24,910


1739
01:52:24,910 --> 01:52:26,535


1740
01:52:26,535 --> 01:52:28,077


1742
01:52:28,646 --> 01:52:32,620


1743
01:52:32,620 --> 01:52:33,495


1744
01:52:33,495 --> 01:52:38,000


1745
01:52:38,000 --> 01:52:41,030
 n

1746
01:52:41,030 --> 01:52:42,073


1747
01:52:42,073 --> 01:52:47,270


1748
01:52:47,270 --> 01:52:52,070
./

1749
01:52:52,070 --> 01:52:59,350
--

1750
01:52:59,350 --> 01:53:03,970


1751
01:53:03,970 --> 01:53:10,960


1752
01:53:10,960 --> 01:53:13,600


1753
01:53:13,600 --> 01:53:26,420
 4  4  5  5 ----

1754
01:53:26,420 --> 01:53:30,010


1755
01:53:30,010 --> 01:53:33,330


1756
01:53:33,330 --> 01:53:34,440


1758
01:53:35,010 --> 01:53:38,255
[]

1759
01:53:38,255 --> 01:53:39,130


1760
01:53:39,130 --> 01:53:43,060


1761
01:53:43,060 --> 01:53:44,110


1762
01:53:44,110 --> 01:53:45,680


1763
01:53:45,680 --> 01:53:48,070


1764
01:53:48,070 --> 01:53:50,410


1765
01:53:50,410 --> 01:53:51,160


1766
01:53:51,160 --> 01:54:01,000
 maybe n 

1767
01:54:01,000 --> 01:54:03,550
 3

1768
01:54:03,550 --> 01:54:06,610
 3 n

1769
01:54:06,610 --> 01:54:13,000
 4 5

1770
01:54:13,000 --> 01:54:13,845


1771
01:54:13,845 --> 01:54:16,720


1772
01:54:16,720 --> 01:54:19,840


1773
01:54:19,840 --> 01:54:28,985
 n++ 

1774
01:54:28,985 --> 01:54:31,693
/

1775
01:54:31,693 --> 01:54:34,240
 n 

1776
01:54:34,240 --> 01:54:41,020
 5 

1777
01:54:41,020 --> 01:54:44,170
 Scratch 

1778
01:54:44,170 --> 01:54:50,740
 const 

1779
01:54:50,740 --> 01:55:02,320
 C  n  5  3

1780
01:55:02,320 --> 01:55:05,530


1781
01:55:05,530 --> 01:55:08,420


1782
01:55:08,420 --> 01:55:12,160


1783
01:55:12,160 --> 01:55:13,235


1784
01:55:13,235 --> 01:55:14,110


1785
01:55:14,110 --> 01:55:15,970


1786
01:55:15,970 --> 01:55:23,570


1787
01:55:23,570 --> 01:55:26,420
 3

1788
01:55:26,420 --> 01:55:28,580
 n

1789
01:55:28,580 --> 01:55:33,250
./

1790
01:55:33,250 --> 01:55:35,560


1791
01:55:35,560 --> 01:55:37,330


1792
01:55:37,330 --> 01:55:40,720


1793
01:55:40,720 --> 01:55:41,740


1794
01:55:41,740 --> 01:55:43,700


1795
01:55:43,700 --> 01:55:48,940


1796
01:55:48,940 --> 01:55:52,060


1797
01:55:52,060 --> 01:55:57,400
 4  14 

1798
01:55:57,400 --> 01:56:04,520
 7  13 

1799
01:56:04,520 --> 01:56:10,090


1800
01:56:10,090 --> 01:56:17,080


1801
01:56:17,080 --> 01:56:20,170


1802
01:56:20,170 --> 01:56:28,270
----make mario./mario

1803
01:56:28,270 --> 01:56:36,860


1804
01:56:36,860 --> 01:56:38,020


1805
01:56:38,020 --> 01:56:44,230


1806
01:56:44,230 --> 01:56:46,420


1807
01:56:46,420 --> 01:56:53,710


1808
01:56:53,710 --> 01:56:57,220


1809
01:56:57,220 --> 01:57:03,565
 VS 

1810
01:57:03,565 --> 01:57:11,800


1811
01:57:11,800 --> 01:57:13,690


1812
01:57:13,690 --> 01:57:16,060


1813
01:57:16,060 --> 01:57:21,190


1814
01:57:21,190 --> 01:57:24,880
 3  3 

1815
01:57:24,880 --> 01:57:26,840


1816
01:57:26,840 --> 01:57:32,020
 n 

1817
01:57:32,020 --> 01:57:38,320
 get_int 

1818
01:57:38,320 --> 01:57:40,150


1819
01:57:40,150 --> 01:57:46,450
 make mario --

1820
01:57:46,450 --> 01:57:49,930


1821
01:57:49,930 --> 01:57:53,785


1822
01:57:53,785 --> 01:57:56,660
 cs50.h

1823
01:57:56,660 --> 01:57:59,930
-J- CS50 

1824
01:57:59,930 --> 01:58:03,420
 get_int 

1825
01:58:03,420 --> 01:58:04,880


1826
01:58:04,880 --> 01:58:07,730
 cs50.h

1827
01:58:07,730 --> 01:58:10,790
 make mario

1828
01:58:10,790 --> 01:58:12,800


1829
01:58:12,800 --> 01:58:14,550


1830
01:58:14,550 --> 01:58:16,490
 3

1831
01:58:16,490 --> 01:58:20,900
 10

1832
01:58:20,900 --> 01:58:23,360


1833
01:58:23,360 --> 01:58:25,940
 cat

1834
01:58:25,940 --> 01:58:28,770
get_int 

1835
01:58:28,770 --> 01:58:30,687


1836
01:58:30,687 --> 01:58:32,570


1837
01:58:32,570 --> 01:58:36,200
 get_int 

1838
01:58:36,200 --> 01:58:40,680


1839
01:58:40,680 --> 01:58:48,440
 1  3 

1840
01:58:48,440 --> 01:58:51,230


1841
01:58:51,230 --> 01:58:52,730


1842
01:58:52,730 --> 01:58:57,150


1843
01:58:57,150 --> 01:58:58,530


1844
01:58:58,530 --> 01:59:08,190
 n  1 --  0 

1845
01:59:08,190 --> 01:59:12,380


1846
01:59:12,380 --> 01:59:18,530
 n n 

1847
01:59:18,530 --> 01:59:19,790


1848
01:59:19,790 --> 01:59:21,510


1850
01:59:22,010 --> 01:59:25,190


1851
01:59:25,190 --> 01:59:33,020
 n  1

1852
01:59:33,020 --> 01:59:35,240


1853
01:59:35,240 --> 01:59:39,860


1854
01:59:39,860 --> 01:59:40,790


1855
01:59:40,790 --> 01:59:44,810


1856
01:59:44,810 --> 01:59:48,170


1857
01:59:48,170 --> 01:59:49,128
 while 

1858
01:59:49,128 --> 01:59:50,920
-J-

1859
01:59:50,920 --> 01:59:52,160
 while 

1860
01:59:52,160 --> 01:59:54,240
 for 

1861
01:59:54,240 --> 01:59:55,290


1862
01:59:55,290 --> 01:59:58,760


1863
01:59:58,760 --> 01:59:59,790


1864
01:59:59,790 --> 02:00:09,560
 n  1 

1865
02:00:09,560 --> 02:00:15,470


1866
02:00:15,470 --> 02:00:19,640
 int  6  9 

1867
02:00:19,640 --> 02:00:26,300


1868
02:00:26,300 --> 02:00:27,350


1869
02:00:27,350 --> 02:00:27,850


1870
02:00:27,850 --> 02:00:29,330
/

1871
02:00:29,330 --> 02:00:31,040


1872
02:00:31,040 --> 02:00:37,730
C 

1873
02:00:37,730 --> 02:00:41,210


1874
02:00:41,210 --> 02:00:45,510
 do while 

1875
02:00:45,510 --> 02:00:48,000
 C 

1876
02:00:48,000 --> 02:00:53,370
 n

1877
02:00:53,370 --> 02:00:56,870
 int n 

1878
02:00:56,870 --> 02:00:57,590


1879
02:00:57,590 --> 02:00:59,840


1880
02:00:59,840 --> 02:01:02,870


1881
02:01:02,870 --> 02:01:04,460


1882
02:01:04,460 --> 02:01:05,930


1883
02:01:05,930 --> 02:01:11,750
 get_int  n

1884
02:01:11,750 --> 02:01:14,040


1885
02:01:14,040 --> 02:01:17,900
 n  1 

1886
02:01:17,900 --> 02:01:23,570


1888
02:01:24,230 --> 02:01:31,175
 6  n

1889
02:01:31,175 --> 02:01:33,300


1890
02:01:33,300 --> 02:01:34,640


1891
02:01:34,640 --> 02:01:36,380
 7 

1892
02:01:36,380 --> 02:01:41,660
get_int n 

1893
02:01:41,660 --> 02:01:53,670
 C  11 " n  8  1 

1894
02:01:53,670 --> 02:01:58,400
-- 0 1  3--

1895
02:01:58,400 --> 02:02:04,530
 do while 

1896
02:02:04,530 --> 02:02:08,480
C  do while 

1897
02:02:08,480 --> 02:02:10,730
Python  do while 

1898
02:02:10,730 --> 02:02:20,570


1899
02:02:20,570 --> 02:02:22,980
 while 

1900
02:02:22,980 --> 02:02:26,150


1901
02:02:26,150 --> 02:02:28,820


1902
02:02:28,820 --> 02:02:35,640
" "

1903
02:02:35,640 --> 02:02:39,530


1904
02:02:39,530 --> 02:02:41,750


1905
02:02:41,750 --> 02:02:47,720


1906
02:02:47,720 --> 02:02:53,520


1907
02:02:53,520 --> 02:02:59,173
 C 

1908
02:02:59,173 --> 02:03:00,840
 Scratch 

1909
02:03:00,840 --> 02:03:04,680


1910
02:03:04,680 --> 02:03:07,020
 C 

1911
02:03:07,020 --> 02:03:13,860


1912
02:03:13,860 --> 02:03:17,860


1913
02:03:17,860 --> 02:03:27,870
 --

1914
02:03:27,870 --> 02:03:34,350


1915
02:03:34,350 --> 02:03:43,560


1916
02:03:43,560 --> 02:03:46,500


1917
02:03:46,500 --> 02:03:49,680


1918
02:03:49,680 --> 02:03:58,110
 6 

1919
02:03:58,110 --> 02:03:59,070


1920
02:03:59,070 --> 02:04:00,440


1921
02:04:00,440 --> 02:04:05,160
/

1922
02:04:05,160 --> 02:04:08,910


1923
02:04:08,910 --> 02:04:14,130


1924
02:04:14,130 --> 02:04:23,760
 20 

1925
02:04:23,760 --> 02:04:33,600


1926
02:04:33,600 --> 02:04:37,590


1927
02:04:37,590 --> 02:04:43,530
--

1928
02:04:43,530 --> 02:04:46,440
3 4 5

1929
02:04:46,440 --> 02:04:56,310


1930
02:04:56,310 --> 02:05:02,080


1931
02:05:02,080 --> 02:05:06,910


1932
02:05:06,910 --> 02:05:14,610
 "" ""

1933
02:05:14,610 --> 02:05:16,410


1934
02:05:16,410 --> 02:05:18,690


1935
02:05:18,690 --> 02:05:20,910


1936
02:05:20,910 --> 02:05:22,380


1937
02:05:22,380 --> 02:05:26,050


1938
02:05:26,050 --> 02:05:28,230


1939
02:05:28,230 --> 02:05:34,650
 get size 

1940
02:05:34,650 --> 02:05:36,220


1941
02:05:36,220 --> 02:05:38,790
 int n  get_size

1942
02:05:38,790 --> 02:05:43,000
 get_size 

1943
02:05:43,000 --> 02:05:43,500


1944
02:05:43,500 --> 02:05:45,420
CS50 

1945
02:05:45,420 --> 02:05:47,520


1946
02:05:47,520 --> 02:05:49,110


1947
02:05:49,110 --> 02:05:57,060
 print_grid  n 

1948
02:05:57,060 --> 02:05:58,950


1949
02:05:58,950 --> 02:06:00,330


1950
02:06:00,330 --> 02:06:01,800


1951
02:06:01,800 --> 02:06:06,240
 C  Scratch 

1952
02:06:06,240 --> 02:06:07,600


1953
02:06:07,600 --> 02:06:09,630


1954
02:06:09,630 --> 02:06:12,810
 main 

1956
02:06:13,110 --> 02:06:18,090


1957
02:06:18,090 --> 02:06:19,360


1958
02:06:19,360 --> 02:06:26,010
 get_size 

1959
02:06:26,010 --> 02:06:28,380


1960
02:06:28,380 --> 02:06:34,920


1961
02:06:34,920 --> 02:06:37,450


1962
02:06:37,450 --> 02:06:45,810
---- void get_size 

1963
02:06:45,810 --> 02:06:46,950


1964
02:06:46,950 --> 02:06:48,138
 int

1965
02:06:48,138 --> 02:06:50,430


1966
02:06:50,430 --> 02:06:55,920


1967
02:06:55,920 --> 02:06:57,727
 get_size

1968
02:06:57,727 --> 02:06:59,310
 get_size

1969
02:06:59,310 --> 02:07:01,140


1970
02:07:01,140 --> 02:07:03,180


1971
02:07:03,180 --> 02:07:12,270
 n  get_int

1972
02:07:12,270 --> 02:07:22,830
 n  1  C  n 

1973
02:07:22,830 --> 02:07:27,330


1974
02:07:27,330 --> 02:07:36,970
 C  return 

1975
02:07:36,970 --> 02:07:47,280
 15  21  n

1976
02:07:47,280 --> 02:07:48,720
 1 2

1977
02:07:48,720 --> 02:07:51,180
 0 1

1978
02:07:51,180 --> 02:07:56,360


1979
02:07:56,360 --> 02:07:58,990
 7 

1980
02:07:58,990 --> 02:08:01,630
 get_int  get_string 

1981
02:08:01,630 --> 02:08:04,650
--

1982
02:08:04,650 --> 02:08:09,970
 n 

1983
02:08:09,970 --> 02:08:19,090
 get_size

1984
02:08:19,090 --> 02:08:21,710


1985
02:08:21,710 --> 02:08:27,160
 print_grid 

1986
02:08:27,160 --> 02:08:29,180


1987
02:08:29,180 --> 02:08:32,050
 print_grid 

1988
02:08:32,050 --> 02:08:33,590


1989
02:08:33,590 --> 02:08:35,440


1990
02:08:35,440 --> 02:08:38,230


1991
02:08:38,230 --> 02:08:39,040


1992
02:08:39,040 --> 02:08:40,820


1993
02:08:40,820 --> 02:08:42,670


1994
02:08:42,670 --> 02:08:44,660


1995
02:08:44,660 --> 02:08:52,337
C 

1996
02:08:52,337 --> 02:08:53,920


1997
02:08:53,920 --> 02:08:54,940


1998
02:08:54,940 --> 02:08:56,140
 n

1999
02:08:56,140 --> 02:09:01,030
 size

2000
02:09:01,030 --> 02:09:18,790
for int i gets 0, i less than size--  3-- i++for int j gets 0, j is less than size j++

2001
02:09:18,790 --> 02:09:28,660
 printf 

2002
02:09:28,660 --> 02:09:30,370


2003
02:09:30,370 --> 02:09:32,860


2004
02:09:32,860 --> 02:09:39,190
 Scratch 

2005
02:09:39,190 --> 02:09:40,900


2006
02:09:40,900 --> 02:09:48,160
 get_size  print_grid 

2007
02:09:48,160 --> 02:09:50,590


2008
02:09:50,590 --> 02:09:59,500
 C  get_size 

2009
02:09:59,500 --> 02:10:03,460


2010
02:10:03,460 --> 02:10:06,362
 CS50 get_int 

2011
02:10:06,362 --> 02:10:09,070


2012
02:10:09,070 --> 02:10:10,270


2013
02:10:10,270 --> 02:10:12,580
C 

2014
02:10:12,580 --> 02:10:18,910
 7  10 

2015
02:10:18,910 --> 02:10:20,690


2016
02:10:20,690 --> 02:10:26,342


2017
02:10:26,342 --> 02:10:27,550


2018
02:10:27,550 --> 02:10:30,280


2019
02:10:30,280 --> 02:10:33,380
 main 

2020
02:10:33,380 --> 02:10:34,930


2021
02:10:34,930 --> 02:10:36,560


2022
02:10:36,560 --> 02:10:39,170


2023
02:10:39,170 --> 02:10:40,730


2024
02:10:40,730 --> 02:10:46,060
 CS50  C /

2025
02:10:46,060 --> 02:10:58,270
"......"

2026
02:10:58,270 --> 02:11:01,010


2027
02:11:01,010 --> 02:11:03,190


2028
02:11:03,190 --> 02:11:07,660


2029
02:11:07,660 --> 02:11:11,830
 main 

2030
02:11:11,830 --> 02:11:15,190
 -- 

2031
02:11:15,190 --> 02:11:17,260
 print  printf

2032
02:11:17,260 --> 02:11:20,860
--printf

2033
02:11:20,860 --> 02:11:27,790
./ 3

2034
02:11:27,790 --> 02:11:32,800


2035
02:11:32,800 --> 02:11:35,240


2037
02:11:35,740 --> 02:11:38,050


2038
02:11:38,050 --> 02:11:40,060


2039
02:11:40,060 --> 02:11:42,430


2041
02:11:42,940 --> 02:11:46,338


2042
02:11:46,338 --> 02:11:54,380


2043
02:11:54,380 --> 02:12:00,410


2044
02:12:00,410 --> 02:12:04,300


2045
02:12:04,300 --> 02:12:10,610
C 

2046
02:12:10,610 --> 02:12:14,025


2047
02:12:14,025 --> 02:12:19,130


2048
02:12:19,130 --> 02:12:21,400
 VS 

2049
02:12:21,400 --> 02:12:25,030
 calculator.c 

2050
02:12:25,030 --> 02:12:33,670
--cs50.h  stdio.h

2051
02:12:33,670 --> 02:12:37,540
 int main(void)  main

2052
02:12:37,540 --> 02:12:40,250
 main 

2053
02:12:40,250 --> 02:12:48,040
 int  x get int  x 

2054
02:12:48,040 --> 02:12:50,240


2055
02:12:50,240 --> 02:12:51,490
 y

2056
02:12:51,490 --> 02:12:57,780
 get_int  y

2057
02:12:57,780 --> 02:13:05,080
 x  y 

2058
02:13:05,080 --> 02:13:10,930
 printfquote/unquote %i n 

2059
02:13:10,930 --> 02:13:14,640
 x  y 

2060
02:13:14,640 --> 02:13:16,710


2061
02:13:16,710 --> 02:13:20,340


2062
02:13:20,340 --> 02:13:22,080


2063
02:13:22,080 --> 02:13:23,880
 ./calculator.

2064
02:13:23,880 --> 02:13:28,500
 2  2  4

2065
02:13:28,500 --> 02:13:29,340


2066
02:13:29,340 --> 02:13:34,677


2067
02:13:34,677 --> 02:13:36,510


2068
02:13:36,510 --> 02:13:37,890


2069
02:13:37,890 --> 02:13:39,990


2070
02:13:39,990 --> 02:13:47,280
 20  x y

2071
02:13:47,280 --> 02:13:52,560
 20  20  40 

2072
02:13:52,560 --> 02:13:53,970


2073
02:13:53,970 --> 02:14:02,070


2074
02:14:02,070 --> 02:14:04,240


2075
02:14:04,240 --> 02:14:07,770
 RAM

2076
02:14:07,770 --> 02:14:08,850


2077
02:14:08,850 --> 02:14:15,930


2078
02:14:15,930 --> 02:14:19,320


2079
02:14:19,320 --> 02:14:29,670


2080
02:14:29,670 --> 02:14:32,790


2081
02:14:32,790 --> 02:14:35,800
 0  1 

2082
02:14:35,800 --> 02:14:38,640


2083
02:14:38,640 --> 02:14:40,072


2084
02:14:40,072 --> 02:14:48,120
 32  0  1  C  int

2085
02:14:48,120 --> 02:14:55,020
 32  int  32  0 --

2086
02:14:55,020 --> 02:14:56,970
 32 

2087
02:14:56,970 --> 02:15:07,200
 0  1 40 

2088
02:15:07,200 --> 02:15:17,160
 32  1 4,294,967,295

2089
02:15:17,160 --> 02:15:24,730


2090
02:15:24,730 --> 02:15:33,360
 0  0  40 

2091
02:15:33,360 --> 02:15:41,890
 0  1 

2092
02:15:41,890 --> 02:15:52,500
 32  int  C  20 

2093
02:15:52,500 --> 02:15:57,180
 2 147 483 647

2094
02:15:57,180 --> 02:16:06,630
 20 

2095
02:16:06,630 --> 02:16:16,360


2096
02:16:16,360 --> 02:16:23,080


2097
02:16:23,080 --> 02:16:26,767


2098
02:16:26,767 --> 02:16:28,600


2099
02:16:28,600 --> 02:16:37,080


2100
02:16:37,080 --> 02:16:45,360
 0 0  1234567

2101
02:16:45,360 --> 02:16:56,250
 7  1 1 1000

2102
02:16:56,250 --> 02:17:07,799
 32  1000

2103
02:17:07,799 --> 02:17:10,620
 000

2104
02:17:10,620 --> 02:17:17,850


2105
02:17:17,850 --> 02:17:27,129
 7 1  0

2106
02:17:27,129 --> 02:17:30,209


2107
02:17:30,209 --> 02:17:32,490
C  ints

2108
02:17:32,490 --> 02:17:38,468


2109
02:17:38,468 --> 02:17:40,079


2110
02:17:40,080 --> 02:17:41,430


2111
02:17:41,430 --> 02:17:47,010


2112
02:17:47,010 --> 02:17:53,227
 CS50  get_long get_int

2113
02:17:53,227 --> 02:17:55,769


2114
02:17:55,770 --> 02:17:57,808
 get_int  get_long

2115
02:17:57,808 --> 02:18:01,479


2116
02:18:01,480 --> 02:18:09,629
printf -- %i  %s

2117
02:18:09,629 --> 02:18:16,379
%li%f

2118
02:18:16,379 --> 02:18:21,690
 printf  %li  %i

2119
02:18:21,690 --> 02:18:29,159
 --  -- ./calculator

2120
02:18:29,160 --> 02:18:31,740
2  2  4

2121
02:18:31,740 --> 02:18:44,629
 20  y  20 

2122
02:18:44,629 --> 02:18:48,340


2123
02:18:48,340 --> 02:18:57,850
 32  64  20  20 

2124
02:18:57,850 --> 02:19:04,840
 40 

2125
02:19:04,840 --> 02:19:07,459


2126
02:19:07,459 --> 02:19:12,340
9 

2127
02:19:12,340 --> 02:19:14,888


2128
02:19:14,888 --> 02:19:17,836


2129
02:19:17,837 --> 02:19:22,930


2130
02:19:22,930 --> 02:19:25,430


2131
02:19:25,430 --> 02:19:28,660


2132
02:19:28,660 --> 02:19:35,770


2133
02:19:35,770 --> 02:19:43,610
----

2134
02:19:43,610 --> 02:19:45,549
VS 

2135
02:19:45,549 --> 02:19:46,900


2136
02:19:46,900 --> 02:19:52,520


2137
02:19:52,520 --> 02:19:55,090


2138
02:19:55,090 --> 02:19:59,020
 make calculator 

2139
02:19:59,020 --> 02:20:06,370
 ./ 1  x3  y

2140
02:20:06,370 --> 02:20:08,380
 

2141
02:20:08,380 --> 02:20:11,500
1  3  1/3

2142
02:20:11,500 --> 02:20:21,890
 0.33333 3

2143
02:20:21,890 --> 02:20:30,040
 0

2144
02:20:30,040 --> 02:20:31,700


2145
02:20:31,700 --> 02:20:42,640


2146
02:20:42,640 --> 02:20:46,370


2147
02:20:46,370 --> 02:20:56,560
 %li  %f

2148
02:20:56,560 --> 02:21:04,100
 z 

2149
02:21:04,100 --> 02:21:07,300
 z  x  y

2150
02:21:07,300 --> 02:21:10,720
 x  y z

2151
02:21:10,720 --> 02:21:20,260
 long  int 

2152
02:21:20,260 --> 02:21:24,710


2153
02:21:24,710 --> 02:21:34,180
 Make --  -- ./calculator 1  3

2154
02:21:34,180 --> 02:21:36,868


2155
02:21:36,868 --> 02:21:41,350
  %f  float

2156
02:21:41,350 --> 02:21:46,570
 1  3 

2157
02:21:46,570 --> 02:21:48,520


2158
02:21:48,520 --> 02:21:57,340
 ""

2159
02:21:57,340 --> 02:22:04,390


2160
02:22:04,390 --> 02:22:05,480


2161
02:22:05,480 --> 02:22:07,100


2162
02:22:07,100 --> 02:22:18,310
 C  x  y 

2163
02:22:18,310 --> 02:22:24,830


2164
02:22:24,830 --> 02:22:33,910
 x  long  float

2165
02:22:33,910 --> 02:22:39,950
 y  long  float

2166
02:22:39,950 --> 02:22:49,330
nz  long  long  int  int  float  float 

2167
02:22:49,330 --> 02:22:55,300
 make calculator --  -- ./calculator

2168
02:22:55,300 --> 02:23:05,380
 13 0.333333

2169
02:23:05,380 --> 02:23:11,710


2170
02:23:11,710 --> 02:23:13,900


2171
02:23:13,900 --> 02:23:22,180
--

2172
02:23:22,180 --> 02:23:27,100


2173
02:23:27,100 --> 02:23:34,060
 int  long 

2174
02:23:34,060 --> 02:23:39,220


2175
02:23:39,220 --> 02:23:41,560
VS 

2176
02:23:41,560 --> 02:23:43,430


2177
02:23:43,430 --> 02:23:52,250
%f 

2178
02:23:52,250 --> 02:23:57,520
 20 

2179
02:23:57,520 --> 02:24:08,440
 %f %.20 20 

2180
02:24:08,440 --> 02:24:10,390


2181
02:24:10,390 --> 02:24:12,550
 ./

2182
02:24:12,550 --> 02:24:14,890
 1 3

2183
02:24:14,890 --> 02:24:17,560


2184
02:24:17,560 --> 02:24:21,580
 1  3  1/3

2185
02:24:21,580 --> 02:24:28,180
 0.33333

2186
02:24:28,180 --> 02:24:31,660


2187
02:24:31,660 --> 02:24:37,480
 3 4326744079590

2188
02:24:37,480 --> 02:24:42,100


2189
02:24:42,100 --> 02:24:52,300


2190
02:24:52,300 --> 02:24:57,190


2191
02:24:57,190 --> 02:25:07,040


2192
02:25:07,040 --> 02:25:14,500


2193
02:25:14,500 --> 02:25:17,740


2194
02:25:17,740 --> 02:25:19,180


2195
02:25:19,180 --> 02:25:24,760
 double  float float 

2196
02:25:24,760 --> 02:25:27,820
 64 32

2197
02:25:27,820 --> 02:25:31,570
 long  int 

2198
02:25:31,570 --> 02:25:34,480


2199
02:25:34,480 --> 02:25:36,850
 x  double

2200
02:25:36,850 --> 02:25:38,740
 y 

2201
02:25:38,740 --> 02:25:41,530
--

2202
02:25:41,530 --> 02:25:45,220
%.20f 

2203
02:25:45,220 --> 02:25:46,990


2204
02:25:46,990 --> 02:25:48,970
 ./calculator.

2205
02:25:48,970 --> 02:25:51,460
 1  3

2206
02:25:51,460 --> 02:25:53,770


2207
02:25:53,770 --> 02:25:56,590
 20 

2208
02:25:56,590 --> 02:25:59,900


2209
02:25:59,900 --> 02:26:03,640


2210
02:26:03,640 --> 02:26:06,520


2211
02:26:06,520 --> 02:26:14,980
 C 

2212
02:26:14,980 --> 02:26:18,910


2213
02:26:18,910 --> 02:26:21,952
 Python 

2214
02:26:21,952 --> 02:26:29,470


2215
02:26:29,470 --> 02:26:33,140


2216
02:26:33,140 --> 02:26:35,170


2217
02:26:35,170 --> 02:26:45,010
 1999 

2218
02:26:45,010 --> 02:26:48,910


2219
02:26:48,910 --> 02:27:01,400
 1999  1999 

2220
02:27:01,400 --> 02:27:14,290
 1999  2000 2001 

2221
02:27:14,290 --> 02:27:16,990
 "99 " 1

2222
02:27:16,990 --> 02:27:28,390
 2000  1900 

2223
02:27:28,390 --> 02:27:30,740


2224
02:27:30,740 --> 02:27:37,240


2225
02:27:37,240 --> 02:27:42,160


2226
02:27:42,160 --> 02:27:50,800
2038  1  19 

2227
02:27:50,800 --> 02:27:58,870
 32 

2228
02:27:58,870 --> 02:28:01,090
--

2229
02:28:01,090 --> 02:28:03,350
1970  1  1 

2230
02:28:03,350 --> 02:28:06,860


2231
02:28:06,860 --> 02:28:14,710
 1970  1  1 

2232
02:28:14,710 --> 02:28:23,470
 32 

2233
02:28:23,470 --> 02:28:32,080
 2038  1  19 

2234
02:28:32,080 --> 02:28:42,460
 1901  12  13 

2235
02:28:42,460 --> 02:28:48,560


2236
02:28:48,560 --> 02:28:50,560


2237
02:28:50,560 --> 02:28:54,550
 1 

