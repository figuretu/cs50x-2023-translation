1
00:00:02,982 --> 00:00:06,461
[MUSIC PLAYING]

2
00:01:12,600 --> 00:01:13,590
DAVID MALAN: All right.

3
00:01:13,590 --> 00:01:24,120
This is CS50, and this is week 2 wherein we're going to take a look at a lower level at how things work, and indeed, among the goals of the course is this bottom-up understanding

4
00:01:24,120 --> 00:01:29,920
so that in a couple of weeks' time, even a few years' time, when you encounter some new technology, you'll be able to think back hopefully

5
00:01:29,920 --> 00:01:36,060
on some of this week's and this is basic building blocks and primitives and really just deduce how tomorrow's technologies work.

6
00:01:36,060 --> 00:01:41,380
But along the way, it's going to seem-- it's going to be a little hard, perhaps, to see the forest for the trees, so to speak.

7
00:01:41,380 --> 00:01:44,783
And so the goal at the end of the day still is going to be problem-solving.

8
00:01:44,783 --> 00:01:53,280
And so we thought we'd begin today with a look at some of the problems we'll talk about or solve this coming week, and for that, we have some brave volunteers who have already come up.

9
00:01:53,280 --> 00:01:58,320
If we could turn on some dramatic lighting and meet today's volunteers.

10
00:01:58,320 --> 00:02:00,430
So on my left here, we have--

11
00:02:00,430 --> 00:02:00,930
ALEX: Hi.

12
00:02:00,930 --> 00:02:01,960
My name is Alex.

13
00:02:01,960 --> 00:02:05,340
I'm a first-year at the college and I'm from Chapel Hill, North Carolina.

14
00:02:05,340 --> 00:02:07,080
DAVID MALAN: Welcome to Alex.

15
00:02:07,080 --> 00:02:09,180
And to Alex's right.

16
00:02:09,180 --> 00:02:10,050
SARAH: I'm Sarah.

17
00:02:10,050 --> 00:02:13,230
I'm from Toronto, Canada, and I'm also a first-year student at the college.

18
00:02:13,230 --> 00:02:14,188
DAVID MALAN: Wonderful.

19
00:02:14,188 --> 00:02:15,869
Well, welcome to both Alex and Sarah.

20
00:02:15,869 --> 00:02:25,650
So one of the problems you'll perhaps solve this week for problem set 2 is to analyze the reading level of a body of text, whether someone reads at a first grade level, second grade level, third grade

21
00:02:25,650 --> 00:02:28,570
level, all the way up to 12 or 13 or beyond.

22
00:02:28,570 --> 00:02:36,750
What you perhaps never quite thought about, certainly in terms of code, like how you would analyze some text, some book and figure out what reading level is it at.

23
00:02:36,750 --> 00:02:40,330
And yet, surely our teachers growing up knew or had an intuitive sense of this.

24
00:02:40,330 --> 00:02:42,450
So let's consider some sample text.

25
00:02:42,450 --> 00:02:45,960
For instance, Alex, what have you been reading lately?

26
00:02:45,960 --> 00:02:52,502
ALEX: One fish, two fish, red fish, blue fish.

27
00:02:52,502 --> 00:02:53,460
DAVID MALAN: Wonderful.

28
00:02:53,460 --> 00:02:58,890
So given that, what grade level would you say Alex is currently reading at?

29
00:02:58,890 --> 00:03:01,500
Feel free to just shout it out.

30
00:03:01,500 --> 00:03:02,730
First, first?

31
00:03:02,730 --> 00:03:10,410
So indeed, you'll see this week, if you run your code on Alex's text, it actually turns out he reads below a first grade reading level.

32
00:03:10,410 --> 00:03:12,400
But why might that be?

33
00:03:12,400 --> 00:03:19,020
What might your intuition be for why we've accused Alex of reading at this level?

34
00:03:19,020 --> 00:03:20,990
Feel free to shout out.

35
00:03:20,990 --> 00:03:21,490
Yeah.

36
00:03:21,490 --> 00:03:24,520
So very few syllables, short words, short sentences.

37
00:03:24,520 --> 00:03:30,370
And so there's some heuristics, perhaps, we can infer from that short text, that that probably means that it's best for younger children.

38
00:03:30,370 --> 00:03:33,370
Now Sarah, by contrast, what have you been reading?

39
00:03:33,370 --> 00:03:35,470
SARAH: Mr. And Mrs. Dursley of Number.

40
00:03:35,470 --> 00:03:41,050
Four Privet Drive were proud to say that they were perfectly normal, thank you very much.

41
00:03:41,050 --> 00:03:47,952
They were the last people you'd expect to be involved in anything strange or mysterious because they just didn't hold with much nonsense.

42
00:03:47,952 --> 00:03:48,910
DAVID MALAN: All right.

43
00:03:48,910 --> 00:03:55,230
Now irrespective of what grade you were in when you might have read that text, what grade level to Sarah seemed to be reading at?

44
00:03:55,230 --> 00:03:57,570
So eighth grade, second grade.

45
00:03:57,570 --> 00:03:58,080
OK.

46
00:03:58,080 --> 00:04:03,240
So hearing a bit of everything, so with that, at least according to code, it would actually be seventh grade.

47
00:04:03,240 --> 00:04:05,130
And what might the intuition there be?

48
00:04:05,130 --> 00:04:09,917
Why is that a higher grade level even though we might disagree exactly which grade it is?

49
00:04:09,917 --> 00:04:11,250
AUDIENCE: Complicated sentences.

50
00:04:11,250 --> 00:04:12,000
DAVID MALAN: Yeah.

51
00:04:12,000 --> 00:04:14,218
So complicated sentences, longer sentences.

52
00:04:14,218 --> 00:04:18,519
So indeed a lot more words were being spoken by Sarah because there was so much more there on the page.

53
00:04:18,519 --> 00:04:26,910
So we'll translate these ideas this coming week in problem set 2, if you tackle this one, through code so that you can ultimately infer things of these quantitatively.

54
00:04:26,910 --> 00:04:29,190
But to do so, we're going to have to understand text.

55
00:04:29,190 --> 00:04:32,610
So let's first thank our volunteers and then we'll dive in to that lower level.

56
00:04:32,610 --> 00:04:35,337
[APPLAUSE]

57
00:04:39,910 --> 00:04:40,600
Sorry.

58
00:04:40,600 --> 00:04:41,490
You can keep those.

59
00:04:41,490 --> 00:04:42,222
SARAH: Oh, OK.

60
00:04:42,222 --> 00:04:43,180
DAVID MALAN: All right.

61
00:04:43,180 --> 00:04:50,210
So besides that, let's consider one other body of text perhaps that you might see this week, which is namely a little something like this.

62
00:04:50,210 --> 00:04:53,860
What I have here on the screen is what we'll start calling today ciphertext.

63
00:04:53,860 --> 00:04:56,530
It's the result of encrypting some piece of information.

64
00:04:56,530 --> 00:05:00,908
And encryption, or more generally, the art and science of cryptography is all around us.

65
00:05:00,908 --> 00:05:03,700
It's what you're using on the web, on your phones, with your banks.

66
00:05:03,700 --> 00:05:07,000
And anything that tries to keep data secure is using encryption.

67
00:05:07,000 --> 00:05:11,140
But there's going to be different levels of encryption-- strong encryption, weak encryption.

68
00:05:11,140 --> 00:05:22,030
And what you see here on the screen isn't all that strong, but we'll see later today how we might decrypt this and actually reveal what the plaintext is that corresponds to that ciphertext.

69
00:05:22,030 --> 00:05:26,197
But in order to do so, we have to start taking off some training wheels, so to speak.

70
00:05:26,197 --> 00:05:32,230
And believe it or not, even though your time would see this past week for the first time, probably, might have been rather in the weeds.

71
00:05:32,230 --> 00:05:39,760
And much more complicated seemingly than C, it turns out that along the way, we have been providing and we'll continue to provide certain training wheels.

72
00:05:39,760 --> 00:05:49,730
For instance, the CS50 Library is one of them, and even some of the explanations we give of topics for now in these early weeks will be somewhat simplified-- abstracted away, if you will.

73
00:05:49,730 --> 00:05:58,210
But the goal ultimately is for you to understand each and every one of those details so that after CS50, you really can stand on your own and understand and wrap your mind

74
00:05:58,210 --> 00:06:01,040
around any future technologies as well.

75
00:06:01,040 --> 00:06:06,110
So let's consider first the very first program with which we began last week, which was this one.

76
00:06:06,110 --> 00:06:14,890
So "hello, world" in C. At the end of the day, it was really the printf function that was doing the interesting part of the work, but there was a lot of technical stuff above and below it.

77
00:06:14,890 --> 00:06:21,730
The curly braces, the parentheses, words like void and include, and then of course, the angled brackets and more.

78
00:06:21,730 --> 00:06:30,190
But at the end of the day, we needed to convert that source code in C to machine code, the 0's and 1's in binary that the computer understood.

79
00:06:30,190 --> 00:06:33,700
And to do that, of course, we ran-- we compiled the code.

80
00:06:33,700 --> 00:06:37,400
We ran make and then we were able to actually run that code there.

81
00:06:37,400 --> 00:06:44,510
So let me actually go over here to VS Code and really quickly recreate that hello.c pretty much by transcribing the same.

82
00:06:44,510 --> 00:06:51,970
So I might have here include stdio.h, int main void.

83
00:06:51,970 --> 00:06:57,430
And then in here, I had quite simply, hello, comma, world with my backslash, endquotes, and more.

84
00:06:57,430 --> 00:07:01,693
Now last time, to compile this, I indeed ran make hello, followed by Enter.

85
00:07:01,693 --> 00:07:03,860
Hopefully you see no errors and that's a good thing.

86
00:07:03,860 --> 00:07:07,840
And if you do dot, slash, hello, you see, in fact, the results of that program.

87
00:07:07,840 --> 00:07:12,950
But it turns out that make is not actually a compiler as I alluded to last week.

88
00:07:12,950 --> 00:07:19,030
It's a program that clearly makes your program, but it itself just automates the process of using an actual compiler.

89
00:07:19,030 --> 00:07:27,640
And there's lots of different compilers out there, and the one that it's actually using underneath the hood is a little something called Clang for C Language.

90
00:07:27,640 --> 00:07:30,190
And Clang is a pretty popular compiler nowadays.

91
00:07:30,190 --> 00:07:40,310
There's another one that's been around for ages called GCC, but these are just specific names for types of compilers that different people, different companies, different groups have actually created.

92
00:07:40,310 --> 00:07:50,703
But if you use in week 1 a compiler yourself manually, you have to understand a little more about what's going on because it's even more cryptic than what just make alone.

93
00:07:50,703 --> 00:07:59,360
So in fact, let me go back to my terminal window here, let me go ahead and clear the screen a little bit and just run really the raw compiler command.

94
00:07:59,360 --> 00:08:03,620
So what make is automating for me let me, actually do this manually for just a moment.

95
00:08:03,620 --> 00:08:10,450
So if I want to compile hello.c into an executable program I can run,

96
00:08:10,450 --> 00:08:17,110
I can do this. clang, space, hello.c, and then Enter.

97
00:08:17,110 --> 00:08:22,010
And now there's no output, which is a good thing in this case, no errors, but notice this.

98
00:08:22,010 --> 00:08:32,140
If I go ahead and type ls, it turns out there's a file that's been created suddenly in my current folder weirdly called a.out.

99
00:08:32,140 --> 00:08:33,580
That stands for Assembler Output.

100
00:08:33,580 --> 00:08:39,440
And long story short, that's actually the default name of a program that's created when you just run Clang by itself.

101
00:08:39,440 --> 00:08:44,000
Now that's a pretty bad name for a program because it doesn't describe what it does.

102
00:08:44,000 --> 00:08:55,420
So better would be here to perhaps do, well, instead of a.out, which, yes, still prints hello.world, but isn't really a clearly-named program, it'd be nice to name this hello.

103
00:08:55,420 --> 00:08:56,240
So what could I do?

104
00:08:56,240 --> 00:09:01,820
I could do like we learned last week-- well, I could rename a.out to hello by using Linux's mv command.

105
00:09:01,820 --> 00:09:04,480
So I'm going to move a.out to become hello.

106
00:09:04,480 --> 00:09:06,370
But that, too, seems kind of tedious.

107
00:09:06,370 --> 00:09:07,720
Now I have three steps.

108
00:09:07,720 --> 00:09:12,190
Like write my code, compile my code, and then rename it before I can even run it.

109
00:09:12,190 --> 00:09:13,580
We can do better than that.

110
00:09:13,580 --> 00:09:20,380
And so it turns out that certain commands like clang support what we're going to start today calling command line arguments.

111
00:09:20,380 --> 00:09:30,400
A command line argument, unlike an argument to a function, is just an additional word or key phrase that you type after a command at your prompt in your terminal

112
00:09:30,400 --> 00:09:33,440
window that just modifies the behavior of that command.

113
00:09:33,440 --> 00:09:35,600
It configures it a little more specifically.

114
00:09:35,600 --> 00:09:45,220
So what you're seeing here on the screen is some of a better command with which to run clang so that now I can specify the output of this command per this o.

115
00:09:45,220 --> 00:09:46,610
So do what I mean by that?

116
00:09:46,610 --> 00:09:54,955
Well, let me go ahead and clear my terminal window again and more explicitly type clang -o hello hello.c and then Enter.

117
00:09:54,955 --> 00:10:02,860
Nothing, again, appears to happen, but that's a good thing when you see no errors and now the program I just created is indeed called Hello.

118
00:10:02,860 --> 00:10:07,280
So it achieves really the same exact effect as make did, but what.

119
00:10:07,280 --> 00:10:11,075
I don't have to do with make is type and remember something as long as this command.

120
00:10:11,075 --> 00:10:12,700
And this, too, is a bit of a white lie.

121
00:10:12,700 --> 00:10:22,840
It turns out, we have preconfigured VS Code in the cloud for you to also use some other features of Clang that would be even more tedious for you to write yourselves.

122
00:10:22,840 --> 00:10:28,130
And so really, this is why we distill this as ultimately just running make.

123
00:10:28,130 --> 00:10:37,720
So let me pause here to see first if there's any questions on what I've done by taking my very first program in C and just now compiling it first with make, but then starting over

124
00:10:37,720 --> 00:10:46,820
and now manually compiling it with clang with what we'll call command line arguments. -o, space, hello, and then the name of the file.

125
00:10:46,820 --> 00:10:47,320
Yeah?

126
00:10:47,320 --> 00:10:48,780
AUDIENCE: What is a.out?

127
00:10:48,780 --> 00:10:49,530
DAVID MALAN: Yeah.

128
00:10:49,530 --> 00:10:51,870
So a.out is a historical name.

129
00:10:51,870 --> 00:10:55,240
It refers to assembler output-- more on that soon.

130
00:10:55,240 --> 00:11:02,970
And it's just the default file name that you get automatically if you just run the compiler on any file so that you have just a standard name for it.

131
00:11:02,970 --> 00:11:05,213
But it's not a very well-named program.

132
00:11:05,213 --> 00:11:09,880
Instead of running Microsoft Word on your Mac or PC, it would be like double-clicking on a.out.

133
00:11:09,880 --> 00:11:17,370
So instead with these command line arguments, you can customize the output of Clang and call it hello or anything you want.

134
00:11:17,370 --> 00:11:23,020
Other questions on what I've done here with Clang itself, the compiler?

135
00:11:23,020 --> 00:11:23,520
Yeah?

136
00:11:23,520 --> 00:11:25,510
AUDIENCE: What is -o?

137
00:11:25,510 --> 00:11:30,500
DAVID MALAN: So -o-- and you would only know this from reading the manual, taking a class, means output.

138
00:11:30,500 --> 00:11:38,680
So -o means change Clang's output to be a file called hello instead of the default, which is a.out.

139
00:11:38,680 --> 00:11:44,810
And this, too, is, again, a detail you would have to look up on a web page, read the manual, hear someone like me tell you about it.

140
00:11:44,810 --> 00:11:48,890
And in fact, there's even more than these options, but we'll just scratch the surface here.

141
00:11:48,890 --> 00:11:49,390
All right.

142
00:11:49,390 --> 00:11:53,530
So if we now know this, what more is actually happening underneath the hood?

143
00:11:53,530 --> 00:12:03,430
Well, let's take a closer look at not just this version of my code, but my slightly more complicated version last week, which looked a little something like this, wherein

144
00:12:03,430 --> 00:12:11,810
I added in some dynamic input from the user so I could say not hello, world to everyone, but hello, David or hello to whoever actually runs this program.

145
00:12:11,810 --> 00:12:17,770
So in fact, let me go ahead and change my code here in VS Code just to match that same code from last week.

146
00:12:17,770 --> 00:12:19,190
So no new code yet.

147
00:12:19,190 --> 00:12:22,820
I'm just going to, in a moment, compile it in a slightly different way.

148
00:12:22,820 --> 00:12:29,020
So I did last week's string, I think, answer equals string, quote-unquote,

149
00:12:29,020 --> 00:12:30,100
"What's your name?"

150
00:12:30,100 --> 00:12:31,540
Just like in Scratch.

151
00:12:31,540 --> 00:12:37,450
And then down here, instead of doing world, I initially wrote answer, but that didn't go well.

152
00:12:37,450 --> 00:12:42,940
What did I ultimately do instead to print out hello, David or hello, so-and-so?

153
00:12:42,940 --> 00:12:44,722
Yeah?

154
00:12:44,722 --> 00:12:45,680
Sorry, a little louder?

155
00:12:45,680 --> 00:12:46,430
AUDIENCE: %s?

156
00:12:46,430 --> 00:12:51,020
DAVID MALAN: Yeah, so %s, the so-called format code that printf just knows how to deal with.

157
00:12:51,020 --> 00:12:52,470
And I had to add one other thing.

158
00:12:52,470 --> 00:12:54,850
Someone else besides %s-- yeah?

159
00:12:54,850 --> 00:12:56,050
AUDIENCE: The name of the variable.

160
00:12:56,050 --> 00:13:00,190
DAVID MALAN: The name of the variable that I want to plug into that placeholder %s.

161
00:13:00,190 --> 00:13:01,630
And in this case, it's answer.

162
00:13:01,630 --> 00:13:11,560
Now let me make one refinement only because now we're in week 2 and we're going to start writing more lines of code, even though Scratch called the return value of the ask puzzle piece, answer always.

163
00:13:11,560 --> 00:13:14,480
And see, we have full control over what our variables are called.

164
00:13:14,480 --> 00:13:19,870
And now it's probably good not to just generically always call my variable answer if I'm using get_string.

165
00:13:19,870 --> 00:13:21,050
Let's call it what it is.

166
00:13:21,050 --> 00:13:23,680
So this is now just a matter of style, if you will.

167
00:13:23,680 --> 00:13:34,000
Let me change the variable to be name just so that it's a little clearer to me, to you, to a TF or TA exactly what that variable represents instead of more generically answer.

168
00:13:34,000 --> 00:13:41,050
All right, so that said, let me go down to my terminal window, and last week again, I ran make to compile this exact same program.

169
00:13:41,050 --> 00:13:43,270
Now, though, let me go ahead and just use clang.

170
00:13:43,270 --> 00:13:45,490
So clang -o--

171
00:13:45,490 --> 00:13:49,330
I'll still call this version hello-- space, hello.c.

172
00:13:49,330 --> 00:13:51,080
So exact same command as before.

173
00:13:51,080 --> 00:13:56,330
The only thing that's different is I've added a couple of more lines of code to get the user's input.

174
00:13:56,330 --> 00:13:59,960
Let me hit Enter, and now, darn it, our first error.

175
00:13:59,960 --> 00:14:05,420
So output from clang and make is not a good thing, and here, we're seeing something particularly cryptic.

176
00:14:05,420 --> 00:14:13,480
So something in function 'main--' undefined reference to 'get_string,' string and then linker command failed with exit code 1.

177
00:14:13,480 --> 00:14:22,130
So there's actually a lot of jargon in there that will tease apart today, but my hint is that clearly my problem's in main, although that's not surprising because there's nothing else going on here.

178
00:14:22,130 --> 00:14:26,830
get_string is an issue, and the issue is that it's an undefined reference.

179
00:14:26,830 --> 00:14:28,990
And yet, notice, I was pretty good.

180
00:14:28,990 --> 00:14:39,070
I added the CS50 header file and I said last week that that's enough to teach the compiler that functions exist, but the problem is that even though this does, in fact,

181
00:14:39,070 --> 00:14:51,860
teach Clang that get_string exists, it is not sufficient information for Clang to go find on the hard drive of the computer the 0's and 1's that actually implement get_string itself.

182
00:14:51,860 --> 00:14:55,333
So in other words, this include line, per last week, is a little bit of a hint.

183
00:14:55,333 --> 00:14:59,560
It's a teaser to Clang that you're about to see and use this function somewhere.

184
00:14:59,560 --> 00:15:11,470
But if you actually want to use the 0's and 1's that CS50 wrote some time ago and bake those into your program so your program actually knows how to get input from the user, well then,

185
00:15:11,470 --> 00:15:15,440
I'm going to have to go ahead and run a slightly different command.

186
00:15:15,440 --> 00:15:16,250
So let me do this.

187
00:15:16,250 --> 00:15:23,020
Let me clear my terminal window just get rid of that distraction and let me propose now that we run this command instead.

188
00:15:23,020 --> 00:15:35,050
Almost the same as before, clang -o, space, hello, then hello.c, but with one additional command line argument at the end, and this is a -l-- not a number 1.

189
00:15:35,050 --> 00:15:39,370
So -lcs with no space in between those two.

190
00:15:39,370 --> 00:15:48,850
Now the l is going to result in all of those 0's and 1's that actually were in by CS50 being linked into your code, your few lines of code or mine here.

191
00:15:48,850 --> 00:15:58,537
But that's the second step that the compiler requires in order to know how to actually execute and rather compile your code and CS50's.

192
00:15:58,537 --> 00:16:00,370
And CS50 is not the only one that does this.

193
00:16:00,370 --> 00:16:10,000
If you use any third party library in C that doesn't come with the language, you would do -l such and such where whoever-- however they've named their own library.

194
00:16:10,000 --> 00:16:14,298
But you don't have to do it for built in things like we've been using thus far.

195
00:16:14,298 --> 00:16:16,090
All right, so let me go ahead and try this.

196
00:16:16,090 --> 00:16:23,620
I'll go back to VS Code here, and let me go ahead now and run clang -o hello, then hello.c.

197
00:16:23,620 --> 00:16:29,590
And now instead of just hitting Enter, -lcs50 with no space between the l and the cs50, Enter.

198
00:16:29,590 --> 00:16:33,310
Now nothing bad happens, and now I can do ./hello.

199
00:16:33,310 --> 00:16:34,180
What's your name?

200
00:16:34,180 --> 00:16:37,633
I'll type in David, Enter, and now we see hello, David.

201
00:16:37,633 --> 00:16:46,460
Now honestly, this is where we're really getting into the weeds, and now this is taking-- this is really just adding nuisance to the process of compiling and running your code.

202
00:16:46,460 --> 00:16:55,240
And so the reality is, even though this is indeed what is happening, this is why we used last week and we're going to continue using this week onward make because it just

203
00:16:55,240 --> 00:16:57,130
automates that whole process for you.

204
00:16:57,130 --> 00:17:05,858
But it's ideal to understand what's going wrong because any of the error messages you saw for problem set 1, any of the error messages you see for the next few weeks probably aren't coming from make,

205
00:17:05,858 --> 00:17:10,780
they're coming from Clang underneath the hood because make is just automating the process.

206
00:17:10,780 --> 00:17:17,560
But with make, you literally just write make and then the name of the program, you don't have to worry about any of those command line arguments.

207
00:17:17,560 --> 00:17:22,240
Questions, then, on compiling with dash -lcs50 or anything else?

208
00:17:22,240 --> 00:17:23,042
Yeah?

209
00:17:23,042 --> 00:17:24,959
AUDIENCE: What is the benefit of [INAUDIBLE]??

210
00:17:24,960 --> 00:17:26,220
DAVID MALAN: Sorry, what is the benefit of--

211
00:17:26,220 --> 00:17:27,512
AUDIENCE: Using Clang manually.

212
00:17:27,512 --> 00:17:30,000
DAVID MALAN: What is the benefit of using Clang manually?

213
00:17:30,000 --> 00:17:30,870
None, really.

214
00:17:30,870 --> 00:17:35,055
In fact, all main is doing is just say-- make is doing is saving us some keystrokes.

215
00:17:35,055 --> 00:17:42,090
If you prefer, though, and you just like to be more in control, you can totally run Clang manually if you remember the various command line arguments.

216
00:17:42,090 --> 00:17:42,660
Yeah?

217
00:17:42,660 --> 00:17:47,335
AUDIENCE: So why did you have to explain [INAUDIBLE]

218
00:17:47,335 --> 00:17:48,210
DAVID MALAN: Exactly.

219
00:17:48,210 --> 00:17:55,470
Why did I have to explain-- that is, provide a hint to CS50 with the cs50.h header file, but I didn't have to do that with standardio.h?

220
00:17:55,470 --> 00:18:03,060
Just because. standardio.h comes with C, just like a few other libraries come with C that we'll start seeing today.

221
00:18:03,060 --> 00:18:07,890
CS50, though, is not built into C everywhere, and so you do have to explicitly add that one there.

222
00:18:07,890 --> 00:18:08,767
Yeah?

223
00:18:08,767 --> 00:18:11,970
AUDIENCE: Can you define what command line argument [INAUDIBLE]??

224
00:18:11,970 --> 00:18:22,200
DAVID MALAN: A command line argument is a word or phrase that you type at the command line-- a.k.a., your terminal-- in order to influence the behavior of a program.

225
00:18:22,200 --> 00:18:22,742
AUDIENCE: OK.

226
00:18:22,742 --> 00:18:24,430
So it's a term for whatever you're giving it.

227
00:18:24,430 --> 00:18:24,565
DAVID MALAN: Yeah.

228
00:18:24,565 --> 00:18:25,660
It changes the defaults.

229
00:18:25,660 --> 00:18:33,460
In our GUI world, Graphical User Interface, you and I would probably click some boxes, we would select some menu options to configure a program to behave in the same way.

230
00:18:33,460 --> 00:18:39,600
At a command line interface, you have to just say everything all at once, and that's why we have command line arguments.

231
00:18:39,600 --> 00:18:40,605
Yeah?

232
00:18:40,605 --> 00:18:43,243
AUDIENCE: Is make [INAUDIBLE]

233
00:18:43,243 --> 00:18:43,910
DAVID MALAN: No.

234
00:18:43,910 --> 00:18:45,470
Make is not just for CS50.

235
00:18:45,470 --> 00:18:52,020
It's used globally in any project really nowadays using C, C++, even other languages as well.

236
00:18:52,020 --> 00:18:57,530
In fact, most every command you see in this class, unless it has 5-0 at the end of it, is globally used.

237
00:18:57,530 --> 00:19:00,758
Only those-- a suffix with 50 are, indeed, course-specific.

238
00:19:00,758 --> 00:19:06,890
And even those we'll gradually take training wheels off of so that exactly what those commands are doing as well.

239
00:19:06,890 --> 00:19:09,053
All right, so what is it that we've just done?

240
00:19:09,053 --> 00:19:15,967
Everything we've just done, of course, I keep calling compiling, but let's just go down one rabbit hole so that you understand that when you compile code,

241
00:19:15,967 --> 00:19:26,060
there's actually a whole bunch of steps, happening and this is going to enable a lot of features, like companies can write code and then convert it to run it on Macs and PCs alike

242
00:19:26,060 --> 00:19:27,240
or phones or the like.

243
00:19:27,240 --> 00:19:35,840
So it's not just a matter of converting source code to machine code, there's actually four steps involved in what you and I, as of last week, know as compiling.

244
00:19:35,840 --> 00:19:41,450
And these aren't terms that you'll have to keep in mind constantly because again, we're going to abstract a lot of this away.

245
00:19:41,450 --> 00:19:51,080
But just so we've gone down the rabbit hole once, let's consider each of these four steps that have been happening for you for a week automatically, the first of which is called preprocessing.

246
00:19:51,080 --> 00:19:52,260
So what does this mean?

247
00:19:52,260 --> 00:19:54,450
Well, let's consider that same program as before.

248
00:19:54,450 --> 00:19:57,830
So notice that two of the lines of code start with a hash mark.

249
00:19:57,830 --> 00:20:02,338
That is a special symbol in C, and it's a so-called preprocessor directive.

250
00:20:02,338 --> 00:20:07,005
You don't need to memorize terms like that, but it just means that it's a little different from every other line.

251
00:20:07,005 --> 00:20:13,315
And anything with a hash symbol here should be preprocessed-- that is, analyzed initially before anything else happens.

252
00:20:13,315 --> 00:20:17,100
So let's consider these two lines up top, what exactly is happening.

253
00:20:17,100 --> 00:20:23,390
Well, it turns out with these two lines, you have two header files, of course, cs50.h and stdio.h.

254
00:20:23,390 --> 00:20:28,550
Where are those files, because they've never been in VS Code for you, seemingly.

255
00:20:28,550 --> 00:20:35,900
If you type LS-- if you open up the File Explorer in the GUI, you have never seen, probably, cs50.h or stdio.h.

256
00:20:35,900 --> 00:20:45,690
They just work, but that's because there's a folder somewhere on the hard drive that you're using on your Mac or PC or somewhere in the cloud, as in our case.

257
00:20:45,690 --> 00:20:50,210
And inside of this folder, traditionally called /usr/include.

258
00:20:50,210 --> 00:20:51,857
And user is deliberately misspelled.

259
00:20:51,857 --> 00:20:55,760
It's just slightly more succinct, although it's a little weird why we drop that one letter.

260
00:20:55,760 --> 00:21:03,990
But usr/include is just a folder on the server that contains cs50.h, stdio.h, and a bunch of other things as well.

261
00:21:03,990 --> 00:21:15,470
So in fact, if you type in VS Code, in your terminal window, when you're using code spaces in the cloud and type LS space /usr/include, you can see all of the files in that folder.

262
00:21:15,470 --> 00:21:17,580
But we've preinstalled all of that stuff for you.

263
00:21:17,580 --> 00:21:20,390
So let's consider what's actually in those files here.

264
00:21:20,390 --> 00:21:25,370
If I highlight these two lines up top that start with hash include, well,

265
00:21:25,370 --> 00:21:32,660
I kind of hinted last week that what's in that first file is a hint as to what functions CS50 wrote for you.

266
00:21:32,660 --> 00:21:41,000
So you can kind of think of these include lines as being temporary placeholders for what's going to become like a global find and replace.

267
00:21:41,000 --> 00:21:44,270
That is the first thing clang is going to do is to preprocess this file.

268
00:21:44,270 --> 00:21:47,300
It's going to look for any line that starts with hash include.

269
00:21:47,300 --> 00:21:56,443
And if it sees that, it's going to essentially go into that file, like cs50.h, and then just copy and paste the contents of that file magically there for you.

270
00:21:56,443 --> 00:21:58,110
You don't see it visually on the screen.

271
00:21:58,110 --> 00:22:00,060
But it's happening behind the scenes.

272
00:22:00,060 --> 00:22:13,215
And so really, what's happening with this first line is that somewhere in cs50.h is the declaration of getString like we talked last week, and it probably looks a little something like this.

273
00:22:13,215 --> 00:22:17,030
And we didn't spend much time on this yet this past week, but we will in time more.

274
00:22:17,030 --> 00:22:21,470
Notice that this is how a function is declared.

275
00:22:21,470 --> 00:22:23,677
That is, it is decreed to exist.

276
00:22:23,677 --> 00:22:25,760
The name of the function, of course, is getString.

277
00:22:25,760 --> 00:22:28,310
Inside of the parentheses are its arguments.

278
00:22:28,310 --> 00:22:33,080
In this case, there's one argument to getString, I claim today, but you've known this implicitly.

279
00:22:33,080 --> 00:22:34,160
And it's a prompt.

280
00:22:34,160 --> 00:22:36,860
It's the prompt that the human sees when you use getString.

281
00:22:36,860 --> 00:22:37,790
What is that prompt?

282
00:22:37,790 --> 00:22:43,080
Well, it's a string of text, like quote unquote, "what's your name?" or anything else that I asked last week.

283
00:22:43,080 --> 00:22:46,610
Meanwhile, getString, as we know from last week, has a return value.

284
00:22:46,610 --> 00:22:48,140
It returns something to you.

285
00:22:48,140 --> 00:22:49,610
And that, too, is a string.

286
00:22:49,610 --> 00:22:52,120
So again, this is also called a functions prototype.

287
00:22:52,120 --> 00:23:02,030
It's the thing toward the end of last week that I just copied and pasted from the bottom of my file to the top, just so that it was like this teaser for clang as to what would exist later.

288
00:23:02,030 --> 00:23:11,360
So you can think, then, of these include lines as just kind of combining all of those function declarations in some separate file called cs50.h,

289
00:23:11,360 --> 00:23:18,470
so that you yourself don't have to type them every time you use the library-- or worse, so that you, yourself, don't have to copy and paste those lines.

290
00:23:18,470 --> 00:23:22,520
This is what clang is doing for you in its first step of preprocessing.

291
00:23:22,520 --> 00:23:29,175
Second, and last in this example, what happens when clang preprocesses this second include line?

292
00:23:29,175 --> 00:23:33,650
Well, the only other function we care about in this story is printf, of course, which comes with C.

293
00:23:33,650 --> 00:23:40,820
So essentially, you can think of printf's prototype or declaration as just being this.

294
00:23:40,820 --> 00:23:42,870
Printf is the name of the function.

295
00:23:42,870 --> 00:23:49,110
It takes a string that you want to format like, Hello comma world, or Hello comma %s.

296
00:23:49,110 --> 00:23:52,120
And then with dot, dot, dot, this actually has technical meaning.

297
00:23:52,120 --> 00:23:56,340
It means, of course, that you can plug-in 0 variables, 1 variable, 2 or 10.

298
00:23:56,340 --> 00:23:58,530
So dot, dot, dot means some number of variables.

299
00:23:58,530 --> 00:24:00,072
Now we haven't talked about this yet.

300
00:24:00,072 --> 00:24:05,490
And we won't really, in general. printf actually returns a value, a number, that is an integer.

301
00:24:05,490 --> 00:24:07,420
But more on that perhaps another time.

302
00:24:07,420 --> 00:24:10,920
It's generally not something the programmer tends to look at.

303
00:24:10,920 --> 00:24:21,330
But that's all we mean by preprocessing, so that at the end of this process, even though there's more lines of code in cs50.h and stdio.h, what's really just happening is that clang, in preprocessing

304
00:24:21,330 --> 00:24:31,060
the file, copies and pastes the contents of those files into your code so that now your code knows about everything-- getString, printf, and anything else.

305
00:24:31,060 --> 00:24:35,230
Any questions, then, on that first step, preprocessing?

306
00:24:35,230 --> 00:24:35,920
Yes?

307
00:24:35,920 --> 00:24:49,195
AUDIENCE: [INAUDIBLE]

308
00:24:49,195 --> 00:24:50,320
DAVID MALAN: Good question.

309
00:24:50,320 --> 00:24:54,880
When you include a file, does it only include what you need or does it include everything?

310
00:24:54,880 --> 00:24:56,420
Think of it as including everything.

311
00:24:56,420 --> 00:24:59,020
So if it's a big file, that's a lot of code at the very top.

312
00:24:59,020 --> 00:25:01,880
And that's why, if you think back to all of the zeros and ones

313
00:25:01,880 --> 00:25:08,892
I showed a little bit ago, as well as last week, there's a lot of zeros and ones that end up on the screen as a result of just writing, Hello, world.

314
00:25:08,892 --> 00:25:13,390
A lot of those zeros and ones are perhaps coming from code that you didn't actually, necessarily need.

315
00:25:13,390 --> 00:25:17,740
But some of it is perhaps there, but there are ways to optimize that as well.

316
00:25:17,740 --> 00:25:22,395
All right, so step two of compiling is, confusingly, called compiling.

317
00:25:22,395 --> 00:25:27,940
It's just, this is the term that most everyone uses to describe the whole process, instead of just this one step.

318
00:25:27,940 --> 00:25:35,865
But once a program has been preprocessed behind the scenes by the compiler for you, it looks now a little something like this.

319
00:25:35,865 --> 00:25:39,820
And I've put dot, dot, dot just to imply that, yes, to your question, there's more stuff above it.

320
00:25:39,820 --> 00:25:40,987
There's more stuff below it.

321
00:25:40,987 --> 00:25:43,070
It's just not interesting right now for us.

322
00:25:43,070 --> 00:25:44,860
So now we have just C code.

323
00:25:44,860 --> 00:25:46,960
There's no more preprocessor directives.

324
00:25:46,960 --> 00:25:52,670
At this point, all of the hash symbols and those lines of code have been preprocessed and converted to something else.

325
00:25:52,670 --> 00:25:56,380
And so now-- and this is where things get a little spooky looking.

326
00:25:56,380 --> 00:26:03,310
Here now is what happens when clang, or any compiler, literally compiles code like this.

327
00:26:03,310 --> 00:26:08,720
It converts it from this in C to this in assembly code.

328
00:26:08,720 --> 00:26:10,720
So this is among the scarier languages.

329
00:26:10,720 --> 00:26:12,580
I, myself, don't really have fond memories.

330
00:26:12,580 --> 00:26:14,805
This is not a language that many people program in.

331
00:26:14,805 --> 00:26:21,430
If you take a subsequent class in computer science, in systems, a higher level class, you might actually learn this or some variant thereof.

332
00:26:21,430 --> 00:26:29,320
But there's at least a few people out there that need to know this stuff because this is closer to what the computers themselves, nowadays, understand.

333
00:26:29,320 --> 00:26:37,960
The Intel CPUs or the AMD CPUs, the brains of today's computers and phones understand stuff that looks more like this and less like C.

334
00:26:37,960 --> 00:26:42,430
Now it's completely esoteric, but let me just highlight a few phrases.

335
00:26:42,430 --> 00:26:44,630
There's some stuff that's a little familiar.

336
00:26:44,630 --> 00:26:47,620
There is mention of main at the top there in yellow.

337
00:26:47,620 --> 00:26:49,750
There is mention of getString toward the bottom.

338
00:26:49,750 --> 00:26:52,070
There is mention of printf down below.

339
00:26:52,070 --> 00:27:00,130
So this is just another programming language called assembly language, that decades ago, humans-- myself included in school-- did write code in.

340
00:27:00,130 --> 00:27:06,070
And absolutely, some people still write this code, especially since you can write very, very efficient code.

341
00:27:06,070 --> 00:27:08,590
But it's a lot more arcane.

342
00:27:08,590 --> 00:27:11,380
It's a lot less user friendly.

343
00:27:11,380 --> 00:27:23,630
So you'll see in yellow now, these are the so-called instructions that a computer's brain or CPU understands, pushing values around, moving them, subtracting values, calling functions, and move, move,

344
00:27:23,630 --> 00:27:24,130
move.

345
00:27:24,130 --> 00:27:34,120
So really, the low-level operations that computers understand tend to be arithmetic operations-- subtraction, addition, and the like-- moving things in and out of memory.

346
00:27:34,120 --> 00:27:37,510
It's just a lot more tedious for folks like us to write code like this.

347
00:27:37,510 --> 00:27:40,450
This is why you and I tend to write stuff like this.

348
00:27:40,450 --> 00:27:46,520
And ideally, still, people like you and I tend to drag and drop puzzle pieces that sort of abstract all of that away further.

349
00:27:46,520 --> 00:27:49,420
But for now, this is, again, called assembly language.

350
00:27:49,420 --> 00:27:54,310
It is what happens when the compiler literally compiles your code.

351
00:27:54,310 --> 00:27:57,010
But of course, this, still not zeros and ones.

352
00:27:57,010 --> 00:27:58,580
So we got two steps to go.

353
00:27:58,580 --> 00:28:05,530
So when a compiler proceeds to step three, this is where things get converted to machine code.

354
00:28:05,530 --> 00:28:18,550
And when a compiler assembles your code for you, it converts what we just saw on the screen here to actual zeros and ones-- the so-called machine code that your phone or your computer understands.

355
00:28:18,550 --> 00:28:24,280
But it's worth noting that these are not necessarily all of the zeros and ones of your program.

356
00:28:24,280 --> 00:28:36,940
Yes, they are the zeros and ones that correspond to your Hello program or printf and getString and the like, but notice that here, we need one final step.

357
00:28:36,940 --> 00:28:40,100
In those zeros and ones are only your lines of code.

358
00:28:40,100 --> 00:28:43,540
But what about CS50's lines of code that we wrote to implement getString?

359
00:28:43,540 --> 00:28:46,990
What about the lines of code that humans wrote decades ago to implement printf?

360
00:28:46,990 --> 00:28:54,460
Those are somewhere on this hard drive, like on my Mac, my PC, or somewhere in the cloud, but we need to combine all of those zeros and ones

361
00:28:54,460 --> 00:29:02,420
together and link my code with CS50's code with standard I/O's code, all together.

362
00:29:02,420 --> 00:29:11,440
And so what happens in the last step, ultimately, is that if we have my code here in yellow, and then the code that CS50 wrote, and the code that the authors of C

363
00:29:11,440 --> 00:29:19,960
itself wrote, what really is happening is that somewhere, we have not only hello.c, which, obviously, I wrote, and wrote with us live here,

364
00:29:19,960 --> 00:29:28,210
there's also, let's assume, somewhere on the computer, a cs50.c file that, coincidentally, I and CS50 staff wrote years ago.

365
00:29:28,210 --> 00:29:30,790
And also, somewhere on the computer, there's another file.

366
00:29:30,790 --> 00:29:34,120
Let me oversimplify by just calling it stdio.c.

367
00:29:34,120 --> 00:29:36,850
In practice, it's probably specifically called printf.c.

368
00:29:36,850 --> 00:29:39,460
But they're somewhere, these two other files.

369
00:29:39,460 --> 00:29:48,100
And so this last step called linking takes my zeros and ones from the code I just wrote, namely this code on the screen here.

370
00:29:48,100 --> 00:29:50,810
It then grabs the zeros and ones that CS50 wrote.

371
00:29:50,810 --> 00:29:56,240
And it grabs the zeros and ones that the authors of C wrote, in order to implement the standard I/O library.

372
00:29:56,240 --> 00:30:00,750
And lastly, voila, links them all together.

373
00:30:00,750 --> 00:30:03,980
And this is the same blob of zeros and ones that we saw earlier.

374
00:30:03,980 --> 00:30:15,830
It's just now the result of preprocessing your code, compiling your code, assembling your code, linking your code, and my God, at this point, like if there were any fun in programming for you yet,

375
00:30:15,830 --> 00:30:19,620
we've just taken it all away, we just call this whole process compiling.

376
00:30:19,620 --> 00:30:20,120
Why?

377
00:30:20,120 --> 00:30:27,890
Because now that we know those steps exist-- and smart people solve that problem for us-- you and I can kind of operate at this level of abstraction

378
00:30:27,890 --> 00:30:32,420
and just assume that compiling converts source code to machine code.

379
00:30:32,420 --> 00:30:36,350
Questions, though, on any of these intermediate steps?

380
00:30:36,350 --> 00:30:37,360
Yeah?

381
00:30:37,360 --> 00:30:41,958
AUDIENCE: For linking, are different parts, like [INAUDIBLE]??

382
00:30:50,072 --> 00:30:51,280
DAVID MALAN: A good question.

383
00:30:51,280 --> 00:30:53,238
So where are all of these zeros and one stored?

384
00:30:53,238 --> 00:30:58,330
Because you and I, we've been using a browser, right? code.cs50.io, of course, is this web-based user interface.

385
00:30:58,330 --> 00:31:09,000
But again, recall from last week, even though you're using a web browser to access VS Code, that web-based version of VS code is connected to an actual server somewhere in the cloud.

386
00:31:09,000 --> 00:31:15,360
And on that server, you have your own account and your own files, and really, your own hard drive, virtually in the cloud.

387
00:31:15,360 --> 00:31:19,830
Think of it a little like Dropbox or Box or Google Drive or OneDrive or something like that.

388
00:31:19,830 --> 00:31:23,310
So you have a hard drive somewhere out there that we've provisioned for you.

389
00:31:23,310 --> 00:31:32,700
And it's on that hard drive that you have your code that you just wrote, or I just wrote, cs50.c, stdio.c, and all of the other code

390
00:31:32,700 --> 00:31:36,967
that implements the math functions and everything else that C supports.

391
00:31:36,967 --> 00:31:37,550
Good question.

392
00:31:37,550 --> 00:31:38,964
Yeah?

393
00:31:38,964 --> 00:31:51,935
AUDIENCE: So, say in the CS50 library, the line [INAUDIBLE] do we do the same exact thing [INAUDIBLE] copy paste them all the way over?

394
00:31:51,935 --> 00:31:53,060
DAVID MALAN: Good question.

395
00:31:53,060 --> 00:31:57,110
That hash includes cs50.h line at the top of my code.

396
00:31:57,110 --> 00:32:01,310
If I just replace that with the contents of cs50.c, would that work?

397
00:32:01,310 --> 00:32:03,590
Short answer, yes, that would work.

398
00:32:03,590 --> 00:32:05,400
You could copy all of the code there.

399
00:32:05,400 --> 00:32:08,577
However, there's some order of operations that might come into play.

400
00:32:08,577 --> 00:32:10,910
And so it's probably not quite as simple as copy, paste.

401
00:32:10,910 --> 00:32:13,190
But conceptually, yes, that's what's happening.

402
00:32:13,190 --> 00:32:25,670
Now with that said, in cs50.h, are only the prototypes of the functions, the hints as to how the functions look, what their return type is, what their name is, and what their arguments are.

403
00:32:25,670 --> 00:32:29,867
It's in the dot c file that actual code tends to be written.

404
00:32:29,867 --> 00:32:33,920
And this is a little confusing now because you and I have only written code in dot c files.

405
00:32:33,920 --> 00:32:40,460
But in the next few weeks, you'll actually start writing some of your own dot h files as well, just like CS50, just like standard I/O.

406
00:32:40,460 --> 00:32:46,020
But in essence, that line of code just makes it easier to use and reuse code that's already been written.

407
00:32:46,020 --> 00:32:47,750
And that's the whole point of a library.

408
00:32:47,750 --> 00:32:50,327
AUDIENCE: Does linking them [INAUDIBLE]?

409
00:32:50,327 --> 00:32:51,910
DAVID MALAN: Say that a little louder.

410
00:32:51,910 --> 00:32:54,472
AUDIENCE: Does linking happen when you use the compiler?

411
00:32:54,472 --> 00:32:55,180
DAVID MALAN: Yes.

412
00:32:55,180 --> 00:32:56,980
Does linking happen when you compile your code?

413
00:32:56,980 --> 00:32:57,480
Yes.

414
00:32:57,480 --> 00:33:04,570
When you run make, as we have been doing the past week now, all four of these steps are happening.

415
00:33:04,570 --> 00:33:07,780
Preprocessing converts the hash include lines to something else.

416
00:33:07,780 --> 00:33:14,290
Compiling technically converts it to assembly code, which the Mac, the PC, the server more closely understands.

417
00:33:14,290 --> 00:33:20,080
Assembly converts that language to binary machine code that this computer actually understands.

418
00:33:20,080 --> 00:33:22,540
And then linking combines everything together.

419
00:33:22,540 --> 00:33:32,860
And in fact, if you think back a few minutes ago to when I did this -lcs50, the reason I had to add that, and the reason my code did not compile at first, was because I

420
00:33:32,860 --> 00:33:38,650
forgot to tell clang to link in CS50's zeros and ones per that last step.

421
00:33:38,650 --> 00:33:44,480
I don't need to do -lstdio because it comes with C, so that would just be tedious for everyone in the world.

422
00:33:44,480 --> 00:33:47,140
But CS50 does not come with C, so we link that in.

423
00:33:47,140 --> 00:33:49,780
And to be clear, too, we won't always use CS50's library.

424
00:33:49,780 --> 00:33:53,072
That'll be yet another pair of training wheels we take off in the coming weeks.

425
00:33:53,072 --> 00:33:55,000
But for now, it makes a few things simpler.

426
00:33:55,000 --> 00:33:57,284
Yeah?

427
00:33:57,284 --> 00:33:59,750
AUDIENCE: What is the [INAUDIBLE]?

428
00:34:08,878 --> 00:34:10,170
DAVID MALAN: Short answer, yes.

429
00:34:10,170 --> 00:34:12,870
So what do the zeros and ones, the machine code, translate to?

430
00:34:12,870 --> 00:34:17,340
Yes, there is a one-to-one relationship between the machine code and the assembly code.

431
00:34:17,340 --> 00:34:21,510
Assembly code, it's not really English, but at least it's symbols I recognize.

432
00:34:21,510 --> 00:34:22,800
It's not zeros and ones.

433
00:34:22,800 --> 00:34:24,810
Machine code, of course, is just zeros and ones.

434
00:34:24,810 --> 00:34:30,630
So back in the day, before C existed, people were programming only in assembly code.

435
00:34:30,630 --> 00:34:34,469
Before assembly code existed, people were coding in zeros and ones.

436
00:34:34,469 --> 00:34:40,110
And you can imagine just how painful that was, and so each of these languages makes life, for us, sort of easier and easier.

437
00:34:40,110 --> 00:34:48,090
In a few weeks, we'll transition to Python, which will, in turn, make C even simpler-- or coding, in general, simpler to do too.

438
00:34:48,090 --> 00:34:55,060
All right, so with that said, what now can we-- what could go wrong with this?

439
00:34:55,060 --> 00:34:59,233
Well, it turns out that besides compiling, technically speaking, there's decompiling.

440
00:34:59,233 --> 00:35:01,150
And we've not done this, and we won't do this.

441
00:35:01,150 --> 00:35:04,080
But it's worth considering for just a moment.

442
00:35:04,080 --> 00:35:14,580
If you were to not compile your code, but decompile it-- as the word suggests, this just means reversing the process, converting it, ideally, from machine code-- zeros and ones--

443
00:35:14,580 --> 00:35:22,080
maybe back to C. Now this would be cool, perhaps, if all you have is a program, you can convert it and see the actual source code.

444
00:35:22,080 --> 00:35:28,650
What might a downside be, if anyone on the internet is able to decompile code on their machine?

445
00:35:28,650 --> 00:35:29,160
Yeah?

446
00:35:29,160 --> 00:35:30,270
AUDIENCE: [INAUDIBLE]

447
00:35:30,270 --> 00:35:35,430
DAVID MALAN: OK, so it's easier to find bugs in the code that-- oh, to exploit.

448
00:35:35,430 --> 00:35:45,080
So it might be easier to hack into the software by finding mistakes you and I made because, literally, they're staring at you in code, whereas the zeros and ones make it way less obvious.

449
00:35:45,080 --> 00:35:48,140
Other downsides of what I called decompiling?

450
00:35:48,140 --> 00:35:49,970
Yeah?

451
00:35:49,970 --> 00:35:53,690
AUDIENCE: If stuff is copyrighted or you don't even know how to get it--

452
00:35:53,690 --> 00:35:54,440
DAVID MALAN: Yeah.

453
00:35:54,440 --> 00:35:55,948
AUDIENCE: [INAUDIBLE]

454
00:35:55,948 --> 00:36:03,660
DAVID MALAN: Yeah, if your code, your work, is your intellectual property, copyrighted or otherwise, that's kind of obnoxious that someone can just run a command, and boom,

455
00:36:03,660 --> 00:36:05,577
they can see the original code that you wrote.

456
00:36:05,577 --> 00:36:08,490
Now, it turns out it's not quite as simple as that.

457
00:36:08,490 --> 00:36:19,400
And so even though, yes, you could take a program like Hello, or even Microsoft Word, and convert it from zeros and ones back to some form of source code-- be it in C or Java

458
00:36:19,400 --> 00:36:25,800
or Python or something else, whatever it was originally written in-- odds are it's going to be an utter mess to look at.

459
00:36:25,800 --> 00:36:26,300
Why?

460
00:36:26,300 --> 00:36:30,890
Because things variable names are not retained in the zeros and ones, typically.

461
00:36:30,890 --> 00:36:33,980
Function names might not be retained in the zeros and ones.

462
00:36:33,980 --> 00:36:42,890
The code is, the logic is, but the computer doesn't care what pretty variables you chose and how nicely named your functions were, it just needs to know them as zeros and ones.

463
00:36:42,890 --> 00:36:46,370
Moreover, if you think about last week, we introduced things like loops in C.

464
00:36:46,370 --> 00:36:49,745
And besides for loops, there's what other kind of loop, for instance?

465
00:36:49,745 --> 00:36:50,620
AUDIENCE: [INAUDIBLE]

466
00:36:50,620 --> 00:36:59,910
DAVID MALAN: So, a while loop-- and even though they look different and you have to write different code, they achieve exactly the same functionality, which is to say, when you compile a for loop

467
00:36:59,910 --> 00:37:07,420
or you compile a while loop, if they logically do the same thing, they might end up looking identical as zeros and ones.

468
00:37:07,420 --> 00:37:11,820
And so, therefore, it's not necessarily predictable that you'll get back the original code, why?

469
00:37:11,820 --> 00:37:19,350
Because the zeros and ones might not know, so to speak, whether it was a for loop or a while loop, so maybe compiling will show you one or the other.

470
00:37:19,350 --> 00:37:24,570
And honestly, decompiling, while possible-- and it's one way of reverse engineering someone's product.

471
00:37:24,570 --> 00:37:34,020
Odds are, if you're good enough to start reading code that's been decompiled and reading through the messiness of it, odds are you have the talent probably to just write that same program from scratch

472
00:37:34,020 --> 00:37:34,650
yourself.

473
00:37:34,650 --> 00:37:40,410
Now, that's an overstatement, perhaps, but it's not quite as easy or threatening as you might first think.

474
00:37:40,410 --> 00:37:50,040
So in general, once code is compiled, it's pretty challenging, time consuming, costly to reverse engineer it, much like it would be in the real world, right?

475
00:37:50,040 --> 00:37:52,860
Like all of us have some kind of phone, probably, nowadays in our pocket.

476
00:37:52,860 --> 00:37:57,060
There's nothing stopping you from opening it up somehow, poking around, recreating what's there.

477
00:37:57,060 --> 00:37:59,130
That's a huge amount of effort, most likely.

478
00:37:59,130 --> 00:38:03,310
And at that point, maybe you should just invent the phone, instead of trying to reverse engineer it.

479
00:38:03,310 --> 00:38:06,330
So same kind of idea in the physical world.

480
00:38:06,330 --> 00:38:13,050
Any questions, then, on compiling, or even decompiling in these forms?

481
00:38:13,050 --> 00:38:17,160
All right, so odds are, at this point, not only I, but you have made mistakes.

482
00:38:17,160 --> 00:38:26,490
And you've written buggy code-- a bug in a code is just a mistake, a logical error or otherwise, where the code just does not behave correctly as you intend.

483
00:38:26,490 --> 00:38:35,320
And up until now, odds are, your debugging techniques have been to maybe look back at what I did in class, maybe ask a question online or in-person.

484
00:38:35,320 --> 00:38:39,570
But ultimately, it'd be nice if you had some tools of your own with which to debug code.

485
00:38:39,570 --> 00:38:41,587
And this, honestly, is a lifelong skill.

486
00:38:41,587 --> 00:38:47,910
You're not going to emerge from CS50-- and even 20 years from now, you're not going to be writing-- if you're writing code at all-- correct code all of the time.

487
00:38:47,910 --> 00:38:50,820
Like, all of us on the staff continue to write bugs.

488
00:38:50,820 --> 00:38:55,540
Hopefully, they get a little more sophisticated, and not sort of like, oops, I missed a semicolon.

489
00:38:55,540 --> 00:38:57,660
But even those kinds of mistakes, we make too.

490
00:38:57,660 --> 00:39:03,550
But there's tools out there and techniques that can make your life easier when it comes to solving those problems.

491
00:39:03,550 --> 00:39:06,360
Now, the term bug has actually been around for decades.

492
00:39:06,360 --> 00:39:13,650
But a fun story to tell is that the first documented actual bug was actually somehow connected to Harvard.

493
00:39:13,650 --> 00:39:22,890
In fact, this is the logbook relating to the Harvard Mark II computer from 1947, whereby if you read the notes here-- and I'll Zoom in-- this

494
00:39:22,890 --> 00:39:29,160
was an actual moth discovered inside of this big mainframe computer that was causing some kind of problems.

495
00:39:29,160 --> 00:39:33,610
And the engineers there at the time actually thought it was funny that, wow, physical bug actually explains the issue.

496
00:39:33,610 --> 00:39:39,090
And it's been forever taped to this sheet of paper, which I believe now is on display in the Smithsonian.

497
00:39:39,090 --> 00:39:43,260
With that said, this is just representative, too, of a logical bug.

498
00:39:43,260 --> 00:39:53,640
And that story is actually-- that story was often retold by a famous mathematician, then computer scientist really, Dr. Grace Hopper, who actually worked not only on the Harvard Mark II

499
00:39:53,640 --> 00:39:57,210
computer, but its predecessor, the Harvard Mark I.

500
00:39:57,210 --> 00:40:04,103
And if you ever spent time, yet, in the engineering building across the river here, you can actually see much of this computer, which

501
00:40:04,103 --> 00:40:07,020
is along the wall when you first walk into the Science and Engineering

502
00:40:07,020 --> 00:40:07,530
Complex.

503
00:40:07,530 --> 00:40:11,070
And indeed, as you've probably heard growing up, this is a mainframe computer.

504
00:40:11,070 --> 00:40:18,240
This is what Macs and PCs, so to speak, looked like back in the day, with very physical things that essentially implemented the zeros

505
00:40:18,240 --> 00:40:22,410
and ones that you and I take for granted now being miniaturized in our laptops and phones.

506
00:40:22,410 --> 00:40:23,910
So there's a piece of history there.

507
00:40:23,910 --> 00:40:27,390
If you visit that side of campus sometime, do take a look.

508
00:40:27,390 --> 00:40:31,350
But let's consider, then, how we solve not, of course, physical bugs, but logical bugs.

509
00:40:31,350 --> 00:40:40,320
And let's consider something like this from last week, whereby, we were trying very simply to print like this column of three bricks using hashtags of sorts.

510
00:40:40,320 --> 00:40:44,400
So let me go over here in just a moment to VS Code.

511
00:40:44,400 --> 00:40:47,080
And I'm going to go ahead and open a program I wrote in advance.

512
00:40:47,080 --> 00:40:51,510
And I'm bringing it to class because there's a bug in it, and I'd like to figure out how to solve this bug.

513
00:40:51,510 --> 00:40:56,160
So let me open up a buggy0.c, which is version 0 of my code.

514
00:40:56,160 --> 00:40:58,200
And let's just take a quick peek at what's here.

515
00:40:58,200 --> 00:40:58,950
It's pretty short.

516
00:40:58,950 --> 00:41:07,797
It includes only stdio.h, it uses printf, it uses a for loop, and the goal, quite simply, is to print out that column of three bricks.

517
00:41:07,797 --> 00:41:13,360
Now, it's short enough that some of you, if you're getting comfy already with C, you might already see the logical bug.

518
00:41:13,360 --> 00:41:16,200
It's not a syntax error, like it will compile and run.

519
00:41:16,200 --> 00:41:17,280
But there's a bug there.

520
00:41:17,280 --> 00:41:27,745
And suppose that I'm very new to C, I'm very uncomfortable with C, it's 2:00 AM and I just can't see the bug, what are my recourses here for actually finding a mistake like this?

521
00:41:27,745 --> 00:41:29,370
Well, first, let's look at the symptom.

522
00:41:29,370 --> 00:41:31,740
Let me go down to my terminal window.

523
00:41:31,740 --> 00:41:36,120
I'm going to use make buggy0 because, again, the file is called buggyo.c.

524
00:41:36,120 --> 00:41:37,260
I'm not going to use clang.

525
00:41:37,260 --> 00:41:39,880
In fact, I'm never really going to use clang manually here on out.

526
00:41:39,880 --> 00:41:42,430
I'm just going to use make because it makes our lives easier.

527
00:41:42,430 --> 00:41:43,560
It does compile.

528
00:41:43,560 --> 00:41:45,390
No errors, so it's not syntax.

529
00:41:45,390 --> 00:41:47,670
It's not something silly like a missing semicolon.

530
00:41:47,670 --> 00:41:59,610
But when I run ./buggy0, I, of course, see one, two, three, four-- and this, of course, does not match the one, two, three bricks that I actually intended for that column.

531
00:41:59,610 --> 00:42:02,970
And yet, I'm starting counting at 0, as I usually do.

532
00:42:02,970 --> 00:42:03,930
I've got three.

533
00:42:03,930 --> 00:42:05,280
I'm going up to three.

534
00:42:05,280 --> 00:42:06,780
So where is my logical error?

535
00:42:06,780 --> 00:42:10,150
If it hasn't obviously jumped out at you already, well, how can I solve this?

536
00:42:10,150 --> 00:42:16,080
Well, first and foremost, perhaps the best technique for solving bugs, at least early on, is just use printf.

537
00:42:16,080 --> 00:42:20,020
Like thus far, we've used sprint say, Hello, and other things on the screen.

538
00:42:20,020 --> 00:42:22,530
But printf is just a function for printing anything.

539
00:42:22,530 --> 00:42:31,350
And there's no reason you can't temporarily use printf to print out the contents of variables, what's going on inside of your program, just to figure out where your mistake is.

540
00:42:31,350 --> 00:42:32,940
And then you can delete that line of code later.

541
00:42:32,940 --> 00:42:34,600
It doesn't have to stay there forever.

542
00:42:34,600 --> 00:42:35,740
So let me do this.

543
00:42:35,740 --> 00:42:45,690
Instead of just printing out in VS Code the hash symbol, let me do a little safety check here and print out the value of i.

544
00:42:45,690 --> 00:42:51,610
So let me go ahead and say something like, i is-- now I want to say i is this.

545
00:42:51,610 --> 00:42:54,540
But, of course, this is not how I print out the value of i.

546
00:42:54,540 --> 00:42:58,930
If I want to print out the value of i, what should I put here?

547
00:42:58,930 --> 00:43:02,160
So %i for integer, instead of %s for string.

548
00:43:02,160 --> 00:43:03,410
So they're still placeholders.

549
00:43:03,410 --> 00:43:04,930
But we use %s for integers.

550
00:43:04,930 --> 00:43:09,250
And now if I want to print out i, I just need the comma as the second argument, and then i.

551
00:43:09,250 --> 00:43:13,000
All right, let me go ahead and back to my terminal window.

552
00:43:13,000 --> 00:43:15,760
Let me recompile the program because I've changed it.

553
00:43:15,760 --> 00:43:18,880
That still works fine, ./buggy0.

554
00:43:18,880 --> 00:43:22,540
And now, let me increase the size of my terminal window here.

555
00:43:22,540 --> 00:43:25,510
You just see some diagnostic information, if you will.

556
00:43:25,510 --> 00:43:26,560
This is not the goal.

557
00:43:26,560 --> 00:43:30,070
This is not what you should be submitting for this homework problem, were it one.

558
00:43:30,070 --> 00:43:34,450
But it is helping us diagnostically know that, OK, when i is zero, here's a hash.

559
00:43:34,450 --> 00:43:36,182
When i is 1, here's a hash.

560
00:43:36,182 --> 00:43:37,390
When i is two, here's a hash.

561
00:43:37,390 --> 00:43:39,017
When i is 3, here's a hash.

562
00:43:39,017 --> 00:43:39,850
Well, wait a minute.

563
00:43:39,850 --> 00:43:41,530
That's one, two, three, four.

564
00:43:41,530 --> 00:43:44,360
So clearly, I'm printing it one too many times.

565
00:43:44,360 --> 00:43:48,130
So let me look back at the code here by shrinking my terminal window.

566
00:43:48,130 --> 00:43:53,080
And let me just ask the group, where is, in fact, the mistake?

567
00:43:53,080 --> 00:43:56,080
Or what, equivalently, would be the solution?

568
00:43:56,080 --> 00:43:57,561
Yeah, in the middle.

569
00:43:57,561 --> 00:44:00,020
AUDIENCE: [INAUDIBLE]

570
00:44:00,020 --> 00:44:03,550
DAVID MALAN: Yeah, instead of less than or equal to, use just less than.

571
00:44:03,550 --> 00:44:05,300
So you've got to kind of pick a lane here.

572
00:44:05,300 --> 00:44:10,880
If you're going to start counting from 0, you generally use less than, and go up to, but not through the value.

573
00:44:10,880 --> 00:44:17,300
Or if you prefer, like in the human world, counting from 1 on up, you can use less than or equal to, but you have to be consistent.

574
00:44:17,300 --> 00:44:22,610
And in general, as a programmer, just always start counting from 0 if you're doing something canonical like this.

575
00:44:22,610 --> 00:44:27,860
But the solution is, indeed, just to change this by changing the greater less than or equal to the less than.

576
00:44:27,860 --> 00:44:36,500
If I recompile this program with make buggy0, and then do .buggy0 again-- and let me increase the size of my terminal window.

577
00:44:36,500 --> 00:44:39,050
Now, you see, OK, almost the same output.

578
00:44:39,050 --> 00:44:44,330
But indeed, i starts at 0 and goes up to, but not through, three.

579
00:44:44,330 --> 00:44:48,920
All right, so printf, in short, can be your first diagnostic tool.

580
00:44:48,920 --> 00:44:51,500
Instead of just staring at the screen or raising your hand--

581
00:44:51,500 --> 00:44:57,287
I mean, use printf to see, literally, what's going on inside of your program by just printing out things of interest.

582
00:44:57,287 --> 00:45:02,840
And then once you've solved the problem, you can go back into your code, as I'll do here, by shrinking my terminal window.

583
00:45:02,840 --> 00:45:04,610
I'll delete the printf line.

584
00:45:04,610 --> 00:45:08,870
And now I'm ready to share this program with the world or submit it as homework or the like.

585
00:45:08,870 --> 00:45:11,390
It's just meant there to be temporary.

586
00:45:11,390 --> 00:45:15,440
Any questions on printf as a debugging tool?

587
00:45:18,010 --> 00:45:18,510
No?

588
00:45:18,510 --> 00:45:20,970
All right, well, that only gets us so far.

589
00:45:20,970 --> 00:45:28,860
And honestly, as your programs grow and grow and grow, it's going to actually get really annoying to start going in and adding printf's, then removing them, and figuring out,

590
00:45:28,860 --> 00:45:31,860
if you've got multiple printf's, well, which one printed what?

591
00:45:31,860 --> 00:45:34,560
It just gets messy, eventually, to rely on printf alone.

592
00:45:34,560 --> 00:45:41,040
So being a computer scientist, computer scientists have written software to make it easier to debug code.

593
00:45:41,040 --> 00:45:48,610
That software is what we would generally call a debugger, which would be the second tool of the trade that you can use to actually solve problems in your code.

594
00:45:48,610 --> 00:45:52,690
Now, in the world of VS code, there's actually a debugger built in.

595
00:45:52,690 --> 00:45:58,260
So the graphical user interface you're about to see in VS Code isn't specific to CS50, it actually comes with VS Code.

596
00:45:58,260 --> 00:46:03,030
And it supports C, and C++, and Java, and Python, and lots of other languages too.

597
00:46:03,030 --> 00:46:07,650
But it's, admittedly, a little complicated to just start using the debugger.

598
00:46:07,650 --> 00:46:13,480
You have to create a configuration file and do some annoying steps that just get in the way of solving real problems.

599
00:46:13,480 --> 00:46:17,070
So we have automated the process for you of just starting the debugger.

600
00:46:17,070 --> 00:46:19,680
And thereafter, it's sort of industry standard how you use it.

601
00:46:19,680 --> 00:46:23,380
But we save you the headache of having to create those configuration files.

602
00:46:23,380 --> 00:46:25,330
So, suppose I want to do this.

603
00:46:25,330 --> 00:46:30,330
Suppose I want to try to debug this program step by step using special software.

604
00:46:30,330 --> 00:46:31,810
Well, how can I do that?

605
00:46:31,810 --> 00:46:41,790
Well, let me propose that if I revert this back to the original version where i was less than or equal to 3, I'm pretty sure that I was printing too many hashes.

606
00:46:41,790 --> 00:46:45,160
So I'm going to do this-- and you might have done this accidentally or never at all.

607
00:46:45,160 --> 00:46:54,390
But notice if you hover over the gutter, so to speak, in VS Code, the part of it all the way to the left of the editor, you see this sort of grayed out red dot.

608
00:46:54,390 --> 00:46:57,240
If you click there, it becomes a brighter red dot.

609
00:46:57,240 --> 00:46:59,670
And this represents what we're going to call a breakpoint.

610
00:46:59,670 --> 00:47:07,350
And this is just a visual indicator that you've put like a stop sign equivalent there, and you're telling the debugger in a moment, stop running my code there.

611
00:47:07,350 --> 00:47:07,920
Why?

612
00:47:07,920 --> 00:47:14,380
Because I prefer to step through my code at sort of a human speed, and not as computer speed where it runs all at once.

613
00:47:14,380 --> 00:47:16,750
So I've set my breakpoint, which is step one.

614
00:47:16,750 --> 00:47:18,580
And then step two is quite simply this.

615
00:47:18,580 --> 00:47:26,010
Instead of running the program itself, run the command called debug50, and then ./buggy0.

616
00:47:26,010 --> 00:47:33,060
And now this will start your program, but inside of the debugger, which is a special program that smart people wrote that will empower

617
00:47:33,060 --> 00:47:38,970
you to now step through your code line by line, and again, at your own comfort pace.

618
00:47:38,970 --> 00:47:43,080
I'm going to hit Enter, some stuff's going to happen on the screen-- whoops.

619
00:47:43,080 --> 00:47:45,767
Notice, this is a common mistake that I made accidentally here.

620
00:47:45,767 --> 00:47:47,100
Looks like I've changed my code.

621
00:47:47,100 --> 00:47:49,892
I did because I went in and changed the less than or equal to sign.

622
00:47:49,892 --> 00:47:52,860
So let me go ahead and rerun make buggy0--

623
00:47:52,860 --> 00:47:53,520
Enter.

624
00:47:53,520 --> 00:47:55,590
Good, now let me rerun debug50--

625
00:47:55,590 --> 00:47:57,810
Enter.

626
00:47:57,810 --> 00:48:06,010
And now some stuff just happened on the screen and it takes a moment to get started but once it's started you'll see this you'll still see your code.

627
00:48:06,010 --> 00:48:09,410
But you'll see this yellow highlight, which you've probably not seen before.

628
00:48:09,410 --> 00:48:13,440
And notice that it's specifically highlighting the same line that I set a breakpoint on.

629
00:48:13,440 --> 00:48:13,950
Why?

630
00:48:13,950 --> 00:48:20,670
That just means the debugger has executed all of these lines, except for line 7.

631
00:48:20,670 --> 00:48:23,340
It has broken at-- not in a bad way.

632
00:48:23,340 --> 00:48:27,580
But it has paused execution on line 7, so it hasn't yet printed any hashes.

633
00:48:27,580 --> 00:48:30,450
And you can see that-- no hashes in the terminal window yet.

634
00:48:30,450 --> 00:48:31,980
It's paused execution.

635
00:48:31,980 --> 00:48:37,410
But what's interesting with the debugger is the stuff over here on the left-hand side.

636
00:48:37,410 --> 00:48:41,910
In the debugger here, you'll see, under variables, all of your so-called local variables.

637
00:48:41,910 --> 00:48:45,327
And we haven't really made a distinction between local and something called global.

638
00:48:45,327 --> 00:48:49,390
But for now, local variables just means all of the variables that exist in your function.

639
00:48:49,390 --> 00:48:52,110
So i currently has a value of 0.

640
00:48:52,110 --> 00:48:53,410
OK, and that makes sense.

641
00:48:53,410 --> 00:48:57,360
So now, how do I step through my code and see what it's doing?

642
00:48:57,360 --> 00:49:03,630
Well, at the top of the screen here, you'll see some playback icons, kind of like a video player, but they have special meaning.

643
00:49:03,630 --> 00:49:07,892
This first one will just play the rest of your program all the way to the end.

644
00:49:07,892 --> 00:49:13,110
So you only click that if you've sort of solved the problem and you just want to run it to completion like before.

645
00:49:13,110 --> 00:49:16,920
But the next three-- or next two, really, are really the juiciest.

646
00:49:16,920 --> 00:49:21,930
The second one here, if you hover over it, eventually, you'll see that it's called Step Over.

647
00:49:21,930 --> 00:49:28,630
Step Over means that the debugger will run this currently highlighted line of code, but it's not going to dive into it.

648
00:49:28,630 --> 00:49:32,827
So if it's a function like printf, it's not going to start stepping through printf line by line.

649
00:49:32,827 --> 00:49:33,327
Why?

650
00:49:33,327 --> 00:49:36,420
Because I can pretty much assume printf, written decades ago, is correct.

651
00:49:36,420 --> 00:49:38,050
Problem's probably with me.

652
00:49:38,050 --> 00:49:46,110
But this next line, if I did really want to step into the printf code to figure out how it works or find some problem in it all these years later,

653
00:49:46,110 --> 00:49:54,250
you can step into printf, and then the screen would change, and you'd see each of the lines for printf, line by line-- at least if you have the source code for printf installed.

654
00:49:54,250 --> 00:49:56,490
All right, I'm going to use the first one, Step Over.

655
00:49:56,490 --> 00:49:59,130
And watch as the yellow highlight moves.

656
00:49:59,130 --> 00:50:03,060
And watch as, in the terminal window, there's a hash symbol.

657
00:50:03,060 --> 00:50:03,780
Here we go.

658
00:50:03,780 --> 00:50:05,130
There's one hash.

659
00:50:05,130 --> 00:50:07,230
Now, notice line 5 is highlighted.

660
00:50:07,230 --> 00:50:09,480
That means it has paused on line 5.

661
00:50:09,480 --> 00:50:11,350
Line 5 has not yet been executed.

662
00:50:11,350 --> 00:50:12,600
So what does that mean?

663
00:50:12,600 --> 00:50:16,320
The value of i, per the top left-hand corner, is still 0.

664
00:50:16,320 --> 00:50:24,470
But as soon as I click Step Over again, watch what happens at the top left, where i is a variable on the screen.

665
00:50:24,470 --> 00:50:27,920
Now i-- and it flashed briefly-- has a value of 1.

666
00:50:27,920 --> 00:50:30,650
And now if I step over again, watch the terminal window.

667
00:50:30,650 --> 00:50:32,120
There's my second hash.

668
00:50:32,120 --> 00:50:36,380
Now, let me click Step Over on for loop, watch the variable at top left.

669
00:50:36,380 --> 00:50:38,567
Now 1 goes to 2.

670
00:50:38,567 --> 00:50:39,650
Now let me click it again.

671
00:50:39,650 --> 00:50:43,220
Third hash-- and here's where the logical error is perhaps revealed.

672
00:50:43,220 --> 00:50:45,210
Let me go ahead and step over the loop.

673
00:50:45,210 --> 00:50:46,520
Now i is 3.

674
00:50:46,520 --> 00:50:49,280
Wait a minute, I'm still going to print out a hash.

675
00:50:49,280 --> 00:50:49,810
There it is.

676
00:50:49,810 --> 00:50:50,810
There's the fourth hash.

677
00:50:50,810 --> 00:50:53,852
And at this point, hopefully, the light bulb, proverbially, has gone off.

678
00:50:53,852 --> 00:50:55,020
I realize, oh, I screwed up.

679
00:50:55,020 --> 00:51:02,493
I can either stop the program altogether with the red square, or I can just let it run all the way to the end, which just terminates everything.

680
00:51:02,493 --> 00:51:05,660
At this point, I just want to get back into my code and start fixing things.

681
00:51:05,660 --> 00:51:10,670
And you can close, for instance, as I will here, the File Explorer, just to hide the panel that opened.

682
00:51:10,670 --> 00:51:12,320
So that's debug50.

683
00:51:12,320 --> 00:51:19,520
But it's not a CS50 thing, that just starts the debugger for you, which is something you'd find in most any programming environment nowadays.

684
00:51:19,520 --> 00:51:23,670
Questions on debugging?

685
00:51:23,670 --> 00:51:24,170
Questions?

686
00:51:24,170 --> 00:51:24,670
Yeah?

687
00:51:24,670 --> 00:51:27,295
AUDIENCE: Where does it tell you where it went wrong?

688
00:51:27,295 --> 00:51:28,420
DAVID MALAN: Good question.

689
00:51:28,420 --> 00:51:30,310
Where does it tell you where it went wrong?

690
00:51:30,310 --> 00:51:33,190
So, sadly, it does not tell you any of that.

691
00:51:33,190 --> 00:51:39,580
The onus is still on you, the human, to use this tool productively to walk through your code at a saner pace.

692
00:51:39,580 --> 00:51:42,070
But your brain is the one that still needs to solve it.

693
00:51:42,070 --> 00:51:49,160
And I don't doubt, down the line, with artificial intelligence and more, programs like this will get all the more helpful, and start answering questions like that for us.

694
00:51:49,160 --> 00:51:52,990
And there are other tools we'll introduce you this semester that are even more powerful than this.

695
00:51:52,990 --> 00:51:57,820
But for now, it's just a tool, really, to slow things down and not have to change your code.

696
00:51:57,820 --> 00:52:06,820
The fact that I had that panel on the left that just showed me i's changing value is just an alternative to printf, and I can step through it a little more slowly.

697
00:52:06,820 --> 00:52:10,580
Other questions on debugging?

698
00:52:10,580 --> 00:52:11,080
No?

699
00:52:11,080 --> 00:52:14,950
Let me show you one final example with this debugger here.

700
00:52:14,950 --> 00:52:16,750
And this one, too, I wrote in advance.

701
00:52:16,750 --> 00:52:18,730
Let me close buggy0.c.

702
00:52:18,730 --> 00:52:22,327
And let me open up buggy1.c, my second version thereof.

703
00:52:22,327 --> 00:52:28,030
Let me close my terminal window for a second and give you a quick tour of this program, which similarly, has a mistake.

704
00:52:28,030 --> 00:52:32,830
Now, at the top of this program, some familiar includes, cs50.h and stdio.h.

705
00:52:32,830 --> 00:52:34,730
This is not something we've seen before.

706
00:52:34,730 --> 00:52:38,830
It's specific to this example-- a function called getNegativeInt.

707
00:52:38,830 --> 00:52:41,043
Takes no arguments, and it returns an integer.

708
00:52:41,043 --> 00:52:41,710
What does it do?

709
00:52:41,710 --> 00:52:45,040
It literally gets a negative integer, ideally, from the user.

710
00:52:45,040 --> 00:52:47,200
Fun fact, though, it doesn't correctly.

711
00:52:47,200 --> 00:52:50,090
That's the bug. getNegativeInt is broken at the moment.

712
00:52:50,090 --> 00:52:51,470
So what does main do?

713
00:52:51,470 --> 00:52:55,690
Well, main just calls this function, passing in nothing in parentheses, no inputs.

714
00:52:55,690 --> 00:52:58,240
And it stores the return value in i.

715
00:52:58,240 --> 00:53:00,260
And then it just prints out i on the screen.

716
00:53:00,260 --> 00:53:06,365
So honestly, just by eyeballing this, I feel comfortable enough with programming in C, I think main is correct.

717
00:53:06,365 --> 00:53:07,990
Let me just stipulate, main is correct.

718
00:53:07,990 --> 00:53:09,698
But there is going to be a bug down here.

719
00:53:09,698 --> 00:53:11,210
Now, what's the bug down here?

720
00:53:11,210 --> 00:53:14,830
Well, let me look at getNegativeInt's implementation.

721
00:53:14,830 --> 00:53:18,970
Notice, this first line, 12, is identical to the prototype up here.

722
00:53:18,970 --> 00:53:26,690
The prototype is sort of stupidly required up here because C reads things top to bottom, left to right-- the compiler technically does.

723
00:53:26,690 --> 00:53:36,820
So if you reference getNegativeInt here, but you don't implement it until down here, and you haven't told C in advance that it will exist, again, you get the error we saw last week.

724
00:53:36,820 --> 00:53:39,010
All right, so how does getNegativeInt work?

725
00:53:39,010 --> 00:53:40,960
We declare a variable called n.

726
00:53:40,960 --> 00:53:43,540
We've got to do while loop that does what?

727
00:53:43,540 --> 00:53:47,110
It uses getInt, which comes with the cs50 library, per last week.

728
00:53:47,110 --> 00:53:51,670
It prompts the user for negative integer, quote unquote, and stores the value in n.

729
00:53:51,670 --> 00:53:56,800
I then do all of this while n is less than 0, right?

730
00:53:56,800 --> 00:54:04,970
Remember, we used to do while loop last week to make sure the human cooperates and doesn't give us the wrong type of value, be it positive or negative or something else.

731
00:54:04,970 --> 00:54:06,400
And then we return n.

732
00:54:06,400 --> 00:54:07,570
And there's some subtleties.

733
00:54:07,570 --> 00:54:15,790
Anyone recall-- or have an intuition for why I've declared n on line 14, instead of line 17?

734
00:54:15,790 --> 00:54:17,620
This is a C specific thing.

735
00:54:17,620 --> 00:54:23,465
AUDIENCE: [INAUDIBLE]

736
00:54:23,465 --> 00:54:24,340
DAVID MALAN: Exactly.

737
00:54:24,340 --> 00:54:33,560
There's this notion of scope in C. And we'll continue to see this over time, whereby, a variable only exists inside of the most recent curly braces that you've opened.

738
00:54:33,560 --> 00:54:40,900
So if I've declared n here on line 14, I can use it anywhere between lines 13 and 21 because those are the nearest curly braces.

739
00:54:40,900 --> 00:54:53,470
If by contrast, as you note, if I instead said this, int n equals getInt and so forth, and didn't have the current line 14, well, n would exist inside of these curly braces, but not here, which

740
00:54:53,470 --> 00:54:55,340
is too late, and definitely not here.

741
00:54:55,340 --> 00:54:59,480
So you just have to declare it first, and then use and reuse it as such.

742
00:54:59,480 --> 00:55:01,545
Now, let me just show you how I can debug this.

743
00:55:01,545 --> 00:55:03,170
But let me show you the symptoms first.

744
00:55:03,170 --> 00:55:04,930
Let me open my terminal window.

745
00:55:04,930 --> 00:55:06,970
Let me run make buggy1.

746
00:55:06,970 --> 00:55:13,660
Compiles OK, so it's not something silly like a semicolon. ./buggy1, and I'm asked for a negative integer.

747
00:55:13,660 --> 00:55:15,280
All right, let me give it negative 1--

748
00:55:15,280 --> 00:55:16,710
Enter.

749
00:55:16,710 --> 00:55:20,880
Well, the main function is supposed to print out what I typed, but it clearly didn't.

750
00:55:20,880 --> 00:55:21,880
It's prompting me again.

751
00:55:21,880 --> 00:55:23,830
All right, so maybe it'll like negative 2.

752
00:55:23,830 --> 00:55:24,330
No?

753
00:55:24,330 --> 00:55:26,380
Maybe negative 3.

754
00:55:26,380 --> 00:55:27,570
50?

755
00:55:27,570 --> 00:55:29,160
OK, so it's definitely broken, right?

756
00:55:29,160 --> 00:55:31,528
It kind of seems logically to be doing the opposite.

757
00:55:31,528 --> 00:55:33,820
Now, you can perhaps see why this is happening already.

758
00:55:33,820 --> 00:55:37,170
These are deliberately simple programs for demonstrations sake.

759
00:55:37,170 --> 00:55:38,470
But let's do this.

760
00:55:38,470 --> 00:55:42,870
Let me go ahead and set a breakpoint in main, even though I'm pretty sure main is correct.

761
00:55:42,870 --> 00:55:47,010
But it just helps me start my thought process-- start with main, and then take it from there.

762
00:55:47,010 --> 00:55:51,840
Let me run now, debug50 ./buggy1--

763
00:55:51,840 --> 00:55:52,920
Enter.

764
00:55:52,920 --> 00:55:53,700
And let's see.

765
00:55:53,700 --> 00:55:56,880
With that breakpoint now, the GUI is going to reconfigure itself.

766
00:55:56,880 --> 00:56:01,260
It's going to pause on line 8 because that's the first interesting line inside of main.

767
00:56:01,260 --> 00:56:03,780
So I could have just put the breakpoint on line 8 too.

768
00:56:03,780 --> 00:56:09,570
It's smart enough to know that if I set it on 6, you really mean line 8 because that's the first actual line of code.

769
00:56:09,570 --> 00:56:11,280
And watch, now, what happens.

770
00:56:11,280 --> 00:56:19,470
If I step over this line, notice that i, which at the moment seems to have a default value of 0-- more on that another time.

771
00:56:19,470 --> 00:56:24,750
But if I click Step Over like before, I'm prompted for a negative integer.

772
00:56:24,750 --> 00:56:25,750
Let me type negative 1--

773
00:56:25,750 --> 00:56:27,300
Enter.

774
00:56:27,300 --> 00:56:32,470
And now, notice, there's no additional yellow highlight.

775
00:56:32,470 --> 00:56:32,970
Why?

776
00:56:32,970 --> 00:56:35,160
Where am I currently stuck, logically?

777
00:56:35,160 --> 00:56:37,937
AUDIENCE: [INAUDIBLE]

778
00:56:37,937 --> 00:56:40,770
DAVID MALAN: Yeah, just logically, I must be in that do, while loop.

779
00:56:40,770 --> 00:56:43,560
And even if you don't understand it, like that's the only explanation.

780
00:56:43,560 --> 00:56:46,143
If you keep getting prompted, surely, there's a loop going on.

781
00:56:46,143 --> 00:56:49,270
There's only one loop in my code, so there's probably a problem there.

782
00:56:49,270 --> 00:56:52,900
So I can't just set a breakpoint in main, and then wait for this to work.

783
00:56:52,900 --> 00:56:56,280
So let me just-- let me stop this with the red square.

784
00:56:56,280 --> 00:56:58,860
And let me think, all right, instead of--

785
00:56:58,860 --> 00:57:02,770
I can still set my breakpoint in main, but let me rerun the debugger instead.

786
00:57:02,770 --> 00:57:07,930
And this time, not step over that line of code, let me step into that line of code.

787
00:57:07,930 --> 00:57:09,270
So watch what happens now.

788
00:57:09,270 --> 00:57:14,610
Instead of clicking the second icon here, let me click the third, whose name is, indeed, Step Into.

789
00:57:14,610 --> 00:57:17,880
And watch as the yellow highlight does not move to line 9.

790
00:57:17,880 --> 00:57:25,170
It dives into line 8-- the function on line 8, thereby, bringing me down to line 17.

791
00:57:25,170 --> 00:57:28,270
It's kind of going down into that next function.

792
00:57:28,270 --> 00:57:34,380
Now, it didn't bother pausing on line 12 or 13 or 14 because there's nothing intellectually interesting there happening yet.

793
00:57:34,380 --> 00:57:37,080
The juicy part really starts, it would seem, in line 17.

794
00:57:37,080 --> 00:57:40,980
So, now notice, n is my variable at the top left.

795
00:57:40,980 --> 00:57:42,270
If I click--

796
00:57:42,270 --> 00:57:45,420
I don't want to click Step Into now, though.

797
00:57:45,420 --> 00:57:52,480
What would go wrong if I click on Step Into-- or what would it do that I don't think I want to do?

798
00:57:52,480 --> 00:57:52,990
Yeah?

799
00:57:52,990 --> 00:57:54,755
AUDIENCE: [INAUDIBLE]

800
00:57:54,755 --> 00:57:56,630
DAVID MALAN: Yeah, it would step into getInt.

801
00:57:56,630 --> 00:58:02,120
But I'd like to think that the staff's version of getInt is correct, and that's not our problem today, so I want to step over it.

802
00:58:02,120 --> 00:58:10,670
And watch now at top left that nothing happens yet to the value of n until I go to the terminal window now, and I type in something like negative 1.

803
00:58:10,670 --> 00:58:14,600
Now notice, it jumps to line 19, which is the next interesting line.

804
00:58:14,600 --> 00:58:17,240
Top left, n, indeed, is negative 1.

805
00:58:17,240 --> 00:58:22,760
And here's where I can now pause as a human and think, all right, so while n is less than 0.

806
00:58:22,760 --> 00:58:25,280
All right, n, per the top left corner, is negative 1.

807
00:58:25,280 --> 00:58:29,780
So all right, while negative 1 is less than 0, well, obviously that's true mathematically.

808
00:58:29,780 --> 00:58:30,930
So what's going to happen?

809
00:58:30,930 --> 00:58:32,130
It's a do while loop.

810
00:58:32,130 --> 00:58:39,410
So when I click on Step Over again, it's going to go to this line because it's at the end of the inside of that loop.

811
00:58:39,410 --> 00:58:42,710
And now here, it's looping through again and again.

812
00:58:42,710 --> 00:58:44,240
All right, let me do this once more.

813
00:58:44,240 --> 00:58:45,980
I'm going to step over, all right?

814
00:58:45,980 --> 00:58:48,777
I'm going to type in negative 2, and it's the exact same thing.

815
00:58:48,777 --> 00:58:50,360
Now is my chance, on the yellow line--

816
00:58:50,360 --> 00:58:51,260
OK, wait a minute.

817
00:58:51,260 --> 00:58:53,450
Negative 2 is obviously less than 0.

818
00:58:53,450 --> 00:58:56,080
Let me try this one more time.

819
00:58:56,080 --> 00:58:57,570
Click it once here.

820
00:58:57,570 --> 00:58:59,040
All right, let me give it 50.

821
00:58:59,040 --> 00:59:08,970
And now, OK, while 50 is less than 0, that's not true, so the loop is over because it's not going to do it while 50 is less than 0.

822
00:59:08,970 --> 00:59:09,730
That's not true.

823
00:59:09,730 --> 00:59:15,810
So now watch, when I click Step Over once more, it then finishes the loop, even though there's nothing more to do.

824
00:59:15,810 --> 00:59:17,610
It's now about to return n.

825
00:59:17,610 --> 00:59:21,360
It jumps back up to main, where I left off on line 9.

826
00:59:21,360 --> 00:59:23,778
It now prints, in my terminal window, the number 50.

827
00:59:23,778 --> 00:59:30,700
And hopefully, at this point, to your question earlier, my human brain has realized, oh, I'm an idiot, like I flipped my sign there.

828
00:59:30,700 --> 00:59:32,460
So I probably-- let me stop this.

829
00:59:32,460 --> 00:59:34,780
I probably want to do something like this.

830
00:59:34,780 --> 00:59:45,070
If the goal is to get a negative integer, I probably want to say, while n is, for instance, greater than or equal to 0 would work.

831
00:59:45,070 --> 00:59:48,630
So while n is greater than or equal to 0, keep doing this.

832
00:59:48,630 --> 00:59:50,430
And that's the logic I wanted to express.

833
00:59:50,430 --> 00:59:54,900
So the debugger just saves me from staring at the screen, raising a hand, sort of asking someone else.

834
00:59:54,900 --> 00:59:58,650
At least in this case, it allows me to go through it at a healthier pace.

835
00:59:58,650 --> 01:00:04,940
Questions now on debug50, which should be your new friend, even if it's not your first instinct after printf?

836
01:00:07,690 --> 01:00:09,190
Any questions on debug50?

837
01:00:09,190 --> 01:00:09,730
No?

838
01:00:09,730 --> 01:00:13,960
All right, well, there's one last technique we can equip you with here.

839
01:00:13,960 --> 01:00:22,720
And that is, in addition to printf and a debugger, no joke, a rubber duck is actually a reasonably recommended solution to finding bugs in your code.

840
01:00:22,720 --> 01:00:26,390
To your question earlier, the duck two is not going to solve the problem for you.

841
01:00:26,390 --> 01:00:33,760
But if you've wondered why this little guy has been here for so long, there's this technique, has its own Wikipedia article of called rubber duck debugging.

842
01:00:33,760 --> 01:00:42,820
The idea of which is that if you're home in your dorm room, wrestling with some bug in your code, printf didn't quite reveal the source to you, debugger isn't really helping,

843
01:00:42,820 --> 01:00:46,960
honestly, maybe it would help to just sound out what problem you're having.

844
01:00:46,960 --> 01:00:54,730
Similar to going to office hours, talking to a TA or a professor, just walking through your problems because in sort of talking to the duck about the fact

845
01:00:54,730 --> 01:01:01,180
that you're doing this while n is less than 0, and then if it is-- wait a minute.

846
01:01:01,180 --> 01:01:03,820
I'm an idiot, not just for talking to the rubber duck.

847
01:01:03,820 --> 01:01:11,860
You realize, hopefully, in expressing yourself, literally verbally, you probably will hear with non-zero probability, like some illogic in your statement.

848
01:01:11,860 --> 01:01:16,430
And just by sounding things out, you'll realize like, oh, that's my problem.

849
01:01:16,430 --> 01:01:19,720
And so, frankly, if you have roommates, you can also use a roommate for this.

850
01:01:19,720 --> 01:01:28,150
But the rubber duck is just sort of a go-to when your roommates have no interest in your C problem set, talking something through that as such.

851
01:01:28,150 --> 01:01:29,933
And this is an invaluable technique.

852
01:01:29,933 --> 01:01:34,510
I admittedly tend not to do it so much with a rubber duck, but ideally with colleagues, human colleagues.

853
01:01:34,510 --> 01:01:40,360
But just talking through things often will help you just realize, oh, I said something illogical.

854
01:01:40,360 --> 01:01:41,860
Now I can go back to the code.

855
01:01:41,860 --> 01:01:46,240
So don't solve problems by staring at your screen endlessly for minutes, for hours.

856
01:01:46,240 --> 01:01:52,900
At that point, it's time for a break, time to walk away, time to talk to the duck, if you've already exhausted some of those other tools.

857
01:01:52,900 --> 01:01:59,020
As an aside, on your way out today at the end of class, we have, clearly, plenty of rubber ducks for you.

858
01:01:59,020 --> 01:02:05,770
And it's become a thing over the years, at least among some, to bring the duck with them when they travel and send us photos.

859
01:02:05,770 --> 01:02:15,940
Here, for instance, is CS50's rubber duck debugger, A.K.A. DDB, for Duck Debugger, which is a pun on a geekier program called GDB, the GNU

860
01:02:15,940 --> 01:02:18,740
Debugger, which is an actual piece of software for debugging.

861
01:02:18,740 --> 01:02:25,270
This is CS50's debugger in the hills of Puerto Rico, also, here on the sea.

862
01:02:25,270 --> 01:02:28,310
He made its way to San Francisco here.

863
01:02:28,310 --> 01:02:30,640
Also, down by Fisherman's Wharf by the sea lions.

864
01:02:30,640 --> 01:02:31,660
Familiar?

865
01:02:31,660 --> 01:02:38,950
Here at Stanford, where there's a William Gates Computer Science building for computer science, down the road in SF at Google.

866
01:02:38,950 --> 01:02:41,650
And this is the Trevi Fountain in Rome.

867
01:02:41,650 --> 01:02:43,810
And lastly, the Colosseum.

868
01:02:43,810 --> 01:02:46,990
So we'll be curious to see in the coming years where your duck two travels.

869
01:02:46,990 --> 01:02:49,120
So that, then, was quite a bit.

870
01:02:49,120 --> 01:02:51,850
Why don't we go ahead here and take a short 5 minute break?

871
01:02:51,850 --> 01:02:52,760
No snacks yet.

872
01:02:52,760 --> 01:02:54,400
You're welcome to get up or sit down.

873
01:02:54,400 --> 01:02:56,620
We'll return in about five.

874
01:02:56,620 --> 01:03:00,020
All right, so we are back.

875
01:03:00,020 --> 01:03:09,190
And if the goal, ultimately, today is to have a better understanding of things like strings so that we can solve problems with text, let's consider some simpler types of data

876
01:03:09,190 --> 01:03:17,330
first, how we might represent those, and then see if that doesn't lead us to a discovery as to how strings, and just today's modern software is using things like that.

877
01:03:17,330 --> 01:03:27,640
So when we talked on week zero about representation of data, we had different ways of doing it, in terms of binary and decimal, and unary even.

878
01:03:27,640 --> 01:03:33,980
When we started talking about the same last week in code, we started talking about data types instead.

879
01:03:33,980 --> 01:03:45,070
And these data types were a way of telling the computer, like do you want an integer, do you want a character, do you want a floating point value, like a real number, or even a string, as we've seen?

880
01:03:45,070 --> 01:03:49,930
But it turns out that computers, of course, only have finite amounts of resources.

881
01:03:49,930 --> 01:03:53,740
Your computer only has a fixed amount of memory or RAM.

882
01:03:53,740 --> 01:03:55,910
And that actually has very real world implications.

883
01:03:55,910 --> 01:03:59,630
So for instance, here are some of the data types we've seen thus far.

884
01:03:59,630 --> 01:04:05,650
And it turns out that each of these in C has a specific number of bits allocated to it.

885
01:04:05,650 --> 01:04:08,350
Now, admittedly, this can vary by system.

886
01:04:08,350 --> 01:04:13,100
It's not so much the case nowadays, but for many years, for decades, computers were getting better and better.

887
01:04:13,100 --> 01:04:16,600
The earliest computers might have used fewer bits for some of these data types.

888
01:04:16,600 --> 01:04:18,663
More modern computers might use more bits.

889
01:04:18,663 --> 01:04:21,830
So the numbers you're about to see are pretty much where we are present day.

890
01:04:21,830 --> 01:04:32,380
So when it comes to these data types, a bool, which is true or false, somewhat curiously, uses a whole byte, even though that's way overkill because for a bool, true or false,

891
01:04:32,380 --> 01:04:33,940
you, of course, only need one bit.

892
01:04:33,940 --> 01:04:41,230
But it turns out, even though it's wasteful to use eight bits, or one byte, just to represent true or false, it's just easier for computers.

893
01:04:41,230 --> 01:04:42,820
So a bool tends to be one byte.

894
01:04:42,820 --> 01:04:47,590
An int, which we've been using a lot, uses 4 bytes, typically, or 32 bits.

895
01:04:47,590 --> 01:04:54,040
And if I do some quick math from week zero, with 32 bits, you have 4 billion possible values, roughly.

896
01:04:54,040 --> 01:05:01,020
But if you want to represent positive and negative, that means you can represent roughly negative 2 billion, all the way up to positive 2 billion.

897
01:05:01,020 --> 01:05:02,770
So that's the range, typically, with ints.

898
01:05:02,770 --> 01:05:06,820
If that's too few numbers for you, turns out there's things called longs.

899
01:05:06,820 --> 01:05:15,730
And longs use 64 bits, which allow you to have like a quintillion number of possibilities, which is a lot, certainly, a lot more than 4 billion.

900
01:05:15,730 --> 01:05:17,410
So sometimes you might use a long.

901
01:05:17,410 --> 01:05:18,670
But even that's finite.

902
01:05:18,670 --> 01:05:28,330
And so as we discussed at the end of last week, bad things can happen if you make certain assumptions as to the data because of things like integer overflow or the like, where things wrap around.

903
01:05:28,330 --> 01:05:31,538
Then there's a float, which is a real number, something with a decimal point.

904
01:05:31,538 --> 01:05:37,810
By convention, it's 4 bytes or 32 bits, which gives you, in short, only a specific amount of precision.

905
01:05:37,810 --> 01:05:41,620
It doesn't necessarily dictate how many numbers to the left or to the right.

906
01:05:41,620 --> 01:05:45,250
In the aggregate, ultimately, you have though,

907
01:05:45,250 --> 01:05:47,650
4 billion possible permutations still.

908
01:05:47,650 --> 01:05:57,700
If you need more precision for scientific, for medical, for financial applications, you might use 8 bytes, A.K.A. a double, which just gives you more digits of precision.

909
01:05:57,700 --> 01:06:03,610
They eventually get imprecise per the example we looked at last week, but it at least gets you further down the line.

910
01:06:03,610 --> 01:06:12,640
As an aside, in really, really important applications, in finance, in medicine, in military operations, and the like where you really can't have rounding errors--

911
01:06:12,640 --> 01:06:19,317
long story short, humans have developed libraries in C and other languages that use more, even, than 8 bytes.

912
01:06:19,317 --> 01:06:22,150
So there are solutions to these problems, but they're always finite.

913
01:06:22,150 --> 01:06:24,070
You have to pick an upper bound.

914
01:06:24,070 --> 01:06:29,470
Then there's char, which we saw briefly last week when I asked the user for y or n, for yes or no.

915
01:06:29,470 --> 01:06:34,360
And then there's a string, which I'm going to propose as a question mark because a string totally depends.

916
01:06:34,360 --> 01:06:35,380
Like, Hi!

917
01:06:35,380 --> 01:06:38,890
H-I, exclamation point, would seem to be three bytes.

918
01:06:38,890 --> 01:06:41,140
D-A-V-I-D, would seem to be five.

919
01:06:41,140 --> 01:06:45,400
So the strings, clearly, are variable based on what you or the human type in.

920
01:06:45,400 --> 01:06:48,140
So we'll see what this means, though, in just a bit.

921
01:06:48,140 --> 01:06:51,580
This though, is the thing inside of your Mac, your PC, your phone.

922
01:06:51,580 --> 01:06:56,187
It might not look exactly like this, but this is a memory module for a modern computer.

923
01:06:56,187 --> 01:06:57,520
And let's go ahead and use this.

924
01:06:57,520 --> 01:07:01,360
Really, it's just representative of the finite amount of memory that any computer, indeed, has.

925
01:07:01,360 --> 01:07:06,160
Let's zoom in on one of these little black chips on the circuit board here.

926
01:07:06,160 --> 01:07:16,750
Zoom in, and let me propose that this rectangle really represents some number of bytes, like tucked inside of this little black circuit on the board is maybe, I don't know, a gigabyte,

927
01:07:16,750 --> 01:07:19,300
a billion bytes, maybe it's 100 bytes-- some number of bytes.

928
01:07:19,300 --> 01:07:22,700
It totally depends on the computer and how much you paid for the stick of memory.

929
01:07:22,700 --> 01:07:32,410
But if there's a finite number of bytes physically implemented somehow digitally inside of this hardware, well, then it stands to reason that we could number those bytes.

930
01:07:32,410 --> 01:07:38,800
We can just arbitrarily decide that the top left corner is byte number one, or really byte number zero.

931
01:07:38,800 --> 01:07:46,090
The one next to it is number one, then number two, number 3, dot, dot, dot, number 2 billion or whatever it is, however big this memory is.

932
01:07:46,090 --> 01:07:50,530
So if you use a variable in a C program, that's only one byte.

933
01:07:50,530 --> 01:07:55,120
Like a char, it might literally be stored in that top left-hand corner of the memory.

934
01:07:55,120 --> 01:07:57,760
In practice, you don't care where, physically, it is.

935
01:07:57,760 --> 01:08:04,330
But really, the artist's rendition would be this-- a char might use one of those single bytes somewhere in the computer's memory.

936
01:08:04,330 --> 01:08:07,450
If you use an int, which is 4 bytes, it would give you

937
01:08:07,450 --> 01:08:10,840
4 bytes, contiguous-- that is left to right, top to bottom.

938
01:08:10,840 --> 01:08:16,149
But all 32 bits would be next to each other so the computer knows that those, indeed, all belong to the same int.

939
01:08:16,149 --> 01:08:21,140
If you need a long, or a double for that matter, then you might use a full 8 bytes in this case.

940
01:08:21,140 --> 01:08:29,845
And you just keep using and using this memory, kind of like a canvas, almost in Photoshop or a spreadsheet where you can just move pixels or you can move data around,

941
01:08:29,845 --> 01:08:36,702
that's really what your computer's memory is, a canvas for storing information in units of bytes or 8 bits.

942
01:08:36,702 --> 01:08:39,160
Now, we don't need to keep looking at these circuit boards.

943
01:08:39,160 --> 01:08:41,287
We can abstract it away, as we often do.

944
01:08:41,287 --> 01:08:45,740
And let's go ahead and zoom in on this grid, just to consider some very specific variables.

945
01:08:45,740 --> 01:08:51,580
So let me zoom in, and now I see fewer, but larger boxes on the screen, each of which, again, represents a byte.

946
01:08:51,580 --> 01:08:55,130
And now let me propose that we play with some actual code.

947
01:08:55,130 --> 01:09:01,060
So here in C, albeit without a full program, are three ints-- score1, score2, score3.

948
01:09:01,060 --> 01:09:09,040
I have, coincidentally, given myself two scores around 72 and 73, and then a pretty low score at 33.

949
01:09:09,040 --> 01:09:12,048
Of course, last week or two weeks ago, this would have been high.

950
01:09:12,048 --> 01:09:13,840
But now we're dealing with actual integers.

951
01:09:13,840 --> 01:09:17,750
So these are three so-so scores on my quizzes or tests or the like.

952
01:09:17,750 --> 01:09:19,250
So let me go to VS Code here.

953
01:09:19,250 --> 01:09:22,210
And let's make a program called scores.c.

954
01:09:22,210 --> 01:09:24,399
So I'm going to write, code scores.c.

955
01:09:24,399 --> 01:09:26,149
That's going to give me my new file.

956
01:09:26,149 --> 01:09:28,420
And let me go ahead and implement something like this.

957
01:09:28,420 --> 01:09:37,689
Include stdio.h, int main(void), and then inside of here, let me do int score1 will be 72.

958
01:09:37,689 --> 01:09:40,029
Int score2 will be 73.

959
01:09:40,029 --> 01:09:43,149
And int score3 will be 33.

960
01:09:43,149 --> 01:09:48,042
And then let me just do something like write a program to average my three test scores together, something like that.

961
01:09:48,042 --> 01:09:56,470
So let me do printf, quote unquote, my average is-- and I'm going to go ahead and do, say, %i, /n.

962
01:09:56,470 --> 01:09:58,290
And now, let me plug in the results.

963
01:09:58,290 --> 01:10:00,040
And this is kind of grade school math now.

964
01:10:00,040 --> 01:10:02,210
How do I compute the average of three values?

965
01:10:02,210 --> 01:10:14,457
Well, just like on paper, I can do score1 plus score2 plus score3 in parentheses, because of order of operations, divided by 3, since there's three total scores.

966
01:10:14,457 --> 01:10:16,040
All right, so I think this checks out.

967
01:10:16,040 --> 01:10:23,180
And indeed, you can use parentheses and operators like plus in your code like this in C. Let me go ahead now and do make scores.

968
01:10:23,180 --> 01:10:24,327
No syntax error.

969
01:10:24,327 --> 01:10:25,910
So that's good, nothing missing there.

970
01:10:25,910 --> 01:10:28,850
And now let me do ./scores and see what my test average is.

971
01:10:28,850 --> 01:10:32,270
All right, it's not great, but I think I still passed.

972
01:10:32,270 --> 01:10:36,050
And indeed, my average here is 59.

973
01:10:36,050 --> 01:10:38,360
Is it precisely 59 though?

974
01:10:38,360 --> 01:10:39,140
Well, let's see.

975
01:10:39,140 --> 01:10:44,870
Let's actually, instead of using an int, how about we go ahead and use something like a floating point value here?

976
01:10:44,870 --> 01:10:46,250
And let me go ahead and do this.

977
01:10:46,250 --> 01:10:48,710
So let me recompile my code, make scores.

978
01:10:48,710 --> 01:10:50,600
Huh, all right, I've got an issue.

979
01:10:50,600 --> 01:10:52,340
Let me zoom in on my terminal window.

980
01:10:52,340 --> 01:10:54,710
We've not seen this one, necessarily, before.

981
01:10:54,710 --> 01:10:56,510
But error on line 9.

982
01:10:56,510 --> 01:11:02,180
Format specifies type double, which is a lot of precision, but the argument has type int.

983
01:11:02,180 --> 01:11:03,300
So what does this mean?

984
01:11:03,300 --> 01:11:09,060
Well, it's showing me with these green squiggles that something's bad between the %f and this thing over here.

985
01:11:09,060 --> 01:11:13,020
Well, on the left, I'm implying a float, or a double for that matter.

986
01:11:13,020 --> 01:11:16,835
On the right, though, what data type are score1, score2, score3?

987
01:11:16,835 --> 01:11:17,960
All right, so they're ints.

988
01:11:17,960 --> 01:11:19,583
So clang does not like this.

989
01:11:19,583 --> 01:11:24,170
The compiler just doesn't like that I'm using ints on the right, but I want floats on the left.

990
01:11:24,170 --> 01:11:26,670
So there's going to be different ways of solving this.

991
01:11:26,670 --> 01:11:32,450
One way would be to just ignore the problem like I originally did, and just go back to %i.

992
01:11:32,450 --> 01:11:38,330
Or as an aside, %d is often an alternative to %i for a decimal number.

993
01:11:38,330 --> 01:11:42,358
But we use %i because it sounds like int, so %i is fine here too.

994
01:11:42,358 --> 01:11:44,150
But I don't want to just avoid the problem.

995
01:11:44,150 --> 01:11:46,500
I want to actually display a floating point value.

996
01:11:46,500 --> 01:11:47,730
So how can I fix this?

997
01:11:47,730 --> 01:11:50,272
Well, it turns out, I can solve this in a few different ways.

998
01:11:50,272 --> 01:11:59,330
The simplest is just to make sure that at least one number on the right is a floating point value, like 3.0 instead of just 3.

999
01:11:59,330 --> 01:12:01,700
Now I think clang will be happier.

1000
01:12:01,700 --> 01:12:03,320
Let me do make scores--

1001
01:12:03,320 --> 01:12:04,400
Enter.

1002
01:12:04,400 --> 01:12:05,330
And indeed, it's OK.

1003
01:12:05,330 --> 01:12:05,930
Why?

1004
01:12:05,930 --> 01:12:14,330
As soon as you have at least one more precise data type on the right, it just treats everything, at that point, as floating point value so that the math works out.

1005
01:12:14,330 --> 01:12:17,720
So ./scores, Enter-- and now, there we go, right?

1006
01:12:17,720 --> 01:12:20,390
Some of us might really want that 1/3 of a point.

1007
01:12:20,390 --> 01:12:21,980
Our average was not 59.

1008
01:12:21,980 --> 01:12:25,010
It's 59 1/3, as in this case here.

1009
01:12:25,010 --> 01:12:26,750
All right, so we've solved that there.

1010
01:12:26,750 --> 01:12:30,890
As an aside, though, there's one other technique to show here.

1011
01:12:30,890 --> 01:12:38,760
If you didn't want to change it to 3.0 because that's a little weird, because there were literally three scores, it's not like that needs to have a decimal point,

1012
01:12:38,760 --> 01:12:46,230
you could also explicitly convert the 3 to a float by saying, in parentheses, float.

1013
01:12:46,230 --> 01:12:48,050
This is what's called typecasting.

1014
01:12:48,050 --> 01:12:52,560
And this will just convert the thing right after it to that data type, if it's possible.

1015
01:12:52,560 --> 01:12:59,960
So if I do this again, make scores, no errors now. ./scores, and I get, in fact, the same result. There's a bit of a rounding issue here,

1016
01:12:59,960 --> 01:13:03,650
but we know the rounding relates to the imprecision from last week.

1017
01:13:03,650 --> 01:13:06,980
For now, let me just be happy with my 59.3 something.

1018
01:13:06,980 --> 01:13:08,360
I'll take that for now.

1019
01:13:08,360 --> 01:13:14,660
But this is as close to a good enough correct answer for me now.

1020
01:13:14,660 --> 01:13:18,650
But how do I-- think about now, what's going on inside of the computer's memory?

1021
01:13:18,650 --> 01:13:19,310
Well, let's consider.

1022
01:13:19,310 --> 01:13:20,643
Here's that same grid of memory.

1023
01:13:20,643 --> 01:13:22,490
Each box represents a byte.

1024
01:13:22,490 --> 01:13:25,790
Where are score1, score2, and score3 in my memory?

1025
01:13:25,790 --> 01:13:28,790
Well, score1, let me just propose, is at the top left.

1026
01:13:28,790 --> 01:13:32,060
But it's taking up four boxes for 4 bytes.

1027
01:13:32,060 --> 01:13:38,180
Score2 probably ends up right next to it in memory, though, this isn't always going to be the case, but I've chosen simple examples.

1028
01:13:38,180 --> 01:13:40,910
73 is next to it, also taking up 4 bytes.

1029
01:13:40,910 --> 01:13:45,320
And then lastly, 33 is in score3, down there underneath.

1030
01:13:45,320 --> 01:13:54,110
Now, if we really look at the computer's memory, look at it with some kind of microscope or the like, there's actually 32 bits, 32 bits, 32 bits

1031
01:13:54,110 --> 01:13:59,308
in each of those four groups of four bytes representing those values.

1032
01:13:59,308 --> 01:14:03,308
But again, for today's purposes onwards, we don't really need to think again and again in binary.

1033
01:14:03,308 --> 01:14:05,940
It's just, indeed, these decimal numbers being stored there.

1034
01:14:05,940 --> 01:14:08,240
But I claim now, this isn't the best design.

1035
01:14:08,240 --> 01:14:16,970
Even if you have never programmed before CS50, what you're looking at here on the screen, as an excerpt, in what sense is this perhaps bad design, even though it's

1036
01:14:16,970 --> 01:14:19,960
a correct way of storing three test scores?

1037
01:14:19,960 --> 01:14:20,960
What's kind of bad here?

1038
01:14:20,960 --> 01:14:21,882
Yeah?

1039
01:14:21,882 --> 01:14:26,220
AUDIENCE: The more scores you have, the more you [INAUDIBLE]..

1040
01:14:26,220 --> 01:14:31,740
DAVID MALAN: Yeah, always do exactly what you did-- extrapolate to 4 scores, 5 scores 50 scores.

1041
01:14:31,740 --> 01:14:36,300
This can't be that well-designed because now you're going to have 4 lines of code, 5 lines of code,

1042
01:14:36,300 --> 01:14:42,430
50 lines of code that are almost identical, except for this like arbitrary number that we're updating at the end of the variable.

1043
01:14:42,430 --> 01:14:48,690
So indeed, there's probably going to be a better way, even though, at least in C, we haven't yet seen that technique.

1044
01:14:48,690 --> 01:14:52,440
But the solution, today onward, is going to be something called an array.

1045
01:14:52,440 --> 01:15:03,960
An array is a way of storing your data back to back to back in the computer's memory in such a way that you can access each individual member easily.

1046
01:15:03,960 --> 01:15:08,530
Put another way, with an array, you can instead do something like this.

1047
01:15:08,530 --> 01:15:20,700
Instead of saying int score1, int score2, int score3, giving each a value, you can first tell the computer, please give me a variable called scores-- plural, though you can call it anything you want--

1048
01:15:20,700 --> 01:15:24,090
of size three, each of which will be an integer.

1049
01:15:24,090 --> 01:15:30,930
That is to say, this is how you declare an array in C that will have enough room to store three integers.

1050
01:15:30,930 --> 01:15:38,880
Put another way, this is the technical way of telling the computer, please give me 12 bytes in total--

1051
01:15:38,880 --> 01:15:42,660
3 times 4 each for an int, so give me 12 bytes in total.

1052
01:15:42,660 --> 01:15:47,350
And what the computer will do is guarantee that they're back to back to back in the computer's memory.

1053
01:15:47,350 --> 01:15:49,360
And that'll be useful in just a moment.

1054
01:15:49,360 --> 01:15:51,820
So let me go ahead and do something useful with this.

1055
01:15:51,820 --> 01:15:53,640
Let me store three actual scores.

1056
01:15:53,640 --> 01:15:58,500
Here's how I could now store those same numeric scores in this array.

1057
01:15:58,500 --> 01:16:03,040
Syntax is a little different, but there's one variable called scores.

1058
01:16:03,040 --> 01:16:14,280
But if you want to go to its first location, starting today, you use square brackets and go to location 0 first, which because things in C are 0 indexed, so to speak, you start counting at 0.

1059
01:16:14,280 --> 01:16:16,410
The first int is at [0].

1060
01:16:16,410 --> 01:16:18,030
Second int is at [1].

1061
01:16:18,030 --> 01:16:19,530
Third int is at [2].

1062
01:16:19,530 --> 01:16:20,730
So it's not one, two, three.

1063
01:16:20,730 --> 01:16:22,090
It's literally 0, 1, 2.

1064
01:16:22,090 --> 01:16:24,090
And this is not something you have control over.

1065
01:16:24,090 --> 01:16:26,250
You must start at 0.

1066
01:16:26,250 --> 01:16:33,510
So these lines now create an array of size three, and then insert one, two, three values into that array.

1067
01:16:33,510 --> 01:16:37,770
But the upside now is that you only have one name of the variable to remember.

1068
01:16:37,770 --> 01:16:39,240
It's just called scores.

1069
01:16:39,240 --> 01:16:43,380
Yes, you need to go into the array to get individual values.

1070
01:16:43,380 --> 01:16:46,618
You need to index into it using those square brackets.

1071
01:16:46,618 --> 01:16:53,050
But at least you don't have this hackish approach of declaring a separate variable for each and every one of these values.

1072
01:16:53,050 --> 01:16:56,070
So let me go back to scores.c here.

1073
01:16:56,070 --> 01:16:57,580
And let me propose that I do this.

1074
01:16:57,580 --> 01:17:00,580
Let me just use that same idea to do the following.

1075
01:17:00,580 --> 01:17:02,580
Let me get rid of these three separate integers.

1076
01:17:02,580 --> 01:17:06,210
Let me give myself an int scores array of size 3.

1077
01:17:06,210 --> 01:17:10,470
And then scores[0] will, as before, be 72.

1078
01:17:10,470 --> 01:17:14,070
Scores[1] will be 73.

1079
01:17:14,070 --> 01:17:16,830
And scores[2] will be 33.

1080
01:17:16,830 --> 01:17:18,780
And let me get rid of the little dot there.

1081
01:17:18,780 --> 01:17:23,490
All right, so now, if I go ahead and run this again with make scores--

1082
01:17:23,490 --> 01:17:24,642
Enter.

1083
01:17:24,642 --> 01:17:29,060
Huh, what did I do wrong here?

1084
01:17:29,060 --> 01:17:31,680
I think I got a little too ahead of myself.

1085
01:17:31,680 --> 01:17:36,100
Let me increase my terminal window.

1086
01:17:36,100 --> 01:17:38,830
Let's focus on line 10 here, first.

1087
01:17:38,830 --> 01:17:42,310
Error, use of undeclared identifier, score1.

1088
01:17:42,310 --> 01:17:44,170
What did I do here that was dumb?

1089
01:17:44,170 --> 01:17:45,430
Yeah?

1090
01:17:45,430 --> 01:17:47,440
AUDIENCE: You didn't declare it a variable.

1091
01:17:47,440 --> 01:17:49,420
DAVID MALAN: Right, so I didn't declare score1.

1092
01:17:49,420 --> 01:17:50,530
I've got old code.

1093
01:17:50,530 --> 01:17:53,798
So I just kind of, honestly, got ahead of myself here, not even intentionally.

1094
01:17:53,798 --> 01:17:56,090
So let me go ahead and shrink my terminal window again.

1095
01:17:56,090 --> 01:17:57,740
I need to finish my thought here.

1096
01:17:57,740 --> 01:17:58,960
So let me clear my terminal.

1097
01:17:58,960 --> 01:18:05,610
And let me change this now to be scores[0] plus scores[1] plus scores[2].

1098
01:18:05,610 --> 01:18:10,040
So it's a little more verbose because I've got these square brackets, so to speak.

1099
01:18:10,040 --> 01:18:12,220
But I think now my code is consistent.

1100
01:18:12,220 --> 01:18:13,870
So let me make scores now.

1101
01:18:13,870 --> 01:18:14,950
It now compiles.

1102
01:18:14,950 --> 01:18:19,870
./scores gives me, indeed, the same rough average with those same values.

1103
01:18:19,870 --> 01:18:24,280
All right, so let me go ahead and maybe enhance this a little bit.

1104
01:18:24,280 --> 01:18:31,610
It's a little silly to have to write a special program just to check your average of three test scores like 72, 73, 33.

1105
01:18:31,610 --> 01:18:37,250
Why don't I actually make the program dynamic and ask the human for those scores?

1106
01:18:37,250 --> 01:18:39,140
So instead, let me do this.

1107
01:18:39,140 --> 01:18:43,480
How about we get rid of the 72, and change this to getInt.

1108
01:18:43,480 --> 01:18:46,300
And I'll just prompt the user for a score.

1109
01:18:46,300 --> 01:18:52,510
Let me get rid of the 73 and get this to be getInt score, quote unquote.

1110
01:18:52,510 --> 01:19:03,680
And then lastly, get rid of the 33, and replace it with getInt, quote unquote, score. getInt is a CS50 thing for now, so I need to include cs50.h, as always.

1111
01:19:03,680 --> 01:19:08,680
But I think now, it's sort of a better program because now I can compile it once, I can even share it with my friends.

1112
01:19:08,680 --> 01:19:12,490
And now any of us can average three scores on some classes test.

1113
01:19:12,490 --> 01:19:16,910
They don't need to know the code or rewrite the code just to type in their scores.

1114
01:19:16,910 --> 01:19:19,150
So make scores worked.

1115
01:19:19,150 --> 01:19:26,320
./scores, now I can type anything I want-- maybe it's a 72, 73, 33, still get the same answer.

1116
01:19:26,320 --> 01:19:33,520
Or maybe I'm having a better semester, 100, 100, maybe 99, and now we get still a pretty high score there.

1117
01:19:33,520 --> 01:19:34,600
But now it's dynamic.

1118
01:19:34,600 --> 01:19:36,080
Now you don't need the source code.

1119
01:19:36,080 --> 01:19:37,747
You don't need to recompile the program.

1120
01:19:37,747 --> 01:19:39,670
It's just going to work again and again.

1121
01:19:39,670 --> 01:19:41,090
But this, too.

1122
01:19:41,090 --> 01:19:45,910
Let me propose that this code is correct if I want to get three scores from the user.

1123
01:19:45,910 --> 01:19:53,170
But these highlighted lines now, 6 through 9, are they well-designed, would you say?

1124
01:19:53,170 --> 01:19:53,680
Yeah?

1125
01:19:53,680 --> 01:19:54,898
AUDIENCE: Can you loop?

1126
01:19:54,898 --> 01:19:55,940
DAVID MALAN: Yeah, right?

1127
01:19:55,940 --> 01:19:58,220
This is-- we can use a loop, is the spoiler here.

1128
01:19:58,220 --> 01:19:58,820
Why?

1129
01:19:58,820 --> 01:20:01,590
I mean, my God, it's like the same code again and again and again.

1130
01:20:01,590 --> 01:20:03,465
The only thing that's changing is the number.

1131
01:20:03,465 --> 01:20:11,810
And this should have kind of had some code smell again, because if I keep typing the same thing again and again, that's clearly an opportunity to better design something.

1132
01:20:11,810 --> 01:20:13,650
So let me do this.

1133
01:20:13,650 --> 01:20:18,590
Let me go ahead and still create my array of size three.

1134
01:20:18,590 --> 01:20:26,610
But let me use our old friend, the for loop, for int i equals 0, i less than 3, i++.

1135
01:20:26,610 --> 01:20:32,920
And then in here, let me do scores bracket-- we haven't seen this before, but any intuition?

1136
01:20:32,920 --> 01:20:34,220
Scores bracket--

1137
01:20:34,220 --> 01:20:34,720
AUDIENCE: i.

1138
01:20:34,720 --> 01:20:40,720
DAVID MALAN: i, because that will use whatever i is, be it 0 or 1 or 2 in iteration.

1139
01:20:40,720 --> 01:20:47,000
And then I can get an int, asking the user for score, without having to repeat myself again and again.

1140
01:20:47,000 --> 01:20:50,560
So hopefully, if I didn't make any typos, make scores, all good.

1141
01:20:50,560 --> 01:20:54,665
./scores, 72, 73, 33, and we're back in business.

1142
01:20:54,665 --> 01:21:04,940
But the code is arguably now better designed, because now, I haven't actually hardcoded the scores, and I haven't actually copied and pasted any of that code.

1143
01:21:04,940 --> 01:21:10,510
Well, if we consider now what's going on inside of the computer's memory, it's pretty much the same in terms of the values.

1144
01:21:10,510 --> 01:21:17,210
But instead of the variables being, literally, score1, score2, score3, there's just one variable.

1145
01:21:17,210 --> 01:21:19,030
It's an array called scores.

1146
01:21:19,030 --> 01:21:28,810
But you can index into its three locations by using scores[0] to get the first, scores[1] to get the second, scores[2] to get the third.

1147
01:21:28,810 --> 01:21:29,990
But this is key.

1148
01:21:29,990 --> 01:21:33,040
The memory is contiguous.

1149
01:21:33,040 --> 01:21:35,380
The screen is only so large, so it wraps around.

1150
01:21:35,380 --> 01:21:40,270
But physically, digitally, the memory is contiguous-- top to bottom, left to right.

1151
01:21:40,270 --> 01:21:41,530
And that's important, why?

1152
01:21:41,530 --> 01:21:48,790
Because the brackets indicate 0, 1, 2, that each of these integers is just one integer away from the next.

1153
01:21:48,790 --> 01:21:51,220
It can't be randomly down here all of a sudden.

1154
01:21:51,220 --> 01:21:54,070
It's got to be back to back to back.

1155
01:21:54,070 --> 01:22:00,710
All right, now equipped with that paradigm, what more could we actually do here?

1156
01:22:00,710 --> 01:22:06,850
Well, it turns out, it's worth knowing that it's possible in code to even pass arrays around as arguments.

1157
01:22:06,850 --> 01:22:11,320
And let me just whip this program up somewhat quickly, just so you've seen it before long.

1158
01:22:11,320 --> 01:22:13,190
But let me go ahead and do this.

1159
01:22:13,190 --> 01:22:18,130
Let me propose that I create a function that does this averaging for me.

1160
01:22:18,130 --> 01:22:22,510
So I'm going to create a function called average that returns a float.

1161
01:22:22,510 --> 01:22:28,640
And the arguments this thing is going to take-- let's see, it's going to be the array.

1162
01:22:28,640 --> 01:22:33,050
So it turns out, if you want to take in an array of numbers-- you can call it anything you want.

1163
01:22:33,050 --> 01:22:39,790
This is how you tell C that a function takes, not an integer, but an array of integers.

1164
01:22:39,790 --> 01:22:41,290
And you don't have to call it array.

1165
01:22:41,290 --> 01:22:42,790
I'm doing that just for the sake of discussion.

1166
01:22:42,790 --> 01:22:43,660
It can be called x.

1167
01:22:43,660 --> 01:22:44,490
It can be numbers.

1168
01:22:44,490 --> 01:22:45,490
It can be anything else.

1169
01:22:45,490 --> 01:22:49,060
I'm just calling an array to be super explicit as to what it is there.

1170
01:22:49,060 --> 01:22:51,730
Now, how do I change my code down here?

1171
01:22:51,730 --> 01:22:55,130
What I think I'm going to do for the moment is just this.

1172
01:22:55,130 --> 01:22:59,110
I'm going to get rid of this code here, where I manually computed the average.

1173
01:22:59,110 --> 01:23:05,000
And let me just call the average function here by passing in the whole array of scores.

1174
01:23:05,000 --> 01:23:08,890
So this is just an example of abstraction, like now I have a function called average.

1175
01:23:08,890 --> 01:23:09,670
I don't care.

1176
01:23:09,670 --> 01:23:12,490
I don't have to remember how it works once I implement it.

1177
01:23:12,490 --> 01:23:15,010
It just kind of tightens up my main code a little bit.

1178
01:23:15,010 --> 01:23:17,030
But I do still have to implement this.

1179
01:23:17,030 --> 01:23:27,010
So later in my file-- let me repeat myself before, the only time it's OK in C to repeat yourself again and again, by typing out again, average, and then int array open bracket--

1180
01:23:27,010 --> 01:23:28,580
but now not a semicolon.

1181
01:23:28,580 --> 01:23:30,250
Now I have to implement this thing.

1182
01:23:30,250 --> 01:23:37,630
And I can implement this in a bunch of different ways, but I don't know in advance--

1183
01:23:37,630 --> 01:23:39,040
I can't just do this.

1184
01:23:39,040 --> 01:23:52,130
I can't just do array[0] plus array[1] plus array[2], unless this program's only ever going to work on three numbers.

1185
01:23:52,130 --> 01:23:55,460
So let me go ahead and do this.

1186
01:23:55,460 --> 01:23:58,570
Let me first propose that there's a poor design here.

1187
01:23:58,570 --> 01:24:01,930
In my main function, what value have I repeated twice?

1188
01:24:05,050 --> 01:24:07,550
Among the highlighted lines, what jumps out at you as twice?

1189
01:24:07,550 --> 01:24:09,020
AUDIENCE: The length of the array?

1190
01:24:09,020 --> 01:24:11,520
DAVID MALAN: Yeah, the length of the array, it's just three.

1191
01:24:11,520 --> 01:24:18,440
Now it's not a huge deal that I typed the number three on line 8 and line 9, but this is exactly the kind of like shortcut that's going to get you in trouble eventually.

1192
01:24:18,440 --> 01:24:18,860
Why?

1193
01:24:18,860 --> 01:24:26,270
Because, eventually, you or someone else is going to go in and make the array bigger or smaller, and you're not going to realize that magically, that same number is in two places.

1194
01:24:26,270 --> 01:24:29,270
And indeed, this is what a programmer would often call a magic number.

1195
01:24:29,270 --> 01:24:31,940
A magic number is one that just kind of appears magically.

1196
01:24:31,940 --> 01:24:36,688
And you're on the honor system to change it here, if you change it here, and then you change it over here.

1197
01:24:36,688 --> 01:24:43,190
That's not going to end well if the onus is on the programmer to remember where they hardcoded-- that is, wrote out three explicitly.

1198
01:24:43,190 --> 01:24:46,250
So any time you reuse a value like this, you know what?

1199
01:24:46,250 --> 01:24:56,990
We should probably do what we did last week, which was to declare a variable, perhaps at the very top of my program, so it's super obvious what it is, called, maybe n, and set that equal to 3.

1200
01:24:56,990 --> 01:25:02,390
Better yet, what did I do last week to make sure that I can't screw up and accidentally change that value?

1201
01:25:02,390 --> 01:25:03,440
Yeah, constant.

1202
01:25:03,440 --> 01:25:05,810
And the keyword there was just const for short.

1203
01:25:05,810 --> 01:25:11,870
And now I have a global variable-- global in the sense that I can access it anywhere-- that is called n.

1204
01:25:11,870 --> 01:25:12,680
It's an int.

1205
01:25:12,680 --> 01:25:14,450
And it's always going to be 3.

1206
01:25:14,450 --> 01:25:23,870
And now I can improve my main function a little bit by just changing the 3's to n, so now if I, if a colleague realized, oh, wait a minute, there's four tests this year.

1207
01:25:23,870 --> 01:25:31,190
You change n to four, recompile the code, and it just works everywhere else, except in my average function.

1208
01:25:31,190 --> 01:25:33,830
Let me change it back to 3, just for consistency.

1209
01:25:33,830 --> 01:25:43,610
This is not going to fly now, to just sum up things like this, for instance, and then return this divided by 3.

1210
01:25:43,610 --> 01:25:51,130
Why will this not work now as I've defined it?

1211
01:25:51,130 --> 01:25:52,159
Yeah?

1212
01:25:52,159 --> 01:25:58,030
AUDIENCE: [INAUDIBLE]

1213
01:25:58,030 --> 01:26:00,980
DAVID MALAN: OK, I might be returning an integer value when

1214
01:26:00,980 --> 01:26:02,870
I intend to return a float per this.

1215
01:26:02,870 --> 01:26:11,010
But I think I'm OK because I used that little trick where I made sure that at least one of the numbers in my arithmetic expression is, in fact, a floating point value.

1216
01:26:11,010 --> 01:26:15,650
And just by adding the point 0, make sure that everything gets treated as a float.

1217
01:26:15,650 --> 01:26:17,864
So I think that's OK.

1218
01:26:17,864 --> 01:26:19,034
AUDIENCE: [INAUDIBLE]

1219
01:26:19,034 --> 01:26:20,701
DAVID MALAN: I'm sorry, a little louder.

1220
01:26:20,701 --> 01:26:24,385
AUDIENCE: It just seems like you're [INAUDIBLE]..

1221
01:26:24,385 --> 01:26:25,260
DAVID MALAN: Exactly.

1222
01:26:25,260 --> 01:26:33,510
So left hand's not talking to the right hand here, in that my current implementation of average is still assuming that there's only going to be three tests or whatever.

1223
01:26:33,510 --> 01:26:39,480
But wait a minute, I just went through the trouble of modifying this to be n, generically.

1224
01:26:39,480 --> 01:26:46,690
And if I change this to 4, I'm not going to be happy, perhaps, with my average because now I'm going to ignore one of my test scores altogether.

1225
01:26:46,690 --> 01:26:48,450
So let me change this back to 3.

1226
01:26:48,450 --> 01:27:00,920
And unfortunately, if it's a variable now, n, and therefore, I have literally a variable number of scores, how do I take the average of a variable number of things?

1227
01:27:00,920 --> 01:27:02,630
I mean, what's my building block there?

1228
01:27:02,630 --> 01:27:03,170
Yeah?

1229
01:27:03,170 --> 01:27:10,100
AUDIENCE: [INAUDIBLE]

1230
01:27:10,100 --> 01:27:10,850
DAVID MALAN: Yeah.

1231
01:27:10,850 --> 01:27:14,880
Why don't I use a loop that goes through the array and adds things up as you go?

1232
01:27:14,880 --> 01:27:19,730
I mean, kind of like grade school, as you take the average on your calculator or paper and pencil, you just keep adding the numbers together,

1233
01:27:19,730 --> 01:27:22,380
and then you divide at the end by the total number of things.

1234
01:27:22,380 --> 01:27:23,520
So how can I do this?

1235
01:27:23,520 --> 01:27:30,515
Well, let me change my implementation of average to first declare a variable called sum, or whatever, set it equal to 0.

1236
01:27:30,515 --> 01:27:36,590
So this is like me on my piece of paper getting ready to count, or my calculator, of course, when you turn it on, typically defaults to zero.

1237
01:27:36,590 --> 01:27:46,730
And now, let me do for, int i equals 0. i is less than a-- well, no, I didn't do that. i is less than n, i++.

1238
01:27:46,730 --> 01:27:55,910
And now in here, let me go ahead and add to the current sum, whatever is in the array's location, i.

1239
01:27:55,910 --> 01:28:04,560
And then down here, I think I can just return some divided by 3.0-- not 3.0, n, perhaps here.

1240
01:28:04,560 --> 01:28:08,492
And actually, I think I'm going to get-- let's make sure it's a float.

1241
01:28:08,492 --> 01:28:15,540
Let's use the type casting trick just to make sure I don't accidentally shortchange someone and throw away everything after the decimal point.

1242
01:28:15,540 --> 01:28:17,300
So it just escalated quickly, right?

1243
01:28:17,300 --> 01:28:18,990
Average just got a lot more involved.

1244
01:28:18,990 --> 01:28:22,130
It's not just a single one line of code, but now it's dynamic.

1245
01:28:22,130 --> 01:28:25,070
I initialize a variable called sum to 0.

1246
01:28:25,070 --> 01:28:36,740
In this loop, I go through and just keep adding to sum, which is initially 0, whatever's in array[i]-- or specifically array[0], array[1], array[2].

1247
01:28:36,740 --> 01:28:40,970
That gives me a total sum that I return, divided by the total number of things.

1248
01:28:40,970 --> 01:28:42,560
Now, this I can tighten slightly.

1249
01:28:42,560 --> 01:28:45,650
Recall that this is syntactic sugar for just adding things.

1250
01:28:45,650 --> 01:28:48,620
I can't use plus plus because that only literally adds one.

1251
01:28:48,620 --> 01:28:52,630
But I can use here, plus equals.

1252
01:28:52,630 --> 01:28:54,880
Questions on this implementation here?

1253
01:28:54,880 --> 01:29:06,450
Really the only takeaway-- or the most important takeaway is that this is the syntax for how you tell a function that it expects a whole array, not a single variable like an int or the like.

1254
01:29:06,450 --> 01:29:11,530
You literally use square brackets, but you don't specify the length inside there.

1255
01:29:11,530 --> 01:29:12,748
Yeah?

1256
01:29:12,748 --> 01:29:16,410
AUDIENCE: What variable [INAUDIBLE] at the top?

1257
01:29:16,410 --> 01:29:18,410
DAVID MALAN: What about the variable at the top?

1258
01:29:18,410 --> 01:29:22,205
AUDIENCE: [INAUDIBLE]

1259
01:29:22,205 --> 01:29:23,330
DAVID MALAN: Good question.

1260
01:29:23,330 --> 01:29:25,220
What do I have it defined as at the top?

1261
01:29:25,220 --> 01:29:33,840
This variable, N, it must be an integer if you're going to use it inside of an arrays square brackets here.

1262
01:29:33,840 --> 01:29:38,360
So this line 10, notice, no longer says 3, it says N.

1263
01:29:38,360 --> 01:29:43,970
And so whatever N is 3 or 4 or something else, that's how many integers I will get in that array.

1264
01:29:43,970 --> 01:29:48,320
And it must be, by definition of an array, an integer that goes in those square brackets.

1265
01:29:48,320 --> 01:29:50,000
And here's a common source of confusion.

1266
01:29:50,000 --> 01:29:56,210
When you create the array, that is declare it, you use square brackets like this, where you put the total number of elements you want.

1267
01:29:56,210 --> 01:30:04,610
When you subsequently use the array, like I'm doing here, you don't mention int again-- just like you don't mention int again and again once a variable exists.

1268
01:30:04,610 --> 01:30:11,990
You use the square brackets still, but you don't use N. You use 0 or 1 or 2 or, generically here, i.

1269
01:30:11,990 --> 01:30:17,060
So when C was designed, they sometimes used the same syntax for two different ideas or contexts.

1270
01:30:17,060 --> 01:30:17,984
Yeah?

1271
01:30:17,984 --> 01:30:22,645
AUDIENCE: Do you have to include line 6 [INAUDIBLE]??

1272
01:30:22,645 --> 01:30:23,770
DAVID MALAN: Good question.

1273
01:30:23,770 --> 01:30:25,900
Do I have to include line 6?

1274
01:30:25,900 --> 01:30:29,290
Short answer, yes, because of the reason we ran into last week.

1275
01:30:29,290 --> 01:30:32,750
C, or clang really, reads your code top to bottom, left to right.

1276
01:30:32,750 --> 01:30:43,610
And so if the compiler sees some mention of this function average on line 16, but you haven't told the compiler that average exists, you're going to get an error on the screen.

1277
01:30:43,610 --> 01:30:51,260
So the conventional way to do that is you just copy paste the first line of code from the function, it's so-called prototype or declaration.

1278
01:30:51,260 --> 01:30:51,760
Yeah?

1279
01:30:51,760 --> 01:30:55,662
AUDIENCE: Is there a library if you don't know the size of the array?

1280
01:30:55,662 --> 01:30:58,120
DAVID MALAN: Really good question, and a perfect segue way.

1281
01:30:58,120 --> 01:31:01,078
Is there a library you can use if you don't know the size of the array?

1282
01:31:01,078 --> 01:31:01,720
No.

1283
01:31:01,720 --> 01:31:11,020
And so if any of you have programmed in Java or Python or other languages, you can actually just ask the array, how big is it?

1284
01:31:11,020 --> 01:31:13,778
In C, you and I, the programmers, have to remember it.

1285
01:31:13,778 --> 01:31:17,445
And so short answer, no, there's no function that will just automatically do this for us.

1286
01:31:17,445 --> 01:31:25,160
And in fact, let me make a more subtle claim that it's fine to use global variables like this if they're really for configuration options.

1287
01:31:25,160 --> 01:31:25,660
Why?

1288
01:31:25,660 --> 01:31:32,440
It's just convenient to put them at the very top of the file because everyone, you, your colleagues, your TAs are going to see them at the top of the code.

1289
01:31:32,440 --> 01:31:36,130
But you really shouldn't be using them everywhere throughout your code.

1290
01:31:36,130 --> 01:31:40,610
It'd be better if the average function, itself, were independent of that special variable.

1291
01:31:40,610 --> 01:31:42,025
So by that, I mean this.

1292
01:31:42,025 --> 01:31:46,240
You know what I should really do, if I really want to be well-designed?

1293
01:31:46,240 --> 01:31:51,400
I should pass in the length of the array to the average function.

1294
01:31:51,400 --> 01:31:54,310
I should give the average function a second argument--

1295
01:31:54,310 --> 01:31:57,800
I'll call it length, for instance, but I could call it anything I want.

1296
01:31:57,800 --> 01:32:05,745
And so rather than putting N all the way down here at the bottom of my file, let me just dynamically say length instead.

1297
01:32:05,745 --> 01:32:08,620
And this is a subtlety-- and no need to get too tripped up over this.

1298
01:32:08,620 --> 01:32:13,690
But this, now, is just an example of how the same function can take not one, but two arguments.

1299
01:32:13,690 --> 01:32:19,900
But indeed, in C, you must remember, yourself, what the length of an array is.

1300
01:32:19,900 --> 01:32:26,560
You can't just ask the array via some syntax like you can, those of you who've programmed before in Java or Python.

1301
01:32:26,560 --> 01:32:27,070
Yeah?

1302
01:32:27,070 --> 01:32:35,115
AUDIENCE: [INAUDIBLE]

1303
01:32:35,115 --> 01:32:36,240
DAVID MALAN: Good question.

1304
01:32:36,240 --> 01:32:39,198
Would it be better designed to write a function that computes the size?

1305
01:32:39,198 --> 01:32:48,180
Short answer, can't do that in C. As soon as you pass an array into a function in C, you cannot figure out its size if it's a generic array like that of integers.

1306
01:32:48,180 --> 01:32:51,040
There are special cases that you can do that.

1307
01:32:51,040 --> 01:32:53,283
But in general, no, it's just not possible in C.

1308
01:32:53,283 --> 01:32:57,180
And if that's some frustration, honestly, this is why more modern languages add that feature.

1309
01:32:57,180 --> 01:32:57,680
Why?

1310
01:32:57,680 --> 01:33:01,560
Because it was really annoying, as I'm alluding here to not having that information.

1311
01:33:01,560 --> 01:33:07,540
Now, just to make sure I didn't screw up anywhere, let me compile this final version of scores.

1312
01:33:07,540 --> 01:33:08,620
Suspense.

1313
01:33:08,620 --> 01:33:14,030
All good. ./scores, 72, 73, 33, and we're still back in business.

1314
01:33:14,030 --> 01:33:15,530
So this version is more complicated.

1315
01:33:15,530 --> 01:33:18,738
And as always, we'll have this version on the course's website for reference.

1316
01:33:18,738 --> 01:33:30,440
But the point, really, is that arrays, not only can be used as containers to store multiple values-- three or more in this case-- you can also even pass them around as arguments, as such.

1317
01:33:30,440 --> 01:33:36,100
All right, now besides that, let's simplify for just a moment, and consider now the world of chars.

1318
01:33:36,100 --> 01:33:39,200
If we've just got single bytes, where does this lead us?

1319
01:33:39,200 --> 01:33:44,170
And how does this get us, ultimately, to strings to solve problems like readability and cryptography and the like?

1320
01:33:44,170 --> 01:33:48,967
Well here, for instance, are three lines of code, out of context, that simply store three chars.

1321
01:33:48,967 --> 01:33:50,800
And you can already see where this is going.

1322
01:33:50,800 --> 01:33:57,470
Having three variables called c1, c2, c3 is clearly going to end up being bad design because of all the silly redundancy here.

1323
01:33:57,470 --> 01:34:01,330
But notice, I'm using single quotes like last week because these are single chars.

1324
01:34:01,330 --> 01:34:03,647
What does this look like in the computer's memory?

1325
01:34:03,647 --> 01:34:05,480
Well, it looks a little something like this.

1326
01:34:05,480 --> 01:34:12,562
If we clear out the old memory, c1, c2, c3 probably will end up here, maybe not literally in the top left-hand corner.

1327
01:34:12,562 --> 01:34:14,020
This is just an artist's rendition.

1328
01:34:14,020 --> 01:34:18,440
But c1, c2, c3 will probably end up like that.

1329
01:34:18,440 --> 01:34:20,020
Now, what's really there?

1330
01:34:20,020 --> 01:34:21,730
It's really those same three numbers--

1331
01:34:21,730 --> 01:34:23,350
72, 73, 33.

1332
01:34:23,350 --> 01:34:27,920
But how many bits does a byte have?

1333
01:34:27,920 --> 01:34:28,880
Just eight.

1334
01:34:28,880 --> 01:34:35,330
So if we were to look at the binary representation of these characters, it would only be eight bits each.

1335
01:34:35,330 --> 01:34:39,140
That's enough to store small numbers like 72, 73, 33.

1336
01:34:39,140 --> 01:34:41,580
We're not dealing with Unicode and emoji and the like.

1337
01:34:41,580 --> 01:34:42,837
But the point is the same.

1338
01:34:42,837 --> 01:34:45,170
You don't have to use four bytes to store these numbers.

1339
01:34:45,170 --> 01:34:51,420
You can use a different data type like chars, and underneath the hood, it's, indeed, going to use just single bytes for each.

1340
01:34:51,420 --> 01:34:55,850
But this is sort of like a-- this isn't really how we implement strings, right?

1341
01:34:55,850 --> 01:34:59,270
When you wanted to say, hi, last week, or this, we used double quotes.

1342
01:34:59,270 --> 01:35:02,900
And we wrote all of the things together and used one variable, not three, right?

1343
01:35:02,900 --> 01:35:06,260
When I typed in David, I didn't have a variable for D-A-V-I-D.

1344
01:35:06,260 --> 01:35:09,750
I had one variable called name that stored the whole thing.

1345
01:35:09,750 --> 01:35:13,310
So in C, we keep talking about these things called strings.

1346
01:35:13,310 --> 01:35:17,427
We'll see, eventually, that strings are not necessarily what they seem to be.

1347
01:35:17,427 --> 01:35:22,070
But for now, the key thing about strings is that they're variable length, so to speak, right?

1348
01:35:22,070 --> 01:35:28,250
They might be three characters, Hi, or five characters, David, or anything smaller or larger.

1349
01:35:28,250 --> 01:35:33,110
So how do we go about implementing strings, if all we have at the end of the day is my memory?

1350
01:35:33,110 --> 01:35:41,900
Well, here is an example of just creating, declaring, and defining a string called s. s because it's just a simple string, and quote unquote, HI!, in double quotes.

1351
01:35:41,900 --> 01:35:44,090
What does this look like in the computer's memory?

1352
01:35:44,090 --> 01:35:45,230
Well, let's clear it again.

1353
01:35:45,230 --> 01:35:50,960
And here, now, because it's technically stored in one variable, s, here is how I might draw it as an artist.

1354
01:35:50,960 --> 01:35:52,520
It's three bytes in total--

1355
01:35:52,520 --> 01:35:53,990
H-I exclamation point.

1356
01:35:53,990 --> 01:35:59,630
But there's no c1, c2, c3, it's just, the whole thing is s.

1357
01:35:59,630 --> 01:36:06,990
But it turns out that a string, fun fact, is really just what underneath the hood?

1358
01:36:06,990 --> 01:36:12,090
Kind of leading up to this-- what is a string, if this is how it's laid out in memory?

1359
01:36:12,090 --> 01:36:13,190
AUDIENCE: An array.

1360
01:36:13,190 --> 01:36:15,830
DAVID MALAN: Literally, it's just an array of characters.

1361
01:36:15,830 --> 01:36:18,590
And we didn't have to know about arrays last week to use strings.

1362
01:36:18,590 --> 01:36:21,382
This is where, again, the training wheels are starting to come off.

1363
01:36:21,382 --> 01:36:23,730
But a string is just an array of characters.

1364
01:36:23,730 --> 01:36:26,040
H-I exclamation point, for instance.

1365
01:36:26,040 --> 01:36:38,150
So technically, an array-- or a string called s is really a variable called s that allows you to get at the first character with s[0], if you want-- s[1], s[2].

1366
01:36:38,150 --> 01:36:47,000
You can literally get individual characters just by treating s as though it's an array, which it really is underneath the hood, in this case.

1367
01:36:47,000 --> 01:36:48,560
But there's a catch.

1368
01:36:48,560 --> 01:36:51,500
How do you know where strings end?

1369
01:36:51,500 --> 01:36:54,560
In the past, when I drew some integers on the screen,

1370
01:36:54,560 --> 01:36:57,080
I know, I claim they always take up 4 bytes.

1371
01:36:57,080 --> 01:37:00,200
If I had drawn a long, it always takes up 8 bytes.

1372
01:37:00,200 --> 01:37:03,530
If I had drawn a character, it always takes up 1 byte.

1373
01:37:03,530 --> 01:37:06,533
But how many bytes does a string take up?

1374
01:37:06,533 --> 01:37:08,450
Yeah, I mean, that's kind of the right answer.

1375
01:37:08,450 --> 01:37:10,490
In this case, three, it would seem.

1376
01:37:10,490 --> 01:37:13,490
But if it's David, that's a good five characters.

1377
01:37:13,490 --> 01:37:16,173
But where do we put the number three?

1378
01:37:16,173 --> 01:37:17,840
Where do you put the number five, right?

1379
01:37:17,840 --> 01:37:20,190
This is literally all that's inside your computer.

1380
01:37:20,190 --> 01:37:23,430
This is all our building blocks in front of us.

1381
01:37:23,430 --> 01:37:25,490
So how can we-- where does the three go?

1382
01:37:25,490 --> 01:37:26,540
Where does the five go?

1383
01:37:26,540 --> 01:37:29,420
Well, it turns out you can solve this in a couple of different ways.

1384
01:37:29,420 --> 01:37:41,840
But the way humans decided to implement strings years ago is, indeed, an array, but they added one extra byte at the end of every such string array, just to make clear, with a so-called sentinel value,

1385
01:37:41,840 --> 01:37:44,480
that the string ends here.

1386
01:37:44,480 --> 01:37:45,050
Why?

1387
01:37:45,050 --> 01:37:54,590
So that if you have two strings in the computer's memory like, HI! and bye, you know where the barrier is between the exclamation point of one and the letter B in the next, right?

1388
01:37:54,590 --> 01:37:56,000
You need some kind of delimiter.

1389
01:37:56,000 --> 01:38:00,110
And so what really is underneath the hood is this.

1390
01:38:00,110 --> 01:38:07,040
When you store a string in memory, when you type in a string-- as the user, if you type in 3 characters, it's going to use

1391
01:38:07,040 --> 01:38:10,280
3 plus 1 equals 4 bytes in total.

1392
01:38:10,280 --> 01:38:14,130
If you type in David, it's going to use 5 plus 1 equals 6 bytes in total.

1393
01:38:14,130 --> 01:38:14,630
Why?

1394
01:38:14,630 --> 01:38:20,210
Because C automatically adds this special 0 at the end of the string.

1395
01:38:20,210 --> 01:38:25,710
I've drawn it with backslash 0 because this is how you represent 0 as a char, as a character.

1396
01:38:25,710 --> 01:38:28,230
But this is literally just 0, as we'll soon see.

1397
01:38:28,230 --> 01:38:36,197
So any time there's a string in memory, it always takes up one more byte than you, yourself, as the programmer or human typed in.

1398
01:38:36,197 --> 01:38:45,170
In fact, if we convert this again, just for discussion's sake, to those integers, what's literally stored in the computer's memory is going to be 72, 73, 33, and now a 0.

1399
01:38:45,170 --> 01:38:54,530
And the computer, because of C and how it was invented, it's just smart enough to know that when you print out a string, it prints out every character until it sees a 0,

1400
01:38:54,530 --> 01:38:56,150
and then it just stops printing.

1401
01:38:56,150 --> 01:38:58,470
In particular, printf knows how this works.

1402
01:38:58,470 --> 01:39:02,050
And this is why printf knows when to stop printing.

1403
01:39:02,050 --> 01:39:03,800
Decimal numbers are not that enlightening.

1404
01:39:03,800 --> 01:39:05,940
We'll generally write the characters like this.

1405
01:39:05,940 --> 01:39:09,350
And again, backslash 0 is just special symbology.

1406
01:39:09,350 --> 01:39:13,190
It's what the programmer types to make clear that you're not saying, HI!, 0.

1407
01:39:13,190 --> 01:39:15,980
You're saying HI!, and then it's a special 0.

1408
01:39:15,980 --> 01:39:22,220
Specifically, it is eight 0 bits that indicate that it's the end of the string.

1409
01:39:22,220 --> 01:39:26,330
Technically, that backslash zero, if you want to be fancy, it's called null,

1410
01:39:26,330 --> 01:39:27,320
N-U-L-L.

1411
01:39:27,320 --> 01:39:30,320
And it turns out, you've seen this before, though we didn't call it out.

1412
01:39:30,320 --> 01:39:33,230
Here's that same ASCII chart from the past couple of weeks.

1413
01:39:33,230 --> 01:39:39,080
If I highlight this, what is decimal number 0 mapping to?

1414
01:39:39,080 --> 01:39:42,830
NUL, which is just programmer speak for the special null character.

1415
01:39:42,830 --> 01:39:46,550
All 0 bits that means the string ends here.

1416
01:39:46,550 --> 01:39:48,510
This all happens automatically for you.

1417
01:39:48,510 --> 01:39:53,420
You do not need to create these null characters or these zeros.

1418
01:39:53,420 --> 01:40:00,030
Any questions then, on this implementation thus far?

1419
01:40:00,030 --> 01:40:01,820
Any questions here?

1420
01:40:01,820 --> 01:40:02,320
No?

1421
01:40:02,320 --> 01:40:03,195
Well, let me do this.

1422
01:40:03,195 --> 01:40:05,310
Let me go back to VS Code in a second.

1423
01:40:05,310 --> 01:40:07,770
And let's actually corroborate this with some code.

1424
01:40:07,770 --> 01:40:10,830
Let me go ahead and create a small program called hi.c.

1425
01:40:10,830 --> 01:40:12,070
And how about we do this?

1426
01:40:12,070 --> 01:40:14,550
Let me include stdio.h.

1427
01:40:14,550 --> 01:40:18,670
Let me include-- let me type out int main void, as always.

1428
01:40:18,670 --> 01:40:24,960
And now let me do something simple and kind of bad, but char c1 equals quote unquote, h, in single quotes.

1429
01:40:24,960 --> 01:40:28,590
Char c2 equals quote unquote, I, in single quotes.

1430
01:40:28,590 --> 01:40:32,830
And lastly, char c3 equals exclamation point, in single quotes.

1431
01:40:32,830 --> 01:40:34,500
And now, let me just print this out.

1432
01:40:34,500 --> 01:40:36,960
I can't use %s because that is not a string.

1433
01:40:36,960 --> 01:40:40,290
That's literally three chars, because that's the design decision I made.

1434
01:40:40,290 --> 01:40:41,430
But I could do this--

1435
01:40:41,430 --> 01:40:48,600
%c, %c, %c, which we haven't seen before, but %s is string, %i is int,

1436
01:40:48,600 --> 01:40:51,060
%c is, indeed, char.

1437
01:40:51,060 --> 01:40:56,280
So let me put a backslash n at the end for cleanliness, and now do, c1, c2, c3.

1438
01:40:56,280 --> 01:41:00,430
So this is like a char-based version of printing string.

1439
01:41:00,430 --> 01:41:01,650
So let me make HI!

1440
01:41:01,650 --> 01:41:05,880
And then let me do ./hi, and it looks like I used printf with %s.

1441
01:41:05,880 --> 01:41:09,750
But I did things very manually by printing out each individual character.

1442
01:41:09,750 --> 01:41:16,560
What's cool now, though, is that once you know that characters are just numbers and strings are just characters, you can kind of poke around.

1443
01:41:16,560 --> 01:41:21,970
Let me change all three placeholders to %i instead.

1444
01:41:21,970 --> 01:41:23,860
And this is totally fine, too.

1445
01:41:23,860 --> 01:41:26,310
Let me rerun this, make hi.

1446
01:41:26,310 --> 01:41:31,570
Actually, let me make one change, just so we can see this.

1447
01:41:31,570 --> 01:41:40,350
Let me add spaces, just for aesthetics sake, let me do make hi, ./hi, Enter, and voila, like now, you can actually see the numbers,

1448
01:41:40,350 --> 01:41:44,085
that I claimed back in week zero, were in fact happening underneath the hood.

1449
01:41:44,085 --> 01:41:45,960
Well, this is not how you would make strings.

1450
01:41:45,960 --> 01:41:50,790
It'd be incredibly tedious to have three variables for three letter words, five variables for five letter words.

1451
01:41:50,790 --> 01:41:54,450
We've been using, of course, strings since last week, so let's do that instead.

1452
01:41:54,450 --> 01:41:59,370
String s equals quote unquote, double quotes "HI!"

1453
01:41:59,370 --> 01:42:02,520
For this, no, because of these training wheels,

1454
01:42:02,520 --> 01:42:04,560
I need to include the CS50 library.

1455
01:42:04,560 --> 01:42:06,580
But we'll come back to that in the coming weeks.

1456
01:42:06,580 --> 01:42:10,530
But for now, I'm going to go ahead and create a string s called quote unquote,

1457
01:42:10,530 --> 01:42:11,580
"HI!"

1458
01:42:11,580 --> 01:42:17,610
And now I'm going to change this to be my familiar %s, and now just print out s itself.

1459
01:42:17,610 --> 01:42:24,750
This, of course, is the same thing as last week, ./hi, gives me the exact same thing, but now, we're dealing, of course, with strings.

1460
01:42:24,750 --> 01:42:27,610
But how can we see a little beyond that?

1461
01:42:27,610 --> 01:42:28,810
Well, how about this?

1462
01:42:28,810 --> 01:42:31,530
Let's poke around further with today's primitives.

1463
01:42:31,530 --> 01:42:39,000
Even though s is a string, I could technically print out its first character with %c by doing s[0].

1464
01:42:39,000 --> 01:42:43,110
I could technically print out its second character with %c by doing s[1].

1465
01:42:43,110 --> 01:42:47,820
I could print out its third character with %c and printing out s[2].

1466
01:42:47,820 --> 01:42:52,770
So again, this just derives logically from my understanding now that strings are arrays, as you note.

1467
01:42:52,770 --> 01:42:57,300
Let me do make-- let me do make hi, ./hi.

1468
01:42:57,300 --> 01:43:00,760
And no visual change, but I'm just kind of now tinkering around.

1469
01:43:00,760 --> 01:43:03,400
And in fact, if you're really curious, let me do this.

1470
01:43:03,400 --> 01:43:08,250
Let me change these back to i, back to i-- oops, back to i.

1471
01:43:08,250 --> 01:43:14,490
And let me add a fourth one because if I'm really curious now, let's see what's in s[3].

1472
01:43:14,490 --> 01:43:16,020
This is the fourth byte.

1473
01:43:16,020 --> 01:43:18,990
And even though the string itself is H-I,

1474
01:43:18,990 --> 01:43:21,840
I think we can corroborate this whole null thing.

1475
01:43:21,840 --> 01:43:26,248
Make hi, ./hi, Enter, and there it is.

1476
01:43:26,248 --> 01:43:29,580
You could have done this last week, if you really wanted to geek out on strings.

1477
01:43:29,580 --> 01:43:33,060
But for now, it's just revealing what's going on underneath the hood.

1478
01:43:33,060 --> 01:43:36,480
Questions then, on what these strings are?

1479
01:43:36,480 --> 01:43:37,498
Yeah?

1480
01:43:37,498 --> 01:43:41,293
AUDIENCE: [INAUDIBLE]

1481
01:43:41,293 --> 01:43:42,960
DAVID MALAN: Why do we need the bracket?

1482
01:43:42,960 --> 01:43:45,430
AUDIENCE: [INAUDIBLE]

1483
01:43:45,430 --> 01:43:47,180
DAVID MALAN: Why do you not need brackets?

1484
01:43:47,180 --> 01:43:47,780
Good question.

1485
01:43:47,780 --> 01:43:51,620
Why do I not need brackets on line 6?

1486
01:43:51,620 --> 01:43:53,300
Because s is a string.

1487
01:43:53,300 --> 01:44:02,240
We'll see in a couple of weeks that s is, essentially, implemented underneath the hood, indeed, as an array, but that happens automatically for you.

1488
01:44:02,240 --> 01:44:06,800
You can treat s as just a variable name without square brackets.

1489
01:44:06,800 --> 01:44:13,730
You will use square brackets when you have arrays of ints or you manually create arrays of chars or doubles or floats or anything else.

1490
01:44:13,730 --> 01:44:14,900
But strings are special.

1491
01:44:14,900 --> 01:44:15,440
Why?

1492
01:44:15,440 --> 01:44:19,190
I mean, every program you write seems to use strings, text in some form.

1493
01:44:19,190 --> 01:44:21,930
We're humans we like text, not just numbers and such.

1494
01:44:21,930 --> 01:44:28,580
So this is just treated a little specially in C and many other languages as well.

1495
01:44:28,580 --> 01:44:31,170
Other questions on this here?

1496
01:44:31,170 --> 01:44:31,670
No?

1497
01:44:31,670 --> 01:44:33,530
Let's add then, one other string to the mix.

1498
01:44:33,530 --> 01:44:38,660
So instead of just saying, HI!, why don't we consider a version of the program that says both, HI! and BYE!.

1499
01:44:38,660 --> 01:44:48,570
And I claim now that that backslash zero, that null character is going to be ever more important now if we've got two strings in memory, so that C knows how to distinguish one from the other.

1500
01:44:48,570 --> 01:44:51,487
So let me go ahead and just get rid of these two lines for the moment.

1501
01:44:51,487 --> 01:44:55,430
Let me recreate string s equals, quote unquote double quotes, "HI!"

1502
01:44:55,430 --> 01:44:56,780
Let me give myself another one.

1503
01:44:56,780 --> 01:44:59,905
And because I'm just playing around, I'll choose very short variable names.

1504
01:44:59,905 --> 01:45:04,410
String t equals quote unquote, "BYE!"

1505
01:45:04,410 --> 01:45:06,470
And then let me just print them both out.

1506
01:45:06,470 --> 01:45:16,910
Let me go ahead and print out %s, backslash n, comma s, and then printf %s backslash n, and then t.

1507
01:45:16,910 --> 01:45:19,970
So very simple demonstration of just these two variables.

1508
01:45:19,970 --> 01:45:26,090
Make hi, ./hi, and of course, it prints out two lines, one after the other.

1509
01:45:26,090 --> 01:45:27,980
What's actually going on underneath the hood?

1510
01:45:27,980 --> 01:45:29,510
Well, let's go back to the computer's memory.

1511
01:45:29,510 --> 01:45:32,160
HI!, I think, is going to be, I claim, pretty much the same.

1512
01:45:32,160 --> 01:45:36,170
So s, I'll claim, is in the top left, followed by the backslash zero.

1513
01:45:36,170 --> 01:45:40,035
And that's important now because BYE! probably is going to end up there.

1514
01:45:40,035 --> 01:45:44,330
And visually, it wraps just by nature of how I've drawn this grid of bytes, but it's contiguous.

1515
01:45:44,330 --> 01:45:58,580
B-Y-E-! null, A.K.A. backslash zero, this is now helpful to printf because now printf knows where one begins and ends by way of that special null character.

1516
01:45:58,580 --> 01:46:00,230
But we can poke around now, too.

1517
01:46:00,230 --> 01:46:01,620
What else can I do here?

1518
01:46:01,620 --> 01:46:02,840
How about this?

1519
01:46:02,840 --> 01:46:15,410
How about I go into my code here, back to VS code, and let me go ahead and say something like, well, if I've got two of these strings, you know, let's put them in an array.

1520
01:46:15,410 --> 01:46:20,520
Let's kind of do this sort of arrays in arrays, sort of inception-style here.

1521
01:46:20,520 --> 01:46:23,060
So string words[2].

1522
01:46:23,060 --> 01:46:25,100
So give me an array of two strings is what

1523
01:46:25,100 --> 01:46:28,100
I'm saying here in code, even though we've not done it with strings yet.

1524
01:46:28,100 --> 01:46:29,270
We only did it with ints.

1525
01:46:29,270 --> 01:46:30,770
And now let me do this.

1526
01:46:30,770 --> 01:46:35,480
The first word A.K.A. words[0] will equal, as before, HI!

1527
01:46:35,480 --> 01:46:40,940
And now words[1] will equal quote unquote, "BYE!"

1528
01:46:40,940 --> 01:46:48,650
And now I've done the exact same thing, but again, I'm just avoiding having s, t, q, r, and all these different variables in my code.

1529
01:46:48,650 --> 01:46:52,790
I just now am treating them as one single array of strings.

1530
01:46:52,790 --> 01:46:54,750
How do I change my code down here?

1531
01:46:54,750 --> 01:46:57,380
Well, if I want to print the first word, I do words[0].

1532
01:46:57,380 --> 01:46:59,900
And if I want to print the second word, I do words[1].

1533
01:46:59,900 --> 01:47:04,130
This is not a useful exercise at the moment because I'm just making my code more complicated.

1534
01:47:04,130 --> 01:47:09,530
But again, it allows us to poke around and see what's going on because there is that HI! and BYE!.

1535
01:47:09,530 --> 01:47:10,700
But watch this.

1536
01:47:10,700 --> 01:47:14,670
If I really want to be cool, I can do this.

1537
01:47:14,670 --> 01:47:25,700
Let's print out %c, %c, %c, backslash n, and then here, %c, %c, %c, %c, so four of those.

1538
01:47:25,700 --> 01:47:28,430
And now here's where things get interesting.

1539
01:47:28,430 --> 01:47:30,620
Words is an array of strings.

1540
01:47:30,620 --> 01:47:33,400
Again, if I may, what's a string?

1541
01:47:33,400 --> 01:47:35,060
An array of characters.

1542
01:47:35,060 --> 01:47:36,790
So just use the same logic.

1543
01:47:36,790 --> 01:47:41,110
If words is an array of strings, you get at the first string with words[0].

1544
01:47:41,110 --> 01:47:44,530
How do you get at the first character in the first string?

1545
01:47:44,530 --> 01:47:52,150
Bracket 0, words[0][1], and lastly, words[0][2].

1546
01:47:52,150 --> 01:47:57,460
And now down here, words[1], but the first character is there.

1547
01:47:57,460 --> 01:48:00,400
Word[1], the second character is here.

1548
01:48:00,400 --> 01:48:04,720
Words[1], the third character is here-- whoops-- third character's here.

1549
01:48:04,720 --> 01:48:07,898
And words[1], the fourth character is here.

1550
01:48:07,898 --> 01:48:09,190
This is not how people program.

1551
01:48:09,190 --> 01:48:10,840
This is only for demonstrations sake.

1552
01:48:10,840 --> 01:48:13,060
My God, it's so tedious and verbose already.

1553
01:48:13,060 --> 01:48:22,990
But if I make hi now, ./hi, now, I'm manually reinventing %s, if I forgot it existed, using %c alone.

1554
01:48:22,990 --> 01:48:25,900
But you can indeed manipulate arrays in this way.

1555
01:48:25,900 --> 01:48:32,200
But because strings are arrays of characters, you can manipulate strings in this way too.

1556
01:48:32,200 --> 01:48:34,675
Any question now on this syntax?

1557
01:48:37,210 --> 01:48:38,800
Any questions here?

1558
01:48:38,800 --> 01:48:39,970
No?

1559
01:48:39,970 --> 01:48:45,830
All right, well, let's go ahead and propose that we solve a couple of other problems we might not have as before.

1560
01:48:45,830 --> 01:48:49,150
But first, a quick visual of what's been going on underneath the hood here.

1561
01:48:49,150 --> 01:49:00,880
If here, again, is where we left off on the screen, HI! and BYE! back to back, here is really how I just treated these things. s bracket 0, 1, 2, 3 and then t 0, 1, 2, 3, 4.

1562
01:49:00,880 --> 01:49:04,840
But really, once I put them in an array, the picture becomes this.

1563
01:49:04,840 --> 01:49:07,030
Words[0] is the whole HI!.

1564
01:49:07,030 --> 01:49:08,680
Words[1] is the whole BYE!.

1565
01:49:08,680 --> 01:49:20,710
But if I really get into the weeds and start indexing into individual characters in those strings, all I'm using is new syntax in order to represent these same values here.

1566
01:49:20,710 --> 01:49:28,710
Questions then, on these representations before we forge ahead?

1567
01:49:28,710 --> 01:49:29,430
No?

1568
01:49:29,430 --> 01:49:30,030
Yeah?

1569
01:49:30,030 --> 01:49:33,390
AUDIENCE: Does the new line character not [INAUDIBLE]??

1570
01:49:33,390 --> 01:49:36,030
DAVID MALAN: Does the new line character-- say that once more?

1571
01:49:36,030 --> 01:49:38,597
AUDIENCE: Does the new line character take up any space?

1572
01:49:38,597 --> 01:49:40,180
DAVID MALAN: Ah, really good question.

1573
01:49:40,180 --> 01:49:42,730
Does the new line character take up any space?

1574
01:49:42,730 --> 01:49:45,340
It does, so far as printf is concerned.

1575
01:49:45,340 --> 01:49:53,460
But I'm not storing the backslash n in my strings, printf is being manually handed that thing instead.

1576
01:49:53,460 --> 01:50:00,680
All right, so let's go ahead then and consider how we might solve some problems that have arisen now with these strings, as follows here.

1577
01:50:00,680 --> 01:50:02,760
Suppose I-- let's do this.

1578
01:50:02,760 --> 01:50:04,400
Let me go back to VS Code here.

1579
01:50:04,400 --> 01:50:09,980
And let me go ahead and open up a new file called, how about, length.c.

1580
01:50:09,980 --> 01:50:16,130
And let's consider for a moment how I might actually figure out what the length of a string is, which is distinct from the length of an array.

1581
01:50:16,130 --> 01:50:20,180
I claimed earlier, you cannot figure out dynamically what the length of an array is.

1582
01:50:20,180 --> 01:50:26,960
But I can figure out the length of a string, specifically, because of this implementation detail of that null character.

1583
01:50:26,960 --> 01:50:28,500
So let me go ahead and do this.

1584
01:50:28,500 --> 01:50:31,940
Let me include cs50.h in this second program here.

1585
01:50:31,940 --> 01:50:35,090
Let me include stdio.h, as before.

1586
01:50:35,090 --> 01:50:40,970
And let me do this, int main void-- and the first thing I'll do is just get a string from the user.

1587
01:50:40,970 --> 01:50:43,250
I'll ask the user, as always, for their name.

1588
01:50:43,250 --> 01:50:48,170
So I'll call getString, and say, what's your name, question mark, as always.

1589
01:50:48,170 --> 01:50:58,465
And then down here, if I want to figure out the length of this string and print the length out on the screen, well, I can kind of do this similar in spirit to the average,

1590
01:50:58,465 --> 01:50:59,840
where I'm accumulating something.

1591
01:50:59,840 --> 01:51:02,600
Let me go ahead and initialize N to 0.

1592
01:51:02,600 --> 01:51:07,035
Let me give myself-- it's not a for loop because I don't have a--

1593
01:51:07,035 --> 01:51:08,660
I don't know in advance how long it is.

1594
01:51:08,660 --> 01:51:09,980
But what if I do this?

1595
01:51:09,980 --> 01:51:25,590
While the value at name[n] does not equal '/0'-- crazy syntax at the moment, but it's just the culmination of these various building blocks.

1596
01:51:25,590 --> 01:51:28,970
Let me just finish the thought here, n++.

1597
01:51:28,970 --> 01:51:43,220
And then down here, let's just print out, with printf and %i, that value of N. So I claim this is going to show me the length of any string I type in, whether it's hi or bye or David or anything else.

1598
01:51:43,220 --> 01:51:47,535
I initialize a variable to zero, and that's good because that's where you start counting in general.

1599
01:51:47,535 --> 01:51:50,990
While name[0] does not equal backslash zero.

1600
01:51:50,990 --> 01:51:51,930
What is this saying?

1601
01:51:51,930 --> 01:51:59,390
Well, if name is the string the user typed in-- and name is just an array, as you noted-- the name[0] is going to be the first character.

1602
01:51:59,390 --> 01:52:03,680
And I'm asking the question, well, does the first character not equal backslash zero?

1603
01:52:03,680 --> 01:52:08,750
And if I type in David, D, it's not, so I keep going and I add 1 to N.

1604
01:52:08,750 --> 01:52:10,750
Then I'm going to check name[1].

1605
01:52:10,750 --> 01:52:13,895
Well, if I typed in David, name[1] is going to be A.

1606
01:52:13,895 --> 01:52:18,740
A does not equal backslash zero, and so it's going to go again and again and again.

1607
01:52:18,740 --> 01:52:23,090
But five steps in total later, it's going to get to the byte after

1608
01:52:23,090 --> 01:52:26,480
D-A-V-I-D, realize, wait a minute, that is a backslash n.

1609
01:52:26,480 --> 01:52:29,750
The loop finishes, and I print out the total length.

1610
01:52:29,750 --> 01:52:33,050
Arrays, in general, do not have this null character.

1611
01:52:33,050 --> 01:52:34,910
However, strings do.

1612
01:52:34,910 --> 01:52:39,590
Again, strings are special versus all of the other data types we've talked about thus far.

1613
01:52:39,590 --> 01:52:43,220
But how could I, for instance, do this differently?

1614
01:52:43,220 --> 01:52:47,220
Well, let's actually factor this out as a function, as I've commonly done.

1615
01:52:47,220 --> 01:52:50,540
But rather than implement it myself, you know what?

1616
01:52:50,540 --> 01:52:57,260
It turns out what's nice about strings being so common, there are many other people who have solved these problems before.

1617
01:52:57,260 --> 01:53:00,290
And in fact, there's a whole string library in C.

1618
01:53:00,290 --> 01:53:04,190
It is used by way of a header file called string.h.

1619
01:53:04,190 --> 01:53:08,400
And what string.h is, is a library of string-related functions.

1620
01:53:08,400 --> 01:53:18,050
In fact, you can see in CS50's manual pages for C, the string.h functions, at least those that we recommend as most useful, and in particular, if you poke around there,

1621
01:53:18,050 --> 01:53:20,290
you'll see that there's a function called strlen.

1622
01:53:20,290 --> 01:53:22,055
It means string length.

1623
01:53:22,055 --> 01:53:25,850
It was named very succinctly, just because it's a little easier to type than string length.

1624
01:53:25,850 --> 01:53:28,800
But strlen tells you the length of a string.

1625
01:53:28,800 --> 01:53:30,990
So how might I use this in my code here?

1626
01:53:30,990 --> 01:53:34,020
Well, it turns out, I can simplify this quite a bit.

1627
01:53:34,020 --> 01:53:45,630
Let me get rid of my loop, get rid of my accounting manually, and do something like this-- int n equals strlen of the humans name, name.

1628
01:53:45,630 --> 01:53:51,290
And now I'll just use printf, as before, with %i backslash n, and output the value of n.

1629
01:53:51,290 --> 01:53:54,380
But there's a bug at the moment.

1630
01:53:54,380 --> 01:53:58,480
What have I forgotten to do?

1631
01:53:58,480 --> 01:54:03,260
Yeah, I have to include the header file at the top of the screen, so let me-- at the top of the code.

1632
01:54:03,260 --> 01:54:10,970
So let me also include string.h at the top of my file, so that C knows that, in fact, strlen exists.

1633
01:54:10,970 --> 01:54:14,170
Let me go ahead and make length, as before.

1634
01:54:14,170 --> 01:54:18,670
./length-- or actually, really for the first time, what's your name?

1635
01:54:18,670 --> 01:54:22,360
D-A-V-I-D. And hopefully, I'm going to see, in fact, 5.

1636
01:54:22,360 --> 01:54:26,950
By contrast, if I run it again and type in HI!, now I see three.

1637
01:54:26,950 --> 01:54:29,785
So strlen is just one of the functions in that library.

1638
01:54:29,785 --> 01:54:30,910
And there are so many more.

1639
01:54:30,910 --> 01:54:40,580
In fact, yet another library that might be useful moving forward is this one, ctype, which relates to C data types and lots of functions therein that can be useful.

1640
01:54:40,580 --> 01:54:49,460
For instance, if you review its documentation in the manual pages online, you'll see that there are functions via which we can solve problems like this.

1641
01:54:49,460 --> 01:54:53,680
Let me go ahead and propose here-- let me see.

1642
01:54:53,680 --> 01:55:06,700
Let's do an example here involving-- how about checking if something is uppercase or lowercase, and converting it to uppercase only.

1643
01:55:06,700 --> 01:55:10,810
Let me go back to VS Code, and code a program called uppercase.c.

1644
01:55:10,810 --> 01:55:15,220
In this, file I'm going to start by including now, as always, cs50.h.

1645
01:55:15,220 --> 01:55:17,710
I'm going to include stdio.h.

1646
01:55:17,710 --> 01:55:26,230
And I'm going to add one other to the mix, which is string.h now too, so I can access the length of things as needed.

1647
01:55:26,230 --> 01:55:28,570
Int main void comes next.

1648
01:55:28,570 --> 01:55:32,230
And then within my main function, I'm going to go ahead and declare a string called s.

1649
01:55:32,230 --> 01:55:34,240
I'm going to call getString, as before.

1650
01:55:34,240 --> 01:55:38,170
And I'm going to go ahead and just ask the user for a string called before.

1651
01:55:38,170 --> 01:55:39,670
I want to do a before and after.

1652
01:55:39,670 --> 01:55:41,350
Whatever the user types in is before.

1653
01:55:41,350 --> 01:55:44,770
But I want to force everything to uppercase, thereafter.

1654
01:55:44,770 --> 01:55:48,740
Let me now, in this loop here, do this.

1655
01:55:48,740 --> 01:55:53,800
Let me printf quote unquote, "After," just so we can see this on the screen.

1656
01:55:53,800 --> 01:56:02,440
And let me do four int i gets 0, i is less than strlen of s, i++.

1657
01:56:02,440 --> 01:56:03,610
What am I about to do?

1658
01:56:03,610 --> 01:56:11,230
I'm about to iterate over every character in the string from left to right, from 0 on up to, but not through, the length of s.

1659
01:56:11,230 --> 01:56:16,990
And how do I check if something is lowercase, so that I can actually force it to uppercase?

1660
01:56:16,990 --> 01:56:19,630
Well, it turns out, I could do this literally.

1661
01:56:19,630 --> 01:56:31,780
If the character in s at location i is greater than or equal to capital A, ampersand, ampersand, which means and instead of or, which we saw

1662
01:56:31,780 --> 01:56:41,800
in the past, s[i] is less than or equal to little z, that means, logically in English, that this is indeed lowercase.

1663
01:56:41,800 --> 01:56:44,830
How do I now convert it to uppercase, this character?

1664
01:56:44,830 --> 01:56:48,160
Well, I could just literally print out the same character.

1665
01:56:48,160 --> 01:56:52,280
But that would not be the answer here because that's not changing the value.

1666
01:56:52,280 --> 01:56:54,470
But what could I do instead?

1667
01:56:54,470 --> 01:57:03,220
Well, let me actually pull up here real fast the ASCII chart as before, and let's see if we can't glean some insight.

1668
01:57:03,220 --> 01:57:09,790
If I pull up the same ASCII chart, and suppose the human has typed in a lowercase a, that's 97.

1669
01:57:09,790 --> 01:57:13,240
What letter-- I want to convert it to uppercase

1670
01:57:13,240 --> 01:57:18,660
A, so what number do I want to convert the 97 to, per week zero?

1671
01:57:18,660 --> 01:57:21,000
So 65, we keep coming back to that one.

1672
01:57:21,000 --> 01:57:23,010
What if the user types in lowercase b?

1673
01:57:23,010 --> 01:57:27,550
I want to change the 98 value to 66, and so forth.

1674
01:57:27,550 --> 01:57:30,130
And any quick math, how far apart are those?

1675
01:57:30,130 --> 01:57:37,990
So it's always 32, like uppercase to lowercase is always, wonderfully, good design, 32 away, one from the other.

1676
01:57:37,990 --> 01:57:39,100
So what does this mean?

1677
01:57:39,100 --> 01:57:42,600
Well, I think we saw earlier that underneath the hood, a char is just a number.

1678
01:57:42,600 --> 01:57:44,340
You can certainly do arithmetic on it.

1679
01:57:44,340 --> 01:57:48,180
And here, again, if you understand these lower level primitives, what if I do this?

1680
01:57:48,180 --> 01:57:57,048
Whatever s[i] is, if I know on line 13 that it's lowercase, do I want to add or subtract 32?

1681
01:57:57,048 --> 01:57:57,840
AUDIENCE: Subtract.

1682
01:57:57,840 --> 01:58:06,560
DAVID MALAN: So I want to subtract because I want to go from like 97 to 65 or 98 to 66, so indeed, if you do some quick math, that gives you 32.

1683
01:58:06,560 --> 01:58:16,370
So it's suffices to just treat chars as numbers, subtract the 32, and printing it with %c, I think, will just convert lowercase to uppercase.

1684
01:58:16,370 --> 01:58:24,980
If you now fast forward to the real world, Microsoft Word or Google Docs, if you've ever chosen the menu option that forces things to uppercase or lowercase on occasion, literally, that's

1685
01:58:24,980 --> 01:58:26,480
what Microsoft and Google have done.

1686
01:58:26,480 --> 01:58:33,810
They iterate over every character in the document, check if it's lowercase, and if so, they subtract 32 from it and show you the new value.

1687
01:58:33,810 --> 01:58:36,650
What if, though, it is not a lowercase letter?

1688
01:58:36,650 --> 01:58:46,490
I think I can keep it easy and just print out the current letter unchanged, if my goal is to simply force things to all uppercase, and that letter, then would be s[i].

1689
01:58:46,490 --> 01:58:50,750
So let me go ahead now and make uppercase, hopefully, no errors.

1690
01:58:50,750 --> 01:58:57,120
./uppercase, and I'll now type in David with an uppercase D, but lowercase everything else.

1691
01:58:57,120 --> 01:59:01,190
But now the after version is DAVID-- an aesthetic bug.

1692
01:59:01,190 --> 01:59:05,930
Notice here, I forgot to include, just for prettiness sake, a backslash n at the end.

1693
01:59:05,930 --> 01:59:07,640
No problem, I'll add that.

1694
01:59:07,640 --> 01:59:08,870
Let me fix my mistake.

1695
01:59:08,870 --> 01:59:12,050
Make uppercase, ./uppercase, Enter.

1696
01:59:12,050 --> 01:59:14,240
D-A-V-I-D, Enter, and voila.

1697
01:59:14,240 --> 01:59:22,070
And I deliberately added another space after, just so they would line up pretty, even though before and after have different numbers of letters.

1698
01:59:22,070 --> 01:59:28,380
Questions then, on this implementation of forcing something to uppercase, which in and of itself is not all that enlightening,

1699
01:59:28,380 --> 01:59:33,990
but is representative now of how you can leverage these low level primitives.

1700
01:59:33,990 --> 01:59:35,880
Question?

1701
01:59:35,880 --> 01:59:36,380
No?

1702
01:59:36,380 --> 01:59:38,633
All right, well, this honestly is tedious.

1703
01:59:38,633 --> 01:59:43,550
My God, like does Microsoft, Google, everyone, you have to literally write out this code just to do something simple?

1704
01:59:43,550 --> 01:59:46,310
Well, no, that's, again, why we have things like libraries.

1705
01:59:46,310 --> 01:59:55,940
And increasingly now, for problem sets, projects, and beyond, well, you just use libraries more often off-the-shelf so as to solve problems that, surely, other people have had before you.

1706
01:59:55,940 --> 01:59:59,570
So how can I now use this library, ctype.h?

1707
01:59:59,570 --> 02:00:01,320
Well, let me go back into my code.

1708
02:00:01,320 --> 02:00:05,090
Let me include this among my header files here.

1709
02:00:05,090 --> 02:00:08,030
Just so I can skim things easily, I tend to alphabetize my headers.

1710
02:00:08,030 --> 02:00:13,400
But that's not strictly necessary, but it allows me, at a glance, to realize, did I or did I not include something I need?

1711
02:00:13,400 --> 02:00:15,570
Now, let me go ahead and do this.

1712
02:00:15,570 --> 02:00:28,910
It turns out if you read the documentation for the C type library, there's a function, wonderfully called, if islower, that takes in a character as its argument, essentially, so s[i].

1713
02:00:28,910 --> 02:00:33,890
And if that returns true, a Boolean value, if you will, well, I'm going to force it to lowercase.

1714
02:00:33,890 --> 02:00:36,560
But I don't have to do this math anymore.

1715
02:00:36,560 --> 02:00:45,060
Turns out, in the C type library, there's also a function called to upper that takes a character as input, like s[i], and it just does the math for you.

1716
02:00:45,060 --> 02:00:50,400
So that you can abstract away the 32 thing, and just know that someone else has solved that problem for you.

1717
02:00:50,400 --> 02:00:55,200
Otherwise, I can leave my code unchanged down below because I'm not changing anything else.

1718
02:00:55,200 --> 02:01:03,710
So if I do make uppercase now, and then ./uppercase, D-a-v-i-d, with just a capital D, and now it still works.

1719
02:01:03,710 --> 02:01:07,520
But if you read the documentation further, it turns out that to upper is smart.

1720
02:01:07,520 --> 02:01:13,040
If you pass in a character to to upper, that's lowercase, it obviously converts it to uppercase by doing that math.

1721
02:01:13,040 --> 02:01:21,540
But if you pass in a character to to upper that's already uppercase, the documentation you would see tells you that it leaves it unchanged.

1722
02:01:21,540 --> 02:01:23,910
So I can tighten all of this up.

1723
02:01:23,910 --> 02:01:25,880
I can get rid of the whole else.

1724
02:01:25,880 --> 02:01:33,620
I can get rid of the whole if, and arguably now, implement a program that's just as correct, but better designed.

1725
02:01:33,620 --> 02:01:34,250
Why?

1726
02:01:34,250 --> 02:01:39,740
Fewer lines of code easier to read, lower probability of mistakes, assuming the library is correct.

1727
02:01:39,740 --> 02:01:43,160
It just makes it easier and faster for me, now, to write code.

1728
02:01:43,160 --> 02:01:50,190
So if I now do, one last time, make uppercase, Enter, ./uppercase, and type in my name, still working.

1729
02:01:50,190 --> 02:01:57,740
But now notice, we've whittled this down to far fewer lines of code, albeit, using now this additional library.

1730
02:01:57,740 --> 02:02:00,140
Questions then on how we did this?

1731
02:02:03,930 --> 02:02:09,120
Well, even though this code, I daresay, is correct, it's not necessarily well-designed just yet.

1732
02:02:09,120 --> 02:02:17,900
In fact, there's one line of code, one function call in this current implementation that's more inefficient than it needs to be.

1733
02:02:17,900 --> 02:02:24,320
And allow me to draw your attention to this here, line 10, wherein we're calling strlen.

1734
02:02:24,320 --> 02:02:29,000
But we're calling it inside of this for loop, specifically, inside of the condition.

1735
02:02:29,000 --> 02:02:33,720
And why might that not necessarily be the best idea?

1736
02:02:33,720 --> 02:02:36,810
Well, is the length of the string as changing, ever?

1737
02:02:36,810 --> 02:02:38,950
I mean, certainly not within the span of this loop.

1738
02:02:38,950 --> 02:02:45,242
And so here we are within our for loop on line 10, 11, 12, and 13, asking on every iteration that same question.

1739
02:02:45,242 --> 02:02:48,330
What's the length of s?

1740
02:02:48,330 --> 02:02:52,660
And in turn, we're calling strlen every time, even though we're getting back the same answer.

1741
02:02:52,660 --> 02:02:59,490
So I daresay a better solution here would be to maybe figure out the length of s earlier on in my code, and maybe declare a variable.

1742
02:02:59,490 --> 02:03:07,860
Or perhaps do something that's syntactically a little more elegant, and in fact, a very common design in a loop like this, would be to declare not just one variable like i,

1743
02:03:07,860 --> 02:03:16,530
but to actually declare a second variable called n, for instance, where n is just some number, set n equal to the length of s.

1744
02:03:16,530 --> 02:03:24,540
But thereafter, inside of this condition, instead of calling strlen of s again and again and again, what might I now do?

1745
02:03:24,540 --> 02:03:32,730
I could instead just compare i against n itself, because n now will only be calculated once when it's initialized, just as i is initialize to zero.

1746
02:03:32,730 --> 02:03:37,350
And thereafter, we're going to be comparing i, which is changing, against n, which will not be.

1747
02:03:37,350 --> 02:03:40,330
So it's going to be marginally more efficient by design.

1748
02:03:40,330 --> 02:03:47,100
Now with that said, a good compiler could also recognize that there is this optimization possibility, and maybe do it for us.

1749
02:03:47,100 --> 02:03:54,010
But for now, best to get into the habit, best to develop the muscle memory for making those better design decisions yourselves.

1750
02:03:54,010 --> 02:03:56,380
Questions, then, on how we did this?

1751
02:03:58,900 --> 02:03:59,650
No?

1752
02:03:59,650 --> 02:04:03,050
All right, a few final building blocks for the day.

1753
02:04:03,050 --> 02:04:13,090
So we started by talking about those command line arguments that clang uses, whereby, anything after the command that you type at a prompt, be it make

1754
02:04:13,090 --> 02:04:21,350
or clang or even CD in Linux, any word thereafter, or something cryptic like -o is a command line argument.

1755
02:04:21,350 --> 02:04:22,840
It's an input to the command.

1756
02:04:22,840 --> 02:04:27,280
It's different from a function argument because a function argument, of course, is an input to a function.

1757
02:04:27,280 --> 02:04:28,345
But it's the same idea.

1758
02:04:28,345 --> 02:04:30,970
It's just different syntax after the dollar sign at the prompt.

1759
02:04:30,970 --> 02:04:41,800
Well, it turns out that command line arguments are something you can now use in your own programs by accessing words after the prompt.

1760
02:04:41,800 --> 02:04:45,410
And let me propose that we invent this as follows.

1761
02:04:45,410 --> 02:04:53,560
Let me propose that we switch back to VS Code here, and I'll open a new file here called greet.c.

1762
02:04:53,560 --> 02:04:57,070
So in greet.c, it's going to be a program that very simply greets the user.

1763
02:04:57,070 --> 02:04:59,440
Had we written this last week, we would have done this.

1764
02:04:59,440 --> 02:05:15,980
Include cs50.h, and then include stdio.h, and then int main void, and then we might do something simple like string name equals getString, quote unquote, "What's your name?"

1765
02:05:15,980 --> 02:05:21,490
And then we would have printed out, as always, Hello, %s, and then plugging in that name.

1766
02:05:21,490 --> 02:05:29,140
So this is the same program we've implemented many times, just to make sure it works-- although, nope, that's not quite the same program.

1767
02:05:29,140 --> 02:05:30,940
Semicolon's in the wrong place.

1768
02:05:30,940 --> 02:05:32,960
This now is the same program.

1769
02:05:32,960 --> 02:05:37,610
So make greet, dot ./greet, and I'll type in my own name. hello, David.

1770
02:05:37,610 --> 02:05:38,770
So we're back there.

1771
02:05:38,770 --> 02:05:44,110
Now, what's arguably a little annoying about this program, if I type in something else like, Carter,

1772
02:05:44,110 --> 02:05:48,910
Enter, I have to run the program, wait for the prompt, type in my name, hit Enter.

1773
02:05:48,910 --> 02:05:52,360
And that's fine, but imagine if every program worked like this.

1774
02:05:52,360 --> 02:05:58,540
Like make, suppose you could only type make, then you wait for a prompt, then you type the name of the program you want to make, then you hit Enter.

1775
02:05:58,540 --> 02:06:07,930
Or worse, in Linux when you have to change directories, as you might have for problem set one, what if you had to type CD, Enter, now type the name of the folder you want to change into, Enter--

1776
02:06:07,930 --> 02:06:09,710
I mean, it just slows life down.

1777
02:06:09,710 --> 02:06:11,470
And so it just gets annoying quickly.

1778
02:06:11,470 --> 02:06:16,070
So command line arguments just let you express your whole thought all at once.

1779
02:06:16,070 --> 02:06:18,200
So how can I do this?

1780
02:06:18,200 --> 02:06:22,450
Well, if I want to express the notion of command line arguments in my code,

1781
02:06:22,450 --> 02:06:25,640
I could do something like this.

1782
02:06:25,640 --> 02:06:34,780
I could, for the very first time, go up and get rid of this void, which as of today means, this program takes no command line arguments.

1783
02:06:34,780 --> 02:06:37,540
And I can change it to exactly this.

1784
02:06:37,540 --> 02:06:43,490
Int argc, string argv, with brackets.

1785
02:06:43,490 --> 02:06:44,950
Now it's cryptic, admittedly.

1786
02:06:44,950 --> 02:06:46,150
And let me zoom in.

1787
02:06:46,150 --> 02:06:49,300
But I think we can perhaps infer now, what's going on.

1788
02:06:49,300 --> 02:06:59,230
If main now does not have void as its input, which means it takes no arguments, surely, the spoiler here is that now main will take command line arguments somehow.

1789
02:06:59,230 --> 02:07:05,180
Any guesses as to what argv is or will be?

1790
02:07:05,180 --> 02:07:08,330
What might this represent?

1791
02:07:08,330 --> 02:07:11,390
It's an array of strings, right, by way of the syntax.

1792
02:07:11,390 --> 02:07:13,223
Yeah?

1793
02:07:13,223 --> 02:07:15,480
AUDIENCE: All the characters will be typed out.

1794
02:07:15,480 --> 02:07:16,050
DAVID MALAN: Exactly.

1795
02:07:16,050 --> 02:07:19,830
It will be all of the characters, or really all of the words that you type at the prompt.

1796
02:07:19,830 --> 02:07:21,765
Argc, as an int, any guess?

1797
02:07:24,360 --> 02:07:30,290
Argument count is what it generally stands for, though technically, you could call these things anything.

1798
02:07:30,290 --> 02:07:31,520
But this is the convention.

1799
02:07:31,520 --> 02:07:41,420
Because I claimed earlier that arrays don't keep track of their own length, if you want to know how many words the human typed at the prompt after your program's name, you have to be told,

1800
02:07:41,420 --> 02:07:45,650
not just the array of the words, but the length of that array.

1801
02:07:45,650 --> 02:07:55,020
The strings, you can figure out the length of using strlen, but you can't figure out the length of the array of strings, the collection of words that the human typed in.

1802
02:07:55,020 --> 02:07:56,760
So how can I now use this?

1803
02:07:56,760 --> 02:07:59,190
Well, let me go ahead and do this.

1804
02:07:59,190 --> 02:08:04,190
Let me go ahead and change this program now just to be printf, quote unquote,

1805
02:08:04,190 --> 02:08:11,630
"hello, %2 /n", then argv[1].

1806
02:08:11,630 --> 02:08:14,780
So this is not the best version of my code yet, but it's my first.

1807
02:08:14,780 --> 02:08:21,020
Make greet, and now let me do ./greet, David all at once.

1808
02:08:21,020 --> 02:08:23,210
Enter, hello, David.

1809
02:08:23,210 --> 02:08:25,820
Now let me run it again, ./greet, Carter.

1810
02:08:25,820 --> 02:08:27,620
Enter, hello, Carter.

1811
02:08:27,620 --> 02:08:32,330
It's a marginal improvement, but I don't have to wait for getString to prompt me to hit Enter.

1812
02:08:32,330 --> 02:08:34,370
It's just speeding things up, twice as fast.

1813
02:08:34,370 --> 02:08:36,890
One less command to type in.

1814
02:08:36,890 --> 02:08:41,390
But I deliberately did [1], but what's the beginning of argv?

1815
02:08:41,390 --> 02:08:42,170
It would be [0].

1816
02:08:44,730 --> 02:08:45,780
Well, what's that?

1817
02:08:45,780 --> 02:08:48,840
This is sometimes useful, though for now, it's not.

1818
02:08:48,840 --> 02:08:54,110
Suppose I recompile my code and run this program now, greet David.

1819
02:08:54,110 --> 02:08:58,598
Anyone want to guess what's in argv[0]?

1820
02:08:58,598 --> 02:08:59,530
AUDIENCE: [INAUDIBLE]

1821
02:08:59,530 --> 02:09:00,220
DAVID MALAN: Say again?

1822
02:09:00,220 --> 02:09:01,230
AUDIENCE: Greet, hello.

1823
02:09:01,230 --> 02:09:04,530
DAVID MALAN: Greet, Enter, hello, ./greet.

1824
02:09:04,530 --> 02:09:14,460
So if you want to sort of inception style your program to figure out what its own name is, or at least how it was executed at the command line, at the terminal, you can look at argv[0].

1825
02:09:14,460 --> 02:09:21,900
In general, probably not that useful, probably better to start looking at [1], which was the first word after the program name.

1826
02:09:21,900 --> 02:09:27,690
And if there were more, I could do this how about argv[2], let me add in a second %s.

1827
02:09:27,690 --> 02:09:29,550
Let me recompile greet.

1828
02:09:29,550 --> 02:09:37,112
Let me do ./greet David Malan, Enter, and that, too, now works, taking in two words at the prompt.

1829
02:09:37,112 --> 02:09:38,820
If I really want to be smart at this now,

1830
02:09:38,820 --> 02:09:40,445
I could do something like this, though.

1831
02:09:40,445 --> 02:09:58,440
How about if the count of arguments, A.K.A. argc, equals equals to, then assume that the human typed in only their first name, and do printf hello comma %s /n, and then argv[1].

1832
02:09:58,440 --> 02:10:07,890
Else, if the human did not provide exactly two arguments, the name of the program and their own name, let's just print out a default value, lest they forgot their name

1833
02:10:07,890 --> 02:10:09,990
or they typed in two names or three names.

1834
02:10:09,990 --> 02:10:13,110
Let's just do, hello comma world as a default.

1835
02:10:13,110 --> 02:10:15,270
And we'll just ignore what the human typed in.

1836
02:10:15,270 --> 02:10:20,850
If I recompile this, make greet, I can do ./greet and David again, Enter.

1837
02:10:20,850 --> 02:10:24,840
Oops-- sorry, what am I missing?

1838
02:10:24,840 --> 02:10:26,640
Yeah, so newbie mistake.

1839
02:10:26,640 --> 02:10:30,090
Else, all right, make greet again.

1840
02:10:30,090 --> 02:10:34,050
./greet, David, Enter, there's my hello, David.

1841
02:10:34,050 --> 02:10:37,870
But if I omit my name, I just get the generic, like a default value.

1842
02:10:37,870 --> 02:10:41,590
And if I get a little curious and I type in both names, then I get ignored too.

1843
02:10:41,590 --> 02:10:42,090
Why?

1844
02:10:42,090 --> 02:10:44,880
Because I just haven't built in support for argc of three.

1845
02:10:44,880 --> 02:10:50,730
I could do anything I want, but now we have access to these kinds of building blocks.

1846
02:10:50,730 --> 02:10:52,780
All right, what else might I do here?

1847
02:10:52,780 --> 02:10:57,660
Well, it turns out there might be some final features for us to now execute.

1848
02:10:57,660 --> 02:11:06,180
Notice, though, that in C, despite what you might see in books or online tutorials, nowadays, the two official formats for defining a main function

1849
02:11:06,180 --> 02:11:17,880
are either this, which we've been using now for two plus weeks or now this, whereby, you change the void to int argc, and then for now, string argv, and then empty brackets.

1850
02:11:17,880 --> 02:11:21,400
And we'll see that this, too, is a simplification, some training wheels if you will.

1851
02:11:21,400 --> 02:11:27,840
But for now, those are the two forms, even though you will see in online tutorials and even books, some people use main in different ways.

1852
02:11:27,840 --> 02:11:30,142
These are the two now to keep in mind.

1853
02:11:30,142 --> 02:11:33,360
And I'll note that these command line arguments are kind of all over the place.

1854
02:11:33,360 --> 02:11:35,590
Didn't probably expect to see this word on the screen here.

1855
02:11:35,590 --> 02:11:36,490
And what does it mean?

1856
02:11:36,490 --> 02:11:41,880
Well, it turns out that for decades-- there's actually this program that comes with Linux systems in particular called cowsay.

1857
02:11:41,880 --> 02:11:42,510
Why?

1858
02:11:42,510 --> 02:11:51,520
Probably because someone had too much free time once and decided to write a program that creates ASCII art out of a cow saying something textually on the screen.

1859
02:11:51,520 --> 02:11:55,780
But you use cowsay, just for fun, by way of command line arguments.

1860
02:11:55,780 --> 02:12:04,770
So for instance, let me propose that I go back to VS Code here, not because I want to write any code, but I just want to use my terminal window.

1861
02:12:04,770 --> 02:12:07,320
And let me maximize my terminal window here.

1862
02:12:07,320 --> 02:12:13,170
And let me go ahead and type in something like, how about cowsay, space moo?

1863
02:12:13,170 --> 02:12:14,822
So cowsay is not a program I wrote.

1864
02:12:14,822 --> 02:12:16,030
It's been around for decades.

1865
02:12:16,030 --> 02:12:18,870
But we installed it in VS Code for you in the cloud.

1866
02:12:18,870 --> 02:12:21,330
It takes at least one command line argument.

1867
02:12:21,330 --> 02:12:23,070
What do you want the cow to say?

1868
02:12:23,070 --> 02:12:29,490
I can say, cowsay moo, and hit Enter, and voila, there is my ASCII art of a cow saying moo on the screen.

1869
02:12:29,490 --> 02:12:31,090
It can say multiple words.

1870
02:12:31,090 --> 02:12:33,960
So I can say, Hello, world, Enter.

1871
02:12:33,960 --> 02:12:35,800
And now it says, Hello, world.

1872
02:12:35,800 --> 02:12:40,470
So this is just an example of a silly program that uses command line arguments, but it takes others too.

1873
02:12:40,470 --> 02:12:45,750
Just like clang, use this convention of hyphens to change the output of the program.

1874
02:12:45,750 --> 02:12:53,520
Dash something is just a super common convention with command line arguments when you want a very terse notation for some option like output.

1875
02:12:53,520 --> 02:13:03,460
In cowsay, I read the documentation, and it turns out there's a dash f command line argument that allows you to change the appearance of the cow, if you will.

1876
02:13:03,460 --> 02:13:11,640
So if I do cowsay dash f, duck, and then some other word like quack, it's no longer a cow.

1877
02:13:11,640 --> 02:13:15,850
That command line argument turns it into a tiny, adorable duck instead.

1878
02:13:15,850 --> 02:13:20,790
And then lastly, just for fun, because I spent way too much time playing with command line arguments.

1879
02:13:20,790 --> 02:13:27,910
Cowsay dash f, dragon, and then how about, rawr, Enter, you can even get this on the screen here.

1880
02:13:27,910 --> 02:13:34,230
So this, too, is just an example of what you can do with these command line arguments now that we have this building block.

1881
02:13:34,230 --> 02:13:36,960
And there's one final thing we can now do with code.

1882
02:13:36,960 --> 02:13:48,450
There's one last feature today that we'll introduce before we now connect all of these dots to readability and encryption by talking, lastly, about something called exit status.

1883
02:13:48,450 --> 02:13:58,260
It turns out that whenever your main function exits, it returns a secret integer that you can figure out, as the programmer or an advanced user, what it was.

1884
02:13:58,260 --> 02:14:02,398
And these exit codes, exit statuses, are typically used to indicate errors.

1885
02:14:02,398 --> 02:14:08,560
So for instance, over the past couple of years, if you've used zoom and you ever got some kind of error, you might have seen a screen like this.

1886
02:14:08,560 --> 02:14:11,040
It's usually not that helpful, maybe tells you to click

1887
02:14:11,040 --> 02:14:13,050
Report Problem or Contact Support.

1888
02:14:13,050 --> 02:14:23,640
But very often in our human world on Macs, PCs, and phones, you see cryptic error codes, like literally numbers that probably only Zoom knows, or Microsoft or Google or whatever company

1889
02:14:23,640 --> 02:14:25,050
wrote the software you're using.

1890
02:14:25,050 --> 02:14:32,070
But that number corresponds to a specific error that some human somewhere knows might very well happen.

1891
02:14:32,070 --> 02:14:38,260
These are used similarly, although under a different name that we'll talk about later in the term, on the web as well.

1892
02:14:38,260 --> 02:14:41,350
Have you ever seen this-- maybe not character, but number?

1893
02:14:41,350 --> 02:14:43,485
So, 404 means what?

1894
02:14:43,485 --> 02:14:44,880
AUDIENCE: Error.

1895
02:14:44,880 --> 02:14:47,790
DAVID MALAN: So error, yes, but really, not found.

1896
02:14:47,790 --> 02:14:48,410
So, why?

1897
02:14:48,410 --> 02:14:49,993
I mean, this is the most arcane thing.

1898
02:14:49,993 --> 02:14:57,500
And we'll talk in a few weeks about what this and other numbers mean, but numbers are all around us in technology, and they very often mean something to the technical people who

1899
02:14:57,500 --> 02:15:00,270
wrote the software, less so to humans like you and me.

1900
02:15:00,270 --> 02:15:05,900
Why so many of us recognize 404 is kind of weird, that like that's been around long enough that we all know it.

1901
02:15:05,900 --> 02:15:10,250
But it really is just a special number that represents an error of some sort.

1902
02:15:10,250 --> 02:15:18,200
So it turns out, the last thing we'll reveal today about what we've been taking for granted for two weeks, is what the int is in main.

1903
02:15:18,200 --> 02:15:24,680
We've seen, just a moment ago, that the thing in the parentheses, which up until now has been void, which means no command line arguments.

1904
02:15:24,680 --> 02:15:29,690
now int argc string argv brackets just means, yes, command line arguments.

1905
02:15:29,690 --> 02:15:31,290
And we've seen how to access them.

1906
02:15:31,290 --> 02:15:37,460
So the last piece of the puzzle, honestly, of all the cryptic syntax the past two weeks, is just what int means.

1907
02:15:37,460 --> 02:15:46,010
Int is always there for main, and it indicates that main will always return an integer, even though you and I have never done so explicitly.

1908
02:15:46,010 --> 02:15:53,928
Usually, main returns 0, by default. But it would be weird if you saw an error message saying 0, so 0 is just hidden.

1909
02:15:53,928 --> 02:15:55,470
You would never see it on the screen.

1910
02:15:55,470 --> 02:15:58,670
But it's happening automatically by way of how C is designed.

1911
02:15:58,670 --> 02:16:01,550
So let me write one final program here.

1912
02:16:01,550 --> 02:16:05,750
I'll call it, for instance, status.c to show you these exit statuses.

1913
02:16:05,750 --> 02:16:21,350
Code of status.c, and then up here, let me do something simple like include cs50.h, then include stdio.h, and then int main-- actually, let's use a command line argument. int argc, string argv[],

1914
02:16:21,350 --> 02:16:23,180
so that's copy, paste.

1915
02:16:23,180 --> 02:16:26,000
But now let's do this.

1916
02:16:26,000 --> 02:16:30,780
If argc does not equal to-- why don't we do something like this?

1917
02:16:30,780 --> 02:16:33,740
Let's not just default to hello, world like last time.

1918
02:16:33,740 --> 02:16:34,770
Let's yell at the user.

1919
02:16:34,770 --> 02:16:43,160
So let's say something like printf missing command line argument, so that they know they screwed up and they need to run the program again correctly.

1920
02:16:43,160 --> 02:16:56,730
Else, let's go ahead and say, print out, as before, Hello, comma %s, and then plug in argv[1], so the human's name from the prompt.

1921
02:16:56,730 --> 02:17:03,590
Now at this point, let me go ahead and run status, ./status, and I'll type nothing first.

1922
02:17:03,590 --> 02:17:04,700
I get yelled at.

1923
02:17:04,700 --> 02:17:10,170
This time, I'll type it again. ./status David, and it works properly.

1924
02:17:10,170 --> 02:17:14,090
But now let me show you a somewhat secret, cryptic command.

1925
02:17:14,090 --> 02:17:18,740
You can type this at your prompt, and it's just a coincidence that there's another dollar sign.

1926
02:17:18,740 --> 02:17:25,490
Echo $?, totally arcane, but it allows you to see what exit status your program has ended with.

1927
02:17:25,490 --> 02:17:27,558
So let me run this again the wrong way.

1928
02:17:27,558 --> 02:17:31,039
./status, I get the error message.

1929
02:17:31,040 --> 02:17:32,780
What was secretly returned?

1930
02:17:32,780 --> 02:17:33,440
I can't see it.

1931
02:17:33,440 --> 02:17:37,280
There's obviously no error screen, but by typing echo $?,

1932
02:17:37,280 --> 02:17:42,170
I can see that, oh, my program automatically, by default, returns zero.

1933
02:17:42,170 --> 02:17:48,690
However, if I run it again correctly, ./status David, Enter, this is the correct version.

1934
02:17:48,690 --> 02:17:52,879
But if I run echo $? status again, it's still entered with 0.

1935
02:17:52,879 --> 02:17:55,879
And long story short, this is just a missed opportunity.

1936
02:17:55,879 --> 02:17:59,570
When something goes wrong, why don't I return a value other than 0?

1937
02:17:59,570 --> 02:18:01,070
0, by default, means success.

1938
02:18:01,070 --> 02:18:02,690
And it's always there automatically.

1939
02:18:02,690 --> 02:18:04,940
But you can control this.

1940
02:18:04,940 --> 02:18:11,160
I can go into my code here and return 1, else, if something works fine,

1941
02:18:11,160 --> 02:18:17,129
I can return 0, by default. And honestly, if I omit the return zero, again, zero automatically is returned.

1942
02:18:17,129 --> 02:18:20,718
So let me go ahead and go be explicit, just so I know what's going on.

1943
02:18:20,718 --> 02:18:26,359
Make status again, ./status, and let's do this correctly with David.

1944
02:18:26,360 --> 02:18:28,520
Enter, hello, David.

1945
02:18:28,520 --> 02:18:32,058
Echo $?, zero.

1946
02:18:32,058 --> 02:18:33,269
So all is well.

1947
02:18:33,270 --> 02:18:38,240
But now if I do ./status and nothing, or multiple things, but not just David,

1948
02:18:38,240 --> 02:18:40,530
Enter, I get the error message.

1949
02:18:40,530 --> 02:18:45,230
But now if I do echo $?, voila, there now is the one.

1950
02:18:45,230 --> 02:18:47,330
So what does this now mean?

1951
02:18:47,330 --> 02:18:52,459
This is, in the graphical world, we would just show something like this on the screen, which is a little more informative to the user.

1952
02:18:52,459 --> 02:18:58,549
But even in the Linux world where you don't have a GUI, necessarily, even for the programs we've written, you can check these exit statuses.

1953
02:18:58,549 --> 02:19:07,339
And in fact, more comfortable, more advanced programmers, when they write code that calls programs, be it cowsay or anything else, you can encode,

1954
02:19:07,340 --> 02:19:13,170
check what the exit status is of a program, and then decide, did my program work or did it not?

1955
02:19:13,170 --> 02:19:19,069
And now let's connect the final dots before we adjourn for some fruit snacks.

1956
02:19:19,070 --> 02:19:27,650
Cryptography, namely one of the applications this week via which you'll be able to send, if you will, secret messages, and better yet, decrypt secret messages.

1957
02:19:27,650 --> 02:19:34,040
This will be in addition to perhaps analyzing the readability of text using heuristics, like we identified at the start of class two.

1958
02:19:34,040 --> 02:19:45,980
So cryptography is just the art, the science of encrypting information, scrambling information so that if you have a secret message to send in so-called plaintext, you can run it through some algorithm

1959
02:19:45,980 --> 02:19:49,910
and turn it into what's called ciphertext, thereby, encrypting it.

1960
02:19:49,910 --> 02:19:59,880
And only someone who knows what algorithm you've used and what input you've used to the algorithm, theoretically, can decrypt that process and convert it back to the original message.

1961
02:19:59,880 --> 02:20:03,030
So if we use our mental model from last week, here is a problem.

1962
02:20:03,030 --> 02:20:04,910
Here is an input and output.

1963
02:20:04,910 --> 02:20:13,640
The goal I claim here is to take some plain text, like the message you want to send, think back to grade school if you ever passed a note to a friend or to your crush saying, I love you,

1964
02:20:13,640 --> 02:20:16,910
it's a little awkward if the teacher or someone else intercepts the paper.

1965
02:20:16,910 --> 02:20:19,490
And in English, it just says, I love you, or whatever it is.

1966
02:20:19,490 --> 02:20:22,350
It'd be nice if you had at least encrypted it in some way.

1967
02:20:22,350 --> 02:20:32,040
But the other person needs to know what algorithm you used and what inputs you use to that algorithm so that, ultimately, they can decode the so-called ciphertext, which is the output.

1968
02:20:32,040 --> 02:20:34,190
So what goes inside of the box today?

1969
02:20:34,190 --> 02:20:37,970
Well, an algorithm, as it relates to cryptography, is called a cipher.

1970
02:20:37,970 --> 02:20:43,250
And a cipher is a fancy name for an algorithm that encrypts text from plaintext to ciphertext.

1971
02:20:43,250 --> 02:20:48,750
The catch is, there needs to be not just the algorithm, there needs to be an input to it.

1972
02:20:48,750 --> 02:20:53,090
And so, for instance, you might draw the picture like this for the first time today.

1973
02:20:53,090 --> 02:20:54,257
And we've seen this in code.

1974
02:20:54,257 --> 02:20:57,180
You can give multiple inputs or arguments to functions.

1975
02:20:57,180 --> 02:21:02,510
So in this black box, can you imagine passing in the message you want to send, and then some secret.

1976
02:21:02,510 --> 02:21:10,310
So for instance, suppose that, the simplest thing I could think of as a kid was instead of sending the letter A, why don't I write the letter B?

1977
02:21:10,310 --> 02:21:13,070
Instead of the letter B, why don't I write the letter C?

1978
02:21:13,070 --> 02:21:16,280
So I can kind of shift the English alphabet by one space.

1979
02:21:16,280 --> 02:21:18,740
So A becomes B, B becomes C, dot, dot, dot,

1980
02:21:18,740 --> 02:21:21,690
Z becomes A. You can wrap around at the end.

1981
02:21:21,690 --> 02:21:24,120
And let's assume no punctuation in this part of the story.

1982
02:21:24,120 --> 02:21:32,090
So that's a very simple algorithm-- add a value to each letter and send the value as the ciphertext.

1983
02:21:32,090 --> 02:21:41,300
And now the teacher, the classmate, they have to know that you use, not only this rotational algorithm, also known as a Caesar cipher, they also need to know what number you use.

1984
02:21:41,300 --> 02:21:45,200
Did you add 1 to every letter, 2 to every letter, 25 to every letter?

1985
02:21:45,200 --> 02:21:51,165
Now if they're super smart and probably not the young age in this story, they could also just try all possibilities.

1986
02:21:51,165 --> 02:21:53,040
And that would be an attack on the algorithm.

1987
02:21:53,040 --> 02:21:56,970
This is not a sophisticated algorithm, but it's enough to send a message in class.

1988
02:21:56,970 --> 02:22:06,950
So if the two inputs now are HI! as the plain text message, and 1 as the so-called key, the secret number that only you and the other person know, you

1989
02:22:06,950 --> 02:22:11,040
might be able to encrypt a message from one way to the other.

1990
02:22:11,040 --> 02:22:16,198
And so in this case, for instance, HI! would become I-J-!.

1991
02:22:16,198 --> 02:22:19,823
In this version of the algorithm, we're not going to bother with numbers or punctuation.

1992
02:22:19,823 --> 02:22:23,090
We'll only operate on A through Z, be it uppercase or lowercase.

1993
02:22:23,090 --> 02:22:33,440
So now if you were to receive a slip of paper in class with I-J on it, you, the recipient, would know what it is so long as you know that the sender used one,

1994
02:22:33,440 --> 02:22:36,500
because you just reverse the algorithm and you subtract one instead.

1995
02:22:36,500 --> 02:22:42,975
The teacher, they probably don't know what this means, and they're not going to spend time hacking the message, so it just looks scrambled to them.

1996
02:22:42,975 --> 02:22:44,600
And that's what we get from encryption.

1997
02:22:44,600 --> 02:22:52,700
Someone who intercepts it, be it in class or in the real world, on the internet or anywhere else, can't actually figure out, ideally, what it is you have sent.

1998
02:22:52,700 --> 02:22:56,300
The opposite, of course, is indeed called decryption, but the process is the same.

1999
02:22:56,300 --> 02:22:58,370
We now pass in negative 1.

2000
02:22:58,370 --> 02:23:00,300
And so how about this?

2001
02:23:00,300 --> 02:23:02,840
Why don't we end with a demonstration here?

2002
02:23:02,840 --> 02:23:08,360
UIJT XBT DT50-- there's a bit of a tell there.

2003
02:23:08,360 --> 02:23:14,180
If we pass that in and do negative 1, well, how do we get out the plaintext originally?

2004
02:23:14,180 --> 02:23:18,200
Well, if this is the ciphertext, and we subtract 1 from each letter,

2005
02:23:18,200 --> 02:23:28,010
I think U becomes T, I becomes H, J becomes I, T becomes S, X becomes W,

2006
02:23:28,010 --> 02:23:37,580
B becomes A, T becomes S, D becomes C, T becomes S, and this was, indeed, CS50.

2007
02:23:37,580 --> 02:23:40,250
Have a duck on your way out, and some snacks in the lobby.

2008
02:23:40,250 --> 02:23:42,350
[APPLAUSE]

2009
02:23:42,350 --> 02:23:43,850
[FILM ROLLING]

2010
02:23:43,850 --> 02:23:47,500
[MUSIC PLAYING]

2
00:01:12,600 --> 00:01:13,590
好的。

3
00:01:13,590 --> 00:01:24,120
这里是 CS50，这是第二周，我们将从较低的层次来了解事物是如何工作的，事实上，本课程的目标之一就是这种自下而上的理解

4
00:01:24,120 --> 00:01:29,920
这样，几周后，甚至几年后，当你遇到一些新技术时，你就能回想起来，希望

5
00:01:29,920 --> 00:01:36,060
在本周的一些基本构件和基元的基础上，真正推导出未来技术的工作原理。

6
00:01:36,060 --> 00:01:41,380
但一路走来，我们会发现--也许，要做到 "只见树木，不见森林 "有点困难。

7
00:01:41,380 --> 00:01:44,783
因此，最终的目标仍然是解决问题。

8
00:01:44,783 --> 00:01:53,280
为此，我们请来了一些勇敢的志愿者，他们已经站了出来。

9
00:01:53,280 --> 00:01:58,320
如果我们能打开一些戏剧性的灯光，见见今天的志愿者。

10
00:01:58,320 --> 00:02:00,430
在我的左边

12
00:02:00,930 --> 00:02:01,960
我叫亚历克斯。

13
00:02:01,960 --> 00:02:05,340
我是学院的一年级学生，来自北卡罗来纳州的教堂山。

14
00:02:05,340 --> 00:02:07,080
戴维-马兰：欢迎亚历克斯。

15
00:02:07,080 --> 00:02:09,180
在亚历克斯的右边

16
00:02:09,180 --> 00:02:10,050
我是莎拉

17
00:02:10,050 --> 00:02:13,230
我来自加拿大多伦多，也是学院的一年级学生。

18
00:02:13,230 --> 00:02:14,188
太棒了。

19
00:02:14,188 --> 00:02:15,869
欢迎亚历克斯和莎拉。

20
00:02:15,869 --> 00:02:25,650
因此，你们本周要解决的问题集 2 中的一个问题是分析文章的阅读水平，即某人的阅读水平是一年级水平、二年级水平还是三年级水平。

21
00:02:25,650 --> 00:02:28,570
级，一直到 12、13 级或更高。

22
00:02:28,570 --> 00:02:36,750
你可能从来没有想过，当然是在代码方面，比如你如何分析一些文本、书籍，并找出它的阅读水平。

23
00:02:36,750 --> 00:02:40,330
然而，我们成长过程中的老师肯定知道或直观地感受到了这一点。

24
00:02:40,330 --> 00:02:42,450
让我们来看看一些示例文本。

25
00:02:42,450 --> 00:02:45,960
比如，亚历克斯，你最近在读什么书？

26
00:02:45,960 --> 00:02:52,502
一条鱼、两条鱼、红鱼、蓝鱼

27
00:02:52,502 --> 00:02:53,460
太棒了。

28
00:02:53,460 --> 00:02:58,890
那么，您认为亚历克斯目前的阅读水平在哪个年级？

29
00:02:58,890 --> 00:03:01,500
请随时大声喊出来。

30
00:03:01,500 --> 00:03:02,730
第一个，第一个？

31
00:03:02,730 --> 00:03:10,410
因此，本周你会看到，如果你在亚历克斯的文本上运行代码，实际上会发现他的阅读水平低于一年级。

32
00:03:10,410 --> 00:03:12,400
但为什么会这样呢？

33
00:03:12,400 --> 00:03:19,020
你对我们指责亚历克斯的阅读水平的直觉是什么？

34
00:03:19,020 --> 00:03:20,990
请随时大声喊出来。

36
00:03:21,490 --> 00:03:24,520
因此，音节很少，单词很短，句子也很短。

37
00:03:24,520 --> 00:03:30,370
因此，我们或许可以从这篇短文中推断出一些启发式的结论，那就是这篇短文最适合年龄较小的儿童阅读。

38
00:03:30,370 --> 00:03:33,370
相比之下，萨拉，你都读了些什么？

39
00:03:33,370 --> 00:03:35,470
杜斯利先生和杜斯利夫人

40
00:03:35,470 --> 00:03:41,050
Four Privet Drive 很自豪地说，他们完全正常，非常感谢。

41
00:03:41,050 --> 00:03:47,952
他们是你最不可能想到会卷入任何奇怪或神秘事件的人，因为他们不喜欢胡言乱语。

42
00:03:47,952 --> 00:03:48,910
好的。

43
00:03:48,910 --> 00:03:55,230
不管你读这篇课文时是哪个年级，莎拉的阅读水平似乎在哪个年级？

44
00:03:55,230 --> 00:03:57,570
所以是八年级，二年级。

46
00:03:58,080 --> 00:04:03,240
因此，我什么都听过一些，所以，至少根据代码，实际上应该是七年级。

47
00:04:03,240 --> 00:04:05,130
直觉是什么？

48
00:04:05,130 --> 00:04:09,917
尽管我们可能不同意到底是哪个年级，但为什么说这是一个更高的年级呢？

49
00:04:09,917 --> 00:04:11,250
听众：复杂的句子。

50
00:04:11,250 --> 00:04:12,000
是的

51
00:04:12,000 --> 00:04:14,218
所以句子复杂，句子较长。

52
00:04:14,218 --> 00:04:18,519
因此，莎拉确实说了更多的话，因为纸上的内容太多了。

53
00:04:18,519 --> 00:04:26,910
因此，我们将在下周的问题集 2（如果你解决了这个问题集 2）中，通过代码来转化这些想法，这样你就能最终定量地推断出这些东西。

54
00:04:26,910 --> 00:04:29,190
但要做到这一点，我们必须理解文本。

55
00:04:29,190 --> 00:04:32,610
因此，让我们首先感谢我们的志愿者，然后再进入下一层。

58
00:04:40,600 --> 00:04:41,490
你可以留着这些。

59
00:04:41,490 --> 00:04:42,222
哦，好的

60
00:04:42,222 --> 00:04:43,180
好的。

61
00:04:43,180 --> 00:04:50,210
除此以外，让我们考虑一下本周可能会看到的其他文字，即类似这样的文字。

62
00:04:50,210 --> 00:04:53,860
我在屏幕上看到的就是我们今天开始所说的密码文本。

63
00:04:53,860 --> 00:04:56,530
它是对某些信息进行加密的结果。

64
00:04:56,530 --> 00:05:00,908
而加密，或者更笼统地说，密码学的艺术和科学就在我们身边。

65
00:05:00,908 --> 00:05:03,700
您在网络、手机和银行中使用的都是它。

66
00:05:03,700 --> 00:05:07,000
任何试图保证数据安全的东西都在使用加密技术。

67
00:05:07,000 --> 00:05:11,140
但加密的级别会有所不同，有强加密，也有弱加密。

68
00:05:11,140 --> 00:05:22,030
你在屏幕上看到的并不是那么强大，但我们今天稍后会看到如何解密，并揭示与密码文本相对应的明文是什么。

69
00:05:22,030 --> 00:05:26,197
但是，为了做到这一点，我们必须开始摘掉一些训练用的轮子。

70
00:05:26,197 --> 00:05:32,230
信不信由你，即使你的时间会看到过去一周的第一次，可能，可能已经相当在杂草丛生。

71
00:05:32,230 --> 00:05:39,760
而比 C 更复杂的是，我们一直在提供并将继续提供某些训练车轮。

72
00:05:39,760 --> 00:05:49,730
例如，CS50 图书馆就是其中之一，甚至在最初几周，我们暂时对一些主题的解释也会有所简化--可以说是抽象化了。

73
00:05:49,730 --> 00:05:58,210
但是，我们的最终目标是让您了解其中的每一个细节，这样在 CS50 之后，您就能真正自立于世，并理解和融会贯通。

74
00:05:58,210 --> 00:06:01,040
以及未来的任何技术。

75
00:06:01,040 --> 00:06:06,110
因此，让我们先来看看上周开始的第一个项目，也就是这个项目。

76
00:06:06,110 --> 00:06:14,890
说到底，printf 函数才是真正有趣的部分，但在它之上和之下还有很多技术性的东西。

77
00:06:14,890 --> 00:06:21,730
大括号、小括号、void 和 include 等单词，当然还有斜括号等等。

78
00:06:21,730 --> 00:06:30,190
但最终，我们需要将 C 语言源代码转换为机器代码，即计算机能够理解的二进制 0 和 1。

79
00:06:30,190 --> 00:06:33,700
当然，为了做到这一点，我们运行 -- 我们编译了代码。

80
00:06:33,700 --> 00:06:37,400
我们运行了 make，然后就能在那里实际运行代码了。

81
00:06:37,400 --> 00:06:44,510
因此，让我到 VS 代码中快速重新创建 hello.c。

82
00:06:44,510 --> 00:06:51,970
因此，我可能在这里包含 stdio.h，int main void。

83
00:06:51,970 --> 00:06:57,430
然后在这里，我很简单地输入了 "你好"、"逗号"、"世界"、"反斜线"、"尾引号 "等等。

84
00:06:57,430 --> 00:07:01,693
上次编译时，我确实运行了 make hello，然后是 Enter。

85
00:07:01,693 --> 00:07:03,860
希望您没有看到任何错误，这是一件好事。

86
00:07:03,860 --> 00:07:07,840
如果你进行点、斜线、你好的操作，你就会看到该程序的结果。

87
00:07:07,840 --> 00:07:12,950
但事实证明，正如我上周提到的，make 实际上并不是一个编译器。

88
00:07:12,950 --> 00:07:19,030
它是一个程序，可以清晰地编译你的程序，但它本身只是将使用实际编译器的过程自动化。

89
00:07:19,030 --> 00:07:27,640
现在有很多不同的编译器，而它实际上使用的是一种叫做 Clang 的 C 语言编译器。

90
00:07:27,640 --> 00:07:30,190
而 Clang 是时下相当流行的编译器。

91
00:07:30,190 --> 00:07:40,310
还有一种已经存在很久的编译器叫 GCC，但这些只是不同的人、不同的公司、不同的团体所创建的编译器类型的特定名称。

92
00:07:40,310 --> 00:07:50,703
但是，如果你在第 1 周手动使用编译器，你就必须多了解一些情况，因为它比单独编译更令人费解。

93
00:07:50,703 --> 00:07:59,360
事实上，让我回到终端窗口，清空一下屏幕，然后运行原始编译器命令。

94
00:07:59,360 --> 00:08:03,620
因此，让我手动操作一下，就能实现自动化。

95
00:08:03,620 --> 00:08:10,450
因此，如果我想将 hello.c 编译成可执行程序，我就可以运行它、

96
00:08:10,450 --> 00:08:17,110
clang、空格、hello.c，然后回车。

97
00:08:17,110 --> 00:08:22,010
现在没有输出了，在这种情况下，没有错误是件好事，但请注意这一点。

98
00:08:22,010 --> 00:08:32,140
如果我继续输入 ls，就会发现在我的当前文件夹中突然创建了一个文件，文件名很奇怪，叫 a.out。

99
00:08:32,140 --> 00:08:33,580
这代表汇编输出。

100
00:08:33,580 --> 00:08:39,440
长话短说，这其实就是运行 Clang 时创建的程序的默认名称。

101
00:08:39,440 --> 00:08:44,000
现在看来，这个程序的名字很糟糕，因为它无法描述程序的功能。

102
00:08:44,000 --> 00:08:55,420
因此，最好的办法也许是：好吧，不要用 a.out，没错，它仍然打印 hello.world，但并不是一个真正有明确名称的程序，最好给它取名为 hello。

103
00:08:55,420 --> 00:08:56,240
我能做些什么呢？

104
00:08:56,240 --> 00:09:01,820
我可以像上周学过的那样--嗯，我可以用 Linux 的 mv 命令把 a.out 重命名为 hello。

105
00:09:01,820 --> 00:09:04,480
所以，我要把一个.移出来，变成 "你好"。

106
00:09:04,480 --> 00:09:06,370
但这似乎也有点乏味。

107
00:09:06,370 --> 00:09:07,720
现在我有三个步骤。

108
00:09:07,720 --> 00:09:12,190
比如写代码、编译代码，然后在运行之前重命名代码。

109
00:09:12,190 --> 00:09:13,580
我们可以做得更好。

110
00:09:13,580 --> 00:09:20,380
事实证明，某些命令（如 clang）支持我们今天开始所说的命令行参数。

111
00:09:20,380 --> 00:09:30,400
与函数参数不同，命令行参数只是在终端提示符下，在命令后键入的一个附加单词或关键短语

112
00:09:30,400 --> 00:09:33,440
窗口，修改该命令的行为。

113
00:09:33,440 --> 00:09:35,600
它的配置更具体一些。

114
00:09:35,600 --> 00:09:45,220
因此，你在屏幕上看到的是一个更好的运行 clang 的命令，现在我可以根据这个 o 指定这个命令的输出。

115
00:09:45,220 --> 00:09:46,610
那么，我的意思是什么呢？

116
00:09:46,610 --> 00:09:54,955
好吧，让我再次清空终端窗口，然后更明确地输入 clang -o hello hello.c，然后回车。

117
00:09:54,955 --> 00:10:02,860
同样，什么也没有发生，但这是件好事，因为你没有看到任何错误，而且现在我刚刚创建的程序确实叫做 Hello。

118
00:10:02,860 --> 00:10:07,280
因此，它所达到的效果确实与 make 所达到的效果完全相同，但又如何呢？

119
00:10:07,280 --> 00:10:11,075
我不需要输入和记住像这条命令这么长的内容。

120
00:10:11,075 --> 00:10:12,700
这也有点像白色谎言。

121
00:10:12,700 --> 00:10:22,840
原来，我们已经在云中为您预配置了 VS Code，让您也能使用 Clang 的其他一些功能，而这些功能如果由您自己编写会更加繁琐。

122
00:10:22,840 --> 00:10:28,130
因此，这就是为什么我们将其提炼为最终只是运行制造。

123
00:10:28,130 --> 00:10:37,720
所以，让我在这里暂停一下，先看看大家对我用 C 语言编写的第一个程序有什么疑问，现在先用 make 编译，然后重新开始

124
00:10:37,720 --> 00:10:46,820
现在用 clang 手动编译，我们称之为命令行参数。-o、空格、hello，然后是文件名。

126
00:10:47,320 --> 00:10:48,780
AUDIENCE：什么是.out？

127
00:10:48,780 --> 00:10:49,530
是的

128
00:10:49,530 --> 00:10:51,870
因此，a.out 是一个历史名称。

129
00:10:51,870 --> 00:10:55,240
它指的是汇编程序的输出--很快会有更多介绍。

130
00:10:55,240 --> 00:11:02,970
如果在任何文件上运行编译器，都会自动获得默认的文件名，这样就有了一个标准的文件名。

131
00:11:02,970 --> 00:11:05,213
但这个计划的名字并不好听。

132
00:11:05,213 --> 00:11:09,880
而不是在 Mac 或 PC 上运行 Microsoft Word，就像双击 .out。

133
00:11:09,880 --> 00:11:17,370
因此，有了这些命令行参数，你就可以自定义 Clang 的输出，并将其称为 hello 或任何你想要的名字。

134
00:11:17,370 --> 00:11:23,020
关于 Clang 编译器的其他问题？

136
00:11:23,520 --> 00:11:25,510
听众：什么是-o？

137
00:11:25,510 --> 00:11:30,500
你只有读过手册、上过课才会知道，这意味着输出。

138
00:11:30,500 --> 00:11:38,680
所以 -o 意味着将 Clang 的输出改为名为 hello 的文件，而不是默认的 a.out。

139
00:11:38,680 --> 00:11:44,810
这也是一个细节问题，你需要在网页上查找，阅读手册，或者听我这样的人告诉你。

140
00:11:44,810 --> 00:11:48,890
事实上，可供选择的方案远不止这些，但我们在此也只是浅尝辄止。

142
00:11:49,390 --> 00:11:53,530
如果我们现在知道了这些，那么在引擎盖下面究竟还发生了什么呢？

143
00:11:53,530 --> 00:12:03,430
好吧，让我们仔细看看我的代码，不仅是这个版本，还有上周稍微复杂一点的版本，看起来有点像这样，其中包括

144
00:12:03,430 --> 00:12:11,810
我添加了一些来自用户的动态输入，这样我就可以不对所有人说 "你好，世界"，而是对实际运行这个程序的人说 "你好，大卫 "或 "你好"。

145
00:12:11,810 --> 00:12:17,770
因此，事实上，让我继续在 VS 代码中修改我的代码，以便与上周的代码保持一致。

146
00:12:17,770 --> 00:12:19,190
所以还没有新代码。

147
00:12:19,190 --> 00:12:22,820
稍后，我将以稍有不同的方式对其进行编译。

148
00:12:22,820 --> 00:12:29,020
所以我做了上周的字符串，我想，答案等于字符串，引号-引号、

149
00:12:29,020 --> 00:12:30,100
"你叫什么名字？"

150
00:12:30,100 --> 00:12:31,540
就像在 Scratch 中一样。

151
00:12:31,540 --> 00:12:37,450
然后在下面，我没有做世界，而是开始写答案，但写得并不顺利。

152
00:12:37,450 --> 00:12:42,940
打印出 "你好，大卫 "或 "你好，某某"，我最终做了什么？

154
00:12:44,722 --> 00:12:45,680
抱歉，再大点声？

155
00:12:45,680 --> 00:12:46,430
听众：%s？

156
00:12:46,430 --> 00:12:51,020
DAVID MALAN：是的，所以 %s，也就是 printf 知道如何处理的所谓格式代码。

157
00:12:51,020 --> 00:12:52,470
我还得补充一点。

158
00:12:52,470 --> 00:12:54,850
除了 %s 还有别人吗？

159
00:12:54,850 --> 00:12:56,050
AUDIENCE：变量名称。

160
00:12:56,050 --> 00:13:00,190
DAVID MALAN：我要插入占位符 %s 的变量名。

161
00:13:00,190 --> 00:13:01,630
在这种情况下，它就是答案。

162
00:13:01,630 --> 00:13:11,560
现在让我做一个改进，因为我们已经进入了第 2 周，我们将开始编写更多行的代码，尽管 Scratch 总是将问谜题的返回值称为答案。

163
00:13:11,560 --> 00:13:14,480
瞧，我们可以完全控制变量的名称。

164
00:13:14,480 --> 00:13:19,870
现在，如果我使用 get_string，最好不要总是通用地调用我的变量 answer。

165
00:13:19,870 --> 00:13:21,050
就这么说吧。

166
00:13:21,050 --> 00:13:23,680
所以，现在这只是一个风格问题。

167
00:13:23,680 --> 00:13:34,000
让我把变量改成 name，这样我、你、TF 或 TA 就能更清楚地知道这个变量代表什么，而不是更笼统地回答。

168
00:13:34,000 --> 00:13:41,050
好了，说了这么多，让我回到终端窗口，上周我又运行 make 编译了这个一模一样的程序。

169
00:13:41,050 --> 00:13:43,270
现在，让我直接使用 clang。

170
00:13:43,270 --> 00:13:45,490
所以哐当

171
00:13:45,490 --> 00:13:49,330
我还是把这个版本叫做 hello--space，hello.c。

172
00:13:49,330 --> 00:13:51,080
因此，命令与之前的完全相同。

173
00:13:51,080 --> 00:13:56,330
唯一不同的是，我增加了几行代码来获取用户的输入。

174
00:13:56,330 --> 00:13:59,960
让我按下回车键，现在，该死的，我们的第一个错误。

175
00:13:59,960 --> 00:14:05,420
因此，从 clang 和 make 输出并不是一件好事，在这里，我们看到了一些特别隐秘的东西。

176
00:14:05,420 --> 00:14:13,480
因此，函数 "main "中出现了对 "get_string "字符串的未定义引用，然后链接器命令失败，退出代码为 1。

177
00:14:13,480 --> 00:14:22,130
因此，实际上有很多专业术语在里面，今天会挑明，但我的提示是，显然我的问题出在主要方面，尽管这并不奇怪，因为这里没有其他事情发生。

178
00:14:22,130 --> 00:14:26,830
get_string 是一个问题，问题在于它是一个未定义的引用。

179
00:14:26,830 --> 00:14:28,990
然而，请注意，我做得很好。

180
00:14:28,990 --> 00:14:39,070
我添加了 CS50 头文件，上周我曾说过，这足以让编译器知道函数的存在，但问题是，即使这样做了，事实上、

181
00:14:39,070 --> 00:14:51,860
虽然 Clang 知道 get_string 的存在，但要它在计算机硬盘上找到真正实现 get_string 本身的 0 和 1 并不足够。

182
00:14:51,860 --> 00:14:55,333
因此，换句话说，按照上周的说法，这句话是一个小小的暗示。

183
00:14:55,333 --> 00:14:59,560
这是向 Clang 发出的预告，告诉它你即将在某处看到并使用这个函数。

184
00:14:59,560 --> 00:15:11,470
但是，如果你真的想使用 CS50 很久以前编写的 0 和 1，并将其融入到你的程序中，让你的程序真正知道如何从用户那里获取输入，那就好办了、

185
00:15:11,470 --> 00:15:15,440
我得继续运行一个稍有不同的命令。

186
00:15:15,440 --> 00:15:16,250
那就让我来吧。

187
00:15:16,250 --> 00:15:23,020
让我清空终端窗口，以消除干扰，我建议现在运行这条命令。

188
00:15:23,020 --> 00:15:35,050
几乎和之前一样，clang -o、空格、hello，然后是 hello.c，但最后多了一个命令行参数，是 -l--而不是数字 1。

189
00:15:35,050 --> 00:15:39,370
因此，-lcs 中间没有空格。

190
00:15:39,370 --> 00:15:48,850
现在，"升 "将导致 CS50 所输入的所有 0 和 1 被链接到你的代码、你的几行代码或我的代码中。

191
00:15:48,850 --> 00:15:58,537
但这是编译器需要的第二步，以便知道如何实际执行和编译您的代码和 CS50 的代码。

192
00:15:58,537 --> 00:16:00,370
并不是只有 CS50 才这样做。

193
00:16:00,370 --> 00:16:10,000
如果你在 C 语言中使用任何不自带的第三方库，你可以使用 -l 诸如此类的命令，不管他们给自己的库起了什么名字。

194
00:16:10,000 --> 00:16:14,298
但你不必像我们迄今为止所使用的那样，为内置设备这样做。

195
00:16:14,298 --> 00:16:16,090
好吧，让我来试试这个。

196
00:16:16,090 --> 00:16:23,620
我将回到 VS 代码，现在让我继续运行 clang -o hello，然后运行 hello.c。

197
00:16:23,620 --> 00:16:29,590
现在不用直接敲回车键，而是敲-lcs50，l 和 cs50 之间不留空格，然后敲回车键。

198
00:16:29,590 --> 00:16:33,310
现在不会发生任何不好的事情，我也可以做 ./hello。

199
00:16:33,310 --> 00:16:34,180
你叫什么名字？

200
00:16:34,180 --> 00:16:37,633
我输入大卫，回车，现在我们看到你好，大卫。

201
00:16:37,633 --> 00:16:46,460
老实说，这才是我们真正要解决的问题，现在这只会给编译和运行代码的过程增加麻烦。

202
00:16:46,460 --> 00:16:55,240
因此，现实情况是，尽管这确实是正在发生的事情，但这就是为什么我们使用上周，并将继续使用本周的原因，因为它只是

203
00:16:55,240 --> 00:16:57,130
为您自动完成整个过程。

204
00:16:57,130 --> 00:17:05,858
但最理想的做法是了解问题出在哪里，因为你在问题集 1 中看到的任何错误信息，以及接下来几周看到的任何错误信息，可能都不是来自 make、

205
00:17:05,858 --> 00:17:10,780
它们来自引擎盖下的 Clang，因为 make 只是在自动执行这一过程。

206
00:17:10,780 --> 00:17:17,560
但使用 make 时，你只需写下 make 和程序名称，而不必担心任何命令行参数。

207
00:17:17,560 --> 00:17:22,240
那么，对使用 dash -lcs50 或其他方法编译有疑问吗？

209
00:17:23,042 --> 00:17:24,959
听众：[听不清]有什么好处？

210
00:17:24,960 --> 00:17:26,220
戴维-马兰：对不起，有什么好处？

211
00:17:26,220 --> 00:17:27,512
听众：手动使用 Clang

212
00:17:27,512 --> 00:17:30,000
DAVID MALAN：手动使用 Clang 有什么好处？

213
00:17:30,000 --> 00:17:30,870
没有，真的没有。

214
00:17:30,870 --> 00:17:35,055
事实上，main 所做的只是说--make 所做的只是让我们少敲几下键盘。

215
00:17:35,055 --> 00:17:42,090
不过，如果你更喜欢控制，只要记住各种命令行参数，完全可以手动运行 Clang。

217
00:17:42,660 --> 00:17:47,335
你为什么要解释？那么你为什么要解释[听不清] So why did you have to explain [INAUDIBLE]

218
00:17:47,335 --> 00:17:48,210
大卫-马兰：没错。

219
00:17:48,210 --> 00:17:55,470
为什么我必须解释--即用 cs50.h 头文件为 CS50 提供提示，而用 standardio.h 却不必这样做？

220
00:17:55,470 --> 00:18:03,060
Standardio.h 是 C 语言的自带库，就像我们今天开始看到的其他一些 C 语言库一样。

221
00:18:03,060 --> 00:18:07,890
不过，CS50 并非随处都内置在 C 语言中，因此您必须明确地将其添加到 C 语言中。

223
00:18:08,767 --> 00:18:11,970
听众：你能定义什么命令行参数吗？

224
00:18:11,970 --> 00:18:22,200
戴维-马兰：命令行参数是你在命令行--也就是你的终端--输入的单词或短语，目的是影响程序的行为。

225
00:18:22,200 --> 00:18:22,742
AUDIENCE：OK.

226
00:18:22,742 --> 00:18:24,430
所以，你给它什么，它就是什么。

227
00:18:24,430 --> 00:18:24,565
是的

228
00:18:24,565 --> 00:18:25,660
它可以更改默认设置。

229
00:18:25,660 --> 00:18:33,460
在我们的图形用户界面（GUI）世界里，你和我可能会点击一些方框，选择一些菜单选项，以同样的方式配置程序的行为。

230
00:18:33,460 --> 00:18:39,600
在命令行界面上，你必须一次性说出所有内容，这就是我们使用命令行参数的原因。

232
00:18:40,605 --> 00:18:43,243
是让[听不清]

233
00:18:43,243 --> 00:18:43,910
DAVID MALAN: No.

234
00:18:43,910 --> 00:18:45,470
Make 不仅仅适用于 CS50。

235
00:18:45,470 --> 00:18:52,020
如今，在任何使用 C、C++ 甚至其他语言的项目中，它都被广泛使用。

236
00:18:52,020 --> 00:18:57,530
事实上，你在这一类中看到的大多数命令，除非结尾有 5-0，否则都是全球通用的。

237
00:18:57,530 --> 00:19:00,758
只有那些后缀为 50 的课程才是特定课程。

238
00:19:00,758 --> 00:19:06,890
即使是这些命令，我们也会逐步卸下训练轮，以便准确了解这些命令的作用。

239
00:19:06,890 --> 00:19:09,053
好吧，我们刚才做了什么？

240
00:19:09,053 --> 00:19:15,967
当然，我们刚才所做的一切，我一直称之为编译，但让我们先钻一个兔子洞，这样你就能理解编译代码的含义了、

241
00:19:15,967 --> 00:19:26,060
实际上，有一大堆步骤正在进行，这将使许多功能得以实现，例如，公司可以编写代码，然后将其转换为在 Mac 和 PC 上运行的代码

242
00:19:26,060 --> 00:19:27,240
或电话之类的东西。

243
00:19:27,240 --> 00:19:35,840
因此，这不仅仅是将源代码转换为机器代码的问题，从上周开始，你我所知道的编译实际上涉及四个步骤。

244
00:19:35,840 --> 00:19:41,450
这些都不是你必须时刻牢记的术语，因为我们会再次抽象出很多内容。

245
00:19:41,450 --> 00:19:51,080
不过，我们已经走过了一次兔子洞，让我们考虑一下这四个步骤中的每一个步骤，它们已经为你自动进行了一周，其中第一个步骤叫做预处理。

246
00:19:51,080 --> 00:19:52,260
这意味着什么？

247
00:19:52,260 --> 00:19:54,450
那么，让我们考虑一下之前的那个程序。

248
00:19:54,450 --> 00:19:57,830
请注意，有两行代码是以哈希标记开头的。

249
00:19:57,830 --> 00:20:02,338
这是 C 语言中的一个特殊符号，也就是所谓的预处理器指令。

250
00:20:02,338 --> 00:20:07,005
你不需要记住这样的术语，但这只是意味着它与其他线路有些不同。

251
00:20:07,005 --> 00:20:13,315
任何带有哈希符号的内容都应进行预处理，即在进行任何其他操作之前先进行初步分析。

252
00:20:13,315 --> 00:20:17,100
那么，让我们来看看上面这两条线，到底发生了什么。

253
00:20:17,100 --> 00:20:23,390
有了这两行，就有了两个头文件，当然是 cs50.h 和 stdio.h。

254
00:20:23,390 --> 00:20:28,550
这些文件在哪里，因为它们似乎从未出现在你的 VS 代码中。

255
00:20:28,550 --> 00:20:35,900
如果你键入 LS -- 如果你在图形用户界面中打开文件资源管理器，你可能从未见过 cs50.h 或 stdio.h。

256
00:20:35,900 --> 00:20:45,690
它们之所以能正常工作，是因为在你 Mac 或 PC 上使用的硬盘驱动器或云端的某个地方有一个文件夹，就像我们的情况一样。

257
00:20:45,690 --> 00:20:50,210
这个文件夹的传统名称是 /usr/include。

258
00:20:50,210 --> 00:20:51,857
而 user 则是故意拼错的。

259
00:20:51,857 --> 00:20:55,760
这只是略微简洁了一些，虽然我们为什么要去掉那一个字母有点奇怪。

260
00:20:55,760 --> 00:21:03,990
但 usr/include 只是服务器上的一个文件夹，其中包含 cs50.h、stdio.h 和其他一些内容。

261
00:21:03,990 --> 00:21:15,470
因此，事实上，如果你在 VS Code 中的终端窗口中键入 LS space /usr/include，当你在云中使用代码空间时，就能看到该文件夹中的所有文件。

262
00:21:15,470 --> 00:21:17,580
但我们已经为你预装了所有这些功能。

263
00:21:17,580 --> 00:21:20,390
因此，让我们来看看这些文件中到底有什么。

264
00:21:20,390 --> 00:21:25,370
如果我把上面这两行以散列包含开头的部分突出显示出来，效果就会很好、

265
00:21:25,370 --> 00:21:32,660
上周我曾暗示过，第一个文件中的内容暗示了 CS50 为你编写了哪些功能。

266
00:21:32,660 --> 00:21:41,000
因此，你可以把这些包含行看作是临时的占位符，用于全局查找和替换。

267
00:21:41,000 --> 00:21:44,270
clang 要做的第一件事就是预处理这个文件。

268
00:21:44,270 --> 00:21:47,300
它会查找任何以散列 include 开头的行。

269
00:21:47,300 --> 00:21:56,443
如果它看到了，就会进入该文件，如 cs50.h，然后复制并粘贴该文件的内容。

270
00:21:56,443 --> 00:21:58,110
你在屏幕上看不到。

271
00:21:58,110 --> 00:22:00,060
但这一切都发生在幕后。

272
00:22:00,060 --> 00:22:13,215
实际上，第一行的内容是在 cs50.h 中的某处对 getString 的声明，就像我们上周说的那样，它看起来可能有点像这样。

273
00:22:13,215 --> 00:22:17,030
上周我们在这方面花的时间还不多，但以后会花更多时间。

274
00:22:17,030 --> 00:22:21,470
请注意，函数就是这样声明的。

275
00:22:21,470 --> 00:22:23,677
也就是说，它是注定要存在的。

276
00:22:23,677 --> 00:22:25,760
当然，函数的名称是 getString。

277
00:22:25,760 --> 00:22:28,310
括号内是参数。

278
00:22:28,310 --> 00:22:33,080
在这种情况下，getString 只有一个参数，我今天声称，但你已经隐约知道了。

279
00:22:33,080 --> 00:22:34,160
这是一个提示。

280
00:22:34,160 --> 00:22:36,860
这是使用 getString 时人类看到的提示。

281
00:22:36,860 --> 00:22:37,790
提示是什么？

282
00:22:37,790 --> 00:22:43,080
嗯，就是一串文字，就像我上周问的 "你叫什么名字？"之类的。

283
00:22:43,080 --> 00:22:46,610
与此同时，正如我们在上周所知道的，getString 有一个返回值。

284
00:22:46,610 --> 00:22:48,140
它会给你回报一些东西。

285
00:22:48,140 --> 00:22:49,610
这也是一个字符串。

286
00:22:49,610 --> 00:22:52,120
因此，这也被称为函数原型。

287
00:22:52,120 --> 00:23:02,030
就是上周末的那篇文章，我把它从文件底部复制粘贴到了顶部，这样就像给铛铛的预告一样，让他知道后面会有什么。

288
00:23:02,030 --> 00:23:11,360
因此，你可以把这些包含行看作是将所有这些函数声明合并到一个名为 cs50.h 的单独文件中、

289
00:23:11,360 --> 00:23:18,470
这样，您就不必每次使用图书馆时都输入这些信息，或者更糟糕的是，您自己也不必复制和粘贴这些行文。

290
00:23:18,470 --> 00:23:22,520
这就是 clang 在第一步预处理中为你做的事情。

291
00:23:22,520 --> 00:23:29,175
其次，也是本例的最后一个问题，当 clang 预处理第二行 include 时会发生什么？

292
00:23:29,175 --> 00:23:33,650
在这个故事中，我们唯一关心的函数当然是 C 语言自带的 printf 函数。

293
00:23:33,650 --> 00:23:40,820
因此，你可以把 printf 的原型或声明理解为这样。

294
00:23:40,820 --> 00:23:42,870
Printf 是函数的名称。

295
00:23:42,870 --> 00:23:49,110
它接收一个要格式化的字符串，如：你好，逗号世界，或你好，逗号 %s。

296
00:23:49,110 --> 00:23:52,120
然后是点、点、点，这其实是有技术含义的。

297
00:23:52,120 --> 00:23:56,340
当然，这意味着您可以插入 0 个变量、1 个变量、2 个或 10 个变量。

298
00:23:56,340 --> 00:23:58,530
因此，点、点、点意味着一些变量的数量。

299
00:23:58,530 --> 00:24:00,072
现在我们还没谈到这个问题。

300
00:24:00,072 --> 00:24:05,490
实际上，printf 返回的是一个数值，一个整数。

301
00:24:05,490 --> 00:24:07,420
但关于这一点，或许下次再谈。

302
00:24:07,420 --> 00:24:10,920
一般来说，程序员不会关注这个问题。

303
00:24:10,920 --> 00:24:21,330
但这就是我们所说的预处理，因此在这个过程的最后，尽管 cs50.h 和 stdio.h 中的代码行数增加了，但实际上只是 clang 在预处理时发生了以下变化

304
00:24:21,330 --> 00:24:31,060
文件，然后将这些文件的内容复制并粘贴到你的代码中，这样你的代码就知道了一切--getString、printf 和其他任何内容。

305
00:24:31,060 --> 00:24:35,230
那么，关于第一步，预处理，有什么问题吗？

308
00:24:49,195 --> 00:24:50,320
大卫-马兰：问得好。

309
00:24:50,320 --> 00:24:54,880
包含文件时，是只包含您需要的内容，还是包含所有内容？

310
00:24:54,880 --> 00:24:56,420
把它想象成包括一切。

311
00:24:56,420 --> 00:24:59,020
因此，如果文件很大，最顶端的代码就会很多。

312
00:24:59,020 --> 00:25:01,880
这就是为什么，如果你回想一下所有的 0 和 1

313
00:25:01,880 --> 00:25:08,892
我在不久前和上周都演示过，只要写下 "你好，世界"，屏幕上就会出现大量的 0 和 1。

314
00:25:08,892 --> 00:25:13,390
很多 0 和 1 可能来自于你实际上并不一定需要的代码。

315
00:25:13,390 --> 00:25:17,740
但其中一些也许是存在的，但也有优化的方法。

316
00:25:17,740 --> 00:25:22,395
好了，编译的第二步令人困惑地叫做 "编译"。

317
00:25:22,395 --> 00:25:27,940
只是，大多数人都用这个词来描述整个过程，而不仅仅是这一步。

318
00:25:27,940 --> 00:25:35,865
但是，一旦编译器在幕后为你预处理了程序，它现在看起来就有点像这样了。

319
00:25:35,865 --> 00:25:39,820
我把 "点"、"点"、"点 "放在这里，只是为了暗示，是的，对于你的问题，上面还有更多的东西。

320
00:25:39,820 --> 00:25:40,987
下面还有更多内容。

321
00:25:40,987 --> 00:25:43,070
只是现在对我们来说没什么意思。

322
00:25:43,070 --> 00:25:44,860
现在我们只有 C 代码了。

323
00:25:44,860 --> 00:25:46,960
没有预处理器指令了。

324
00:25:46,960 --> 00:25:52,670
此时，所有哈希符号和这些代码行都已被预处理并转换成其他内容。

325
00:25:52,670 --> 00:25:56,380
现在事情变得有点诡异了

326
00:25:56,380 --> 00:26:03,310
下面是 clang 或任何编译器编译这样的代码时发生的情况。

327
00:26:03,310 --> 00:26:08,720
它将 C 语言中的此代码转换为汇编代码中的此代码。

328
00:26:08,720 --> 00:26:10,720
因此，这是一种比较可怕的语言。

329
00:26:10,720 --> 00:26:12,580
我自己并没有什么美好的回忆。

330
00:26:12,580 --> 00:26:14,805
很多人都不会用这种语言编程。

331
00:26:14,805 --> 00:26:21,430
如果你选修了计算机科学、系统方面的后续课程，或者更高级别的课程，你可能真的会学到这些知识或其中的一些变体。

332
00:26:21,430 --> 00:26:29,320
但至少有一些人需要了解这些知识，因为这更接近于现在的计算机本身所能理解的东西。

333
00:26:29,320 --> 00:26:37,960
英特尔 CPU 或 AMD CPU 是当今电脑和手机的大脑，它们能理解的东西看起来更像这个，而不像 C。

334
00:26:37,960 --> 00:26:42,430
这完全是个深奥的问题，但我只想强调几句话。

335
00:26:42,430 --> 00:26:44,630
有些东西有点熟悉。

336
00:26:44,630 --> 00:26:47,620
顶部的黄色部分提到了主要内容。

337
00:26:47,620 --> 00:26:49,750
底部提到了 getString。

338
00:26:49,750 --> 00:26:52,070
下面提到了 printf。

339
00:26:52,070 --> 00:27:00,130
因此，这只是另一种名为汇编语言的编程语言，几十年前，人类--包括我自己在学校里--确实用这种语言写过代码。

340
00:27:00,130 --> 00:27:06,070
当然，有些人仍然在写这样的代码，尤其是你可以写出非常非常高效的代码。

341
00:27:06,070 --> 00:27:08,590
但它更神秘。

342
00:27:08,590 --> 00:27:11,380
它对用户不那么友好。

343
00:27:11,380 --> 00:27:23,630
所以，你现在会看到黄色的部分，这些就是所谓的指令，计算机的大脑或 CPU 可以理解这些指令，将数值推来推去、移动它们、减去数值、调用函数、移动、移动、

345
00:27:24,130 --> 00:27:34,120
因此，计算机能理解的低级运算往往是算术运算--减法、加法等--将东西移入或移出内存。

346
00:27:34,120 --> 00:27:37,510
对于我们这样的人来说，编写这样的代码要乏味得多。

347
00:27:37,510 --> 00:27:40,450
这就是为什么你和我倾向于写这样的东西。

348
00:27:40,450 --> 00:27:46,520
理想情况下，像你我这样的人还是倾向于拖放拼图，进一步抽象出这一切。

349
00:27:46,520 --> 00:27:49,420
但就目前而言，这还是被称为汇编语言。

350
00:27:49,420 --> 00:27:54,310
这就是编译器编译代码时发生的情况。

351
00:27:54,310 --> 00:27:57,010
当然，这仍然不是 0 和 1。

352
00:27:57,010 --> 00:27:58,580
所以我们还有两步要走。

353
00:27:58,580 --> 00:28:05,530
因此，当编译器进行到第三步时，就会将代码转换为机器代码。

354
00:28:05,530 --> 00:28:18,550
当编译器为你汇编代码时，它会把我们刚才在屏幕上看到的内容转换成实际的 0 和 1，也就是你的手机或电脑能理解的所谓机器码。

355
00:28:18,550 --> 00:28:24,280
但值得注意的是，这些并不一定是程序中所有的 0 和 1。

356
00:28:24,280 --> 00:28:36,940
是的，它们就是对应于 Hello 程序或 printf 和 getString 等的 0 和 1，但请注意，在这里，我们还需要最后一步。

357
00:28:36,940 --> 00:28:40,100
在这些 0 和 1 中，只有你的代码行。

358
00:28:40,100 --> 00:28:43,540
但是，我们为实现 getString 而编写的 CS50 代码又是怎么回事呢？

359
00:28:43,540 --> 00:28:46,990
几十年前人类为实现 printf 而编写的代码行又如何呢？

360
00:28:46,990 --> 00:28:54,460
这些数据在硬盘上的某个地方，比如在我的 Mac、PC 或云端的某个地方，但我们需要将所有这些 0 和 1 结合起来

361
00:28:54,460 --> 00:29:02,420
将我的代码与 CS50 的代码和标准 I/O 的代码连接在一起。

362
00:29:02,420 --> 00:29:11,440
因此，最后一步的最终结果是，如果我的代码是黄色的，CS50 写的代码是黄色的，C 语言的作者写的代码是黄色的，C 语言的作者写的代码是黄色的。

363
00:29:11,440 --> 00:29:19,960
它本身写道，真正发生的事情是，在某个地方，我们不仅有 hello.c，其中，很明显，我写道，并写道与我们住在这里、

364
00:29:19,960 --> 00:29:28,210
另外，我们假设在电脑的某个地方还有一个 cs50.c 文件，巧合的是，这个文件是我和 CS50 工作人员多年前写的。

365
00:29:28,210 --> 00:29:30,790
此外，在电脑的某个地方，还有另一个文件。

366
00:29:30,790 --> 00:29:34,120
让我简化一下，直接称之为 stdio.c。

367
00:29:34,120 --> 00:29:36,850
实际上，它的具体名称可能是 printf.c。

368
00:29:36,850 --> 00:29:39,460
但它们就在某处，就是另外两个文件。

369
00:29:39,460 --> 00:29:48,100


370
00:29:48,100 --> 00:29:50,810
然后抓取 CS50 写入的 0 和 1。

371
00:29:50,810 --> 00:29:56,240
为了实现标准 I/O 库，它抓取了 C 语言作者编写的 0 和 1。

372
00:29:56,240 --> 00:30:00,750
最后，瞧，把它们连接在一起。

373
00:30:00,750 --> 00:30:03,980
这就是我们之前看到的那团 0 和 1。

374
00:30:03,980 --> 00:30:15,830
这只是预处理你的代码、编译你的代码、组装你的代码、链接你的代码的结果，我的天啊，在这一点上，好像编程对你来说还有什么乐趣可言、

375
00:30:15,830 --> 00:30:19,620
我们把这一切都拿走了，我们把整个过程称为编译。

377
00:30:20,120 --> 00:30:27,890
因为既然我们知道这些步骤的存在，而且聪明人也为我们解决了这个问题，你和我就可以在这个抽象的层面上进行操作了

378
00:30:27,890 --> 00:30:32,420
并假定编译会将源代码转换为机器代码。

379
00:30:32,420 --> 00:30:36,350
对这些中间步骤有疑问吗？

381
00:30:37,360 --> 00:30:41,958
听众：对于链接，不同的部分，如[听不清]？

382
00:30:50,072 --> 00:30:51,280
大卫-马兰：问得好。

383
00:30:51,280 --> 00:30:53,238
那么，这些 "0 "和 "1 "都储存在哪里呢？

384
00:30:53,238 --> 00:30:58,330
当然，code.cs50.io 是基于网络的用户界面。

385
00:30:58,330 --> 00:31:09,000
但是，请再次回顾上周的内容，即使你使用网络浏览器访问 VS 代码，该网络版的 VS 代码也是连接到云中某处的实际服务器上的。

386
00:31:09,000 --> 00:31:15,360
在该服务器上，你有自己的账户和文件，实际上，你有自己的硬盘，实际上是在云中。

387
00:31:15,360 --> 00:31:19,830
把它想象成 Dropbox 或 Box 或 Google Drive 或 OneDrive 或类似的东西。

388
00:31:19,830 --> 00:31:23,310
所以，你有一个我们为你配置好的硬盘。

389
00:31:23,310 --> 00:31:32,700
在那个硬盘上，有你刚写的代码，或者我刚写的代码，cs50.c、stdio.c 以及所有其他代码。

390
00:31:32,700 --> 00:31:36,967
来实现数学函数和 C 支持的其他功能。

391
00:31:36,967 --> 00:31:37,550
问得好。

393
00:31:38,964 --> 00:31:51,935
听众：那么，比方说在 CS50 库中，[INAUDIBLE]这一行我们也是这样[INAUDIBLE]复制粘贴过来的吗？

394
00:31:51,935 --> 00:31:53,060
大卫-马兰：问得好。

395
00:31:53,060 --> 00:31:57,110
哈希值包括我代码顶端的 cs50.h 行。

396
00:31:57,110 --> 00:32:01,310
如果我将其替换为 cs50.c 的内容，这样行得通吗？

397
00:32:01,310 --> 00:32:03,590
简而言之，是的，这样可行。

398
00:32:03,590 --> 00:32:05,400
您可以将所有代码复制到这里。

399
00:32:05,400 --> 00:32:08,577
不过，有些操作顺序可能会发挥作用。

400
00:32:08,577 --> 00:32:10,910
因此，这可能不是复制、粘贴那么简单。

401
00:32:10,910 --> 00:32:13,190
但从概念上讲，是的，就是这么回事。

402
00:32:13,190 --> 00:32:25,670
因此，在 cs50.h 中，只有函数的原型、函数的外观提示、返回类型、名称和参数。

403
00:32:25,670 --> 00:32:29,867
实际代码往往是在点 c 文件中编写的。

404
00:32:29,867 --> 00:32:33,920
现在这有点令人困惑，因为你我都只在点 c 文件中编写过代码。

405
00:32:33,920 --> 00:32:40,460
但在接下来的几周里，你将开始编写一些自己的 dot h 文件，就像 CS50 一样，就像标准 I/O 一样。

406
00:32:40,460 --> 00:32:46,020
但实质上，这行代码只是让我们更容易使用和重复使用已经编写好的代码。

407
00:32:46,020 --> 00:32:47,750
而这正是图书馆的意义所在。

408
00:32:47,750 --> 00:32:50,327
听众：把它们联系起来[听不清]吗？

409
00:32:50,327 --> 00:32:51,910
大点声说。

410
00:32:51,910 --> 00:32:54,472
听众：使用编译器时是否会进行链接？

411
00:32:54,472 --> 00:32:55,180
戴维-马兰：是的。

412
00:32:55,180 --> 00:32:56,980
编译代码时是否进行了链接？

414
00:32:57,480 --> 00:33:04,570
当你运行 "制作 "时，就像我们过去一周所做的那样，所有这四个步骤都在进行。

415
00:33:04,570 --> 00:33:07,780
预处理会将哈希包含行转换为其他内容。

416
00:33:07,780 --> 00:33:14,290
从技术上讲，编译会将其转换为汇编代码，Mac、PC 和服务器更容易理解汇编代码。

417
00:33:14,290 --> 00:33:20,080
汇编程序将这种语言转换成二进制机器码，让计算机真正理解。

418
00:33:20,080 --> 00:33:22,540
然后将所有内容连接在一起。

419
00:33:22,540 --> 00:33:32,860
事实上，如果你回想一下几分钟前我做这个 -lcs50 的时候，我之所以要添加这个，以及我的代码一开始无法编译的原因，是因为我

420
00:33:32,860 --> 00:33:38,650
忘了告诉 clang 在最后一步连接 CS50 的 0 和 1。

421
00:33:38,650 --> 00:33:44,480
我不需要使用 -lstdio，因为它是 C 语言自带的，所以这对世界上的每个人来说都很乏味。

422
00:33:44,480 --> 00:33:47,140
但是，CS50 不带 C，因此我们将其连接进来。

423
00:33:47,140 --> 00:33:49,780
我们也要明确一点，我们不会一直使用 CS50 的资料库。

424
00:33:49,780 --> 00:33:53,072
这将是我们在未来几周内摘下的又一副训练轮。

425
00:33:53,072 --> 00:33:55,000
但现在，它让一些事情变得更简单了。

427
00:33:57,284 --> 00:33:59,750
听众：什么是[INNAUDIBLE]？

428
00:34:08,878 --> 00:34:10,170
大卫-马兰：简而言之，是的。

429
00:34:10,170 --> 00:34:12,870
那么，机器码中的 0 和 1 又是什么意思呢？

430
00:34:12,870 --> 00:34:17,340
是的，机器代码和汇编代码之间是一对一的关系。

431
00:34:17,340 --> 00:34:21,510
汇编代码，虽然不是真正的英语，但至少是我认识的符号。

432
00:34:21,510 --> 00:34:22,800
不是 0 和 1。

433
00:34:22,800 --> 00:34:24,810
当然，机器代码只是 0 和 1。

434
00:34:24,810 --> 00:34:30,630
因此，在 C 语言出现之前，人们只能用汇编代码编程。

435
00:34:30,630 --> 00:34:34,469
在汇编代码出现之前，人们用 0 和 1 进行编码。

436
00:34:34,469 --> 00:34:40,110
你可以想象那是多么痛苦，所以每一种语言都让我们的生活变得越来越轻松。

437
00:34:40,110 --> 00:34:48,090
几周后，我们将过渡到 Python，而 Python 又会让 C 语言变得更加简单，或者说让一般的编码工作变得更加简单。

438
00:34:48,090 --> 00:34:55,060
好了，说了这么多，我们现在能 -- 这可能会出什么问题？

439
00:34:55,060 --> 00:34:59,233
原来，除了编译，从技术上讲，还有反编译。

440
00:34:59,233 --> 00:35:01,150
我们没有这样做，也不会这样做。

441
00:35:01,150 --> 00:35:04,080
但这值得我们思考片刻。

442
00:35:04,080 --> 00:35:14,580
如果不对代码进行编译，而是进行反编译--顾名思义，反编译就是颠倒过程，最好是从机器码--0 和 1--进行转换。

443
00:35:14,580 --> 00:35:22,080
如果你有的只是一个程序，你可以转换它并查看实际的源代码。

444
00:35:22,080 --> 00:35:28,650
如果互联网上的任何人都能在自己的机器上反编译代码，那会有什么坏处呢？

447
00:35:30,270 --> 00:35:35,430
好吧，那就更容易在代码中找到漏洞，哦，利用漏洞。

448
00:35:35,430 --> 00:35:45,080
因此，通过查找你我所犯的错误来黑进软件可能会更容易，因为从字面上看，它们是用代码盯着你看的，而 0 和 1 就不那么明显了。

449
00:35:45,080 --> 00:35:48,140
我所说的反编译的其他缺点？

451
00:35:49,970 --> 00:35:53,690
如果东西是有版权的，或者你甚至不知道如何得到它 --

452
00:35:53,690 --> 00:35:54,440
是的

454
00:35:55,948 --> 00:36:03,660
戴维-马兰：是的，如果你的代码、你的作品是你的知识产权，不管是否有版权，有人可以随便运行一个命令，然后 "嘭 "的一声，这就有点令人讨厌了、

455
00:36:03,660 --> 00:36:05,577
他们可以看到你编写的原始代码。

456
00:36:05,577 --> 00:36:08,490
现在看来，事情并非如此简单。

457
00:36:08,490 --> 00:36:19,400
因此，尽管你可以使用 Hello 或 Microsoft Word 这样的程序，并将其从 0 和 1 转换回某种形式的源代码--无论是 C 语言还是 Java 语言

458
00:36:19,400 --> 00:36:25,800
或 Python 或其他语言，不管它最初是用什么语言编写的--都有可能是一团糟。

460
00:36:26,300 --> 00:36:30,890
因为变量名通常不会保留在 0 和 1 中。

461
00:36:30,890 --> 00:36:33,980
函数名可能不会保留在 0 和 1 中。

462
00:36:33,980 --> 00:36:42,890
代码是代码，逻辑是逻辑，但计算机并不关心你选择了什么漂亮的变量，也不关心你的函数名称有多好听，它只需要知道它们是 0 和 1。

463
00:36:42,890 --> 00:36:46,370
此外，回想一下上周，我们介绍了 C 语言中的循环等内容。

464
00:36:46,370 --> 00:36:49,745
除了 for 循环，还有哪种循环？

466
00:36:50,620 --> 00:36:59,910
DAVID MALAN：所以，while 循环--尽管它们看起来不同，你必须写不同的代码，但它们实现的功能完全相同，也就是说，当你编译 for 循环时

467
00:36:59,910 --> 00:37:07,420
或编译一个 while 循环，如果它们在逻辑上做的是同一件事，那么它们最终可能看起来就像 0 和 1 一样。

468
00:37:07,420 --> 00:37:11,820
因此，并不一定能预测你能拿回原始代码，为什么？

469
00:37:11,820 --> 00:37:19,350
因为 0 和 1 可能不知道是 for 循环还是 while 循环，所以编译时可能会显示其中一个。

470
00:37:19,350 --> 00:37:24,570
老实说，反编译虽然可行，但也是逆向工程的一种方法。

471
00:37:24,570 --> 00:37:34,020
如果你有足够的能力开始阅读已经反编译过的代码，并能读懂其中的杂乱无章，那么你就有可能具备从头开始编写相同程序的才能。

473
00:37:34,650 --> 00:37:40,410
现在看来，这也许有点言过其实，但它并不像你最初想象的那样容易或具有威胁性。

474
00:37:40,410 --> 00:37:50,040
因此，一般来说，代码一旦编译完成，要对其进行逆向工程就相当具有挑战性，既费时又费钱，就像在现实世界中一样，对吗？

475
00:37:50,040 --> 00:37:52,860
如今，我们每个人的口袋里都可能装着某种手机。

476
00:37:52,860 --> 00:37:57,060
没有什么能阻止你以某种方式打开它，四处探寻，重现那里的一切。

477
00:37:57,060 --> 00:37:59,130
这很可能是一个巨大的工作量。

478
00:37:59,130 --> 00:38:03,310
到那时，也许你应该发明手机，而不是试图逆向工程它。

479
00:38:03,310 --> 00:38:06,330
因此，在物理世界中也有同样的想法。

480
00:38:06,330 --> 00:38:13,050
那么，对于这些形式的编译甚至反编译有什么问题吗？

481
00:38:13,050 --> 00:38:17,160
好吧，现在看来，不仅是我，你们也有可能犯错。

482
00:38:17,160 --> 00:38:26,490
你写的代码有漏洞--代码中的漏洞就是一个错误，不管是逻辑错误还是其他错误，代码就是不能按照你的意图正确运行。

483
00:38:26,490 --> 00:38:35,320
到目前为止，你的调试技巧很可能就是回顾我在课堂上的表现，或者在网上或当面提问。

484
00:38:35,320 --> 00:38:39,570
但归根结底，如果你有一些自己的工具来调试代码，那就更好了。

485
00:38:39,570 --> 00:38:41,587
老实说，这是一项终身技能。

486
00:38:41,587 --> 00:38:47,910
你不可能从 CS50 中脱颖而出，甚至 20 年后，你也不可能一直写出正确的代码（如果你写的是代码的话）。

487
00:38:47,910 --> 00:38:50,820
比如，我们所有员工都在继续写 bug。

488
00:38:50,820 --> 00:38:55,540
希望他们能变得更成熟一些，而不是像 "哎呀，我漏掉了一个分号 "那样。

489
00:38:55,540 --> 00:38:57,660
但即使是这样的错误，我们也会犯。

490
00:38:57,660 --> 00:39:03,550
但是，在解决这些问题时，有一些工具和技术可以让你的生活变得更轻松。

491
00:39:03,550 --> 00:39:06,360
现在，"窃听器 "这个词实际上已经存在了几十年。

492
00:39:06,360 --> 00:39:13,650
不过，有一个有趣的故事是，第一个记录在案的真正错误实际上与哈佛大学有某种联系。

493
00:39:13,650 --> 00:39:22,890
事实上，这是 1947 年与哈佛 Mark II 计算机有关的日志，如果你读了这里的注释--我将放大--这个

494
00:39:22,890 --> 00:39:29,160
是在这台大型计算机主机内发现了一只真正的蛀虫，它造成了某种问题。

495
00:39:29,160 --> 00:39:33,610
当时在场的工程师们还觉得这很有趣：哇，物理错误居然能解释这个问题。

496
00:39:33,610 --> 00:39:39,090
它被永远地粘在了这张纸上，我相信这张纸现在正在史密森尼博物馆展出。

497
00:39:39,090 --> 00:39:43,260
尽管如此，这也只是一个逻辑错误的代表。

498
00:39:43,260 --> 00:39:53,640
实际上，这个故事经常被一位著名的数学家，也就是后来的计算机科学家格蕾丝-霍珀博士复述。

499
00:39:53,640 --> 00:39:57,210
它的前身是哈佛 Mark I 计算机。

500
00:39:57,210 --> 00:40:04,103
如果你曾在河对岸的工程大楼里待过一段时间，你就能看到这台计算机的许多部分。

501
00:40:04,103 --> 00:40:07,020
当你第一次走进科学与工程学院的时候，你会发现墙边有一个"......

503
00:40:07,530 --> 00:40:11,070
事实上，正如你在成长过程中可能听说过的，这是一台大型计算机。

504
00:40:11,070 --> 00:40:18,240
这就是 Mac 和 PC 当年的样子，它们都有一个非常实体的东西，基本上实现了零的功能

505
00:40:18,240 --> 00:40:22,410
而你我认为理所当然的那些东西，现在都已微型化，装进了我们的笔记本电脑和手机中。

506
00:40:22,410 --> 00:40:23,910
所以这里有一段历史。

507
00:40:23,910 --> 00:40:27,390
如果有机会去校园那边看看，一定要去。

508
00:40:27,390 --> 00:40:31,350
但是，让我们考虑一下，我们如何解决的当然不是物理上的错误，而是逻辑上的错误。

509
00:40:31,350 --> 00:40:40,320
让我们考虑一下上周发生的事情，我们试图用标签打印这三块砖头，非常简单。

510
00:40:40,320 --> 00:40:44,400
所以，让我马上去看看 VS Code。

511
00:40:44,400 --> 00:40:47,080
我现在要打开一个事先写好的程序。

512
00:40:47,080 --> 00:40:51,510
我把它带到课堂上是因为它有一个漏洞，我想知道如何解决这个漏洞。

513
00:40:51,510 --> 00:40:56,160
因此，让我打开 buggy0.c，这是我代码的第 0 版。

514
00:40:56,160 --> 00:40:58,200
让我们快速浏览一下这里的内容。

515
00:40:58,200 --> 00:40:58,950
很短。

516
00:40:58,950 --> 00:41:07,797
它只包含 stdio.h，使用 printf，使用 for 循环，目的很简单，就是打印出那列三个砖块。

517
00:41:07,797 --> 00:41:13,360
现在，它已经足够短了，如果你们中的一些人已经熟悉了 C 语言，你们可能已经看到了逻辑错误。

518
00:41:13,360 --> 00:41:16,200
这不是语法错误，因为它可以编译和运行。

519
00:41:16,200 --> 00:41:17,280
但这里有个漏洞。

520
00:41:17,280 --> 00:41:27,745
假设我是 C 语言的新手，我对 C 语言很不熟悉，现在是凌晨 2 点，我就是看不到这个错误，那么我有什么办法来发现这样的错误呢？

521
00:41:27,745 --> 00:41:29,370
首先，我们来看看症状。

522
00:41:29,370 --> 00:41:31,740
让我进入终端窗口。

523
00:41:31,740 --> 00:41:36,120
我将使用 make buggy0，因为文件名还是 buggyo.c。

524
00:41:36,120 --> 00:41:37,260
我不会用 clang。

525
00:41:37,260 --> 00:41:39,880
事实上，从现在开始我再也不会手动使用 clang 了。

526
00:41:39,880 --> 00:41:42,430
我只想用 make，因为它能让我们的生活更轻松。

527
00:41:42,430 --> 00:41:43,560
确实可以编译。

528
00:41:43,560 --> 00:41:45,390
没有错误，所以不是语法问题。

529
00:41:45,390 --> 00:41:47,670
这不是什么分号丢失之类的傻事。

530
00:41:47,670 --> 00:41:59,610
但是，当我运行 ./buggy0 时，我当然会看到 1、2、3、4 -- 当然，这与我为该列设计的 1、2、3 块砖并不一致。

531
00:41:59,610 --> 00:42:02,970
然而，我还是像往常一样，从 0 开始计数。

532
00:42:02,970 --> 00:42:03,930
我有三个。

533
00:42:03,930 --> 00:42:05,280
我要去三个。

534
00:42:05,280 --> 00:42:06,780
那么，我的逻辑错误在哪里？

535
00:42:06,780 --> 00:42:10,150
如果你还没有明显地意识到这一点，那么，我该如何解决这个问题呢？

536
00:42:10,150 --> 00:42:16,080
首先，解决 bug 的最佳方法也许就是使用 printf，至少在早期是这样。

537
00:42:16,080 --> 00:42:20,020
到目前为止，我们已经在屏幕上使用了 "冲刺说"、"你好 "等功能。

538
00:42:20,020 --> 00:42:22,530
但 printf 只是一个用于打印任何内容的函数。

539
00:42:22,530 --> 00:42:31,350
你没有理由不临时使用 printf 来打印变量的内容、程序内部的情况，以便找出错误所在。

540
00:42:31,350 --> 00:42:32,940
之后你就可以删除这行代码了。

541
00:42:32,940 --> 00:42:34,600
它不必永远留在那里。

542
00:42:34,600 --> 00:42:35,740
那就让我来吧。

543
00:42:35,740 --> 00:42:45,690
与其在 VS 代码中直接打印出哈希符号，不如让我在这里做一下安全检查，打印出 i 的值。

544
00:42:45,690 --> 00:42:51,610
所以，让我继续说，i is -- 现在我想说 i is this。

545
00:42:51,610 --> 00:42:54,540
当然，我并不是这样打印出 i 的值的。

546
00:42:54,540 --> 00:42:58,930
如果我想打印出 i 的值，应该在这里输入什么？

547
00:42:58,930 --> 00:43:02,160
所以 %i 表示整数，而不是 %s 表示字符串。

548
00:43:02,160 --> 00:43:03,410
因此，它们仍然是占位符。

549
00:43:03,410 --> 00:43:04,930
但我们使用 %s 表示整数。

550
00:43:04,930 --> 00:43:09,250
现在，如果我想打印出 i，只需将逗号作为第二个参数，然后再打印出 i。

551
00:43:09,250 --> 00:43:13,000
好了，让我回到终端窗口。

552
00:43:13,000 --> 00:43:15,760
让我重新编译程序，因为我改动了它。

553
00:43:15,760 --> 00:43:18,880
./buggy0 仍能正常工作。

554
00:43:18,880 --> 00:43:22,540
现在，让我增大终端窗口的大小。

555
00:43:22,540 --> 00:43:25,510
你可以看到一些诊断信息。

556
00:43:25,510 --> 00:43:26,560
这不是我们的目标。

557
00:43:26,560 --> 00:43:30,070
这不是你应该提交的作业问题（如果有的话）。

558
00:43:30,070 --> 00:43:34,450
但它可以帮助我们诊断地知道，好的，当 i 为零时，这里有一个哈希值。

559
00:43:34,450 --> 00:43:36,182
当 i 为 1 时，这里有一个哈希值。

560
00:43:36,182 --> 00:43:37,390
当 i 是 2 时，这里有一个散列。

561
00:43:37,390 --> 00:43:39,017
当 i 为 3 时，这里有一个散列。

562
00:43:39,017 --> 00:43:39,850
等一下

563
00:43:39,850 --> 00:43:41,530
一、二、三、四。

564
00:43:41,530 --> 00:43:44,360
很明显，我打印的次数太多了。

565
00:43:44,360 --> 00:43:48,130
因此，让我缩小终端窗口，回顾一下这里的代码。

566
00:43:48,130 --> 00:43:53,080
我想问问大家，错误究竟出在哪里？

567
00:43:53,080 --> 00:43:56,080
或者说，相应的解决方案是什么？

568
00:43:56,080 --> 00:43:57,561
是的，在中间。

570
00:44:00,020 --> 00:44:03,550
DAVID MALAN：是的，与其用小于或等于，不如用小于。

571
00:44:03,550 --> 00:44:05,300
所以，你得在这里选一条道。

572
00:44:05,300 --> 00:44:10,880
如果要从 0 开始计数，一般使用小于，直至，但不是通过值。

573
00:44:10,880 --> 00:44:17,300
或者，如果你愿意，就像人类世界一样，从 1 开始往上数，你也可以使用小于或等于，但必须保持一致。

574
00:44:17,300 --> 00:44:22,610
一般来说，作为程序员，如果要做类似这样的规范性工作，就一定要从 0 开始计数。

575
00:44:22,610 --> 00:44:27,860
但实际上，解决的办法就是通过将大于小于或等于小于来改变这种情况。

576
00:44:27,860 --> 00:44:36,500
如果我用 make buggy0 重新编译这个程序，然后再做一次 .buggy0 -- 让我增大终端窗口的大小。

577
00:44:36,500 --> 00:44:39,050
现在，你看，OK，输出几乎一样。

578
00:44:39,050 --> 00:44:44,330
但事实上，i 从 0 开始，一直到 3，但不是通过 3。

579
00:44:44,330 --> 00:44:48,920
好了，简而言之，printf 可以成为你的第一个诊断工具。

580
00:44:48,920 --> 00:44:51,500
而不是只盯着屏幕或举起手

581
00:44:51,500 --> 00:44:57,287
我的意思是，使用 printf 可以打印出感兴趣的内容，从而了解程序内部发生了什么。

582
00:44:57,287 --> 00:45:02,840
一旦你解决了问题，你就可以回到你的代码中，就像我在这里做的那样，缩小我的终端窗口。

583
00:45:02,840 --> 00:45:04,610
我会删除 printf 行。

584
00:45:04,610 --> 00:45:08,870
现在，我已经准备好与全世界分享这个程序，或者把它作为家庭作业之类的提交。

585
00:45:08,870 --> 00:45:11,390
这只是暂时的。

586
00:45:11,390 --> 00:45:15,440
有关于 printf 作为调试工具的问题吗？

588
00:45:18,510 --> 00:45:20,970
好吧，那也只能到此为止了。

589
00:45:20,970 --> 00:45:28,860
老实说，随着程序的不断发展壮大，开始添加 printf、删除 printf 并找出问题所在会变得非常烦人、

590
00:45:28,860 --> 00:45:31,860
如果你有多个 printf，那么，哪个 printf 打印了什么？

591
00:45:31,860 --> 00:45:34,560
仅仅依靠 printf 最终会变得一团糟。

592
00:45:34,560 --> 00:45:41,040
因此，作为一名计算机科学家，计算机科学家编写的软件可以让调试代码变得更容易。

593
00:45:41,040 --> 00:45:48,610
这个软件就是我们通常所说的调试器，它是你可以用来实际解决代码问题的第二个工具。

594
00:45:48,610 --> 00:45:52,690
现在，在 VS 代码的世界里，实际上已经内置了一个调试器。

595
00:45:52,690 --> 00:45:58,260
所以，你将在 VS Code 中看到的图形用户界面并不是 CS50 特有的，它实际上是 VS Code 自带的。

596
00:45:58,260 --> 00:46:03,030
它还支持 C、C++、Java、Python 和许多其他语言。

597
00:46:03,030 --> 00:46:07,650
但不得不承认，刚开始使用调试器有点复杂。

598
00:46:07,650 --> 00:46:13,480
你必须创建一个配置文件，并执行一些恼人的步骤，这些步骤只会妨碍你解决实际问题。

599
00:46:13,480 --> 00:46:17,070
因此，我们为您自动完成了启动调试器的过程。

600
00:46:17,070 --> 00:46:19,680
此后，如何使用它就成了行业标准。

601
00:46:19,680 --> 00:46:23,380
但我们为您省去了创建这些配置文件的麻烦。

602
00:46:23,380 --> 00:46:25,330
所以，假设我想这样做。

603
00:46:25,330 --> 00:46:30,330
假设我想尝试使用专用软件逐步调试这个程序。

604
00:46:30,330 --> 00:46:31,810
我该怎么做呢？

605
00:46:31,810 --> 00:46:41,790
好吧，让我来提议一下，如果我把它恢复到 i 小于或等于 3 的原始版本，我很确定我打印了太多的哈希值。

606
00:46:41,790 --> 00:46:45,160
所以我要这么做 -- 你可能不小心这么做了，或者根本就没这么做。

607
00:46:45,160 --> 00:46:54,390
但请注意，如果你将鼠标悬停在 VS 代码中的 "沟槽 "上，也就是编辑器左侧的部分，你会看到一个灰色的红点。

608
00:46:54,390 --> 00:46:57,240
如果点击这里，它就会变成一个更亮的红点。

609
00:46:57,240 --> 00:46:59,670
这就是我们所说的断点。

610
00:46:59,670 --> 00:47:07,350
这只是一个可视化的指示器，你在这里设置了一个等同于停止的标志，你在告诉调试器，停止在这里运行我的代码。

612
00:47:07,920 --> 00:47:14,380
因为我更喜欢以人的速度而不是电脑的速度来浏览我的代码。

613
00:47:14,380 --> 00:47:16,750
所以我设置了断点，这是第一步。

614
00:47:16,750 --> 00:47:18,580
第二步就很简单了。

615
00:47:18,580 --> 00:47:26,010
不要运行程序本身，而是运行名为 debug50 的命令，然后运行 ./buggy0。

616
00:47:26,010 --> 00:47:33,060
现在，这将启动你的程序，但在调试器内部，调试器是聪明人编写的一个特殊程序，它将赋予你

617
00:47:33,060 --> 00:47:38,970
现在，您可以按照自己的节奏逐行查看代码。

618
00:47:38,970 --> 00:47:43,080
我按下回车键，屏幕上就会出现一些东西--哎呀。

619
00:47:43,080 --> 00:47:45,767
注意，这是我不小心犯的一个常见错误。

620
00:47:45,767 --> 00:47:47,100
看来我修改了代码。

621
00:47:47,100 --> 00:47:49,892
我这样做是因为我修改了小于或等于号。

622
00:47:49,892 --> 00:47:52,860
因此，让我继续重新运行 make buggy0--

624
00:47:53,520 --> 00:47:55,590
很好，现在让我重新运行 debug50--

626
00:47:57,810 --> 00:48:06,010
现在屏幕上出现了一些东西，启动需要一些时间，但一旦启动，你就会看到这个，你仍然会看到你的代码。

627
00:48:06,010 --> 00:48:09,410
但你会看到这个黄色高亮，这可能是你以前从未见过的。

628
00:48:09,410 --> 00:48:13,440
注意，它特别强调了我设置断点的那一行。

630
00:48:13,950 --> 00:48:20,670
这意味着除第 7 行外，调试器已执行了所有这些行。

631
00:48:20,670 --> 00:48:23,340
它已经坏了，不是坏了。

632
00:48:23,340 --> 00:48:27,580
但它在第 7 行暂停执行，因此尚未打印任何哈希值。

633
00:48:27,580 --> 00:48:30,450
你可以看到终端窗口中还没有哈希值。

634
00:48:30,450 --> 00:48:31,980
这是暂停执行。

635
00:48:31,980 --> 00:48:37,410
但调试器的有趣之处在于左侧的内容。

636
00:48:37,410 --> 00:48:41,910
在调试器中，你会在变量下看到所有所谓的局部变量。

637
00:48:41,910 --> 00:48:45,327
我们还没有真正区分本地和所谓的全球。

638
00:48:45,327 --> 00:48:49,390
但现在，局部变量只是指函数中存在的所有变量。

639
00:48:49,390 --> 00:48:52,110
因此，i 目前的值为 0。

640
00:48:52,110 --> 00:48:53,410
好吧，这就说得通了。

641
00:48:53,410 --> 00:48:57,360
那么，现在我该如何逐步查看我的代码并了解它在做什么呢？

642
00:48:57,360 --> 00:49:03,630
在屏幕顶部，你会看到一些播放图标，有点像视频播放器，但它们有特殊含义。

643
00:49:03,630 --> 00:49:07,892
第一个程序会一直播放到节目结束。

644
00:49:07,892 --> 00:49:13,110
因此，只有当你已经解决了问题，只想像以前一样运行完成时，才会点击这个按钮。

645
00:49:13,110 --> 00:49:16,920
但接下来的三个，或者接下来的两个，真的，才是最精彩的。

646
00:49:16,920 --> 00:49:21,930
这里的第二个，如果你把鼠标悬停在它上面，最终你会看到它叫做 "跨步"。

647
00:49:21,930 --> 00:49:28,630
步骤结束意味着调试器将运行当前高亮显示的这行代码，但不会深入研究。

648
00:49:28,630 --> 00:49:32,827
因此，如果是像 printf 这样的函数，它就不会开始逐行执行 printf。

650
00:49:33,327 --> 00:49:36,420
因为我基本可以认为几十年前写的 printf 是正确的。

651
00:49:36,420 --> 00:49:38,050
问题可能出在我身上。

652
00:49:38,050 --> 00:49:46,110
但接下来这一行，如果我真的想走进 printf 代码，弄清楚它是如何工作的，或者在多年后发现其中的某些问题、

653
00:49:46,110 --> 00:49:54,250
你可以进入 printf，然后屏幕会发生变化，你会看到 printf 的每一行，一行接一行--至少如果你安装了 printf 的源代码的话。

654
00:49:54,250 --> 00:49:56,490
好了，我要用第一个，"跨步"。

655
00:49:56,490 --> 00:49:59,130
注意黄色亮点的移动。

656
00:49:59,130 --> 00:50:03,060
看，终端窗口中出现了一个哈希符号。

657
00:50:03,060 --> 00:50:03,780
开始了

658
00:50:03,780 --> 00:50:05,130
有一个散列。

659
00:50:05,130 --> 00:50:07,230
现在，请注意第 5 行已突出显示。

660
00:50:07,230 --> 00:50:09,480
这意味着它在第 5 行暂停。

661
00:50:09,480 --> 00:50:11,350
第 5 行尚未执行。

662
00:50:11,350 --> 00:50:12,600
这意味着什么？

663
00:50:12,600 --> 00:50:16,320
左上角的 i 值仍为 0。

664
00:50:16,320 --> 00:50:24,470
但当我再次点击 "Step Over "时，请注意左上方的情况，i 是屏幕上的一个变量。

665
00:50:24,470 --> 00:50:27,920
现在 i -- 短暂闪烁 -- 值为 1。

666
00:50:27,920 --> 00:50:30,650
现在，如果我再走过去，注意终端窗口。

667
00:50:30,650 --> 00:50:32,120
这是我的第二个哈希。

668
00:50:32,120 --> 00:50:36,380
现在，让我点击 For 循环的 Step Over，注意左上角的变量。

669
00:50:36,380 --> 00:50:38,567
现在 1 变为 2。

670
00:50:38,567 --> 00:50:39,650
现在让我再点击一次。

671
00:50:39,650 --> 00:50:43,220
第三次散列--这里可能暴露了逻辑错误。

672
00:50:43,220 --> 00:50:45,210
让我先跨过这个环。

673
00:50:45,210 --> 00:50:46,520
现在 i 是 3。

674
00:50:46,520 --> 00:50:49,280
等等，我还是要打印一份散列。

675
00:50:49,280 --> 00:50:49,810
就在那儿。

676
00:50:49,810 --> 00:50:50,810
还有第四根哈希线。

677
00:50:50,810 --> 00:50:53,852
在这一点上，希望灯泡，俗话说，已经熄灭了。

678
00:50:53,852 --> 00:50:55,020
我意识到，哦，我搞砸了。

679
00:50:55,020 --> 00:51:02,493
我可以用红色方块完全停止程序，也可以让程序一直运行到最后，这样就可以终止一切。

680
00:51:02,493 --> 00:51:05,660
此时此刻，我只想回到我的代码中，开始修复问题。

681
00:51:05,660 --> 00:51:10,670
例如，你可以关闭文件资源管理器，以隐藏打开的面板。

682
00:51:10,670 --> 00:51:12,320
这就是 debug50。

683
00:51:12,320 --> 00:51:19,520
但这并不是 CS50 的问题，它只是为你启动调试器，这在当今大多数编程环境中都能找到。

684
00:51:19,520 --> 00:51:23,670
关于调试的问题？

687
00:51:24,670 --> 00:51:27,295
听众：它告诉你哪里出了问题？

688
00:51:27,295 --> 00:51:28,420
大卫-马兰：问得好。

689
00:51:28,420 --> 00:51:30,310
它在哪里告诉你哪里出了问题？

690
00:51:30,310 --> 00:51:33,190
因此，很遗憾，它并没有告诉你这些。

691
00:51:33,190 --> 00:51:39,580
您，人类，仍有责任有效地使用这一工具，以更理智的速度浏览您的代码。

692
00:51:39,580 --> 00:51:42,070
但你的大脑仍然需要解决这个问题。

693
00:51:42,070 --> 00:51:49,160
我毫不怀疑，随着人工智能等技术的发展，这样的程序会越来越有用，并开始为我们解答类似的问题。

694
00:51:49,160 --> 00:51:52,990
本学期我们还将向你介绍比这更强大的其他工具。

695
00:51:52,990 --> 00:51:57,820
但就目前而言，它只是一个工具，真正的作用是减慢速度，而不必更改代码。

696
00:51:57,820 --> 00:52:06,820
事实上，左边的面板只是向我显示 i 的变化值，这只是 printf 的一种替代方法，我可以更慢地完成它。

697
00:52:06,820 --> 00:52:10,580
有关调试的其他问题？

699
00:52:11,080 --> 00:52:14,950
让我用这个调试器给你演示最后一个例子。

700
00:52:14,950 --> 00:52:16,750
这个也是我提前写好的。

701
00:52:16,750 --> 00:52:18,730
让我关闭 buggy0.c。

702
00:52:18,730 --> 00:52:22,327
让我打开 buggy1.c，这是我的第二个版本。

703
00:52:22,327 --> 00:52:28,030
让我先关闭终端窗口，给你快速浏览一下这个程序，同样，它也有一个错误。

704
00:52:28,030 --> 00:52:32,830
现在，在这个程序的顶端，有一些我们熟悉的包括：cs50.h 和 stdio.h。

705
00:52:32,830 --> 00:52:34,730
这是我们以前从未见过的。

706
00:52:34,730 --> 00:52:38,830
这是本例中的一个特殊函数，名为 getNegativeInt。

707
00:52:38,830 --> 00:52:41,043
不带参数，返回一个整数。

708
00:52:41,043 --> 00:52:41,710
它有什么作用？

709
00:52:41,710 --> 00:52:45,040
从字面上看，它可以从用户那里得到一个负整数，理想情况下是这样。

710
00:52:45,040 --> 00:52:47,200
但有趣的是，这并不正确。

711
00:52:47,200 --> 00:52:50,090
这就是问题所在，目前 getNegativeInt 已被破坏。

712
00:52:50,090 --> 00:52:51,470
那么，主要做什么呢？

713
00:52:51,470 --> 00:52:55,690
好吧，main 只是调用这个函数，在括号中什么都没输入，也没有输入。

714
00:52:55,690 --> 00:52:58,240
并将返回值保存在 i 中。

715
00:52:58,240 --> 00:53:00,260
然后它就会在屏幕上打印出 i。

716
00:53:00,260 --> 00:53:06,365
因此，老实说，仅凭目测，我觉得用 C 语言编程已经足够自如了，我认为 main 是正确的。

717
00:53:06,365 --> 00:53:07,990
让我来说明一下，main 是正确的。

718
00:53:07,990 --> 00:53:09,698
但下面会有一个窃听器。

719
00:53:09,698 --> 00:53:11,210
下面的窃听器是什么？

720
00:53:11,210 --> 00:53:14,830
让我看看 getNegativeInt 的实现。

721
00:53:14,830 --> 00:53:18,970
注意，第一行 12 与上面的原型相同。

722
00:53:18,970 --> 00:53:26,690
因为 C 语言是从上到下、从左到右读取数据的--编译器在技术上是这样做的。

723
00:53:26,690 --> 00:53:36,820
因此，如果你在这里引用了 getNegativeInt，但直到下面才实现它，而且没有提前告诉 C 它将存在，那么你将再次出现上周我们看到的错误。

724
00:53:36,820 --> 00:53:39,010
好了，getNegativeInt 如何工作？

725
00:53:39,010 --> 00:53:40,960
我们声明一个名为 n 的变量。

726
00:53:40,960 --> 00:53:43,540
我们必须做一个 while 循环，做什么？

727
00:53:43,540 --> 00:53:47,110
它使用的是 cs50 库自带的 getInt，与上周相同。

728
00:53:47,110 --> 00:53:51,670
它提示用户输入负整数，加引号不加引号，并将数值存储在 n 中。

729
00:53:51,670 --> 00:53:56,800
然后，我在 n 小于 0 的情况下完成所有这些操作，对吗？

730
00:53:56,800 --> 00:54:04,970
还记得吗，上周我们曾经做了一个循环，以确保人类合作，不会给我们错误的值，无论是正值、负值还是其他值。

731
00:54:04,970 --> 00:54:06,400
然后我们返回 n。

732
00:54:06,400 --> 00:54:07,570
还有一些微妙之处。

733
00:54:07,570 --> 00:54:15,790
有谁记得--或者有直觉告诉我为什么我在第 14 行而不是第 17 行声明了 n？

734
00:54:15,790 --> 00:54:17,620
这是 C 语言的特殊情况。

736
00:54:23,465 --> 00:54:24,340
大卫-马兰：没错。

737
00:54:24,340 --> 00:54:33,560
在 C 语言中，有这样一个作用域的概念，我们将继续看到这个概念，即一个变量只存在于你最近打开的大括号中。

738
00:54:33,560 --> 00:54:40,900
因此，如果我在第 14 行声明了 n，我就可以在第 13 行和第 21 行之间的任何地方使用它，因为这些都是最近的大括号。

739
00:54:40,900 --> 00:54:53,470
相比之下，正如你所指出的，如果我改成这样说，int n 等于 getInt 等等，并且没有当前的第 14 行，那么，n 就会存在于这些大括号内，但不会存在于这里，这就意味着

740
00:54:53,470 --> 00:54:55,340
太迟了，而且绝对不是在这里。

741
00:54:55,340 --> 00:54:59,480
因此，你只需先声明它，然后再使用和重复使用它。

742
00:54:59,480 --> 00:55:01,545
现在，让我来告诉你如何调试它。

743
00:55:01,545 --> 00:55:03,170
不过，让我先给你看看症状。

744
00:55:03,170 --> 00:55:04,930
让我打开终端窗口。

745
00:55:04,930 --> 00:55:06,970
让我运行 buggy1。

746
00:55:06,970 --> 00:55:13,660
./buggy1，我被要求输入一个负整数。

747
00:55:13,660 --> 00:55:15,280
好吧，让我给它负1 --

749
00:55:16,710 --> 00:55:20,880
主函数应该打印出我输入的内容，但显然没有。

750
00:55:20,880 --> 00:55:21,880
它又在提示我了。

751
00:55:21,880 --> 00:55:23,830
好吧，也许是负 2。

753
00:55:24,330 --> 00:55:26,380
也许是负 3。

755
00:55:27,570 --> 00:55:29,160
好吧，它肯定坏了，对吗？

756
00:55:29,160 --> 00:55:31,528
从逻辑上讲，这似乎是在做相反的事情。

757
00:55:31,528 --> 00:55:33,820
现在，你或许已经明白为什么会出现这种情况了。

758
00:55:33,820 --> 00:55:37,170
这些都是为了演示而特意设计的简单程序。

759
00:55:37,170 --> 00:55:38,470
但让我们这样做吧。

760
00:55:38,470 --> 00:55:42,870
让我继续在 main 中设置断点，尽管我很确定 main 是正确的。

761
00:55:42,870 --> 00:55:47,010
但这只是帮助我开始我的思考过程--从主要的开始，然后从那里继续。

762
00:55:47,010 --> 00:55:51,840
现在让我运行 debug50 ./buggy1--

764
00:55:52,920 --> 00:55:53,700
让我们看看

765
00:55:53,700 --> 00:55:56,880
有了这个断点，图形用户界面就会重新配置。

766
00:55:56,880 --> 00:56:01,260
它会在第 8 行暂停，因为这是 main 中第一行有趣的内容。

767
00:56:01,260 --> 00:56:03,780
所以我也可以把断点放在第 8 行。

768
00:56:03,780 --> 00:56:09,570
它很聪明，知道如果我把它设置为 6，你指的其实是第 8 行，因为那是第一行实际代码。

769
00:56:09,570 --> 00:56:11,280
现在，看看会发生什么。

770
00:56:11,280 --> 00:56:19,470
如果我跨过这一行，请注意 i，它目前的默认值似乎是 0 -- 下次再谈。

771
00:56:19,470 --> 00:56:24,750
但如果我像以前一样点击 "跨步"，系统会提示我输入一个负整数。

772
00:56:24,750 --> 00:56:25,750
让我输入负 1

774
00:56:27,300 --> 00:56:32,470
现在请注意，没有额外的黄色亮点。

776
00:56:32,970 --> 00:56:35,160
从逻辑上讲，我目前卡在哪里？

778
00:56:37,937 --> 00:56:40,770
戴维-马兰：是的，从逻辑上讲，我一定是在那个 do, while 循环中。

779
00:56:40,770 --> 00:56:43,560
即使你不理解，好像这是唯一的解释。

780
00:56:43,560 --> 00:56:46,143
如果您一直收到提示，肯定是出现了循环。

781
00:56:46,143 --> 00:56:49,270
我的代码中只有一个循环，所以可能有问题。

782
00:56:49,270 --> 00:56:52,900
因此，我不能只在 main 中设置一个断点，然后等待它起作用。

783
00:56:52,900 --> 00:56:56,280
所以，让我 -- 让我用红色方块来阻止这一切。

784
00:56:56,280 --> 00:56:58,860
让我想想，好吧，而不是 --

785
00:56:58,860 --> 00:57:02,770
我仍然可以在主程序中设置断点，但让我重新运行调试器。

786
00:57:02,770 --> 00:57:07,930
这一次，不是跨过那行代码，而是让我走进那行代码。

787
00:57:07,930 --> 00:57:09,270
所以，看看现在会发生什么。

788
00:57:09,270 --> 00:57:14,610
与其点击这里的第二个图标，不如让我点击第三个图标，它的名字确实叫 "走进"。

789
00:57:14,610 --> 00:57:17,880
注意黄色高亮显示不会移动到第 9 行。

790
00:57:17,880 --> 00:57:25,170
它潜入第 8 行 -- 第 8 行的函数，从而把我带到第 17 行。

791
00:57:25,170 --> 00:57:28,270
这是一种进入下一个功能的方式。

792
00:57:28,270 --> 00:57:34,380
现在，在第 12 行、第 13 行或第 14 行时，它懒得暂停，因为那里还没有发生任何有趣的事情。

793
00:57:34,380 --> 00:57:37,080
看来，多汁的部分是从第 17 行开始的。

794
00:57:37,080 --> 00:57:40,980
请注意，n 是左上角的变量。

795
00:57:40,980 --> 00:57:42,270
如果我点击

796
00:57:42,270 --> 00:57:45,420
但我现在不想点击 "进入"。

797
00:57:45,420 --> 00:57:52,480
如果我点击 "进入步骤"，会出现什么问题？

800
00:57:54,755 --> 00:57:56,630
戴维-马兰：是的，这将使我们进入 "获取信息 "阶段。

801
00:57:56,630 --> 00:58:02,120
但我认为工作人员对 getInt 的说法是正确的，这不是我们今天的问题，所以我想跨过这个问题。

802
00:58:02,120 --> 00:58:10,670
现在请注意左上角，在我进入终端窗口并输入负 1 这样的内容之前，n 的值不会发生任何变化。

803
00:58:10,670 --> 00:58:14,600
现在请注意，它跳转到了第 19 行，也就是下一个有趣的行。

804
00:58:14,600 --> 00:58:17,240
左上方的 n 的确是负 1。

805
00:58:17,240 --> 00:58:22,760
现在我可以暂停一下，想一想，好吧，当 n 小于 0 的时候。

806
00:58:22,760 --> 00:58:25,280
好了，左上角的 n 是负 1。

807
00:58:25,280 --> 00:58:29,780
好吧，虽然负 1 小于 0，但显然这在数学上是正确的。

808
00:58:29,780 --> 00:58:30,930
那么会发生什么呢？

809
00:58:30,930 --> 00:58:32,130
这是一个 do while 循环。

810
00:58:32,130 --> 00:58:39,410
因此，当我再次点击 "Step Over "时，它会转到这一行，因为它位于循环内部的末尾。

811
00:58:39,410 --> 00:58:42,710
而现在，它在这里一次又一次地循环。

812
00:58:42,710 --> 00:58:44,240
好吧，让我再来一次。

813
00:58:44,240 --> 00:58:45,980
我要走过去，好吗？

814
00:58:45,980 --> 00:58:48,777
我要输入负 2，情况完全一样。

815
00:58:48,777 --> 00:58:50,360
现在是我的机会，在黄线上 --

816
00:58:50,360 --> 00:58:51,260
好吧，等一下。

817
00:58:51,260 --> 00:58:53,450
负 2 显然小于 0。

818
00:58:53,450 --> 00:58:56,080
让我再试一次。

819
00:58:56,080 --> 00:58:57,570
在此点击一次。

820
00:58:57,570 --> 00:58:59,040
好吧，让我给它50。

821
00:58:59,040 --> 00:59:08,970
现在，好了，当 50 小于 0 时，这不是真的，所以循环结束了，因为它不会在 50 小于 0 时执行。

822
00:59:08,970 --> 00:59:09,730
事实并非如此。

823
00:59:09,730 --> 00:59:15,810
所以现在看，当我再点击一次 Step Over 时，它就会完成循环，即使没有其他事情要做。

824
00:59:15,810 --> 00:59:17,610
现在即将返回 n。

825
00:59:17,610 --> 00:59:21,360
它会跳回到主界面，也就是我在第 9 行离开的地方。

826
00:59:21,360 --> 00:59:23,778
现在，它在我的终端窗口中打印出了数字 50。

827
00:59:23,778 --> 00:59:30,700
希望在这一点上，对于你刚才的问题，我的人脑已经意识到，哦，我是个白痴，就像我在那里翻了牌子一样。

828
00:59:30,700 --> 00:59:32,460
所以，我可能 - 让我停止这一点。

829
00:59:32,460 --> 00:59:34,780
我可能想做这样的事情。

830
00:59:34,780 --> 00:59:45,070
如果目标是得到一个负整数，我可能想说，比如 n 大于或等于 0 也行。

831
00:59:45,070 --> 00:59:48,630
因此，当 n 大于或等于 0 时，继续这样做。

832
00:59:48,630 --> 00:59:50,430
这就是我想表达的逻辑。

833
00:59:50,430 --> 00:59:54,900
因此，调试器可以让我不必盯着屏幕，举起一只手，向其他人询问。

834
00:59:54,900 --> 00:59:58,650
至少在这种情况下，它能让我以更健康的速度完成它。

835
00:59:58,650 --> 01:00:04,940
关于 debug50 的问题，即使它不是你在 printf 之后的第一反应，它也应该是你的新朋友。

836
01:00:07,690 --> 01:00:09,190
有关于 debug50 的问题吗？

838
01:00:09,730 --> 01:00:13,960
好吧，我们还可以教你最后一个技巧。

839
01:00:13,960 --> 01:00:22,720
也就是说，除了 printf 和调试器（不是开玩笑）之外，橡皮鸭其实也是一个值得推荐的查找代码错误的解决方案。

840
01:00:22,720 --> 01:00:26,390
对于你刚才的问题，鸭子二号并不能为你解决问题。

841
01:00:26,390 --> 01:00:33,760
不过，如果你想知道为什么这个小家伙在这里呆了这么久，那么有一种技术，在维基百科上有自己的文章，叫做橡皮鸭调试。

842
01:00:33,760 --> 01:00:42,820
这样做的目的是，如果你在宿舍里与代码中的某个错误搏斗，printf 并没有完全向你揭示源代码，调试器也帮不上什么忙、

843
01:00:42,820 --> 01:00:46,960
老实说，如果能把你遇到的问题说清楚，也许会有帮助。

844
01:00:46,960 --> 01:00:54,730
类似于去办公室，与助教或教授交谈，把你的问题一一道来，因为在与鸭子交谈的过程中，事实上

845
01:00:54,730 --> 01:01:01,180
在 n 小于 0 的情况下进行，如果 n 小于 0 -- 请稍候。

846
01:01:01,180 --> 01:01:03,820
我是个白痴，不只是因为和橡皮鸭说话。

847
01:01:03,820 --> 01:01:11,860
你意识到，希望在表达自己时，从字面上看，你可能会听到非零概率的说法，比如你的陈述中存在一些不合逻辑的地方。

848
01:01:11,860 --> 01:01:16,430
只要把事情说清楚，你就会意识到，哦，这就是我的问题所在。

849
01:01:16,430 --> 01:01:19,720
因此，坦率地说，如果你有室友，你也可以用室友来做这件事。

850
01:01:19,720 --> 01:01:28,150
但是，当室友们对你的 C 题集不感兴趣时，橡皮鸭就成了他们的首选。

851
01:01:28,150 --> 01:01:29,933
这是一项非常宝贵的技术。

852
01:01:29,933 --> 01:01:34,510
我承认，我不太喜欢和橡皮鸭一起玩，但我更喜欢和同事，人类同事一起玩。

853
01:01:34,510 --> 01:01:40,360
但是，只要经常把事情说清楚，你就会意识到，哦，我说了一些不合逻辑的话。

854
01:01:40,360 --> 01:01:41,860
现在我可以回去写代码了。

855
01:01:41,860 --> 01:01:46,240
因此，不要通过无休止地盯着屏幕几分钟、几个小时来解决问题。

856
01:01:46,240 --> 01:01:52,900
这时，如果你已经用尽了其他工具，就该休息一下，该走开了，该和鸭子谈谈了。

857
01:01:52,900 --> 01:01:59,020
顺便说一句，今天下课的时候，我们为你们准备了很多橡皮鸭。

858
01:01:59,020 --> 01:02:05,770
多年来，至少在一些人当中，他们旅行时带上鸭子并给我们寄照片已经成为一种习惯。

859
01:02:05,770 --> 01:02:15,940
例如，这里是 CS50 的橡皮鸭调试器，又名 DDB（鸭子调试器），这是一个双关语，意为 GDB（GNU 调试器）。

860
01:02:15,940 --> 01:02:18,740
调试器，这是一个实际的调试软件。

861
01:02:18,740 --> 01:02:25,270
这是 CS50 在波多黎各山上的调试器，也在海边。

862
01:02:25,270 --> 01:02:28,310
他在这里前往旧金山。

863
01:02:28,310 --> 01:02:30,640
另外，在渔人码头海狮旁边。

865
01:02:31,660 --> 01:02:38,950
在斯坦福大学，有一座威廉-盖茨计算机科学大楼，专门用于计算机科学；在三藩市的谷歌公司，也有一座威廉-盖茨计算机科学大楼。

866
01:02:38,950 --> 01:02:41,650
这就是罗马的许愿泉。

867
01:02:41,650 --> 01:02:43,810
最后是斗兽场。

868
01:02:43,810 --> 01:02:46,990
因此，我们很想知道，在未来的几年里，你的鸭子二号会去哪里旅行。

869
01:02:46,990 --> 01:02:49,120
所以，那就相当多了。

870
01:02:49,120 --> 01:02:51,850
我们为什么不在这里休息 5 分钟呢？

871
01:02:51,850 --> 01:02:52,760
还没有点心。

872
01:02:52,760 --> 01:02:54,400
欢迎起身或坐下。

873
01:02:54,400 --> 01:02:56,620
我们五分钟后回来

874
01:02:56,620 --> 01:03:00,020
好了，我们回来了。

875
01:03:00,020 --> 01:03:09,190
如果我们今天的最终目标是更好地理解字符串之类的东西，从而解决文本问题，那么我们不妨考虑一些更简单的数据类型

876
01:03:09,190 --> 01:03:17,330
首先，我们可以如何表示这些，然后看看这是否会让我们发现字符串是如何使用的，以及今天的现代软件是如何使用类似的东西的。

877
01:03:17,330 --> 01:03:27,640
因此，当我们在第零周讨论数据的表示法时，我们有不同的方法，有二进制和十进制，甚至还有一元制。

878
01:03:27,640 --> 01:03:33,980
当我们上周开始讨论同样的代码时，我们开始讨论数据类型。

879
01:03:33,980 --> 01:03:45,070
这些数据类型是告诉计算机的一种方式，比如你想要一个整数、一个字符、一个浮点数值（如实数），甚至是一个字符串，正如我们已经看到的那样。

880
01:03:45,070 --> 01:03:49,930
但事实证明，计算机的资源当然是有限的。

881
01:03:49,930 --> 01:03:53,740
您的电脑只有固定数量的内存或 RAM。

882
01:03:53,740 --> 01:03:55,910
这实际上具有非常现实的意义。

883
01:03:55,910 --> 01:03:59,630
举例来说，下面是我们迄今为止看到的一些数据类型。

884
01:03:59,630 --> 01:04:05,650
事实证明，C 语言中的每一个比特都有特定的位数分配。

885
01:04:05,650 --> 01:04:08,350
当然，这也会因系统而异。

886
01:04:08,350 --> 01:04:13,100
现在的情况并非如此，但多年来，几十年来，计算机的性能越来越好。

887
01:04:13,100 --> 01:04:16,600
最早的计算机可能使用较少的比特来处理其中一些数据类型。

888
01:04:16,600 --> 01:04:18,663
更现代化的计算机可能会使用更多比特。

889
01:04:18,663 --> 01:04:21,830
因此，你们即将看到的数字就是我们目前的基本情况。

890
01:04:21,830 --> 01:04:32,380
因此，说到这些数据类型，"真 "或 "假 "的 bool 会使用一整个字节，这有点奇怪，因为对于 bool 而言，"真 "或 "假 "都是 "真 "或 "假"、

891
01:04:32,380 --> 01:04:33,940
当然，你只需要一个位。

892
01:04:33,940 --> 01:04:41,230
但事实证明，尽管用八个比特或一个字节来表示 "真 "或 "假 "很浪费，但对计算机来说却更容易。

893
01:04:41,230 --> 01:04:42,820
因此，一个 bool 往往是一个字节。

894
01:04:42,820 --> 01:04:47,590
我们经常使用的 int 通常使用 4 个字节，即 32 位。

895
01:04:47,590 --> 01:04:54,040
如果我从零开始快速计算一下，32 位大概有 40 亿个可能的值。

896
01:04:54,040 --> 01:05:01,020
但是，如果你想表示正数和负数，这意味着你可以大致表示负 20 亿，一直到正 20 亿。

897
01:05:01,020 --> 01:05:02,770
这就是 ints 的典型范围。

898
01:05:02,770 --> 01:05:06,820
如果你觉得数字太少，那么还有一种叫多头的东西。

899
01:05:06,820 --> 01:05:15,730
而长字符使用 64 位，这就允许你拥有五亿种可能性，当然，这比 40 亿要多得多。

900
01:05:15,730 --> 01:05:17,410
因此，有时您可能会使用长号。

901
01:05:17,410 --> 01:05:18,670
但即便如此，也是有限的。

902
01:05:18,670 --> 01:05:28,330
因此，正如我们在上周末所讨论的那样，如果你对数据做出某些假设，就会发生不好的事情，因为会出现整数溢出或类似的情况，即事情缠绕在一起。

903
01:05:28,330 --> 01:05:31,538
然后是浮点数，它是一个实数，带有小数点。

904
01:05:31,538 --> 01:05:37,810
按照惯例，它是 4 字节或 32 位，简而言之，只有特定的精度。

905
01:05:37,810 --> 01:05:41,620
它并不一定决定左边或右边有多少个数字。

906
01:05:41,620 --> 01:05:45,250
不过，总的来说，你还是有的、

907
01:05:45,250 --> 01:05:47,650
仍有 40 亿种可能的排列组合。

908
01:05:47,650 --> 01:05:57,700
如果在科学、医疗和金融应用中需要更高的精度，可以使用 8 字节，也就是双倍，这样可以获得更多位数的精度。

909
01:05:57,700 --> 01:06:03,610
按照我们上周看的例子，它们最终会变得不精确，但至少能让你更进一步。

910
01:06:03,610 --> 01:06:12,640
另外，在非常非常重要的应用领域，如金融、医学、军事行动等，真的不能有四舍五入误差-----------------。

911
01:06:12,640 --> 01:06:19,317
长话短说，人类已经用 C 语言和其他语言开发出了甚至超过 8 字节的库。

912
01:06:19,317 --> 01:06:22,150
因此，这些问题是有解决办法的，但办法总是有限的。

913
01:06:22,150 --> 01:06:24,070
你必须选择一个上限。

914
01:06:24,070 --> 01:06:29,470
然后是 char，上周我在询问用户 "y "或 "n"、"是 "或 "否 "时，我们简单地看到了 char。

915
01:06:29,470 --> 01:06:34,360
然后还有一个字符串，我打算用问号来表示，因为字符串完全取决于实际情况。

917
01:06:35,380 --> 01:06:38,890
H-I，感叹号，似乎是三个字节。

918
01:06:38,890 --> 01:06:41,140
D-A-V-I-D，似乎是五个。

919
01:06:41,140 --> 01:06:45,400
因此，字符串显然是可变的，取决于你或人类输入的内容。

920
01:06:45,400 --> 01:06:48,140
我们稍后就会知道这意味着什么。

921
01:06:48,140 --> 01:06:51,580
不过，这是你的 Mac、PC 和手机里的东西。

922
01:06:51,580 --> 01:06:56,187
它可能看起来并不完全像这样，但这是现代计算机的内存模块。

923
01:06:56,187 --> 01:06:57,520
让我们继续使用它。

924
01:06:57,520 --> 01:07:01,360
实际上，这只是代表了任何计算机内存的有限性。

925
01:07:01,360 --> 01:07:06,160
让我们放大电路板上的这些黑色小芯片。

926
01:07:06,160 --> 01:07:16,750
放大，让我提议，这个矩形确实代表了一定数量的字节，就像藏在电路板上这个黑色小电路里面的，我不知道，可能是一个千兆字节、

927
01:07:16,750 --> 01:07:19,300
十亿字节，也许是 100 字节--某个字节数。

928
01:07:19,300 --> 01:07:22,700
这完全取决于电脑和内存条的价格。

929
01:07:22,700 --> 01:07:32,410
但是，如果硬件内部以某种数字方式物理实现的字节数是有限的，那么我们就有理由对这些字节进行编号。

930
01:07:32,410 --> 01:07:38,800
我们可以任意决定左上角是 1 号字节，或者真的是 0 号字节。

931
01:07:38,800 --> 01:07:46,090
旁边的是 1 号，然后是 2 号、3 号、点、点、点、20 亿或其他数字，不管这个存储器有多大。

932
01:07:46,090 --> 01:07:50,530
因此，如果您在 C 语言程序中使用一个变量，它只有一个字节。

933
01:07:50,530 --> 01:07:55,120
就像字符一样，它可能就存储在内存的左上角。

934
01:07:55,120 --> 01:07:57,760
实际上，你并不关心它的物理位置。

935
01:07:57,760 --> 01:08:04,330
但实际上，艺术家的演绎是这样的--一个字符可能会使用计算机内存中的某个单字节。

936
01:08:04,330 --> 01:08:07,450
如果使用 int（4 个字节），则可以得到

937
01:08:07,450 --> 01:08:10,840
4 字节，连续 - 即从左到右，从上到下。

938
01:08:10,840 --> 01:08:16,149
但所有 32 位都会紧挨着，这样计算机就知道这些位确实都属于同一个 int。

939
01:08:16,149 --> 01:08:21,140
如果您需要长数据或双倍数据，在这种情况下您可能需要使用整整 8 个字节。

940
01:08:21,140 --> 01:08:29,845
你只需不断地使用这个内存，就像在 Photoshop 或电子表格中的画布一样，你可以随意移动像素或数据、

941
01:08:29,845 --> 01:08:36,702
这就是计算机内存的真正含义，它是以字节或 8 位为单位存储信息的画布。

942
01:08:36,702 --> 01:08:39,160
现在，我们不需要继续看这些电路板了。

943
01:08:39,160 --> 01:08:41,287
我们可以把它抽象出来，我们经常这样做。

944
01:08:41,287 --> 01:08:45,740
让我们继续放大这个网格，考虑一些非常具体的变量。

945
01:08:45,740 --> 01:08:51,580
因此，让我放大，现在我看到屏幕上的方框更少但更大，每个方框同样代表一个字节。

946
01:08:51,580 --> 01:08:55,130
现在，让我提议我们来玩一些实际的代码。

947
01:08:55,130 --> 01:09:01,060
因此，在 C 语言中，尽管没有完整的程序，却有三个 ints：score1、score2、score3。

948
01:09:01,060 --> 01:09:09,040
巧合的是，我给自己打出了 72 分和 73 分左右的两个分数，然后又打出了 33 分这个相当低的分数。

949
01:09:09,040 --> 01:09:12,048
当然，在上周或两周前，这个数字还会很高。

950
01:09:12,048 --> 01:09:13,840
但现在我们面对的是实际的整数。

951
01:09:13,840 --> 01:09:17,750
因此，这是我在测验或考试中的三个一般分数。

952
01:09:17,750 --> 01:09:19,250
所以，让我来看看 VS 代码。

953
01:09:19,250 --> 01:09:22,210
让我们制作一个名为 scores.c 的程序。

954
01:09:22,210 --> 01:09:24,399
因此，我要编写代码 scores.c。

955
01:09:24,399 --> 01:09:26,149
这将为我提供新文件。

956
01:09:26,149 --> 01:09:28,420
让我来实现这样的功能。

957
01:09:28,420 --> 01:09:37,689
包括 stdio.h，int main(void)，然后在这里，让我做 int score1 将是 72。

958
01:09:37,689 --> 01:09:40,029
Int score2 将为 73。

959
01:09:40,029 --> 01:09:43,149
int score3 将是 33。

960
01:09:43,149 --> 01:09:48,042
然后让我做一些事情，比如写一个程序，把我的三次考试成绩平均起来，诸如此类。

961
01:09:48,042 --> 01:09:56,470
所以，让我来打印一下，引号后加引号，我的平均值是-- 我要继续打印，比如说，%i, /n。

962
01:09:56,470 --> 01:09:58,290
现在，让我输入结果。

963
01:09:58,290 --> 01:10:00,040
这已经是小学数学了。

964
01:10:00,040 --> 01:10:02,210
如何计算三个值的平均值？

965
01:10:02,210 --> 01:10:14,457
嗯，就像在纸上一样，我可以用 score1 加上 score2 再加上括号里的 score3，因为运算顺序是除以 3，因为一共有三个分数。

966
01:10:14,457 --> 01:10:16,040
好吧，我想这是正确的。

967
01:10:16,040 --> 01:10:23,180
事实上，您可以在 C 语言代码中使用括号和加号等运算符。

968
01:10:23,180 --> 01:10:24,327
无语法错误。

969
01:10:24,327 --> 01:10:25,910
这样很好，没有什么遗漏。

970
01:10:25,910 --> 01:10:28,850
现在让我输入 ./scores 查看我的平均测试成绩。

971
01:10:28,850 --> 01:10:32,270
好吧，虽然不是很好，但我想我还是通过了。

972
01:10:32,270 --> 01:10:36,050
事实上，我在这里的平均成绩是 59 分。

973
01:10:36,050 --> 01:10:38,360
是否正好是 59？

974
01:10:38,360 --> 01:10:39,140
让我想想

975
01:10:39,140 --> 01:10:44,870
实际上，与其使用 int 值，不如使用浮点值。

976
01:10:44,870 --> 01:10:46,250
让我来做这件事。

977
01:10:46,250 --> 01:10:48,710
因此，让我重新编译代码，进行评分。

978
01:10:48,710 --> 01:10:50,600
好吧，我有个问题。

979
01:10:50,600 --> 01:10:52,340
让我放大终端窗口。

980
01:10:52,340 --> 01:10:54,710
我们以前不一定见过这种情况。

981
01:10:54,710 --> 01:10:56,510
但第 9 行出现错误。

982
01:10:56,510 --> 01:11:02,180
格式指定的类型是 double，精度很高，但参数的类型是 int。

983
01:11:02,180 --> 01:11:03,300
这意味着什么？

984
01:11:03,300 --> 01:11:09,060
嗯，它用这些绿色的斜线告诉我，%f 和这里的东西之间有问题。

985
01:11:09,060 --> 01:11:13,020
那么，在左边，我的意思是浮点数，或者双倍数。

986
01:11:13,020 --> 01:11:16,835
右边的 score1、score2、score3 是什么数据类型？

987
01:11:16,835 --> 01:11:17,960
好吧，它们是 ints。

988
01:11:17,960 --> 01:11:19,583
所以，铛铛不喜欢这样。

989
01:11:19,583 --> 01:11:24,170
编译器只是不喜欢我在右边使用 ints，但我想在左边使用浮点数。

990
01:11:24,170 --> 01:11:26,670
因此，会有不同的解决方法。

991
01:11:26,670 --> 01:11:32,450
一种方法是像我最初做的那样忽略问题，回到 %i。

992
01:11:32,450 --> 01:11:38,330
另外，对于十进制数字，%d 通常可以替代 %i。

993
01:11:38,330 --> 01:11:42,358
但我们使用 %i 是因为它听起来像 int，所以 %i 在这里也可以使用。

994
01:11:42,358 --> 01:11:44,150
但我不想回避问题。

995
01:11:44,150 --> 01:11:46,500
我想实际显示一个浮点数值。

996
01:11:46,500 --> 01:11:47,730
那么，我该如何解决这个问题呢？

997
01:11:47,730 --> 01:11:50,272
事实证明，我可以用几种不同的方法来解决这个问题。

998
01:11:50,272 --> 01:11:59,330
最简单的方法是确保右边至少有一个数字是浮点数，比如 3.0 而不是 3。

999
01:11:59,330 --> 01:12:01,700
现在我觉得铛铛会更开心。

1000
01:12:01,700 --> 01:12:03,320
让我来打分

1002
01:12:04,400 --> 01:12:05,330
事实上，这也没问题。

1004
01:12:05,930 --> 01:12:14,330
只要右侧有至少一种更精确的数据类型，它就会将所有数据都视为浮点数，这样数学运算就能顺利进行。

1005
01:12:14,330 --> 01:12:17,720
所以./scores，回车，现在，我们走了，对吗？

1006
01:12:17,720 --> 01:12:20,390
我们中的一些人可能真的想要那 1/3 分。

1007
01:12:20,390 --> 01:12:21,980
我们的平均数不是 59。

1008
01:12:21,980 --> 01:12:25,010
是 59 1/3，就像这里的情况一样。

1009
01:12:25,010 --> 01:12:26,750
好了，我们已经解决了这个问题。

1010
01:12:26,750 --> 01:12:30,890
不过，这里还有一个技巧需要展示。

1011
01:12:30,890 --> 01:12:38,760
如果你不想把它改成 3.0，因为那有点奇怪，因为从字面上看有三个分数，这不像是需要有一个小数点、

1012
01:12:38,760 --> 01:12:46,230
您也可以明确地将 3 转换为浮点数，方法是在括号中说明 float。

1013
01:12:46,230 --> 01:12:48,050
这就是所谓的类型化。

1014
01:12:48,050 --> 01:12:52,560
如果可能的话，这将把它后面的内容转换为该数据类型。

1015
01:12:52,560 --> 01:12:59,960
因此，如果我再次这样做，进行评分，现在就不会出错了。./scores，我得到的结果其实是一样的。这里有点四舍五入的问题、

1016
01:12:59,960 --> 01:13:03,650
但我们知道，四舍五入与上周的不精确有关。

1017
01:13:03,650 --> 01:13:06,980
现在，就让我为我的 59.3 分感到高兴吧。

1018
01:13:06,980 --> 01:13:08,360
我现在就要这个。

1019
01:13:08,360 --> 01:13:14,660
但现在对我来说，这已经是一个足够好的正确答案了。

1020
01:13:14,660 --> 01:13:18,650
但我怎么 -- 现在想想 电脑内存里发生了什么？

1021
01:13:18,650 --> 01:13:19,310
好吧，让我们考虑一下。

1022
01:13:19,310 --> 01:13:20,643
这也是记忆的网格。

1023
01:13:20,643 --> 01:13:22,490
每个方框代表一个字节。

1024
01:13:22,490 --> 01:13:25,790
我记忆中的 score1、score2 和 score3 在哪里？

1025
01:13:25,790 --> 01:13:28,790
好吧，让我来提议，score1 在左上角。

1026
01:13:28,790 --> 01:13:32,060
但它占用了 4 个方框的 4 个字节。

1027
01:13:32,060 --> 01:13:38,180
虽然 Score2 在内存中可能会紧靠着它，但情况并不总是这样，我选择了一些简单的例子。

1028
01:13:38,180 --> 01:13:40,910
73 紧挨着它，也占用 4 个字节。

1029
01:13:40,910 --> 01:13:45,320
最后，33 在 score3 中，就在下面。

1030
01:13:45,320 --> 01:13:54,110
现在，如果我们真正观察一下计算机的内存，用显微镜之类的东西看一下，实际上有 32 位、32 位、32 位

1031
01:13:54,110 --> 01:13:59,308
这四组字节中的每一组都代表这些值。

1032
01:13:59,308 --> 01:14:03,308
但同样，就今天而言，我们并不需要反复思考二进制问题。

1033
01:14:03,308 --> 01:14:05,940
实际上，这些十进制数字就存储在这里。

1034
01:14:05,940 --> 01:14:08,240
但我现在认为，这不是最好的设计。

1035
01:14:08,240 --> 01:14:16,970
即使你在 CS50 之前从未做过编程，你在屏幕上看到的内容，作为一个摘录，从什么意义上说，这可能是糟糕的设计，即使它是

1036
01:14:16,970 --> 01:14:19,960
存储三个测试分数的正确方法？

1037
01:14:19,960 --> 01:14:20,960
这里有什么不好？

1039
01:14:21,882 --> 01:14:26,220
分数越多你的分数越多，你[听不清]的分数就越多。

1040
01:14:26,220 --> 01:14:31,740
戴维-马兰：是的，总是像你做的那样--推断出 4 分、5 分、50 分。

1041
01:14:31,740 --> 01:14:36,300
这不可能是精心设计的，因为现在你将有 4 行代码、5 行代码、

1042
01:14:36,300 --> 01:14:42,430
除了我们在变量末尾更新的这个任意数字，50 行代码几乎完全相同。

1043
01:14:42,430 --> 01:14:48,690
因此，的确可能会有更好的方法，尽管至少在 C 语言中，我们还没有看到这种技术。

1044
01:14:48,690 --> 01:14:52,440
但从今天起，解决方案将是一种叫做数组的东西。

1045
01:14:52,440 --> 01:15:03,960
数组是将数据背靠背存储在计算机内存中的一种方式，这样可以方便地访问每个成员。

1046
01:15:03,960 --> 01:15:08,530
换一种说法，使用数组时，您可以这样做。

1047
01:15:08,530 --> 01:15:20,700
与其说 int score1、int score2、int score3，给每个变量赋值，你可以先告诉计算机，请给我一个叫 scores 的变量，虽然它是复数，但你可以随便叫它什么。

1048
01:15:20,700 --> 01:15:24,090
的大小为 3，其中每个都是整数。

1049
01:15:24,090 --> 01:15:30,930
也就是说，在 C 语言中可以这样声明一个数组，它有足够的空间来存储三个整数。

1050
01:15:30,930 --> 01:15:38,880
换句话说，这就是用技术手段告诉计算机，请总共给我 12 个字节--------------。

1051
01:15:38,880 --> 01:15:42,660
一个 int 3 乘以 4，总共是 12 个字节。

1052
01:15:42,660 --> 01:15:47,350
计算机会保证它们在计算机内存中背靠背。

1053
01:15:47,350 --> 01:15:49,360
一会儿就会派上用场。

1054
01:15:49,360 --> 01:15:51,820
所以，让我继续用它做些有用的事情吧。

1055
01:15:51,820 --> 01:15:53,640
让我来存储三个实际分数。

1056
01:15:53,640 --> 01:15:58,500
现在，我可以在这个数组中存储同样的数字分数。

1057
01:15:58,500 --> 01:16:03,040
语法略有不同，但有一个变量叫 scores。

1058
01:16:03,040 --> 01:16:14,280
但是，如果你想从今天开始转到它的第一个位置，你可以使用方括号，先转到位置 0，因为 C 中的东西都是 0 索引的，可以这么说，你从 0 开始计数。

1059
01:16:14,280 --> 01:16:16,410
第一个 int 位于 [0]。

1060
01:16:16,410 --> 01:16:18,030
第二个 int 位于 [1]。

1061
01:16:18,030 --> 01:16:19,530
第三个 int 位于 [2]。

1062
01:16:19,530 --> 01:16:20,730
所以不是一、二、三。

1063
01:16:20,730 --> 01:16:22,090
简直就是 0、1、2。

1064
01:16:22,090 --> 01:16:24,090
这不是你能控制的。

1065
01:16:24,090 --> 01:16:26,250
必须从 0 开始。

1066
01:16:26,250 --> 01:16:33,510
因此，现在这些行创建了一个大小为 3 的数组，然后向数组中插入 1、2、3 个值。

1067
01:16:33,510 --> 01:16:37,770
但这样做的好处是，你只需记住一个变量名。

1068
01:16:37,770 --> 01:16:39,240
这就是所谓的分数。

1069
01:16:39,240 --> 01:16:43,380
是的，您需要进入数组获取单个值。

1070
01:16:43,380 --> 01:16:46,618
您需要使用方括号将索引输入其中。

1071
01:16:46,618 --> 01:16:53,050
但至少你不用为每一个值都声明一个单独的变量，而采用这种黑客式的方法。

1072
01:16:53,050 --> 01:16:56,070
所以，让我回到 scores.c 这里。

1073
01:16:56,070 --> 01:16:57,580
请允许我提议这样做。

1074
01:16:57,580 --> 01:17:00,580
让我用同样的想法来做下面的事情。

1075
01:17:00,580 --> 01:17:02,580
让我把这三个独立的整数去掉。

1076
01:17:02,580 --> 01:17:06,210
让我给自己一个大小为 3 的 int scores 数组。

1077
01:17:06,210 --> 01:17:10,470
这样，score[0] 就会像以前一样，变成 72。

1078
01:17:10,470 --> 01:17:14,070
分数[1] 将为 73。

1079
01:17:14,070 --> 01:17:16,830
分数[2] 将为 33。

1080
01:17:16,830 --> 01:17:18,780
让我把那里的小点去掉。

1081
01:17:18,780 --> 01:17:23,490
好了，现在，如果我再运行一次，让分数 --

1083
01:17:24,642 --> 01:17:29,060
我做错了什么？

1084
01:17:29,060 --> 01:17:31,680
我想我有点太自以为是了。

1085
01:17:31,680 --> 01:17:36,100
让我增加终端窗口。

1086
01:17:36,100 --> 01:17:38,830
我们先来看看第 10 行。

1087
01:17:38,830 --> 01:17:42,310
错误，使用了未声明的标识符，score1。

1088
01:17:42,310 --> 01:17:44,170
我做了什么蠢事？

1090
01:17:45,430 --> 01:17:47,440
你没有把它声明为变量You didn't declare it a variable.

1091
01:17:47,440 --> 01:17:49,420
戴维-马兰：对，所以我没有宣布得分 1。

1092
01:17:49,420 --> 01:17:50,530
我有旧代码。

1093
01:17:50,530 --> 01:17:53,798
所以，老实说，我只是有点超前了，甚至不是故意的。

1094
01:17:53,798 --> 01:17:56,090
让我再缩小一下终端窗口。

1095
01:17:56,090 --> 01:17:57,740
我需要在这里结束我的想法。

1096
01:17:57,740 --> 01:17:58,960
所以，请允许我清理一下我的终端。

1097
01:17:58,960 --> 01:18:05,610
现在让我将其改为 scores[0] 加 scores[1] 加 scores[2]。

1098
01:18:05,610 --> 01:18:10,040
这样就比较啰嗦了，因为我有这些方括号，可以这么说。

1099
01:18:10,040 --> 01:18:12,220
但我认为现在我的代码是一致的。

1100
01:18:12,220 --> 01:18:13,870
所以，现在让我来记分。

1101
01:18:13,870 --> 01:18:14,950
现在可以编译了。

1102
01:18:14,950 --> 01:18:19,870
./scores 给我的确实是相同数值的大致平均值。

1103
01:18:19,870 --> 01:18:24,280
好吧，让我继续说下去，也许能让这个问题更有说服力一些。

1104
01:18:24,280 --> 01:18:31,610
为了检查 72、73、33 等三个考试成绩的平均值而编写一个专门的程序，这有点傻。

1105
01:18:31,610 --> 01:18:37,250
我为什么不把程序变成动态的，然后向人类询问这些分数呢？

1106
01:18:37,250 --> 01:18:39,140
所以，让我这样做吧。

1107
01:18:39,140 --> 01:18:43,480
不如把 72 去掉，改成 getInt。

1108
01:18:43,480 --> 01:18:46,300
我会提示用户打分。

1109
01:18:46,300 --> 01:18:52,510
让我摆脱 73 分的束缚，让它成为 getInt 分数，引号后加引号。

1110
01:18:52,510 --> 01:19:03,680
最后，去掉 33，取而代之的是 getInt、quote unquote、score。getInt 目前是 CS50 的东西，所以我需要一如既往地包含 cs50.h。

1111
01:19:03,680 --> 01:19:08,680
但我认为现在的程序更好，因为现在我只需编译一次，甚至还可以与朋友分享。

1112
01:19:08,680 --> 01:19:12,490
而现在，我们中的任何人都可以在某个班级的测试中取得三个分数的平均值。

1113
01:19:12,490 --> 01:19:16,910
他们不需要知道代码或重写代码就能输入分数。

1114
01:19:16,910 --> 01:19:19,150
所以，让分数发挥作用。

1115
01:19:19,150 --> 01:19:26,320
./scores，现在我可以输入任何我想输入的内容--也许是 72、73 或 33，但得到的答案还是一样的。

1116
01:19:26,320 --> 01:19:33,520
或者我这学期的成绩比较好，100、100，也许是 99，现在我们得到的分数还是很高的。

1117
01:19:33,520 --> 01:19:34,600
但现在它是动态的。

1118
01:19:34,600 --> 01:19:36,080
现在你不需要源代码了。

1119
01:19:36,080 --> 01:19:37,747
您无需重新编译程序。

1120
01:19:37,747 --> 01:19:39,670
就这样一次又一次地成功。

1121
01:19:39,670 --> 01:19:41,090
但这个也是。

1122
01:19:41,090 --> 01:19:45,910
如果我想从用户那里得到三个分数，那么我建议这段代码是正确的。

1123
01:19:45,910 --> 01:19:53,170
但现在突出显示的 6 到 9 行，你认为它们设计得好吗？

1125
01:19:53,680 --> 01:19:54,898
观众：你能循环播放吗？

1126
01:19:54,898 --> 01:19:55,940
是的，对吗？

1127
01:19:55,940 --> 01:19:58,220
我们可以使用一个循环，就是这里的破坏者。

1129
01:19:58,820 --> 01:20:01,590
我的意思是，我的上帝，这就像相同的代码一而再，再而三。

1130
01:20:01,590 --> 01:20:03,465
唯一变化的是数字。

1131
01:20:03,465 --> 01:20:11,810
而且这还应该有一些代码的味道，因为如果我反复输入同样的内容，这显然是一个更好设计的机会。

1132
01:20:11,810 --> 01:20:13,650
那就让我来吧。

1133
01:20:13,650 --> 01:20:18,590
让我继续创建大小为 3 的数组。

1134
01:20:18,590 --> 01:20:26,610
不过，让我使用我们的老朋友 for 循环，for int i 等于 0，i 小于 3，i++。

1135
01:20:26,610 --> 01:20:32,920
然后，在这里，让我做分数括号 - 我们还没有看到过这一点，但任何直觉？

1136
01:20:32,920 --> 01:20:34,220
分数

1137
01:20:34,220 --> 01:20:34,720
听众： i.

1138
01:20:34,720 --> 01:20:40,720
DAVID MALAN：i，因为这将使用任何 i，无论是 0、1 还是 2。

1139
01:20:40,720 --> 01:20:47,000
然后，我就可以得到一个 int，询问用户得分，而不必一再重复。

1140
01:20:47,000 --> 01:20:50,560
所以，如果我没打错字，打出分数，希望一切顺利。

1141
01:20:50,560 --> 01:20:54,665
./分数，72、73、33，我们又开始工作了。

1142
01:20:54,665 --> 01:21:04,940
但现在的代码可以说设计得更好了，因为现在我没有硬编码分数，也没有复制和粘贴任何代码。

1143
01:21:04,940 --> 01:21:10,510
那么，如果我们现在考虑一下电脑内存中的情况，就数值而言是差不多的。

1144
01:21:10,510 --> 01:21:17,210
但变量不是字面上的 score1、score2、score3，而是只有一个变量。

1145
01:21:17,210 --> 01:21:19,030
这是一个名为 scores 的数组。

1146
01:21:19,030 --> 01:21:28,810
但您可以通过使用 scores[0] 获得第一个位置，使用 scores[1] 获得第二个位置，使用 scores[2] 获得第三个位置，从而索引到这三个位置。

1147
01:21:28,810 --> 01:21:29,990
但这是关键。

1148
01:21:29,990 --> 01:21:33,040
内存是连续的。

1149
01:21:33,040 --> 01:21:35,380
屏幕只有这么大，所以它是环绕的。

1150
01:21:35,380 --> 01:21:40,270
但从物理上和数字上看，内存是连续的，从上到下，从左到右。

1151
01:21:40,270 --> 01:21:41,530
这很重要，为什么？

1152
01:21:41,530 --> 01:21:48,790
因为括号中分别表示 0、1、2，所以每一个整数与下一个整数之间只差一个整数。

1153
01:21:48,790 --> 01:21:51,220
它不可能突然就随机出现在这里。

1154
01:21:51,220 --> 01:21:54,070
必须背靠背。

1155
01:21:54,070 --> 01:22:00,710
好了，有了这个范例，我们还能做些什么呢？

1156
01:22:00,710 --> 01:22:06,850
事实证明，值得了解的是，在代码中甚至可以将数组作为参数传递。

1157
01:22:06,850 --> 01:22:11,320
让我快速地把这个程序调出来，以便你们在很久之前就能看到。

1158
01:22:11,320 --> 01:22:13,190
不过，还是让我来吧。

1159
01:22:13,190 --> 01:22:18,130
我建议创建一个函数，帮我完成这种平均处理。

1160
01:22:18,130 --> 01:22:22,510
因此，我要创建一个名为 average 的函数，返回一个浮点数。

1161
01:22:22,510 --> 01:22:28,640
而这东西的论据 -- 让我想想，应该是数组。

1162
01:22:28,640 --> 01:22:33,050
事实证明，如果你想接收一个数字数组，你可以随意称呼它。

1163
01:22:33,050 --> 01:22:39,790
这样就可以告诉 C 语言，函数使用的不是整数，而是整数数组。

1164
01:22:39,790 --> 01:22:41,290
你也不必把它叫做数组。

1165
01:22:41,290 --> 01:22:42,790
我这样做只是为了讨论。

1166
01:22:42,790 --> 01:22:43,660
它可以被称为 x。

1167
01:22:43,660 --> 01:22:44,490
可以是数字。

1168
01:22:44,490 --> 01:22:45,490
它可以是任何其他东西。

1169
01:22:45,490 --> 01:22:49,060
我只是在调用一个数组，以便更明确地知道它是什么。

1170
01:22:49,060 --> 01:22:51,730
现在，我该如何修改下面的代码？

1171
01:22:51,730 --> 01:22:55,130
我想我现在要做的就是这样。

1172
01:22:55,130 --> 01:22:59,110
我要去掉这里的代码，这里是我手动计算平均值的地方。

1173
01:22:59,110 --> 01:23:05,000
让我在这里通过传入整个分数数组来调用平均值函数。

1174
01:23:05,000 --> 01:23:08,890
因此，这只是一个抽象的例子，比如现在我有一个名为平均值的函数。

1175
01:23:08,890 --> 01:23:09,670
我不在乎

1176
01:23:09,670 --> 01:23:12,490
一旦实施，我就不需要记住它是如何工作的。

1177
01:23:12,490 --> 01:23:15,010
它只是稍微收紧了我的主代码。

1178
01:23:15,010 --> 01:23:17,030
不过，我还得落实这一点。

1179
01:23:17,030 --> 01:23:27,010
所以，在我的文件后面--让我再重复一遍，在 C 语言中，只有一次是可以反复重复的，那就是再次键入平均值，然后用 int 数组打开括号--

1180
01:23:27,010 --> 01:23:28,580
但现在不是分号。

1181
01:23:28,580 --> 01:23:30,250
现在，我必须实施这件事。

1182
01:23:30,250 --> 01:23:37,630
我可以用很多不同的方法来实现这个目标 但我事先并不知道

1183
01:23:37,630 --> 01:23:39,040
我不能就这么做

1184
01:23:39,040 --> 01:23:52,130
我不能只做 array[0] 加上 array[1] 再加上 array[2]，除非这个程序只能在三个数字上运行。

1185
01:23:52,130 --> 01:23:55,460
所以，让我来做这件事吧。

1186
01:23:55,460 --> 01:23:58,570
让我首先提出，这里的设计有问题。

1187
01:23:58,570 --> 01:24:01,930
在我的主函数中，什么值重复了两次？

1188
01:24:05,050 --> 01:24:07,550
在突出显示的句子中，有哪些句子让你印象深刻？

1189
01:24:07,550 --> 01:24:09,020
听众：阵列的长度？

1190
01:24:09,020 --> 01:24:11,520
戴维-马兰：是的，阵列的长度只有三个。

1191
01:24:11,520 --> 01:24:18,440
现在看来，我在第 8 行和第 9 行键入数字 3 并不是什么大问题，但这种类似快捷键的做法最终会给你带来麻烦。

1193
01:24:18,860 --> 01:24:26,270
因为最终，你或其他人会进去把数组变大或变小，而你不会意识到神奇的是，同一个数字被放在了两个地方。

1194
01:24:26,270 --> 01:24:29,270
事实上，这就是程序员通常所说的神奇数字。

1195
01:24:29,270 --> 01:24:31,940
神奇数字是一种神奇出现的数字。

1196
01:24:31,940 --> 01:24:36,688
如果你在这里改了，就在这里改，这是你的荣誉制度。

1197
01:24:36,688 --> 01:24:43,190
如果程序员有责任记住他们硬编码的地方，也就是明确写出了三处，那就不会有好结果。

1198
01:24:43,190 --> 01:24:46,250
所以，每次重复使用这样的值时，你知道吗？

1199
01:24:46,250 --> 01:24:56,990
我们也许应该像上周那样，声明一个变量，也许是在程序的最顶端，这样就能很明显地知道它是什么，叫做 n，然后设置它等于 3。

1200
01:24:56,990 --> 01:25:02,390
更好的是，我上周做了什么来确保我不会搞砸并意外更改该值？

1201
01:25:02,390 --> 01:25:03,440
是的，一直如此。

1202
01:25:03,440 --> 01:25:05,810
关键词是 const，简称 const。

1203
01:25:05,810 --> 01:25:11,870
现在我有了一个全局变量，全局变量的意思是我可以在任何地方访问它，它的名字叫 n。

1204
01:25:11,870 --> 01:25:12,680
这是一个 int.

1205
01:25:12,680 --> 01:25:14,450
而且永远都是 3。

1206
01:25:14,450 --> 01:25:23,870
现在，我只需将 3 改为 n，就能稍稍改进我的主函数，因此，如果我，如果有同事意识到，哦，等一下，今年有四次测试。

1207
01:25:23,870 --> 01:25:31,190
将 n 改为 4，重新编译代码后，除了我的平均函数外，其他地方都能正常工作。

1208
01:25:31,190 --> 01:25:33,830
为了统一起见，我把它改回 3。

1209
01:25:33,830 --> 01:25:43,610
现在这样做是行不通的，举例来说，如果只是求和，然后返回除以 3 的结果。

1210
01:25:43,610 --> 01:25:51,130
为什么按照我的定义，现在就不行了呢？

1213
01:25:58,030 --> 01:26:00,980
戴维-马兰：好吧，我可能会返回一个整数值，当

1214
01:26:00,980 --> 01:26:02,870
我打算就此返回一个浮点数。

1215
01:26:02,870 --> 01:26:11,010
但我觉得我没问题，因为我使用了那个小技巧，确保算术表达式中至少有一个数字实际上是浮点数值。

1216
01:26:11,010 --> 01:26:15,650
只需添加 0 点，就能确保所有内容都被视为浮点数。

1217
01:26:15,650 --> 01:26:17,864
所以，我觉得这没问题。

1219
01:26:19,034 --> 01:26:20,701
对不起，声音再大一点。

1220
01:26:20,701 --> 01:26:24,385
这看起来就像你[听不清]。

1221
01:26:24,385 --> 01:26:25,260
大卫-马兰：没错。

1222
01:26:25,260 --> 01:26:33,510
所以左手在这里并没有和右手对话，因为我目前实现的平均值仍然假设只有三次测试或其他。

1223
01:26:33,510 --> 01:26:39,480
但是，等一下，我刚刚费了好大劲才把它修改成 n。

1224
01:26:39,480 --> 01:26:46,690
如果我把它改为 4，也许我就不会对我的平均分感到满意了，因为现在我将完全忽略我的一个考试成绩。

1225
01:26:46,690 --> 01:26:48,450
所以，让我把它改回 3。

1226
01:26:48,450 --> 01:27:00,920
不幸的是，如果现在是一个变量 n，因此，我的分数数量是可变的，那么我如何求出可变数量的平均值呢？

1227
01:27:00,920 --> 01:27:02,630
我的意思是，我的构件是什么？

1230
01:27:10,100 --> 01:27:10,850
是的

1231
01:27:10,850 --> 01:27:14,880
我为什么不用一个循环来遍历数组，边遍历边累加？

1232
01:27:14,880 --> 01:27:19,730
我的意思是，就像小学一样，当你用计算器或纸和铅笔计算平均值时，你只是不断地把数字相加、

1233
01:27:19,730 --> 01:27:22,380
最后再除以总数。

1234
01:27:22,380 --> 01:27:23,520
那么，我该怎么做呢？

1235
01:27:23,520 --> 01:27:30,515
好吧，让我改变一下平均值的实现，首先声明一个名为 sum 的变量，或者其他什么变量，设置它等于 0。

1236
01:27:30,515 --> 01:27:36,590
因此，这就像我在纸上准备数数，或者我的计算器，当然，当你打开它时，通常默认为零。

1237
01:27:36,590 --> 01:27:46,730
现在，让我来做 for，int i 等于 0，i 小于 a -- 不，我没做那个。i 小于 n，i++。

1238
01:27:46,730 --> 01:27:55,910
现在，让我把数组位置 i 中的内容加到当前总和中。

1239
01:27:55,910 --> 01:28:04,560
然后在这里，我想我可以返回一些除以 3.0 -- 不是 3.0，是 n，也许在这里。

1240
01:28:04,560 --> 01:28:08,492
实际上，我想我要去 -- 让我们确保它是一个浮动。

1241
01:28:08,492 --> 01:28:15,540
让我们使用类型转换技巧，以确保我不会不小心亏待了某人，而把小数点后的所有内容都扔掉。

1242
01:28:15,540 --> 01:28:17,300
所以事情很快就升级了，对吗？

1243
01:28:17,300 --> 01:28:18,990
平均值变得更重要了。

1244
01:28:18,990 --> 01:28:22,130
这不仅仅是一行代码，现在它是动态的。

1245
01:28:22,130 --> 01:28:25,070
我将一个名为 sum 的变量初始化为 0。

1246
01:28:25,070 --> 01:28:36,740
在这个循环中，我会不断地将数组[i]中的任何内容加到 sum 中，初始值为 0，具体来说就是数组[0]、数组[1]、数组[2]。

1247
01:28:36,740 --> 01:28:40,970
这样就得出了我返回的总金额除以物品总数。

1248
01:28:40,970 --> 01:28:42,560
现在，我可以稍微收紧一点。

1249
01:28:42,560 --> 01:28:45,650
请注意，这是一种语法糖，用于添加内容。

1250
01:28:45,650 --> 01:28:48,620
我不能使用加号加号，因为这样只能增加一个。

1251
01:28:48,620 --> 01:28:52,630
但我可以在这里使用 "加等号"。

1252
01:28:52,630 --> 01:28:54,880
对此处的实施有疑问？

1253
01:28:54,880 --> 01:29:06,450
真正唯一的收获--或者说最重要的收获是，这是告诉函数它需要整个数组，而不是 int 或类似的单个变量的语法。

1254
01:29:06,450 --> 01:29:11,530
从字面上看，你使用了方括号，但没有在方括号内指定长度。

1256
01:29:12,748 --> 01:29:16,410
听众：顶部有什么变量？

1257
01:29:16,410 --> 01:29:18,410
大卫-马兰：顶部的变量呢？

1259
01:29:22,205 --> 01:29:23,330
大卫-马兰：问得好。

1260
01:29:23,330 --> 01:29:25,220
我在顶部将其定义为什么？

1261
01:29:25,220 --> 01:29:33,840
如果要在数组方括号内使用 N 变量，它必须是整数。

1262
01:29:33,840 --> 01:29:38,360
请注意，第 10 行不再是 3，而是 N。

1263
01:29:38,360 --> 01:29:43,970
因此，无论 N 是 3、4 还是其他什么，我都能在数组中得到多少个整数。

1264
01:29:43,970 --> 01:29:48,320
根据数组的定义，它必须是一个放在方括号中的整数。

1265
01:29:48,320 --> 01:29:50,000
这里有一个常见的困惑。

1266
01:29:50,000 --> 01:29:56,210
创建数组时，也就是声明数组时，要像这样使用方括号，在方括号中输入想要的元素总数。

1267
01:29:56,210 --> 01:30:04,610
当你随后使用数组时，就像我在这里做的一样，你不会再提到 int--就像你不会在变量存在后反复提到 int 一样。

1268
01:30:04,610 --> 01:30:11,990
仍然使用方括号，但不使用 N，而是使用 0 或 1 或 2，或者这里通用的 i。

1269
01:30:11,990 --> 01:30:17,060
因此，在设计 C 语言时，他们有时会使用相同的语法来表达两种不同的想法或语境。

1271
01:30:17,984 --> 01:30:22,645
你必须包括第6行吗？是否必须包括第 6 行？

1272
01:30:22,645 --> 01:30:23,770
大卫-马兰：问得好。

1273
01:30:23,770 --> 01:30:25,900
是否必须包括第 6 行？

1274
01:30:25,900 --> 01:30:29,290
简而言之，是的，因为我们上周遇到了这个问题。

1275
01:30:29,290 --> 01:30:32,750
C 或 clang 会从上到下、从左到右读取代码。

1276
01:30:32,750 --> 01:30:43,610
因此，如果编译器看到第 16 行提到了 average 这个函数，但你没有告诉编译器 average 存在，屏幕上就会出现错误。

1277
01:30:43,610 --> 01:30:51,260
因此，传统的方法是复制粘贴函数的第一行代码，即所谓的原型或声明。

1279
01:30:51,760 --> 01:30:55,662
听众：如果不知道数组的大小，有图书馆吗？

1280
01:30:55,662 --> 01:30:58,120
大卫-马兰：真是个好问题，也是个完美的切入点。

1281
01:30:58,120 --> 01:31:01,078
如果不知道数组的大小，有没有可以使用的库呢？

1283
01:31:01,720 --> 01:31:11,020
因此，如果你们用 Java、Python 或其他语言编程，实际上可以直接问数组：它有多大？

1284
01:31:11,020 --> 01:31:13,778
在 C 语言中，你和我，程序员，必须记住它。

1285
01:31:13,778 --> 01:31:17,445
简而言之，没有任何功能可以自动帮我们完成这项工作。

1286
01:31:17,445 --> 01:31:25,160
事实上，让我提出一个更微妙的主张：如果全局变量真的是用于配置选项，那么使用这样的全局变量是没有问题的。

1288
01:31:25,660 --> 01:31:32,440
把它们放在文件的最上面很方便，因为每个人、你、你的同事、你的助教都会在代码的最上面看到它们。

1289
01:31:32,440 --> 01:31:36,130
但您真的不应该在代码中到处使用它们。

1290
01:31:36,130 --> 01:31:40,610
如果平均函数本身与该特殊变量无关，那就更好了。

1291
01:31:40,610 --> 01:31:42,025
所以，我的意思是这样的。

1292
01:31:42,025 --> 01:31:46,240
你知道如果我真的想设计得好，我应该怎么做吗？

1293
01:31:46,240 --> 01:31:51,400
我应该把数组的长度传给 average 函数。

1294
01:31:51,400 --> 01:31:54,310
我应该给平均函数添加第二个参数--

1295
01:31:54,310 --> 01:31:57,800
比如，我把它叫做 "长度"，但我想怎么叫都行。

1296
01:31:57,800 --> 01:32:05,745
因此，与其在文件底部一直写 N，不如让我动态地写长度。

1297
01:32:05,745 --> 01:32:08,620
这是一个微妙之处--不必为此过于纠结。

1298
01:32:08,620 --> 01:32:13,690
但这只是一个例子，说明同一个函数可以接受两个参数。

1299
01:32:13,690 --> 01:32:19,900
但实际上，在 C 语言中，你必须自己记住数组的长度是多少。

1300
01:32:19,900 --> 01:32:26,560
你不能像那些用 Java 或 Python 编程的人一样，通过一些语法来询问数组。

1303
01:32:35,115 --> 01:32:36,240
大卫-马兰：问得好。

1304
01:32:36,240 --> 01:32:39,198
写一个计算大小的函数会不会设计得更好？

1305
01:32:39,198 --> 01:32:48,180
简而言之，在 C 语言中无法做到这一点。在 C 语言中，只要将数组传入函数，就无法计算出它的大小（如果它是一个通用数组，如整数数组）。

1306
01:32:48,180 --> 01:32:51,040
在一些特殊情况下，你可以这样做。

1307
01:32:51,040 --> 01:32:53,283
但一般来说，在 C 语言中是不可能实现的。

1308
01:32:53,283 --> 01:32:57,180
老实说，如果这让人感到沮丧，那么这就是为什么更多的现代语言会添加该功能的原因。

1310
01:32:57,680 --> 01:33:01,560
因为这真的很烦人，我在这里暗指的就是没有这些信息。

1311
01:33:01,560 --> 01:33:07,540
现在，为了确保我没有在任何地方出错，让我来整理一下这个最终版本的分数。

1313
01:33:08,620 --> 01:33:14,030
............分数，72，73，33，我们还在继续工作。

1314
01:33:14,030 --> 01:33:15,530
因此，这个版本更加复杂。

1315
01:33:15,530 --> 01:33:18,738
我们将一如既往地在课程网站上发布这一版本，以供参考。

1316
01:33:18,738 --> 01:33:30,440
但问题的关键在于，数组不仅可以用作存储多个值的容器，在本例中可以存储三个或更多的值，还可以将它们作为参数传递。

1317
01:33:30,440 --> 01:33:36,100
好了，除此之外，让我们暂时简化一下，考虑一下字符的世界。

1318
01:33:36,100 --> 01:33:39,200
如果我们只有单字节，这会导致什么结果？

1319
01:33:39,200 --> 01:33:44,170
那么，这最终又是如何让我们用字符串来解决可读性和密码学等问题的呢？

1320
01:33:44,170 --> 01:33:48,967
例如，这里有三行代码，脱离上下文，只是存储三个字符。

1321
01:33:48,967 --> 01:33:50,800
你已经可以看到事情的发展方向了。

1322
01:33:50,800 --> 01:33:57,470
显然，使用 c1、c2、c3 这三个变量最终会导致糟糕的设计，因为这里存在大量愚蠢的冗余。

1323
01:33:57,470 --> 01:34:01,330
但请注意，我和上周一样使用了单引号，因为这些都是单字符。

1324
01:34:01,330 --> 01:34:03,647
这在计算机内存中是什么样子的？

1325
01:34:03,647 --> 01:34:05,480
嗯，看起来有点像这样。

1326
01:34:05,480 --> 01:34:12,562
如果我们清除旧的内存，c1、c2、c3 可能会出现在这里，也许不是字面上的左上角。

1327
01:34:12,562 --> 01:34:14,020
这只是艺术家的描绘。

1328
01:34:14,020 --> 01:34:18,440
但 c1、c2、c3 的结局很可能就是这样。

1329
01:34:18,440 --> 01:34:20,020
现在，那里到底有什么？

1330
01:34:20,020 --> 01:34:21,730
其实就是这三个数字

1331
01:34:21,730 --> 01:34:23,350
72, 73, 33.

1332
01:34:23,350 --> 01:34:27,920
但一个字节有多少位？

1333
01:34:27,920 --> 01:34:28,880
只有八个。

1334
01:34:28,880 --> 01:34:35,330
因此，如果我们查看这些字符的二进制表示法，每个字符只有 8 位。

1335
01:34:35,330 --> 01:34:39,140
这足以存储 72、73、33 等小数字。

1336
01:34:39,140 --> 01:34:41,580
我们不是在处理 Unicode 和表情符号之类的问题。

1337
01:34:41,580 --> 01:34:42,837
但问题是一样的。

1338
01:34:42,837 --> 01:34:45,170
您不必使用四个字节来存储这些数字。

1339
01:34:45,170 --> 01:34:51,420
你可以使用不同的数据类型，如字符，而在引擎盖下，它确实会为每个数据使用单字节。

1340
01:34:51,420 --> 01:34:55,850
但这有点像 -- 这并不是我们实现字符串的真正方式，对吧？

1341
01:34:55,850 --> 01:34:59,270
当你想说 "嗨"、"上周 "或 "这个 "时，我们使用双引号。

1342
01:34:59,270 --> 01:35:02,900
我们把所有东西都写在一起，用一个变量，而不是三个，对吗？

1343
01:35:02,900 --> 01:35:06,260
当我输入 David 时，我没有 D-A-V-I-D 的变量。

1344
01:35:06,260 --> 01:35:09,750
我有一个名为 name 的变量，可以存储所有内容。

1345
01:35:09,750 --> 01:35:13,310
因此，在 C 语言中，我们一直在谈论字符串。

1346
01:35:13,310 --> 01:35:17,427
我们最终会发现，字符串并不一定像它们看起来那样。

1347
01:35:17,427 --> 01:35:22,070
但现在，字符串的关键在于它们的长度是可变的，不是吗？

1348
01:35:22,070 --> 01:35:28,250
它们可能是三个字符，Hi，也可能是五个字符，David，或者更小或更大。

1349
01:35:28,250 --> 01:35:33,110
那么，如果到最后我们所拥有的只是我的记忆，我们该如何实施字符串呢？

1350
01:35:33,110 --> 01:35:41,900
这里有一个创建、声明和定义名为 s 的字符串的示例。s 因为只是一个简单的字符串，所以用双引号引出未加引号的 HI！。

1351
01:35:41,900 --> 01:35:44,090
这在计算机内存中是什么样子的？

1352
01:35:44,090 --> 01:35:45,230
好吧，让我们再澄清一遍。

1353
01:35:45,230 --> 01:35:50,960
现在，因为技术上它只存储在一个变量 s 中，所以作为艺术家，我可以这样画它。

1354
01:35:50,960 --> 01:35:52,520
总共有三个字节

1355
01:35:52,520 --> 01:35:53,990
H-I 感叹号。

1356
01:35:53,990 --> 01:35:59,630
但没有 c1、c2、c3，整个过程都是 s。

1357
01:35:59,630 --> 01:36:06,990
但事实证明，有趣的是，字符串在引擎盖下面到底是什么？

1358
01:36:06,990 --> 01:36:12,090
如果记忆中的字符串是这样排列的，那么字符串又是什么呢？

1359
01:36:12,090 --> 01:36:13,190
听众：一个阵列。

1360
01:36:13,190 --> 01:36:15,830
戴维-马兰：从字面上看，这只是一系列角色。

1361
01:36:15,830 --> 01:36:18,590
上周，我们不需要了解数组就能使用字符串。

1362
01:36:18,590 --> 01:36:21,382
这也是训练车轮开始脱落的地方。

1363
01:36:21,382 --> 01:36:23,730
但字符串只是一个字符数组。

1364
01:36:23,730 --> 01:36:26,040
例如 H-I 感叹号。

1365
01:36:26,040 --> 01:36:38,150
因此，从技术上讲，一个名为 s 的数组或字符串实际上是一个名为 s 的变量，它允许你通过 s[0] 获取第一个字符，如果你想的话，可以通过 s[1] 或 s[2] 获取。

1366
01:36:38,150 --> 01:36:47,000
只需将 s 当作数组处理，就能获得单个字符，而在本例中，s 在外壳下确实是一个数组。

1367
01:36:47,000 --> 01:36:48,560
但有一个问题。

1368
01:36:48,560 --> 01:36:51,500
你怎么知道琴弦在哪里结束？

1369
01:36:51,500 --> 01:36:54,560
过去，当我在屏幕上画一些整数时、

1370
01:36:54,560 --> 01:36:57,080
我知道，我声称它们总是占用 4 个字节。

1371
01:36:57,080 --> 01:37:00,200
如果我画了一个长条，它总是占用 8 个字节。

1372
01:37:00,200 --> 01:37:03,530
如果我画了一个字符，它总是占用 1 个字节。

1373
01:37:03,530 --> 01:37:06,533
但一个字符串要占用多少字节呢？

1374
01:37:06,533 --> 01:37:08,450
是的，我的意思是，这是一个正确的答案。

1375
01:37:08,450 --> 01:37:10,490
在这种情况下，似乎是三个。

1376
01:37:10,490 --> 01:37:13,490
但如果是戴维，那就有五个角色了。

1377
01:37:13,490 --> 01:37:16,173
但是，我们该把数字 3 放在哪里呢？

1378
01:37:16,173 --> 01:37:17,840
你把数字 5 放在哪里，对吗？

1379
01:37:17,840 --> 01:37:20,190
这就是电脑中的全部内容。

1380
01:37:20,190 --> 01:37:23,430
这就是摆在我们面前的所有积木。

1381
01:37:23,430 --> 01:37:25,490
那么，我们怎样才能--这三个人去哪儿了？

1382
01:37:25,490 --> 01:37:26,540
那五个人去哪儿了？

1383
01:37:26,540 --> 01:37:29,420
事实证明，你可以用几种不同的方法来解决这个问题。

1384
01:37:29,420 --> 01:37:41,840
但人类多年前决定实现字符串的方式确实是一个数组，但他们在每个字符串数组的末尾都额外增加了一个字节，以明确所谓的哨兵值、

1385
01:37:41,840 --> 01:37:44,480
字符串到此为止。

1387
01:37:45,050 --> 01:37:54,590
这样，如果电脑内存中有两个字符串，比如 "HI "和 "bye"，你就知道其中一个字符串的感叹号和下一个字符串的字母 B 之间的分界线在哪里，对吗？

1388
01:37:54,590 --> 01:37:56,000
你需要某种分隔符。

1389
01:37:56,000 --> 01:38:00,110
所以，真正的秘密是这样的。

1390
01:38:00,110 --> 01:38:07,040
当你在内存中存储字符串时，当你输入字符串时--作为用户，如果你输入 3 个字符，它会使用

1391
01:38:07,040 --> 01:38:10,280
3 加 1 共等于 4 个字节。

1392
01:38:10,280 --> 01:38:14,130
如果输入 David，则总共要使用 5 加 1 等于 6 个字节。

1394
01:38:14,630 --> 01:38:20,210
因为 C 会自动在字符串末尾添加这个特殊的 0。

1395
01:38:20,210 --> 01:38:25,710
我用反斜杠 0 画它，是因为 0 作为字符就是这样表示的。

1396
01:38:25,710 --> 01:38:28,230
但这只是 0，我们很快就会看到。

1397
01:38:28,230 --> 01:38:36,197
因此，无论何时内存中出现字符串，它总是比程序员或人类输入的字符串多占用一个字节。

1398
01:38:36,197 --> 01:38:45,170
事实上，为了便于讨论，如果我们再次将其转换为整数，那么电脑内存中实际存储的内容将是 72、73、33 和 0。

1399
01:38:45,170 --> 01:38:54,530
由于 C 语言的发明过程，计算机很聪明，它知道当你打印出一个字符串时，它会打印出每个字符，直到看到 0、

1400
01:38:54,530 --> 01:38:56,150
然后就停止打印了。

1401
01:38:56,150 --> 01:38:58,470
特别是，printf 知道如何工作。

1402
01:38:58,470 --> 01:39:02,050
这就是 printf 知道何时停止打印的原因。

1403
01:39:02,050 --> 01:39:03,800
小数点并不那么有启发性。

1404
01:39:03,800 --> 01:39:05,940
我们一般会这样写人物。

1405
01:39:05,940 --> 01:39:09,350
同样，反斜杠 0 只是一种特殊符号。

1406
01:39:09,350 --> 01:39:13,190
这是程序员输入的内容，以明确您不是在说：HI！，0。

1407
01:39:13,190 --> 01:39:15,980
你说 "HI！"，然后就是特别的 "0"。

1408
01:39:15,980 --> 01:39:22,220
具体来说，就是用 8 个 0 位来表示字符串的结束。

1409
01:39:22,220 --> 01:39:26,330
从技术上讲，如果你想花哨一点，这个反斜杠零叫做 null、

1411
01:39:27,320 --> 01:39:30,320
事实证明，你以前见过这种情况，虽然我们没有说出来。

1412
01:39:30,320 --> 01:39:33,230
这是过去几周的 ASCII 图表。

1413
01:39:33,230 --> 01:39:39,080
如果我突出显示这一点，十进制数字 0 映射的是什么？

1414
01:39:39,080 --> 01:39:42,830
NUL，程序员用它来表示特殊的空字符。

1415
01:39:42,830 --> 01:39:46,550
全部为 0 位，表示字符串到此为止。

1416
01:39:46,550 --> 01:39:48,510
这一切都会自动为您完成。

1417
01:39:48,510 --> 01:39:53,420
您无需创建这些空字符或零。

1418
01:39:53,420 --> 01:40:00,030
那么，对迄今为止的实施情况还有什么问题吗？

1419
01:40:00,030 --> 01:40:01,820
有问题吗？

1421
01:40:02,320 --> 01:40:03,195
让我来吧

1422
01:40:03,195 --> 01:40:05,310
让我马上回到 VS 代码。

1423
01:40:05,310 --> 01:40:07,770
让我们用一些代码来证实这一点。

1424
01:40:07,770 --> 01:40:10,830
让我继续创建一个名为 hi.c 的小程序。

1425
01:40:10,830 --> 01:40:12,070
我们这样做如何？

1426
01:40:12,070 --> 01:40:14,550
让我加入 stdio.h。

1427
01:40:14,550 --> 01:40:18,670
让我一如既往地输入 int main void。

1428
01:40:18,670 --> 01:40:24,960
现在让我做一件简单但有点糟糕的事，但字符 c1 等于单引号中的引号 unquote、h。

1429
01:40:24,960 --> 01:40:28,590
字符 c2 等于单引号中的引号 I。

1430
01:40:28,590 --> 01:40:32,830
最后，字符 c3 等于感叹号，用单引号表示。

1431
01:40:32,830 --> 01:40:34,500
现在，让我把这个打印出来。

1432
01:40:34,500 --> 01:40:36,960
我不能使用 %s，因为它不是字符串。

1433
01:40:36,960 --> 01:40:40,290
这实际上是三个字符，因为这是我的设计决定。

1434
01:40:40,290 --> 01:40:41,430
但我可以这么做

1435
01:40:41,430 --> 01:40:48,600
%c、%c、%c，我们以前没见过，但 %s 是字符串，%i 是 int、

1436
01:40:48,600 --> 01:40:51,060
%c 确实是字符。

1437
01:40:51,060 --> 01:40:56,280
为了简洁起见，我在最后加了一个反斜杠 n，现在输入 c1、c2、c3。

1438
01:40:56,280 --> 01:41:00,430
因此，这就像是基于字符的字符串打印版本。

1439
01:41:00,430 --> 01:41:01,650
所以，让我来介绍一下 HI！

1440
01:41:01,650 --> 01:41:05,880
然后让我做 ./hi，看起来我使用了带有 %s 的 printf。

1441
01:41:05,880 --> 01:41:09,750
但我的做法是非常手工地打印出每个字符。

1442
01:41:09,750 --> 01:41:16,560
不过，现在最酷的是，一旦你知道了字符只是数字，字符串只是字符，你就可以四处探索了。

1443
01:41:16,560 --> 01:41:21,970
让我把这三个占位符都改成 %i。

1444
01:41:21,970 --> 01:41:23,860
这也完全没问题。

1445
01:41:23,860 --> 01:41:26,310
让我重播一下，打个招呼。

1446
01:41:26,310 --> 01:41:31,570
实际上，让我做一个改动，这样我们就能看到了。

1447
01:41:31,570 --> 01:41:40,350
让我加上空格，为了美观起见，让我输入 hi、./hi、回车，然后就像现在这样，你就能真正看到数字了、

1448
01:41:40,350 --> 01:41:44,085
事实上，我在第零周时声称的"''......

1449
01:41:44,085 --> 01:41:45,960
嗯，这可不是你做琴弦的方法。

1450
01:41:45,960 --> 01:41:50,790
如果用三个变量来表示三个字母的单词，用五个变量来表示五个字母的单词，那就太乏味了。

1451
01:41:50,790 --> 01:41:54,450
当然，我们从上周开始就一直在使用字符串，所以我们还是用字符串来代替吧。

1452
01:41:54,450 --> 01:41:59,370
字符串 s 等于引号未加引号，双引号 "HI!"

1453
01:41:59,370 --> 01:42:02,520
因为这个，不，是因为这些训练轮、

1454
01:42:02,520 --> 01:42:04,560
我需要加入 CS50 库。

1455
01:42:04,560 --> 01:42:06,580
不过，未来几周我们会再讨论这个问题。

1456
01:42:06,580 --> 01:42:10,530
但现在，我要继续创建一个名为 quote unquote 的字符串、

1458
01:42:11,580 --> 01:42:17,610
现在我要把它改成我熟悉的 %s，然后直接打印出 s 本身。

1459
01:42:17,610 --> 01:42:24,750
当然，这和上周的 ./hi 给我的结果是一样的，但现在我们要处理的当然是字符串。

1460
01:42:24,750 --> 01:42:27,610
但是，我们如何才能看得更远一些呢？

1461
01:42:27,610 --> 01:42:28,810
这样如何？

1462
01:42:28,810 --> 01:42:31,530
让我们进一步探索今天的原语。

1463
01:42:31,530 --> 01:42:39,000
尽管 s 是一个字符串，但从技术上讲，我可以通过执行 s[0]，用 %c 打印出它的第一个字符。

1464
01:42:39,000 --> 01:42:43,110
从技术上讲，我可以通过 s[1] 用 %c 打印出第二个字符。

1465
01:42:43,110 --> 01:42:47,820
我可以用 %c 打印出第三个字符，并打印出 s[2]。

1466
01:42:47,820 --> 01:42:52,770
因此，正如你所指出的，这只是从我现在对字符串是数组的理解中逻辑地推导出来的。

1467
01:42:52,770 --> 01:42:57,300
让我做 - -让我做喜，./喜。

1468
01:42:57,300 --> 01:43:00,760
视觉上没有变化，但我现在正在修修补补。

1469
01:43:00,760 --> 01:43:03,400
事实上，如果你真的很好奇，让我来做这件事。

1470
01:43:03,400 --> 01:43:08,250
让我把这些改回 i，改回 i -- 哎呀，改回 i。

1471
01:43:08,250 --> 01:43:14,490
让我再加上第四个，因为我现在真的很好奇，让我们看看 s[3] 中有什么。

1472
01:43:14,490 --> 01:43:16,020
这是第四个字节。

1473
01:43:16,020 --> 01:43:18,990
尽管字符串本身是 H-I、

1474
01:43:18,990 --> 01:43:21,840
我想我们可以证实整个无效的事情。

1475
01:43:21,840 --> 01:43:26,248
输入 hi、./hi、回车，就可以了。

1476
01:43:26,248 --> 01:43:29,580
如果你真的想在弦乐上大显身手，上周就可以这样做了。

1477
01:43:29,580 --> 01:43:33,060
但现在，它只是揭示了引擎盖下的情况。

1478
01:43:33,060 --> 01:43:36,480
那么，这些字符串是什么呢？

1481
01:43:41,293 --> 01:43:42,960
大卫-马兰：我们为什么需要支架？

1483
01:43:45,430 --> 01:43:47,180
大卫-马兰：为什么不需要支架？

1484
01:43:47,180 --> 01:43:47,780
问得好。

1485
01:43:47,780 --> 01:43:51,620
为什么第 6 行不需要括号？

1486
01:43:51,620 --> 01:43:53,300
因为 s 是一个字符串。

1487
01:43:53,300 --> 01:44:02,240
我们将在几周后看到，s 本质上是作为一个数组在引擎盖下实现的，但它会自动为你实现。

1488
01:44:02,240 --> 01:44:06,800
您可以将 s 仅作为变量名处理，而不去掉方括号。

1489
01:44:06,800 --> 01:44:13,730
在使用 int 数组或手动创建字符数组、双倍数组、浮点数组或其他数组时，需要使用方括号。

1490
01:44:13,730 --> 01:44:14,900
但琴弦很特别。

1492
01:44:15,440 --> 01:44:19,190
我的意思是，你写的每个程序似乎都在使用字符串和某种形式的文本。

1493
01:44:19,190 --> 01:44:21,930
我们是人类，我们喜欢文字，而不仅仅是数字之类的东西。

1494
01:44:21,930 --> 01:44:28,580
因此，在 C 语言和许多其他语言中，这种处理方式都有些特殊。

1495
01:44:28,580 --> 01:44:31,170
还有其他问题吗？

1497
01:44:31,670 --> 01:44:33,530
那么，让我们再加上一根弦。

1498
01:44:33,530 --> 01:44:38,660
因此，与其只说："你好！"，我们为什么不考虑推出一个同时说 "你好！"和 "再见！"的程序版本呢？

1499
01:44:38,660 --> 01:44:48,570
我现在认为，如果内存中有两个字符串，那么反斜杠 0 字符、空字符就会变得越来越重要，这样 C 语言就知道如何区分这两个字符串。

1500
01:44:48,570 --> 01:44:51,487
所以，让我先把这两行去掉吧。

1501
01:44:51,487 --> 01:44:55,430
让我重现字符串 s 的等号，引号不含双引号，"HI！"

1502
01:44:55,430 --> 01:44:56,780
让我再给自己来一次。

1503
01:44:56,780 --> 01:44:59,905
因为我只是随便玩玩，所以我会选择非常简短的变量名。

1504
01:44:59,905 --> 01:45:04,410
字符串 t 等于引号加引号，"再见！"

1505
01:45:04,410 --> 01:45:06,470
然后让我把它们都打印出来。

1506
01:45:06,470 --> 01:45:16,910
让我继续打印 %s、反斜杠 n、逗号 s，然后 printf %s 反斜杠 n，再打印 t。

1507
01:45:16,910 --> 01:45:19,970
因此，只需对这两个变量进行非常简单的演示。

1508
01:45:19,970 --> 01:45:26,090
输入 hi、./hi，当然会打印出两行，一行紧接着一行。

1509
01:45:26,090 --> 01:45:27,980
引擎盖下面究竟发生了什么？

1510
01:45:27,980 --> 01:45:29,510
好吧，让我们回到电脑内存。

1511
01:45:29,510 --> 01:45:32,160
HI！"，我想，我声称，情况会大致相同。

1512
01:45:32,160 --> 01:45:36,170
因此，我认为 s 位于左上方，后面是反斜杠 0。

1513
01:45:36,170 --> 01:45:40,035
现在这一点很重要，因为《再见！》很可能会在那里结束。

1514
01:45:40,035 --> 01:45:44,330
从视觉上看，我绘制的这个字节网格可以将其包裹起来，但它是连续的。

1515
01:45:44,330 --> 01:45:58,580
B-Y-E-！空，又名反斜线零，现在对 printf 很有帮助，因为通过这个特殊的空字符，printf 可以知道一个人从哪里开始，在哪里结束。

1516
01:45:58,580 --> 01:46:00,230
但我们现在也可以四处看看。

1517
01:46:00,230 --> 01:46:01,620
我还能在这里做什么？

1518
01:46:01,620 --> 01:46:02,840
这样如何？

1519
01:46:02,840 --> 01:46:15,410
我在这里输入我的代码，回到 VS 代码，让我继续说，好吧，如果我有两个这样的字符串，你知道，让我们把它们放到一个数组中。

1520
01:46:15,410 --> 01:46:20,520
让我们用数组中的数组的方式，在这里进行初创式的排序。

1521
01:46:20,520 --> 01:46:23,060
So string words[2].

1522
01:46:23,060 --> 01:46:25,100
所以，给我一个包含两个字符串的数组就是

1523
01:46:25,100 --> 01:46:28,100
虽然我们还没有使用字符串，但我在这里说的是代码。

1524
01:46:28,100 --> 01:46:29,270
我们只用 ints 做过。

1525
01:46:29,270 --> 01:46:30,770
现在让我来做这件事。

1526
01:46:30,770 --> 01:46:35,480
第一个单词又名 words[0] 和之前一样，等于 HI！

1527
01:46:35,480 --> 01:46:40,940
现在的话[1] 就等于引号不加引号的 "再见！"

1528
01:46:40,940 --> 01:46:48,650
现在我做了完全相同的事情，但同样，我只是避免在代码中出现 s、t、q、r 和所有这些不同的变量。

1529
01:46:48,650 --> 01:46:52,790
我现在只是把它们当作一个字符串数组。

1530
01:46:52,790 --> 01:46:54,750
如何更改下面的代码？

1531
01:46:54,750 --> 01:46:57,380
好吧，如果我想打印第一个单词，我会打印 words[0]。

1532
01:46:57,380 --> 01:46:59,900
如果我想打印第二个单词，我会打印 words[1]。

1533
01:46:59,900 --> 01:47:04,130
目前这不是一个有用的练习，因为我只是在让我的代码变得更复杂。

1534
01:47:04,130 --> 01:47:09,530
但同样，这也让我们可以四处打探，看看发生了什么，因为这里有 HI！和 BYE！。

1535
01:47:09,530 --> 01:47:10,700
但请注意

1536
01:47:10,700 --> 01:47:14,670
如果我真的想变酷，我可以做到这一点。

1537
01:47:14,670 --> 01:47:25,700
让我们打印出 %c、%c、%c、反斜杠 n，然后在这里打印出 %c、%c、%c、%c，这样就有四个了。

1538
01:47:25,700 --> 01:47:28,430
现在，事情变得有趣了。

1539
01:47:28,430 --> 01:47:30,620
Words 是一个字符串数组。

1540
01:47:30,620 --> 01:47:33,400
请允许我再问一次，什么是字符串？

1541
01:47:33,400 --> 01:47:35,060
字符数组。

1542
01:47:35,060 --> 01:47:36,790
所以，就用同样的逻辑吧。

1543
01:47:36,790 --> 01:47:41,110
如果 words 是字符串数组，则用 words[0] 取得第一个字符串。

1544
01:47:41,110 --> 01:47:44,530
如何获取第一个字符串中的第一个字符？

1545
01:47:44,530 --> 01:47:52,150
括号 0、words[0][1]，最后是 words[0][2]。

1546
01:47:52,150 --> 01:47:57,460
现在这里是 words[1]，但第一个字符就在这里。

1547
01:47:57,460 --> 01:48:00,400
单词[1]，第二个字符在这里。

1548
01:48:00,400 --> 01:48:04,720
Words[1]，第三个字符在这里--哎呀--第三个字符在这里。

1549
01:48:04,720 --> 01:48:07,898
第四个字符是 words[1]。

1550
01:48:07,898 --> 01:48:09,190
人们不是这样编程的。

1551
01:48:09,190 --> 01:48:10,840
这只是为了演示。

1552
01:48:10,840 --> 01:48:13,060
我的天哪，已经如此乏味和啰嗦了。

1553
01:48:13,060 --> 01:48:22,990
但是，如果我现在制作 hi、./hi，如果我忘记了 %s 的存在，我就需要手动重新制作 %s，只使用 %c。

1554
01:48:22,990 --> 01:48:25,900
但你确实可以用这种方法来操作数组。

1555
01:48:25,900 --> 01:48:32,200
但是，由于字符串是字符数组，因此也可以用这种方式操作字符串。

1556
01:48:32,200 --> 01:48:34,675
现在对这个语法还有疑问吗？

1557
01:48:37,210 --> 01:48:38,800
有问题吗？

1559
01:48:39,970 --> 01:48:45,830
好吧，让我们继续提议，解决其他几个我们可能没有的问题。

1560
01:48:45,830 --> 01:48:49,150
但首先，我们要快速了解一下引擎盖下面发生了什么。

1561
01:48:49,150 --> 01:49:00,880
如果这里又是我们在屏幕上离开的地方，HI！和 BYE！背靠背，这里就是我刚才处理这些东西的方式。S 括 0、1、2、3，然后是 T 0、1、2、3、4。

1562
01:49:00,880 --> 01:49:04,840
但实际上，一旦我把它们放入一个数组，画面就会变成这样。

1563
01:49:04,840 --> 01:49:07,030
Words[0] 是整个 HI!

1564
01:49:07,030 --> 01:49:08,680
Words[1] 是整个 BYE！。

1565
01:49:08,680 --> 01:49:20,710
但是，如果我真的深入其中，开始对这些字符串中的单个字符进行索引，我所使用的只是新的语法，以便在这里表示这些相同的值。

1566
01:49:20,710 --> 01:49:28,710
那么，在我们继续前进之前，对这些陈述有什么疑问？

1569
01:49:30,030 --> 01:49:33,390
听众：新的行字符不[听不清]吗？

1570
01:49:33,390 --> 01:49:36,030


1571
01:49:36,030 --> 01:49:38,597
听众：新行字符是否占用空间？

1572
01:49:38,597 --> 01:49:40,180
大卫-马兰：啊，真是个好问题。

1573
01:49:40,180 --> 01:49:42,730
新行字符是否占用空间？

1574
01:49:42,730 --> 01:49:45,340
就 printf 而言，确实如此。

1575
01:49:45,340 --> 01:49:53,460
但我并没有在字符串中存储反斜线 n，而是由 printf 手动将其交给我。

1576
01:49:53,460 --> 01:50:00,680
好吧，那么让我们继续考虑如何解决这些字符串现在出现的一些问题，如下所示。

1577
01:50:00,680 --> 01:50:02,760
假设我... 我们开始吧

1578
01:50:02,760 --> 01:50:04,400
让我回到《VS 代码》这里。

1579
01:50:04,400 --> 01:50:09,980
让我继续打开一个名为 length.c 的新文件。

1580
01:50:09,980 --> 01:50:16,130
让我们先考虑一下，我如何才能算出字符串的长度，这与数组的长度是不同的。

1581
01:50:16,130 --> 01:50:20,180
我之前说过，你无法动态计算数组的长度。

1582
01:50:20,180 --> 01:50:26,960
但我能计算出字符串的长度，特别是因为这个空字符的实现细节。

1583
01:50:26,960 --> 01:50:28,500
所以，让我来做这件事吧。

1584
01:50:28,500 --> 01:50:31,940
让我在第二个程序中加入 cs50.h。

1585
01:50:31,940 --> 01:50:35,090
和之前一样，让我加入 stdio.h。

1586
01:50:35,090 --> 01:50:40,970
让我这样做， int main void -- 我要做的第一件事就是从用户那里获取一个字符串。

1587
01:50:40,970 --> 01:50:43,250
我会一如既往地询问用户的姓名。

1588
01:50:43,250 --> 01:50:48,170
因此，我会调用 getString，然后说，你叫什么名字，问号，一如既往。

1589
01:50:48,170 --> 01:50:58,465
然后，如果我想计算出这个字符串的长度，并在屏幕上打印出来，那么我就可以用类似平均值的方法来计算、

1590
01:50:58,465 --> 01:50:59,840
在那里我积累了一些东西。

1591
01:50:59,840 --> 01:51:02,600
让我把 N 初始化为 0。

1592
01:51:02,600 --> 01:51:07,035
让我给自己 - 这不是一个循环，因为我没有 -

1593
01:51:07,035 --> 01:51:08,660
我事先不知道时间有多长。

1594
01:51:08,660 --> 01:51:09,980
但如果我这样做呢？

1595
01:51:09,980 --> 01:51:25,590
虽然 name[n] 的值不等于'/0'--目前的语法很疯狂，但它只是这些不同构件的顶点。

1596
01:51:25,590 --> 01:51:28,970
让我在这里把想法说完，n++。

1597
01:51:28,970 --> 01:51:43,220
然后，在下面用 printf 和 %i 打印出 N 的值。我声称这将显示我输入的任何字符串的长度，无论是 hi、bye 还是 David 或其他任何字符串。

1598
01:51:43,220 --> 01:51:47,535
我将一个变量初始化为零，这很好，因为一般来说，你就是从这里开始计数的。

1599
01:51:47,535 --> 01:51:50,990
而 name[0] 不等于反斜杠 0。

1600
01:51:50,990 --> 01:51:51,930
这是什么意思？

1601
01:51:51,930 --> 01:51:59,390
如果 name 是用户输入的字符串，而 name 又是一个数组，那么 name[0] 将是第一个字符。

1602
01:51:59,390 --> 01:52:03,680
我想问的是，第一个字符不等于反斜杠 0 吗？

1603
01:52:03,680 --> 01:52:08,750
如果我输入大卫，D，就不是了，所以我继续输入，然后在 N 后面加 1。

1604
01:52:08,750 --> 01:52:10,750
然后我要检查 name[1]。

1605
01:52:10,750 --> 01:52:13,895
那么，如果我输入 David，name[1] 就会是 A。

1606
01:52:13,895 --> 01:52:18,740
A 不等于反斜杠 0，因此会反复出现。

1607
01:52:18,740 --> 01:52:23,090
但总共五步之后，它就会到达字节。

1608
01:52:23,090 --> 01:52:26,480
D-A-V-I-D，等一下，那是反斜杠 N。

1609
01:52:26,480 --> 01:52:29,750
循环结束，我打印出总长度。

1610
01:52:29,750 --> 01:52:33,050
一般来说，数组没有空字符。

1611
01:52:33,050 --> 01:52:34,910
然而，字符串确实如此。

1612
01:52:34,910 --> 01:52:39,590
再说一遍，字符串相对于我们迄今为止讨论过的所有其他数据类型都很特殊。

1613
01:52:39,590 --> 01:52:43,220
但是，比如说，我怎样才能以不同的方式做到这一点呢？

1614
01:52:43,220 --> 01:52:47,220
那么，让我们按照我通常的做法，把它作为一个函数来计算。

1615
01:52:47,220 --> 01:52:50,540
但与其自己实施，你知道吗？

1616
01:52:50,540 --> 01:52:57,260
事实证明，字符串如此常见的好处是，有很多其他人以前也解决过这些问题。

1617
01:52:57,260 --> 01:53:00,290
事实上，在 C 语言中有一个完整的字符串库。

1618
01:53:00,290 --> 01:53:04,190
它是通过一个名为 string.h 的头文件来使用的。

1619
01:53:04,190 --> 01:53:08,400
string.h 是一个字符串相关函数库。

1620
01:53:08,400 --> 01:53:18,050
事实上，你可以在 CS50 的 C 语言手册页面中看到 string.h 函数，至少是我们推荐的那些最有用的函数，特别是，如果你在那里搜索的话、

1621
01:53:18,050 --> 01:53:20,290
你会发现有一个叫做 strlen 的函数。

1622
01:53:20,290 --> 01:53:22,055
表示字符串长度。

1623
01:53:22,055 --> 01:53:25,850
命名非常简洁，只是因为它比字符串长度更容易输入。

1624
01:53:25,850 --> 01:53:28,800
但 strlen 会告诉你字符串的长度。

1625
01:53:28,800 --> 01:53:30,990
那么，如何在我的代码中使用它呢？

1626
01:53:30,990 --> 01:53:34,020
事实证明，我可以简化很多。

1627
01:53:34,020 --> 01:53:45,630
让我去掉循环，去掉手工记账，然后这样做-- int n 等于人类名称 name 的 strlen。

1628
01:53:45,630 --> 01:53:51,290
现在，我将像以前一样使用 printf，使用 %i 反斜线 n，并输出 n 的值。

1629
01:53:51,290 --> 01:53:54,380
但目前有一个漏洞。

1630
01:53:54,380 --> 01:53:58,480
我忘记做什么了？

1631
01:53:58,480 --> 01:54:03,260
是的，我必须在屏幕顶部加入头文件，所以让我 -- 在代码的顶部。

1632
01:54:03,260 --> 01:54:10,970
因此，让我在文件顶部包含 string.h，这样 C 就会知道 strlen 确实存在。

1633
01:54:10,970 --> 01:54:14,170
请允许我像以前一样，把长度加长。

1634
01:54:14,170 --> 01:54:18,670
................长度--或者，实际上，真的是第一次，你叫什么名字？

1635
01:54:18,670 --> 01:54:22,360
D -A -V希望我能看到，事实上，5。

1636
01:54:22,360 --> 01:54:26,950
相比之下，如果我再次运行它并输入 HI！，现在我看到了三个。

1637
01:54:26,950 --> 01:54:29,785
因此，strlen 只是该函数库中的一个函数。

1638
01:54:29,785 --> 01:54:30,910
还有很多很多。

1639
01:54:30,910 --> 01:54:40,580
事实上，还有一个库在未来可能会很有用，那就是 ctype 库，它与 C 数据类型有关，其中有很多有用的函数。

1640
01:54:40,580 --> 01:54:49,460
例如，如果您查看在线手册页面中的文档，就会发现我们可以通过一些功能来解决类似问题。

1641
01:54:49,460 --> 01:54:53,680
让我在这里提议 -- 让我看看。

1642
01:54:53,680 --> 01:55:06,700
让我们举个例子--如何检查某些内容是大写还是小写，并将其转换为大写。

1643
01:55:06,700 --> 01:55:10,810
让我回到 VS 代码，编写一个名为 uppercase.c 的程序。

1644
01:55:10,810 --> 01:55:15,220
在这个文件中，我将一如既往地首先包含 cs50.h。

1645
01:55:15,220 --> 01:55:17,710
我将包含 stdio.h。

1646
01:55:17,710 --> 01:55:26,230
我现在还要添加一个 string.h，这样我就可以根据需要访问事物的长度了。

1647
01:55:26,230 --> 01:55:28,570
接下来是 Int main void。

1648
01:55:28,570 --> 01:55:32,230
然后在我的主函数中，我要继续声明一个名为 s 的字符串。

1649
01:55:32,230 --> 01:55:34,240
我要像以前一样调用 getString。

1650
01:55:34,240 --> 01:55:38,170
我将继续询问用户之前调用的字符串。

1651
01:55:38,170 --> 01:55:39,670
我想做一个前后对比。

1652
01:55:39,670 --> 01:55:41,350
用户输入的内容都在前面。

1653
01:55:41,350 --> 01:55:44,770
但此后，我想把所有东西都强制改为大写。

1654
01:55:44,770 --> 01:55:48,740
现在，让我在这个循环中这样做。

1655
01:55:48,740 --> 01:55:53,800
让我打印出 "之后"，这样我们就能在屏幕上看到了。

1656
01:55:53,800 --> 01:56:02,440
让我来做四个 int i 得到 0，i 小于 s 的 strlen，i++。

1657
01:56:02,440 --> 01:56:03,610
我要做什么？

1658
01:56:03,610 --> 01:56:11,230
我要从左到右遍历字符串中的每个字符，从 0 开始，直到 s 的长度。

1659
01:56:11,230 --> 01:56:16,990
如何检查某些内容是否是小写，以便将其强制改为大写？

1660
01:56:16,990 --> 01:56:19,630
事实证明，我真的可以做到这一点。

1661
01:56:19,630 --> 01:56:31,780
如果 s 中位于 i 处的字符大于或等于大写字母 A，则为 "and"、"amppersand"，即 "and"，而不是我们看到的 "or"。

1662
01:56:31,780 --> 01:56:41,800
在过去，s[i] 小于或等于 little z，这在英语逻辑上意味着这确实是小写字母。

1663
01:56:41,800 --> 01:56:44,830
现在如何将这个字符转换成大写字母？

1664
01:56:44,830 --> 01:56:48,160
好吧，我可以直接打印出相同的字符。

1665
01:56:48,160 --> 01:56:52,280
但这并不是答案，因为这并没有改变价值。

1666
01:56:52,280 --> 01:56:54,470
但我能做什么呢？

1667
01:56:54,470 --> 01:57:03,220
好吧，让我在这里快速调出之前的 ASCII 图表，看看我们是否能从中获得一些启示。

1668
01:57:03,220 --> 01:57:09,790
如果我调出同样的 ASCII 图表，假设人类输入的是小写 a，那就是 97。

1669
01:57:09,790 --> 01:57:13,240
什么字母--我想把它转换成大写字母

1670
01:57:13,240 --> 01:57:18,660
A，那么我想把 97 转换成什么数字，每周 0？

1671
01:57:18,660 --> 01:57:21,000
所以 65，我们一直在回想这个问题。

1672
01:57:21,000 --> 01:57:23,010
如果用户输入的是小写 b 呢？

1673
01:57:23,010 --> 01:57:27,550
我想把 98 的值改为 66，以此类推。

1674
01:57:27,550 --> 01:57:30,130
快速计算一下，它们之间相距多远？

1675
01:57:30,130 --> 01:57:37,990
因此，从大写字母到小写字母总是相差 32 个，就像大写字母到小写字母总是相差 32 个一样，奇妙的设计。

1676
01:57:37,990 --> 01:57:39,100
这意味着什么？

1677
01:57:39,100 --> 01:57:42,600
嗯，我想我们之前已经看到，在引擎盖下面，字符只是一个数字。

1678
01:57:42,600 --> 01:57:44,340
你当然可以用它来做算术题。

1679
01:57:44,340 --> 01:57:48,180
同样，如果你理解了这些低级基元，如果我这样做呢？

1680
01:57:48,180 --> 01:57:57,048
无论 s[i] 是什么，如果我在第 13 行知道它是小写，我是要加上还是减去 32 呢？

1681
01:57:57,048 --> 01:57:57,840
听众：减去

1682
01:57:57,840 --> 01:58:06,560
戴维-马兰：所以我想做减法，因为我想从 97 减到 65，或者从 98 减到 66。

1683
01:58:06,560 --> 01:58:16,370
因此，只需将字符视为数字，减去 32，然后用 %c 打印即可，我认为这样就能将小写转换为大写。

1684
01:58:16,370 --> 01:58:24,980
如果你现在快进到现实世界，Microsoft Word 或 Google Docs，如果你曾经选择过菜单选项，偶尔会强制将东西变成大写或小写，从字面上看，那就是

1685
01:58:24,980 --> 01:58:26,480
微软和谷歌所做的一切。

1686
01:58:26,480 --> 01:58:33,810
它们会遍历文档中的每个字符，检查其是否小写，如果是，就会从中减去 32，然后向你显示新值。

1687
01:58:33,810 --> 01:58:36,650
如果不是小写字母呢？

1688
01:58:36,650 --> 01:58:46,490
如果我的目标只是强制全部大写，我想我可以简单一点，只打印出当前的字母，而这个字母就是 s[i]。

1689
01:58:46,490 --> 01:58:50,750
所以，让我现在继续大写，希望不会出错。

1690
01:58:50,750 --> 01:58:57,120
./uppercase，现在我会用大写字母 D 键入 David，但其他内容都要小写。

1691
01:58:57,120 --> 01:59:01,190
但现在的版本是 DAVID--一个美学错误。

1692
01:59:01,190 --> 01:59:05,930
请注意，为了美观起见，我忘了在末尾加上反斜杠 n。

1693
01:59:05,930 --> 01:59:07,640
没问题，我会加进去的。

1694
01:59:07,640 --> 01:59:08,870
让我来弥补我的错误。

1695
01:59:08,870 --> 01:59:12,050
大写，./uppercase，回车。

1696
01:59:12,050 --> 01:59:14,240
D-A-V-I-D，回车，就可以了。

1697
01:59:14,240 --> 01:59:22,070
我还特意在后面又加了一个空格，尽管前后的字母数不同，但这样排列起来会更美观。

1698
01:59:22,070 --> 01:59:28,380
那么，关于将某些内容强制为大写的问题，这本身并没有什么启发性、

1699
01:59:28,380 --> 01:59:33,990
但现在却代表了如何利用这些低级基元的方法。

1702
01:59:36,380 --> 01:59:38,633
好吧，老实说，这太乏味了。

1703
01:59:38,633 --> 01:59:43,550
我的天啊，微软、谷歌、每个人都要写这么多代码才能完成这么简单的事情吗？

1704
01:59:43,550 --> 01:59:46,310
不，这就是为什么我们有图书馆这样的东西。

1705
01:59:46,310 --> 01:59:55,940
现在，越来越多的问题集、项目以及其他方面，你都会更多地使用现成的库，以便解决别人在你之前已经遇到过的问题。

1706
01:59:55,940 --> 01:59:59,570
那么，我现在如何使用这个库 ctype.h？

1707
01:59:59,570 --> 02:00:01,320
好吧，让我回到我的代码中去。

1708
02:00:01,320 --> 02:00:05,090
让我在这里把它加入我的头文件中。

1709
02:00:05,090 --> 02:00:08,030
为了方便浏览，我倾向于按字母顺序排列标题。

1710
02:00:08,030 --> 02:00:13,400
但严格来说，这并不是必须的，但它能让我一目了然地意识到，我是否包含了我需要的东西？

1711
02:00:13,400 --> 02:00:15,570
现在，让我来做这件事。

1712
02:00:15,570 --> 02:00:28,910
原来，如果你阅读 C 类型库的文档，会发现有一个函数，奇妙地叫做 if islower，它的参数是一个字符，本质上就是 s[i]。

1713
02:00:28,910 --> 02:00:33,890
如果返回值为 true（一个布尔值），我将强制它小写。

1714
02:00:33,890 --> 02:00:36,560
但我不用再做这样的计算了。

1715
02:00:36,560 --> 02:00:45,060
原来，在 C 类型库中，也有一个调用 upper 的函数，它将一个字符作为输入，如 s[i]，然后它就会帮你计算。

1716
02:00:45,060 --> 02:00:50,400
这样，你就可以抽象出 32 件事，只知道别人已经为你解决了这个问题。

1717
02:00:50,400 --> 02:00:55,200
否则，我可以保持下面的代码不变，因为我不会更改任何其他内容。

1718
02:00:55,200 --> 02:01:03,710
因此，如果我现在将大写字母改为./uppercase，D-a-v-i-d，只用大写字母 D，现在它仍然可以工作。

1719
02:01:03,710 --> 02:01:07,520
但如果你进一步阅读文档，就会发现 "upper"（上）才是明智之举。

1720
02:01:07,520 --> 02:01:13,040
如果你输入的字符是小写的大写字母，它显然会通过数学运算将其转换为大写字母。

1721
02:01:13,040 --> 02:01:21,540
但是，如果你传入一个已经是大写的字符到 upper，你看到的文档会告诉你，它会保持不变。

1722
02:01:21,540 --> 02:01:23,910
这样我就能把这些都收紧。

1723
02:01:23,910 --> 02:01:25,880
我可以摆脱整个其他。

1724
02:01:25,880 --> 02:01:33,620
现在，我可以摆脱整个程序，实施一个同样正确但设计更好的程序。

1726
02:01:34,250 --> 02:01:39,740
代码行数更少，更容易阅读，出错概率更低，前提是库是正确的。

1727
02:01:39,740 --> 02:01:43,160
现在，它能让我更轻松、更快速地编写代码。

1728
02:01:43,160 --> 02:01:50,190
所以，如果我现在再做最后一次，输入大写字母，回车，./uppercase，然后输入我的名字，仍然有效。

1729
02:01:50,190 --> 02:01:57,740
但现在请注意，我们已经将代码行数减少了很多，尽管现在使用了这个额外的库。

1730
02:01:57,740 --> 02:02:00,140
有问题吗？

1731
02:02:03,930 --> 02:02:09,120
我敢说，尽管这段代码是正确的，但还不一定是精心设计的。

1732
02:02:09,120 --> 02:02:17,900
事实上，在当前的实现中，有一行代码、一个函数调用的效率比它需要的还要低。

1733
02:02:17,900 --> 02:02:24,320
请大家注意这里的第 10 行，我们正在调用 strlen。

1734
02:02:24,320 --> 02:02:29,000
但我们是在 for 循环中调用它，特别是在条件中。

1735
02:02:29,000 --> 02:02:33,720
为什么这不一定是最好的主意呢？

1736
02:02:33,720 --> 02:02:36,810
那么，字符串的长度是否一直在变化？

1737
02:02:36,810 --> 02:02:38,950
我的意思是，肯定不是在这个循环的范围内。

1738
02:02:38,950 --> 02:02:45,242
因此，我们在第 10、11、12 和 13 行的 for 循环中，每次迭代都会问同一个问题。

1739
02:02:45,242 --> 02:02:48,330
s 的长度是多少？

1740
02:02:48,330 --> 02:02:52,660
反过来，我们每次都要调用 strlen，尽管得到的答案是一样的。

1741
02:02:52,660 --> 02:02:59,490
因此，我敢说，更好的解决办法是在代码的前面找出 s 的长度，然后声明一个变量。

1742
02:02:59,490 --> 02:03:07,860
或者，也可以做一些语法上更优雅的事情，事实上，在这样的循环中，一个非常常见的设计是，不只声明一个像 i 这样的变量、

1743
02:03:07,860 --> 02:03:16,530
但实际上，如果要声明第二个变量 n，例如 n 只是一个数字，则应将 n 设置为等于 s 的长度。

1744
02:03:16,530 --> 02:03:24,540
但此后，在这个条件中，我不再一次又一次地调用 s 的 strlen，而是该怎么做呢？

1745
02:03:24,540 --> 02:03:32,730
我可以直接将 i 与 n 本身进行比较，因为现在 n 只会在初始化时计算一次，就像 i 初始化为零一样。

1746
02:03:32,730 --> 02:03:37,350
此后，我们将把正在变化的 i 与不会变化的 n 进行比较。

1747
02:03:37,350 --> 02:03:40,330
因此，从设计上讲，它的效率会略有提高。

1748
02:03:40,330 --> 02:03:47,100
尽管如此，一个好的编译器也能识别出这种优化的可能性，并为我们做到这一点。

1749
02:03:47,100 --> 02:03:54,010
但现在，最好还是养成习惯，培养肌肉记忆，以便自己做出更好的设计决定。

1750
02:03:54,010 --> 02:03:56,380
那么，我们是如何做到这一点的呢？

1752
02:03:59,650 --> 02:04:03,050
好了，今天的最后几项内容。

1753
02:04:03,050 --> 02:04:13,090
因此，我们首先讨论了 clang 使用的命令行参数，即在提示符下键入的命令后的任何内容，无论是 make

1754
02:04:13,090 --> 02:04:21,350
或 clang，甚至 Linux 中的 CD，其后的任何单词，或像 -o 这样的隐晦词都是命令行参数。

1755
02:04:21,350 --> 02:04:22,840
这是命令的输入。

1756
02:04:22,840 --> 02:04:27,280
它不同于函数参数，因为函数参数当然是函数的输入。

1757
02:04:27,280 --> 02:04:28,345
但想法是一样的。

1758
02:04:28,345 --> 02:04:30,970
只是提示符后的语法不同而已。

1759
02:04:30,970 --> 02:04:41,800
原来，命令行参数可以通过访问提示符后的单词在自己的程序中使用。

1760
02:04:41,800 --> 02:04:45,410
请允许我提议，我们可以这样来发明它。

1761
02:04:45,410 --> 02:04:53,560
我建议我们切换回 VS 代码，然后在这里打开一个名为 greet.c 的新文件。

1762
02:04:53,560 --> 02:04:57,070
因此，在 greet.c 中，它将是一个非常简单地问候用户的程序。

1763
02:04:57,070 --> 02:04:59,440
如果我们上周写这篇文章，我们就会这样做。

1764
02:04:59,440 --> 02:05:15,980
包括 cs50.h，然后包括 stdio.h，然后 int main void，然后我们可能会做一些简单的事情，比如字符串 name 等于 getString，引号 unquote，"你叫什么名字？"

1765
02:05:15,980 --> 02:05:21,490
然后，我们会一如既往地打印出 "Hello, %s"，然后输入该名称。

1766
02:05:21,490 --> 02:05:29,140
所以，这是我们已经实施过多次的相同程序，只是为了确保它能正常运行--不过，不对，这不是完全相同的程序。

1767
02:05:29,140 --> 02:05:30,940
分号的位置不对。

1768
02:05:30,940 --> 02:05:32,960
现在是同一个程序。

1769
02:05:32,960 --> 02:05:37,610
因此，请输入问候语，点 ./问候语，我会输入自己的名字。你好，戴维。

1770
02:05:37,610 --> 02:05:38,770
所以我们又回到了那里。

1771
02:05:38,770 --> 02:05:44,110
现在，可以说这个程序有点恼人的是，如果我输入其他内容，比如卡特、

1772
02:05:44,110 --> 02:05:48,910
回车，我必须运行程序，等待提示，输入我的名字，按回车键。

1773
02:05:48,910 --> 02:05:52,360
这很好，但想象一下，如果每个程序都是这样运行的。

1774
02:05:52,360 --> 02:05:58,540
比如 make，假设你只能键入 make，然后等待提示，接着键入要制作的程序名称，然后按 Enter。

1775
02:05:58,540 --> 02:06:07,930
更糟糕的是，在 Linux 中，当你需要更改目录时，比如要解决一个问题时，如果你必须键入 CD、回车，然后键入要更改的文件夹名称、回车----

1776
02:06:07,930 --> 02:06:09,710
我的意思是，这只会让生活变慢。

1777
02:06:09,710 --> 02:06:11,470
所以很快就会让人厌烦。

1778
02:06:11,470 --> 02:06:16,070
因此，命令行参数可以让你一次性表达你的全部想法。

1779
02:06:16,070 --> 02:06:18,200
那么，我该怎么做呢？

1780
02:06:18,200 --> 02:06:22,450
好吧，如果我想在代码中表达命令行参数的概念、

1781
02:06:22,450 --> 02:06:25,640
我可以这样做

1782
02:06:25,640 --> 02:06:34,780
这是我第一次可以上天入地，摆脱这种无效状态，也就是从今天开始，这个程序不需要命令行参数了。

1783
02:06:34,780 --> 02:06:37,540
我可以把它改成这样。

1784
02:06:37,540 --> 02:06:43,490
Int argc，字符串 argv，带括号。

1785
02:06:43,490 --> 02:06:44,950
诚然，现在它很隐晦。

1786
02:06:44,950 --> 02:06:46,150
让我放大画面。

1787
02:06:46,150 --> 02:06:49,300
但我认为，我们现在或许可以推断出发生了什么。

1788
02:06:49,300 --> 02:06:59,230
如果现在的 main 没有 void 作为输入，这意味着它不需要参数，当然，这里的剧透是，现在的 main 将以某种方式获取命令行参数。

1789
02:06:59,230 --> 02:07:05,180
猜猜 argv 现在是什么样子，将来会是什么样子？

1790
02:07:05,180 --> 02:07:08,330
这可能代表什么？

1791
02:07:08,330 --> 02:07:11,390
根据语法，这是一个字符串数组。

1793
02:07:13,223 --> 02:07:15,480
观众：所有的字符都会打出来。

1794
02:07:15,480 --> 02:07:16,050
大卫-马兰：没错。

1795
02:07:16,050 --> 02:07:19,830
这将是您在提示符下输入的所有字符，或者说所有单词。

1796
02:07:19,830 --> 02:07:21,765
Argc，作为一个 int，猜猜看？

1797
02:07:24,360 --> 02:07:30,290
一般来说，"论据数 "代表的是 "论证次数"，不过从技术上讲，你可以把这些东西叫做任何东西。

1798
02:07:30,290 --> 02:07:31,520
但这就是惯例。

1799
02:07:31,520 --> 02:07:41,420
因为我之前说过数组不会记录自己的长度，所以如果你想知道人类在你的程序名称后面的提示符下输入了多少个字，你必须被告知、

1800
02:07:41,420 --> 02:07:45,650
不仅是单词数组，还有数组的长度。

1801
02:07:45,650 --> 02:07:55,020
使用 strlen 可以计算出字符串的长度，但无法计算出字符串数组的长度，即人类输入的单词集合的长度。

1802
02:07:55,020 --> 02:07:56,760
那么，我现在该如何使用它呢？

1803
02:07:56,760 --> 02:07:59,190
好吧，让我来做这件事。

1804
02:07:59,190 --> 02:08:04,190
让我现在就把这个程序改成 printf，引号后加引号、

1805
02:08:04,190 --> 02:08:11,630
"hello, %2 /n"，则 argv[1]。

1806
02:08:11,630 --> 02:08:14,780
因此，这还不是我的代码的最佳版本，但这是我的第一个版本。

1807
02:08:14,780 --> 02:08:21,020
打招呼，现在让我一次完成 ./greet, David。

1808
02:08:21,020 --> 02:08:23,210
进来，你好，戴维。

1809
02:08:23,210 --> 02:08:25,820
现在让我再运行一次，./问候，卡特。

1810
02:08:25,820 --> 02:08:27,620
进来，你好，卡特

1811
02:08:27,620 --> 02:08:32,330
这只是微不足道的改进，但我不必等待 getString 提示我按回车键。

1812
02:08:32,330 --> 02:08:34,370
这只是加快了速度，快了一倍。

1813
02:08:34,370 --> 02:08:36,890
少输入一条命令

1814
02:08:36,890 --> 02:08:41,390
但我故意做了 [1]，但 argv 的开头是什么？

1815
02:08:41,390 --> 02:08:42,170
应该是 [0]。

1816
02:08:44,730 --> 02:08:45,780
那是什么？

1817
02:08:45,780 --> 02:08:48,840
这有时是有用的，但目前还没有。

1818
02:08:48,840 --> 02:08:54,110
假设我现在重新编译代码并运行这个程序，向大卫问好。

1819
02:08:54,110 --> 02:08:58,598
有人想猜猜 argv[0] 中的内容吗？

1821
02:08:59,530 --> 02:09:00,220
再说一遍？

1822
02:09:00,220 --> 02:09:01,230
观众：Greet, hello.

1823
02:09:01,230 --> 02:09:04,530
DAVID MALAN：Greet（问候），Enter（输入），hello（你好），./greet（问候）。

1824
02:09:04,530 --> 02:09:14,460
因此，如果你想对你的程序进行初探，找出它自己的名字，或者至少知道它是如何在命令行、终端上执行的，你可以查看 argv[0]。

1825
02:09:14,460 --> 02:09:21,900
总的来说，可能用处不大，最好还是从 [1] 开始看起，这是程序名称后面的第一个词。

1826
02:09:21,900 --> 02:09:27,690
如果有更多，我可以这样做 argv[2] 怎么样，让我添加第二个 %s。

1827
02:09:27,690 --> 02:09:29,550
让我重新编译问候语。

1828
02:09:29,550 --> 02:09:37,112
让我输入 ./greet David Malan，回车，现在也可以了，按提示输入了两个单词。

1829
02:09:37,112 --> 02:09:38,820
如果我现在真的想在这个问题上耍小聪明的话、

1830
02:09:38,820 --> 02:09:40,445
不过，我可以这样做。

1831
02:09:40,445 --> 02:09:58,440
如果参数数（又称 argc）等于等于，那么假定人类只输入了自己的名字，并执行 printf hello comma %s /n，然后输入 argv[1]。

1832
02:09:58,440 --> 02:10:07,890
否则，如果人类没有提供准确的两个参数，即程序名称和他们自己的姓名，我们就打印出一个默认值，以免他们忘记自己的姓名

1833
02:10:07,890 --> 02:10:09,990
或者他们输入了两个或三个名字。

1834
02:10:09,990 --> 02:10:13,110
让我们把 "你好，逗号世界 "作为默认设置。

1835
02:10:13,110 --> 02:10:15,270
我们将忽略人类输入的内容。

1836
02:10:15,270 --> 02:10:20,850
如果我重新编译，制作问候语，我就可以再次执行 ./greet 和 David，回车。

1837
02:10:20,850 --> 02:10:24,840
哎呀--对不起，我漏掉了什么？

1838
02:10:24,840 --> 02:10:26,640
是啊，新手的错误。

1839
02:10:26,640 --> 02:10:30,090
否则，好吧，再打一次招呼。

1840
02:10:30,090 --> 02:10:34,050
./你好，戴维，回车，这是我的你好，戴维。

1841
02:10:34,050 --> 02:10:37,870
但如果我省略自己的名字，就会得到通用值，就像默认值一样。

1842
02:10:37,870 --> 02:10:41,590
如果我有点好奇，同时输入两个名字，也会被忽略。

1844
02:10:42,090 --> 02:10:44,880
因为我还没有为三个 argc 建立支持。

1845
02:10:44,880 --> 02:10:50,730
我可以做任何我想做的事情，但现在我们可以使用这些积木了。

1846
02:10:50,730 --> 02:10:52,780
好吧，我还能在这里做什么？

1847
02:10:52,780 --> 02:10:57,660
事实证明，我们现在可能需要执行一些最终功能。

1848
02:10:57,660 --> 02:11:06,180
不过请注意，在 C 语言中，尽管你可能会在书本或在线教程中看到，但如今定义主函数的两种正式格式是

1849
02:11:06,180 --> 02:11:17,880
要么是这个，我们已经用了两个多星期了；要么是这个，你把 void 改成 int argc，然后现在是字符串 argv，然后是空括号。

1850
02:11:17,880 --> 02:11:21,400
我们会发现，这也是一种简化，可以说是一种训练。

1851
02:11:21,400 --> 02:11:27,840
但现在，这是两种形式，尽管你会在在线教程甚至书籍中看到，有些人以不同的方式使用 main。

1852
02:11:27,840 --> 02:11:30,142
这是现在需要牢记的两点。

1853
02:11:30,142 --> 02:11:33,360
我要指出的是，这些命令行参数有点杂乱无章。

1854
02:11:33,360 --> 02:11:35,590
可能没想到会在这里的屏幕上看到这个词。

1855
02:11:35,590 --> 02:11:36,490
这意味着什么？

1856
02:11:36,490 --> 02:11:41,880
事实证明，几十年来，Linux 系统自带的一个程序叫做 cowsay。

1858
02:11:42,510 --> 02:11:51,520
可能是因为有一次有人闲得无聊，决定写一个程序，把一头牛在屏幕上说的文字创作成 ASCII 艺术。

1859
02:11:51,520 --> 02:11:55,780
但你使用 cowsay，只是为了好玩，通过命令行参数的方式。

1860
02:11:55,780 --> 02:12:04,770
例如，我建议回到 VS Code，这并不是因为我想写代码，而是我想使用我的终端窗口。

1861
02:12:04,770 --> 02:12:07,320
让我最大化终端窗口。

1862
02:12:07,320 --> 02:12:13,170
让我继续输入 "cowsay "和 "space moo "怎么样？

1863
02:12:13,170 --> 02:12:14,822
所以，cowsay 并不是我写的程序。

1864
02:12:14,822 --> 02:12:16,030
它已经存在了几十年。

1865
02:12:16,030 --> 02:12:18,870
但我们在云中为您将其安装到了 VS 代码中。

1866
02:12:18,870 --> 02:12:21,330
它至少需要一个命令行参数。

1867
02:12:21,330 --> 02:12:23,070
你想让奶牛说什么？

1868
02:12:23,070 --> 02:12:29,490
我可以说 "cowsay moo"，然后点击回车键，瞧，屏幕上就出现了我的 ASCII 艺术作品--一头牛在说 "哞"。

1869
02:12:29,490 --> 02:12:31,090
它可以说多个单词。

1870
02:12:31,090 --> 02:12:33,960
这样我就可以说，你好，世界，输入。

1871
02:12:33,960 --> 02:12:35,800
现在它说，你好，世界。

1872
02:12:35,800 --> 02:12:40,470
因此，这只是一个使用命令行参数的傻瓜程序的例子，但它也会使用其他参数。

1873
02:12:40,470 --> 02:12:45,750
就像 clang 一样，使用连字符来改变程序的输出。

1874
02:12:45,750 --> 02:12:53,520
Dash something 只是命令行参数的一个超级通用约定，当你想用非常简洁的符号来表示某些选项（如输出）时，就可以使用它。

1875
02:12:53,520 --> 02:13:03,460
在 "奶牛 "中，我阅读了文档，发现有一个破折号 f 命令行参数，可以改变奶牛的外观。

1876
02:13:03,460 --> 02:13:11,640
所以，如果我用 cowsay 破折号 f、duck，再加上其他一些词，比如 quack，它就不再是一头牛了。

1877
02:13:11,640 --> 02:13:15,850
命令行参数会把它变成一只可爱的小鸭子。

1878
02:13:15,850 --> 02:13:20,790
最后，只是为了好玩，因为我花了太多时间玩命令行参数。

1879
02:13:20,790 --> 02:13:27,910
Cowsay dash f, dragon, and then how about, rawr, Enter, you can even get this on the screen here.

1880
02:13:27,910 --> 02:13:34,230
因此，这也只是一个例子，说明我们有了这个构建模块后，可以用这些命令行参数做些什么。

1881
02:13:34,230 --> 02:13:36,960
最后，我们还可以用代码做一件事。

1882
02:13:36,960 --> 02:13:48,450
在我们将所有这些点与可读性和加密连接起来之前，我们今天还要介绍最后一个功能，即退出状态。

1883
02:13:48,450 --> 02:13:58,260
原来，每当主函数退出时，它都会返回一个秘密整数，作为程序员或高级用户，你可以猜出它是什么。

1884
02:13:58,260 --> 02:14:02,398
这些退出代码、退出状态通常用来表示错误。

1885
02:14:02,398 --> 02:14:08,560
例如，在过去的几年里，如果你使用缩放功能时出现了错误，你可能会看到这样的屏幕。

1886
02:14:08,560 --> 02:14:11,040
通常没有什么帮助，也许会告诉你点击

1887
02:14:11,040 --> 02:14:13,050
报告问题或联系技术支持。

1888
02:14:13,050 --> 02:14:23,640
但在我们人类世界的 Mac、PC 和手机上，你经常会看到隐晦的错误代码，比如字面上的数字，可能只有 Zoom、微软、谷歌或其他公司知道。

1889
02:14:23,640 --> 02:14:25,050
编写了您正在使用的软件。

1890
02:14:25,050 --> 02:14:32,070
但这个数字对应的是某个地方的某个人知道很可能会发生的特定错误。

1891
02:14:32,070 --> 02:14:38,260
虽然名称不同，但在网络上也有类似的用法，我们稍后将讨论。

1892
02:14:38,260 --> 02:14:41,350
你见过这种情况吗--也许不是性格，而是数量？

1893
02:14:41,350 --> 02:14:43,485
那么，404 意味着什么？

1894
02:14:43,485 --> 02:14:44,880
错误：错误。

1895
02:14:44,880 --> 02:14:47,790
DAVID MALAN：所以，错误，是的，但真的，没有找到。

1897
02:14:48,410 --> 02:14:49,993
我的意思是，这是最神秘的事情。

1898
02:14:49,993 --> 02:14:57,500
我们将在几周后讨论这个数字和其他数字的含义，但在技术领域，数字无处不在，它们通常对技术人员来说意味着什么。

1899
02:14:57,500 --> 02:15:00,270
而对你我这样的人来说，就不那么重要了。

1900
02:15:00,270 --> 02:15:05,900
为什么我们这么多人都认识 404，这有点奇怪，因为它已经存在了足够长的时间，我们都知道它。

1901
02:15:05,900 --> 02:15:10,250
但它实际上只是一个特殊的数字，代表着某种错误。

1902
02:15:10,250 --> 02:15:18,200
事实证明，我们今天要揭示的最后一件事，就是这两周来我们一直认为理所当然的事情--主要的 int 是什么。

1903
02:15:18,200 --> 02:15:24,680
刚才我们已经看到，括号中的内容到目前为止都是无效的，这意味着没有命令行参数。

1904
02:15:24,680 --> 02:15:29,690
现在 int argc string argv 括弧的意思就是，是的，命令行参数。

1905
02:15:29,690 --> 02:15:31,290
我们已经知道了如何访问它们。

1906
02:15:31,290 --> 02:15:37,460
因此，老实说，在过去两周所有的隐晦语法中，最后一块拼图就是 int 的含义。

1907
02:15:37,460 --> 02:15:46,010
Int 始终存在于 main 中，它表明 main 将始终返回一个整数，尽管你我从未明确这样做。

1908
02:15:46,010 --> 02:15:53,928
通常，main 默认返回 0。但如果你看到的错误信息是 0，那就太奇怪了，所以 0 被隐藏起来了。

1909
02:15:53,928 --> 02:15:55,470
你永远不会在屏幕上看到它。

1910
02:15:55,470 --> 02:15:58,670
但由于 C 语言的设计方式，这一切都会自动发生。

1911
02:15:58,670 --> 02:16:01,550
所以，让我在这里写最后一个程序。

1912
02:16:01,550 --> 02:16:05,750
例如，我会调用 status.c 向你展示这些退出状态。

1913
02:16:05,750 --> 02:16:21,350
status.c 的代码，然后在这里，让我做一些简单的事情，比如包含 cs50.h，然后包含 stdio.h，然后 int main -- 实际上，让我们使用命令行参数。 int argc，字符串 argv[]、

1914
02:16:21,350 --> 02:16:23,180
这就是复制、粘贴。

1915
02:16:23,180 --> 02:16:26,000
但现在，让我们这样做吧。

1916
02:16:26,000 --> 02:16:30,780
如果 argc 不等于 -- 为什么我们不这样做呢？

1917
02:16:30,780 --> 02:16:33,740
我们不要像上次一样，只默认为 "你好，世界"。

1918
02:16:33,740 --> 02:16:34,770
让我们对用户大喊大叫吧。

1919
02:16:34,770 --> 02:16:43,160
因此，我们可以说printf 缺少命令行参数这样的话，这样他们就知道自己搞砸了，需要重新正确运行程序。

1920
02:16:43,160 --> 02:16:56,730
否则，就像之前一样，打印出 "你好，逗号 %s"，然后输入 argv[1]，即提示符中的人名。

1921
02:16:56,730 --> 02:17:03,590
现在，让我继续运行状态，./status，我先什么也不输入。

1922
02:17:03,590 --> 02:17:04,700
我被骂了。

1923
02:17:04,700 --> 02:17:10,170
这次，我再输入./status David，就可以正常工作了。

1924
02:17:10,170 --> 02:17:14,090
不过，现在让我给你看一个有点秘密的、隐秘的命令。

1925
02:17:14,090 --> 02:17:18,740
你可以在提示符下输入这个，只是巧合的是，这里还有一个美元符号。

1926
02:17:18,740 --> 02:17:25,490
Echo $?（回声 $?），完全神秘，但它可以让你看到程序结束时的退出状态。

1927
02:17:25,490 --> 02:17:27,558
所以，让我用错误的方式再跑一次。

1928
02:17:27,558 --> 02:17:31,039
./status，我得到了错误信息。

1929
02:17:31,040 --> 02:17:32,780
秘密归还了什么？

1930
02:17:32,780 --> 02:17:33,440
我看不到。

1931
02:17:33,440 --> 02:17:37,280
显然没有错误屏幕，但输入 echo $?

1932
02:17:37,280 --> 02:17:42,170
我可以看到，哦，我的程序默认自动返回 0。

1933
02:17:42,170 --> 02:17:48,690
不过，如果我再次正确运行 ./status David，回车，这就是正确的版本。

1934
02:17:48,690 --> 02:17:52,879
但如果我再次运行 echo $? status，输入的仍然是 0。

1935
02:17:52,879 --> 02:17:55,879
长话短说，这只是错失良机。

1936
02:17:55,879 --> 02:17:59,570
出错时，为什么不返回 0 以外的值？

1937
02:17:59,570 --> 02:18:01,070
默认情况下，0 表示成功。

1938
02:18:01,070 --> 02:18:02,690
它总是自动存在。

1939
02:18:02,690 --> 02:18:04,940
但你可以控制这一点。

1940
02:18:04,940 --> 02:18:11,160
我可以在这里输入我的代码，然后返回 1，否则，如果某些东西工作正常的话、

1941
02:18:11,160 --> 02:18:17,129
默认情况下，我可以返回 0。老实说，如果我省略了返回 0，同样会自动返回 0。

1942
02:18:17,129 --> 02:18:20,718
所以让我先说清楚，好让我知道发生了什么。

1943
02:18:20,718 --> 02:18:26,359
再做一次状态，./status，让我们和大卫一起正确操作。

1944
02:18:26,360 --> 02:18:28,520
进来，你好，戴维。

1945
02:18:28,520 --> 02:18:32,058
回声 $？

1946
02:18:32,058 --> 02:18:33,269
所以一切顺利。

1947
02:18:33,270 --> 02:18:38,240
但现在，如果我执行 ./status 操作，什么都没有，或者执行多个操作，但不只是 David、

1948
02:18:38,240 --> 02:18:40,530
输入后，我收到了错误信息。

1949
02:18:40,530 --> 02:18:45,230
但现在，如果我执行 echo $？

1950
02:18:45,230 --> 02:18:47,330
这意味着什么？

1951
02:18:47,330 --> 02:18:52,459
在图形世界中，我们只需在屏幕上显示类似这样的内容，这对用户来说信息量更大一些。

1952
02:18:52,459 --> 02:18:58,549
但即使在没有图形用户界面的 Linux 世界，即使是我们编写的程序，也可以检查这些退出状态。

1953
02:18:58,549 --> 02:19:07,339
事实上，更自如、更高级的程序员在编写调用程序的代码时，不管是 Cowsay 还是其他任何程序，都可以进行编码、

1954
02:19:07,340 --> 02:19:13,170
检查程序的退出状态，然后决定我的程序是成功了还是失败了？

1955
02:19:13,170 --> 02:19:19,069
现在，在我们散会去吃水果点心之前，让我们把最后的点连起来。

1956
02:19:19,070 --> 02:19:27,650
密码学是本周的应用之一，通过它，你可以发送秘密信息，更好的是，还可以解密秘密信息。

1957
02:19:27,650 --> 02:19:34,040
除此之外，我们还可以使用启发式方法分析文本的可读性，就像我们在第二课开始时确定的那样。

1958
02:19:34,040 --> 02:19:45,980
因此，密码学就是一门艺术，一门对信息进行加密、扰乱的科学，这样，如果你有一条秘密信息要以所谓的明文发送，你就可以通过某种算法来处理它。

1959
02:19:45,980 --> 02:19:49,910
并将其转化为所谓的密文，从而对其进行加密。

1960
02:19:49,910 --> 02:19:59,880
从理论上讲，只有知道你使用了什么算法以及你对算法使用了什么输入的人，才能解密这一过程，并将其转换回原始信息。

1961
02:19:59,880 --> 02:20:03,030
因此，如果我们使用上周的思维模式，问题就来了。

1962
02:20:03,030 --> 02:20:04,910
下面是输入和输出。

1963
02:20:04,910 --> 02:20:13,640
我在这里提出的目标是获取一些纯文本，比如你想发送的信息，回想一下小学时，你是否曾给朋友或暗恋的人递过一张纸条，上面写着 "我爱你"、

1964
02:20:13,640 --> 02:20:16,910
如果老师或其他人拦截试卷，那就有点尴尬了。

1965
02:20:16,910 --> 02:20:19,490
而在英语中，它只是说 "我爱你"，或者其他什么意思。

1966
02:20:19,490 --> 02:20:22,350
如果你至少能以某种方式加密就更好了。

1967
02:20:22,350 --> 02:20:32,040
但对方需要知道你使用了什么算法，以及该算法的输入是什么，这样才能最终解码所谓的密文，也就是输出。

1968
02:20:32,040 --> 02:20:34,190
那么，今天盒子里装的是什么呢？

1969
02:20:34,190 --> 02:20:37,970
那么，与密码学有关的算法被称为密码。

1970
02:20:37,970 --> 02:20:43,250
密码是一种将文本从明文加密为密文的算法的别称。

1971
02:20:43,250 --> 02:20:48,750
问题是，不仅需要有算法，还需要有输入。

1972
02:20:48,750 --> 02:20:53,090
比如说，你今天可能第一次这样画图。

1973
02:20:53,090 --> 02:20:54,257
我们已经在代码中看到了这一点。

1974
02:20:54,257 --> 02:20:57,180
您可以为函数提供多个输入或参数。

1975
02:20:57,180 --> 02:21:02,510
所以，在这个黑盒子里，你能想象传入你想发送的信息，然后再传入一些秘密吗？

1976
02:21:02,510 --> 02:21:10,310
举个例子，假设我小时候能想到的最简单的事情是，与其寄信 A，我为什么不写 B 呢？

1977
02:21:10,310 --> 02:21:13,070
与其写字母 B，我为什么不写字母 C 呢？

1978
02:21:13,070 --> 02:21:16,280
因此，我可以把英语字母表移动一个空格。

1979
02:21:16,280 --> 02:21:18,740
因此，A 变成 B，B 变成 C，点，点，点、

1980
02:21:18,740 --> 02:21:21,690
Z 变成 A。

1981
02:21:21,690 --> 02:21:24,120
假设这部分故事没有标点符号。

1982
02:21:24,120 --> 02:21:32,090
因此，这是一种非常简单的算法--给每个字母加上一个值，然后将这个值作为密文发送。

1983
02:21:32,090 --> 02:21:41,300
现在，老师和同学不仅要知道你使用了这种旋转算法，也就是所谓的凯撒密码，还要知道你使用了什么数字。

1984
02:21:41,300 --> 02:21:45,200
你是每个字母加 1，每个字母加 2，还是每个字母加 25？

1985
02:21:45,200 --> 02:21:51,165
现在，如果他们超级聪明，而且可能不是故事中的那个年纪，他们也可以尝试所有的可能性。

1986
02:21:51,165 --> 02:21:53,040
这将是对算法的攻击。

1987
02:21:53,040 --> 02:21:56,970
这种算法并不复杂，但足以在课堂上传递信息。

1988
02:21:56,970 --> 02:22:06,950
因此，如果现在的两个输入是作为纯文本信息的 HI！和作为所谓密钥（即只有你和对方知道的秘密数字）的 1，那么你

1989
02:22:06,950 --> 02:22:11,040
可能会从一个方面对信息进行加密。

1990
02:22:11,040 --> 02:22:16,198
因此，在这种情况下，举例来说，"HI！"就会变成 "I-J-！"。

1991
02:22:16,198 --> 02:22:19,823
在这一版本的算法中，我们不打算使用数字或标点符号。

1992
02:22:19,823 --> 02:22:23,090
我们只对 A 到 Z 进行操作，无论是大写还是小写。

1993
02:22:23,090 --> 02:22:33,440
因此，现在如果你在课堂上收到一张写有 I-J 的纸条，只要你知道发件人用的是 I-J，作为收件人的你就会知道它是什么、

1994
02:22:33,440 --> 02:22:36,500
因为你只是颠倒了算法，而是减去了 1。

1995
02:22:36,500 --> 02:22:42,975
老师可能不知道这是什么意思，他们也不会花时间去破解信息，所以对他们来说，这看起来就是乱码。

1996
02:22:42,975 --> 02:22:44,600
这就是我们从加密中得到的。

1997
02:22:44,600 --> 02:22:52,700
无论是在课堂上还是在现实世界中，无论是在互联网上还是在其他任何地方，被拦截的人实际上都无法弄清楚，理想情况下，你发送的是什么。

1998
02:22:52,700 --> 02:22:56,300
当然，与之相反的情况确实叫做解密，但过程是一样的。

1999
02:22:56,300 --> 02:22:58,370
我们现在通过负 1。

2000
02:22:58,370 --> 02:23:00,300
这样如何？

2001
02:23:00,300 --> 02:23:02,840
我们为什么不在这里以示威结束呢？

2002
02:23:02,840 --> 02:23:08,360
UIJT XBT DT50--有一些信息。

2003
02:23:08,360 --> 02:23:14,180
如果我们把它传进去，然后做负 1，那么我们如何取出明文呢？

2004
02:23:14,180 --> 02:23:18,200
好吧，如果这是密文，我们从每个字母中减去 1、

2005
02:23:18,200 --> 02:23:28,010
我认为 U 变成了 T，I 变成了 H，J 变成了 I，T 变成了 S，X 变成了 W、

2006
02:23:28,010 --> 02:23:37,580
B 变成 A，T 变成 S，D 变成 C，T 变成 S，这就是 CS50。

2007
02:23:37,580 --> 02:23:40,250
出门时吃只鸭子，在大厅里吃点小吃。

