1
00:00:02,982 --> 00:00:06,461
[MUSIC PLAYING]

2
00:01:12,600 --> 00:01:13,590
DAVID MALAN: All right.

3
00:01:13,590 --> 00:01:24,120
This is CS50, and this is week 2 wherein we're going to take a look at a lower level at how things work, and indeed, among the goals of the course is this bottom-up understanding

4
00:01:24,120 --> 00:01:29,920
so that in a couple of weeks' time, even a few years' time, when you encounter some new technology, you'll be able to think back hopefully

5
00:01:29,920 --> 00:01:36,060
on some of this week's and this is basic building blocks and primitives and really just deduce how tomorrow's technologies work.

6
00:01:36,060 --> 00:01:41,380
But along the way, it's going to seem-- it's going to be a little hard, perhaps, to see the forest for the trees, so to speak.

7
00:01:41,380 --> 00:01:44,783
And so the goal at the end of the day still is going to be problem-solving.

8
00:01:44,783 --> 00:01:53,280
And so we thought we'd begin today with a look at some of the problems we'll talk about or solve this coming week, and for that, we have some brave volunteers who have already come up.

9
00:01:53,280 --> 00:01:58,320
If we could turn on some dramatic lighting and meet today's volunteers.

10
00:01:58,320 --> 00:02:00,430
So on my left here, we have--

11
00:02:00,430 --> 00:02:00,930
ALEX: Hi.

12
00:02:00,930 --> 00:02:01,960
My name is Alex.

13
00:02:01,960 --> 00:02:05,340
I'm a first-year at the college and I'm from Chapel Hill, North Carolina.

14
00:02:05,340 --> 00:02:07,080
DAVID MALAN: Welcome to Alex.

15
00:02:07,080 --> 00:02:09,180
And to Alex's right.

16
00:02:09,180 --> 00:02:10,050
SARAH: I'm Sarah.

17
00:02:10,050 --> 00:02:13,230
I'm from Toronto, Canada, and I'm also a first-year student at the college.

18
00:02:13,230 --> 00:02:14,188
DAVID MALAN: Wonderful.

19
00:02:14,188 --> 00:02:15,869
Well, welcome to both Alex and Sarah.

20
00:02:15,869 --> 00:02:25,650
So one of the problems you'll perhaps solve this week for problem set 2 is to analyze the reading level of a body of text, whether someone reads at a first grade level, second grade level, third grade

21
00:02:25,650 --> 00:02:28,570
level, all the way up to 12 or 13 or beyond.

22
00:02:28,570 --> 00:02:36,750
What you perhaps never quite thought about, certainly in terms of code, like how you would analyze some text, some book and figure out what reading level is it at.

23
00:02:36,750 --> 00:02:40,330
And yet, surely our teachers growing up knew or had an intuitive sense of this.

24
00:02:40,330 --> 00:02:42,450
So let's consider some sample text.

25
00:02:42,450 --> 00:02:45,960
For instance, Alex, what have you been reading lately?

26
00:02:45,960 --> 00:02:52,502
ALEX: One fish, two fish, red fish, blue fish.

27
00:02:52,502 --> 00:02:53,460
DAVID MALAN: Wonderful.

28
00:02:53,460 --> 00:02:58,890
So given that, what grade level would you say Alex is currently reading at?

29
00:02:58,890 --> 00:03:01,500
Feel free to just shout it out.

30
00:03:01,500 --> 00:03:02,730
First, first?

31
00:03:02,730 --> 00:03:10,410
So indeed, you'll see this week, if you run your code on Alex's text, it actually turns out he reads below a first grade reading level.

32
00:03:10,410 --> 00:03:12,400
But why might that be?

33
00:03:12,400 --> 00:03:19,020
What might your intuition be for why we've accused Alex of reading at this level?

34
00:03:19,020 --> 00:03:20,990
Feel free to shout out.

35
00:03:20,990 --> 00:03:21,490
Yeah.

36
00:03:21,490 --> 00:03:24,520
So very few syllables, short words, short sentences.

37
00:03:24,520 --> 00:03:30,370
And so there's some heuristics, perhaps, we can infer from that short text, that that probably means that it's best for younger children.

38
00:03:30,370 --> 00:03:33,370
Now Sarah, by contrast, what have you been reading?

39
00:03:33,370 --> 00:03:35,470
SARAH: Mr. And Mrs. Dursley of Number.

40
00:03:35,470 --> 00:03:41,050
Four Privet Drive were proud to say that they were perfectly normal, thank you very much.

41
00:03:41,050 --> 00:03:47,952
They were the last people you'd expect to be involved in anything strange or mysterious because they just didn't hold with much nonsense.

42
00:03:47,952 --> 00:03:48,910
DAVID MALAN: All right.

43
00:03:48,910 --> 00:03:55,230
Now irrespective of what grade you were in when you might have read that text, what grade level to Sarah seemed to be reading at?

44
00:03:55,230 --> 00:03:57,570
So eighth grade, second grade.

45
00:03:57,570 --> 00:03:58,080
OK.

46
00:03:58,080 --> 00:04:03,240
So hearing a bit of everything, so with that, at least according to code, it would actually be seventh grade.

47
00:04:03,240 --> 00:04:05,130
And what might the intuition there be?

48
00:04:05,130 --> 00:04:09,917
Why is that a higher grade level even though we might disagree exactly which grade it is?

49
00:04:09,917 --> 00:04:11,250
AUDIENCE: Complicated sentences.

50
00:04:11,250 --> 00:04:12,000
DAVID MALAN: Yeah.

51
00:04:12,000 --> 00:04:14,218
So complicated sentences, longer sentences.

52
00:04:14,218 --> 00:04:18,519
So indeed a lot more words were being spoken by Sarah because there was so much more there on the page.

53
00:04:18,519 --> 00:04:26,910
So we'll translate these ideas this coming week in problem set 2, if you tackle this one, through code so that you can ultimately infer things of these quantitatively.

54
00:04:26,910 --> 00:04:29,190
But to do so, we're going to have to understand text.

55
00:04:29,190 --> 00:04:32,610
So let's first thank our volunteers and then we'll dive in to that lower level.

56
00:04:32,610 --> 00:04:35,337
[APPLAUSE]

57
00:04:39,910 --> 00:04:40,600
Sorry.

58
00:04:40,600 --> 00:04:41,490
You can keep those.

59
00:04:41,490 --> 00:04:42,222
SARAH: Oh, OK.

60
00:04:42,222 --> 00:04:43,180
DAVID MALAN: All right.

61
00:04:43,180 --> 00:04:50,210
So besides that, let's consider one other body of text perhaps that you might see this week, which is namely a little something like this.

62
00:04:50,210 --> 00:04:53,860
What I have here on the screen is what we'll start calling today ciphertext.

63
00:04:53,860 --> 00:04:56,530
It's the result of encrypting some piece of information.

64
00:04:56,530 --> 00:05:00,908
And encryption, or more generally, the art and science of cryptography is all around us.

65
00:05:00,908 --> 00:05:03,700
It's what you're using on the web, on your phones, with your banks.

66
00:05:03,700 --> 00:05:07,000
And anything that tries to keep data secure is using encryption.

67
00:05:07,000 --> 00:05:11,140
But there's going to be different levels of encryption-- strong encryption, weak encryption.

68
00:05:11,140 --> 00:05:22,030
And what you see here on the screen isn't all that strong, but we'll see later today how we might decrypt this and actually reveal what the plaintext is that corresponds to that ciphertext.

69
00:05:22,030 --> 00:05:26,197
But in order to do so, we have to start taking off some training wheels, so to speak.

70
00:05:26,197 --> 00:05:32,230
And believe it or not, even though your time would see this past week for the first time, probably, might have been rather in the weeds.

71
00:05:32,230 --> 00:05:39,760
And much more complicated seemingly than C, it turns out that along the way, we have been providing and we'll continue to provide certain training wheels.

72
00:05:39,760 --> 00:05:49,730
For instance, the CS50 Library is one of them, and even some of the explanations we give of topics for now in these early weeks will be somewhat simplified-- abstracted away, if you will.

73
00:05:49,730 --> 00:05:58,210
But the goal ultimately is for you to understand each and every one of those details so that after CS50, you really can stand on your own and understand and wrap your mind

74
00:05:58,210 --> 00:06:01,040
around any future technologies as well.

75
00:06:01,040 --> 00:06:06,110
So let's consider first the very first program with which we began last week, which was this one.

76
00:06:06,110 --> 00:06:14,890
So "hello, world" in C. At the end of the day, it was really the printf function that was doing the interesting part of the work, but there was a lot of technical stuff above and below it.

77
00:06:14,890 --> 00:06:21,730
The curly braces, the parentheses, words like void and include, and then of course, the angled brackets and more.

78
00:06:21,730 --> 00:06:30,190
But at the end of the day, we needed to convert that source code in C to machine code, the 0's and 1's in binary that the computer understood.

79
00:06:30,190 --> 00:06:33,700
And to do that, of course, we ran-- we compiled the code.

80
00:06:33,700 --> 00:06:37,400
We ran make and then we were able to actually run that code there.

81
00:06:37,400 --> 00:06:44,510
So let me actually go over here to VS Code and really quickly recreate that hello.c pretty much by transcribing the same.

82
00:06:44,510 --> 00:06:51,970
So I might have here include stdio.h, int main void.

83
00:06:51,970 --> 00:06:57,430
And then in here, I had quite simply, hello, comma, world with my backslash, endquotes, and more.

84
00:06:57,430 --> 00:07:01,693
Now last time, to compile this, I indeed ran make hello, followed by Enter.

85
00:07:01,693 --> 00:07:03,860
Hopefully you see no errors and that's a good thing.

86
00:07:03,860 --> 00:07:07,840
And if you do dot, slash, hello, you see, in fact, the results of that program.

87
00:07:07,840 --> 00:07:12,950
But it turns out that make is not actually a compiler as I alluded to last week.

88
00:07:12,950 --> 00:07:19,030
It's a program that clearly makes your program, but it itself just automates the process of using an actual compiler.

89
00:07:19,030 --> 00:07:27,640
And there's lots of different compilers out there, and the one that it's actually using underneath the hood is a little something called Clang for C Language.

90
00:07:27,640 --> 00:07:30,190
And Clang is a pretty popular compiler nowadays.

91
00:07:30,190 --> 00:07:40,310
There's another one that's been around for ages called GCC, but these are just specific names for types of compilers that different people, different companies, different groups have actually created.

92
00:07:40,310 --> 00:07:50,703
But if you use in week 1 a compiler yourself manually, you have to understand a little more about what's going on because it's even more cryptic than what just make alone.

93
00:07:50,703 --> 00:07:59,360
So in fact, let me go back to my terminal window here, let me go ahead and clear the screen a little bit and just run really the raw compiler command.

94
00:07:59,360 --> 00:08:03,620
So what make is automating for me let me, actually do this manually for just a moment.

95
00:08:03,620 --> 00:08:10,450
So if I want to compile hello.c into an executable program I can run,

96
00:08:10,450 --> 00:08:17,110
I can do this. clang, space, hello.c, and then Enter.

97
00:08:17,110 --> 00:08:22,010
And now there's no output, which is a good thing in this case, no errors, but notice this.

98
00:08:22,010 --> 00:08:32,140
If I go ahead and type ls, it turns out there's a file that's been created suddenly in my current folder weirdly called a.out.

99
00:08:32,140 --> 00:08:33,580
That stands for Assembler Output.

100
00:08:33,580 --> 00:08:39,440
And long story short, that's actually the default name of a program that's created when you just run Clang by itself.

101
00:08:39,440 --> 00:08:44,000
Now that's a pretty bad name for a program because it doesn't describe what it does.

102
00:08:44,000 --> 00:08:55,420
So better would be here to perhaps do, well, instead of a.out, which, yes, still prints hello.world, but isn't really a clearly-named program, it'd be nice to name this hello.

103
00:08:55,420 --> 00:08:56,240
So what could I do?

104
00:08:56,240 --> 00:09:01,820
I could do like we learned last week-- well, I could rename a.out to hello by using Linux's mv command.

105
00:09:01,820 --> 00:09:04,480
So I'm going to move a.out to become hello.

106
00:09:04,480 --> 00:09:06,370
But that, too, seems kind of tedious.

107
00:09:06,370 --> 00:09:07,720
Now I have three steps.

108
00:09:07,720 --> 00:09:12,190
Like write my code, compile my code, and then rename it before I can even run it.

109
00:09:12,190 --> 00:09:13,580
We can do better than that.

110
00:09:13,580 --> 00:09:20,380
And so it turns out that certain commands like clang support what we're going to start today calling command line arguments.

111
00:09:20,380 --> 00:09:30,400
A command line argument, unlike an argument to a function, is just an additional word or key phrase that you type after a command at your prompt in your terminal

112
00:09:30,400 --> 00:09:33,440
window that just modifies the behavior of that command.

113
00:09:33,440 --> 00:09:35,600
It configures it a little more specifically.

114
00:09:35,600 --> 00:09:45,220
So what you're seeing here on the screen is some of a better command with which to run clang so that now I can specify the output of this command per this o.

115
00:09:45,220 --> 00:09:46,610
So do what I mean by that?

116
00:09:46,610 --> 00:09:54,955
Well, let me go ahead and clear my terminal window again and more explicitly type clang -o hello hello.c and then Enter.

117
00:09:54,955 --> 00:10:02,860
Nothing, again, appears to happen, but that's a good thing when you see no errors and now the program I just created is indeed called Hello.

118
00:10:02,860 --> 00:10:07,280
So it achieves really the same exact effect as make did, but what.

119
00:10:07,280 --> 00:10:11,075
I don't have to do with make is type and remember something as long as this command.

120
00:10:11,075 --> 00:10:12,700
And this, too, is a bit of a white lie.

121
00:10:12,700 --> 00:10:22,840
It turns out, we have preconfigured VS Code in the cloud for you to also use some other features of Clang that would be even more tedious for you to write yourselves.

122
00:10:22,840 --> 00:10:28,130
And so really, this is why we distill this as ultimately just running make.

123
00:10:28,130 --> 00:10:37,720
So let me pause here to see first if there's any questions on what I've done by taking my very first program in C and just now compiling it first with make, but then starting over

124
00:10:37,720 --> 00:10:46,820
and now manually compiling it with clang with what we'll call command line arguments. -o, space, hello, and then the name of the file.

125
00:10:46,820 --> 00:10:47,320
Yeah?

126
00:10:47,320 --> 00:10:48,780
AUDIENCE: What is a.out?

127
00:10:48,780 --> 00:10:49,530
DAVID MALAN: Yeah.

128
00:10:49,530 --> 00:10:51,870
So a.out is a historical name.

129
00:10:51,870 --> 00:10:55,240
It refers to assembler output-- more on that soon.

130
00:10:55,240 --> 00:11:02,970
And it's just the default file name that you get automatically if you just run the compiler on any file so that you have just a standard name for it.

131
00:11:02,970 --> 00:11:05,213
But it's not a very well-named program.

132
00:11:05,213 --> 00:11:09,880
Instead of running Microsoft Word on your Mac or PC, it would be like double-clicking on a.out.

133
00:11:09,880 --> 00:11:17,370
So instead with these command line arguments, you can customize the output of Clang and call it hello or anything you want.

134
00:11:17,370 --> 00:11:23,020
Other questions on what I've done here with Clang itself, the compiler?

135
00:11:23,020 --> 00:11:23,520
Yeah?

136
00:11:23,520 --> 00:11:25,510
AUDIENCE: What is -o?

137
00:11:25,510 --> 00:11:30,500
DAVID MALAN: So -o-- and you would only know this from reading the manual, taking a class, means output.

138
00:11:30,500 --> 00:11:38,680
So -o means change Clang's output to be a file called hello instead of the default, which is a.out.

139
00:11:38,680 --> 00:11:44,810
And this, too, is, again, a detail you would have to look up on a web page, read the manual, hear someone like me tell you about it.

140
00:11:44,810 --> 00:11:48,890
And in fact, there's even more than these options, but we'll just scratch the surface here.

141
00:11:48,890 --> 00:11:49,390
All right.

142
00:11:49,390 --> 00:11:53,530
So if we now know this, what more is actually happening underneath the hood?

143
00:11:53,530 --> 00:12:03,430
Well, let's take a closer look at not just this version of my code, but my slightly more complicated version last week, which looked a little something like this, wherein

144
00:12:03,430 --> 00:12:11,810
I added in some dynamic input from the user so I could say not hello, world to everyone, but hello, David or hello to whoever actually runs this program.

145
00:12:11,810 --> 00:12:17,770
So in fact, let me go ahead and change my code here in VS Code just to match that same code from last week.

146
00:12:17,770 --> 00:12:19,190
So no new code yet.

147
00:12:19,190 --> 00:12:22,820
I'm just going to, in a moment, compile it in a slightly different way.

148
00:12:22,820 --> 00:12:29,020
So I did last week's string, I think, answer equals string, quote-unquote,

149
00:12:29,020 --> 00:12:30,100
"What's your name?"

150
00:12:30,100 --> 00:12:31,540
Just like in Scratch.

151
00:12:31,540 --> 00:12:37,450
And then down here, instead of doing world, I initially wrote answer, but that didn't go well.

152
00:12:37,450 --> 00:12:42,940
What did I ultimately do instead to print out hello, David or hello, so-and-so?

153
00:12:42,940 --> 00:12:44,722
Yeah?

154
00:12:44,722 --> 00:12:45,680
Sorry, a little louder?

155
00:12:45,680 --> 00:12:46,430
AUDIENCE: %s?

156
00:12:46,430 --> 00:12:51,020
DAVID MALAN: Yeah, so %s, the so-called format code that printf just knows how to deal with.

157
00:12:51,020 --> 00:12:52,470
And I had to add one other thing.

158
00:12:52,470 --> 00:12:54,850
Someone else besides %s-- yeah?

159
00:12:54,850 --> 00:12:56,050
AUDIENCE: The name of the variable.

160
00:12:56,050 --> 00:13:00,190
DAVID MALAN: The name of the variable that I want to plug into that placeholder %s.

161
00:13:00,190 --> 00:13:01,630
And in this case, it's answer.

162
00:13:01,630 --> 00:13:11,560
Now let me make one refinement only because now we're in week 2 and we're going to start writing more lines of code, even though Scratch called the return value of the ask puzzle piece, answer always.

163
00:13:11,560 --> 00:13:14,480
And see, we have full control over what our variables are called.

164
00:13:14,480 --> 00:13:19,870
And now it's probably good not to just generically always call my variable answer if I'm using get_string.

165
00:13:19,870 --> 00:13:21,050
Let's call it what it is.

166
00:13:21,050 --> 00:13:23,680
So this is now just a matter of style, if you will.

167
00:13:23,680 --> 00:13:34,000
Let me change the variable to be name just so that it's a little clearer to me, to you, to a TF or TA exactly what that variable represents instead of more generically answer.

168
00:13:34,000 --> 00:13:41,050
All right, so that said, let me go down to my terminal window, and last week again, I ran make to compile this exact same program.

169
00:13:41,050 --> 00:13:43,270
Now, though, let me go ahead and just use clang.

170
00:13:43,270 --> 00:13:45,490
So clang -o--

171
00:13:45,490 --> 00:13:49,330
I'll still call this version hello-- space, hello.c.

172
00:13:49,330 --> 00:13:51,080
So exact same command as before.

173
00:13:51,080 --> 00:13:56,330
The only thing that's different is I've added a couple of more lines of code to get the user's input.

174
00:13:56,330 --> 00:13:59,960
Let me hit Enter, and now, darn it, our first error.

175
00:13:59,960 --> 00:14:05,420
So output from clang and make is not a good thing, and here, we're seeing something particularly cryptic.

176
00:14:05,420 --> 00:14:13,480
So something in function 'main--' undefined reference to 'get_string,' string and then linker command failed with exit code 1.

177
00:14:13,480 --> 00:14:22,130
So there's actually a lot of jargon in there that will tease apart today, but my hint is that clearly my problem's in main, although that's not surprising because there's nothing else going on here.

178
00:14:22,130 --> 00:14:26,830
get_string is an issue, and the issue is that it's an undefined reference.

179
00:14:26,830 --> 00:14:28,990
And yet, notice, I was pretty good.

180
00:14:28,990 --> 00:14:39,070
I added the CS50 header file and I said last week that that's enough to teach the compiler that functions exist, but the problem is that even though this does, in fact,

181
00:14:39,070 --> 00:14:51,860
teach Clang that get_string exists, it is not sufficient information for Clang to go find on the hard drive of the computer the 0's and 1's that actually implement get_string itself.

182
00:14:51,860 --> 00:14:55,333
So in other words, this include line, per last week, is a little bit of a hint.

183
00:14:55,333 --> 00:14:59,560
It's a teaser to Clang that you're about to see and use this function somewhere.

184
00:14:59,560 --> 00:15:11,470
But if you actually want to use the 0's and 1's that CS50 wrote some time ago and bake those into your program so your program actually knows how to get input from the user, well then,

185
00:15:11,470 --> 00:15:15,440
I'm going to have to go ahead and run a slightly different command.

186
00:15:15,440 --> 00:15:16,250
So let me do this.

187
00:15:16,250 --> 00:15:23,020
Let me clear my terminal window just get rid of that distraction and let me propose now that we run this command instead.

188
00:15:23,020 --> 00:15:35,050
Almost the same as before, clang -o, space, hello, then hello.c, but with one additional command line argument at the end, and this is a -l-- not a number 1.

189
00:15:35,050 --> 00:15:39,370
So -lcs with no space in between those two.

190
00:15:39,370 --> 00:15:48,850
Now the l is going to result in all of those 0's and 1's that actually were in by CS50 being linked into your code, your few lines of code or mine here.

191
00:15:48,850 --> 00:15:58,537
But that's the second step that the compiler requires in order to know how to actually execute and rather compile your code and CS50's.

192
00:15:58,537 --> 00:16:00,370
And CS50 is not the only one that does this.

193
00:16:00,370 --> 00:16:10,000
If you use any third party library in C that doesn't come with the language, you would do -l such and such where whoever-- however they've named their own library.

194
00:16:10,000 --> 00:16:14,298
But you don't have to do it for built in things like we've been using thus far.

195
00:16:14,298 --> 00:16:16,090
All right, so let me go ahead and try this.

196
00:16:16,090 --> 00:16:23,620
I'll go back to VS Code here, and let me go ahead now and run clang -o hello, then hello.c.

197
00:16:23,620 --> 00:16:29,590
And now instead of just hitting Enter, -lcs50 with no space between the l and the cs50, Enter.

198
00:16:29,590 --> 00:16:33,310
Now nothing bad happens, and now I can do ./hello.

199
00:16:33,310 --> 00:16:34,180
What's your name?

200
00:16:34,180 --> 00:16:37,633
I'll type in David, Enter, and now we see hello, David.

201
00:16:37,633 --> 00:16:46,460
Now honestly, this is where we're really getting into the weeds, and now this is taking-- this is really just adding nuisance to the process of compiling and running your code.

202
00:16:46,460 --> 00:16:55,240
And so the reality is, even though this is indeed what is happening, this is why we used last week and we're going to continue using this week onward make because it just

203
00:16:55,240 --> 00:16:57,130
automates that whole process for you.

204
00:16:57,130 --> 00:17:05,858
But it's ideal to understand what's going wrong because any of the error messages you saw for problem set 1, any of the error messages you see for the next few weeks probably aren't coming from make,

205
00:17:05,858 --> 00:17:10,780
they're coming from Clang underneath the hood because make is just automating the process.

206
00:17:10,780 --> 00:17:17,560
But with make, you literally just write make and then the name of the program, you don't have to worry about any of those command line arguments.

207
00:17:17,560 --> 00:17:22,240
Questions, then, on compiling with dash -lcs50 or anything else?

208
00:17:22,240 --> 00:17:23,042
Yeah?

209
00:17:23,042 --> 00:17:24,959
AUDIENCE: What is the benefit of [INAUDIBLE]??

210
00:17:24,960 --> 00:17:26,220
DAVID MALAN: Sorry, what is the benefit of--

211
00:17:26,220 --> 00:17:27,512
AUDIENCE: Using Clang manually.

212
00:17:27,512 --> 00:17:30,000
DAVID MALAN: What is the benefit of using Clang manually?

213
00:17:30,000 --> 00:17:30,870
None, really.

214
00:17:30,870 --> 00:17:35,055
In fact, all main is doing is just say-- make is doing is saving us some keystrokes.

215
00:17:35,055 --> 00:17:42,090
If you prefer, though, and you just like to be more in control, you can totally run Clang manually if you remember the various command line arguments.

216
00:17:42,090 --> 00:17:42,660
Yeah?

217
00:17:42,660 --> 00:17:47,335
AUDIENCE: So why did you have to explain [INAUDIBLE]

218
00:17:47,335 --> 00:17:48,210
DAVID MALAN: Exactly.

219
00:17:48,210 --> 00:17:55,470
Why did I have to explain-- that is, provide a hint to CS50 with the cs50.h header file, but I didn't have to do that with standardio.h?

220
00:17:55,470 --> 00:18:03,060
Just because. standardio.h comes with C, just like a few other libraries come with C that we'll start seeing today.

221
00:18:03,060 --> 00:18:07,890
CS50, though, is not built into C everywhere, and so you do have to explicitly add that one there.

222
00:18:07,890 --> 00:18:08,767
Yeah?

223
00:18:08,767 --> 00:18:11,970
AUDIENCE: Can you define what command line argument [INAUDIBLE]??

224
00:18:11,970 --> 00:18:22,200
DAVID MALAN: A command line argument is a word or phrase that you type at the command line-- a.k.a., your terminal-- in order to influence the behavior of a program.

225
00:18:22,200 --> 00:18:22,742
AUDIENCE: OK.

226
00:18:22,742 --> 00:18:24,430
So it's a term for whatever you're giving it.

227
00:18:24,430 --> 00:18:24,565
DAVID MALAN: Yeah.

228
00:18:24,565 --> 00:18:25,660
It changes the defaults.

229
00:18:25,660 --> 00:18:33,460
In our GUI world, Graphical User Interface, you and I would probably click some boxes, we would select some menu options to configure a program to behave in the same way.

230
00:18:33,460 --> 00:18:39,600
At a command line interface, you have to just say everything all at once, and that's why we have command line arguments.

231
00:18:39,600 --> 00:18:40,605
Yeah?

232
00:18:40,605 --> 00:18:43,243
AUDIENCE: Is make [INAUDIBLE]

233
00:18:43,243 --> 00:18:43,910
DAVID MALAN: No.

234
00:18:43,910 --> 00:18:45,470
Make is not just for CS50.

235
00:18:45,470 --> 00:18:52,020
It's used globally in any project really nowadays using C, C++, even other languages as well.

236
00:18:52,020 --> 00:18:57,530
In fact, most every command you see in this class, unless it has 5-0 at the end of it, is globally used.

237
00:18:57,530 --> 00:19:00,758
Only those-- a suffix with 50 are, indeed, course-specific.

238
00:19:00,758 --> 00:19:06,890
And even those we'll gradually take training wheels off of so that exactly what those commands are doing as well.

239
00:19:06,890 --> 00:19:09,053
All right, so what is it that we've just done?

240
00:19:09,053 --> 00:19:15,967
Everything we've just done, of course, I keep calling compiling, but let's just go down one rabbit hole so that you understand that when you compile code,

241
00:19:15,967 --> 00:19:26,060
there's actually a whole bunch of steps, happening and this is going to enable a lot of features, like companies can write code and then convert it to run it on Macs and PCs alike

242
00:19:26,060 --> 00:19:27,240
or phones or the like.

243
00:19:27,240 --> 00:19:35,840
So it's not just a matter of converting source code to machine code, there's actually four steps involved in what you and I, as of last week, know as compiling.

244
00:19:35,840 --> 00:19:41,450
And these aren't terms that you'll have to keep in mind constantly because again, we're going to abstract a lot of this away.

245
00:19:41,450 --> 00:19:51,080
But just so we've gone down the rabbit hole once, let's consider each of these four steps that have been happening for you for a week automatically, the first of which is called preprocessing.

246
00:19:51,080 --> 00:19:52,260
So what does this mean?

247
00:19:52,260 --> 00:19:54,450
Well, let's consider that same program as before.

248
00:19:54,450 --> 00:19:57,830
So notice that two of the lines of code start with a hash mark.

249
00:19:57,830 --> 00:20:02,338
That is a special symbol in C, and it's a so-called preprocessor directive.

250
00:20:02,338 --> 00:20:07,005
You don't need to memorize terms like that, but it just means that it's a little different from every other line.

251
00:20:07,005 --> 00:20:13,315
And anything with a hash symbol here should be preprocessed-- that is, analyzed initially before anything else happens.

252
00:20:13,315 --> 00:20:17,100
So let's consider these two lines up top, what exactly is happening.

253
00:20:17,100 --> 00:20:23,390
Well, it turns out with these two lines, you have two header files, of course, cs50.h and stdio.h.

254
00:20:23,390 --> 00:20:28,550
Where are those files, because they've never been in VS Code for you, seemingly.

255
00:20:28,550 --> 00:20:35,900
If you type LS-- if you open up the File Explorer in the GUI, you have never seen, probably, cs50.h or stdio.h.

256
00:20:35,900 --> 00:20:45,690
They just work, but that's because there's a folder somewhere on the hard drive that you're using on your Mac or PC or somewhere in the cloud, as in our case.

257
00:20:45,690 --> 00:20:50,210
And inside of this folder, traditionally called /usr/include.

258
00:20:50,210 --> 00:20:51,857
And user is deliberately misspelled.

259
00:20:51,857 --> 00:20:55,760
It's just slightly more succinct, although it's a little weird why we drop that one letter.

260
00:20:55,760 --> 00:21:03,990
But usr/include is just a folder on the server that contains cs50.h, stdio.h, and a bunch of other things as well.

261
00:21:03,990 --> 00:21:15,470
So in fact, if you type in VS Code, in your terminal window, when you're using code spaces in the cloud and type LS space /usr/include, you can see all of the files in that folder.

262
00:21:15,470 --> 00:21:17,580
But we've preinstalled all of that stuff for you.

263
00:21:17,580 --> 00:21:20,390
So let's consider what's actually in those files here.

264
00:21:20,390 --> 00:21:25,370
If I highlight these two lines up top that start with hash include, well,

265
00:21:25,370 --> 00:21:32,660
I kind of hinted last week that what's in that first file is a hint as to what functions CS50 wrote for you.

266
00:21:32,660 --> 00:21:41,000
So you can kind of think of these include lines as being temporary placeholders for what's going to become like a global find and replace.

267
00:21:41,000 --> 00:21:44,270
That is the first thing clang is going to do is to preprocess this file.

268
00:21:44,270 --> 00:21:47,300
It's going to look for any line that starts with hash include.

269
00:21:47,300 --> 00:21:56,443
And if it sees that, it's going to essentially go into that file, like cs50.h, and then just copy and paste the contents of that file magically there for you.

270
00:21:56,443 --> 00:21:58,110
You don't see it visually on the screen.

271
00:21:58,110 --> 00:22:00,060
But it's happening behind the scenes.

272
00:22:00,060 --> 00:22:13,215
And so really, what's happening with this first line is that somewhere in cs50.h is the declaration of getString like we talked last week, and it probably looks a little something like this.

273
00:22:13,215 --> 00:22:17,030
And we didn't spend much time on this yet this past week, but we will in time more.

274
00:22:17,030 --> 00:22:21,470
Notice that this is how a function is declared.

275
00:22:21,470 --> 00:22:23,677
That is, it is decreed to exist.

276
00:22:23,677 --> 00:22:25,760
The name of the function, of course, is getString.

277
00:22:25,760 --> 00:22:28,310
Inside of the parentheses are its arguments.

278
00:22:28,310 --> 00:22:33,080
In this case, there's one argument to getString, I claim today, but you've known this implicitly.

279
00:22:33,080 --> 00:22:34,160
And it's a prompt.

280
00:22:34,160 --> 00:22:36,860
It's the prompt that the human sees when you use getString.

281
00:22:36,860 --> 00:22:37,790
What is that prompt?

282
00:22:37,790 --> 00:22:43,080
Well, it's a string of text, like quote unquote, "what's your name?" or anything else that I asked last week.

283
00:22:43,080 --> 00:22:46,610
Meanwhile, getString, as we know from last week, has a return value.

284
00:22:46,610 --> 00:22:48,140
It returns something to you.

285
00:22:48,140 --> 00:22:49,610
And that, too, is a string.

286
00:22:49,610 --> 00:22:52,120
So again, this is also called a functions prototype.

287
00:22:52,120 --> 00:23:02,030
It's the thing toward the end of last week that I just copied and pasted from the bottom of my file to the top, just so that it was like this teaser for clang as to what would exist later.

288
00:23:02,030 --> 00:23:11,360
So you can think, then, of these include lines as just kind of combining all of those function declarations in some separate file called cs50.h,

289
00:23:11,360 --> 00:23:18,470
so that you yourself don't have to type them every time you use the library-- or worse, so that you, yourself, don't have to copy and paste those lines.

290
00:23:18,470 --> 00:23:22,520
This is what clang is doing for you in its first step of preprocessing.

291
00:23:22,520 --> 00:23:29,175
Second, and last in this example, what happens when clang preprocesses this second include line?

292
00:23:29,175 --> 00:23:33,650
Well, the only other function we care about in this story is printf, of course, which comes with C.

293
00:23:33,650 --> 00:23:40,820
So essentially, you can think of printf's prototype or declaration as just being this.

294
00:23:40,820 --> 00:23:42,870
Printf is the name of the function.

295
00:23:42,870 --> 00:23:49,110
It takes a string that you want to format like, Hello comma world, or Hello comma %s.

296
00:23:49,110 --> 00:23:52,120
And then with dot, dot, dot, this actually has technical meaning.

297
00:23:52,120 --> 00:23:56,340
It means, of course, that you can plug-in 0 variables, 1 variable, 2 or 10.

298
00:23:56,340 --> 00:23:58,530
So dot, dot, dot means some number of variables.

299
00:23:58,530 --> 00:24:00,072
Now we haven't talked about this yet.

300
00:24:00,072 --> 00:24:05,490
And we won't really, in general. printf actually returns a value, a number, that is an integer.

301
00:24:05,490 --> 00:24:07,420
But more on that perhaps another time.

302
00:24:07,420 --> 00:24:10,920
It's generally not something the programmer tends to look at.

303
00:24:10,920 --> 00:24:21,330
But that's all we mean by preprocessing, so that at the end of this process, even though there's more lines of code in cs50.h and stdio.h, what's really just happening is that clang, in preprocessing

304
00:24:21,330 --> 00:24:31,060
the file, copies and pastes the contents of those files into your code so that now your code knows about everything-- getString, printf, and anything else.

305
00:24:31,060 --> 00:24:35,230
Any questions, then, on that first step, preprocessing?

306
00:24:35,230 --> 00:24:35,920
Yes?

307
00:24:35,920 --> 00:24:49,195
AUDIENCE: [INAUDIBLE]

308
00:24:49,195 --> 00:24:50,320
DAVID MALAN: Good question.

309
00:24:50,320 --> 00:24:54,880
When you include a file, does it only include what you need or does it include everything?

310
00:24:54,880 --> 00:24:56,420
Think of it as including everything.

311
00:24:56,420 --> 00:24:59,020
So if it's a big file, that's a lot of code at the very top.

312
00:24:59,020 --> 00:25:01,880
And that's why, if you think back to all of the zeros and ones

313
00:25:01,880 --> 00:25:08,892
I showed a little bit ago, as well as last week, there's a lot of zeros and ones that end up on the screen as a result of just writing, Hello, world.

314
00:25:08,892 --> 00:25:13,390
A lot of those zeros and ones are perhaps coming from code that you didn't actually, necessarily need.

315
00:25:13,390 --> 00:25:17,740
But some of it is perhaps there, but there are ways to optimize that as well.

316
00:25:17,740 --> 00:25:22,395
All right, so step two of compiling is, confusingly, called compiling.

317
00:25:22,395 --> 00:25:27,940
It's just, this is the term that most everyone uses to describe the whole process, instead of just this one step.

318
00:25:27,940 --> 00:25:35,865
But once a program has been preprocessed behind the scenes by the compiler for you, it looks now a little something like this.

319
00:25:35,865 --> 00:25:39,820
And I've put dot, dot, dot just to imply that, yes, to your question, there's more stuff above it.

320
00:25:39,820 --> 00:25:40,987
There's more stuff below it.

321
00:25:40,987 --> 00:25:43,070
It's just not interesting right now for us.

322
00:25:43,070 --> 00:25:44,860
So now we have just C code.

323
00:25:44,860 --> 00:25:46,960
There's no more preprocessor directives.

324
00:25:46,960 --> 00:25:52,670
At this point, all of the hash symbols and those lines of code have been preprocessed and converted to something else.

325
00:25:52,670 --> 00:25:56,380
And so now-- and this is where things get a little spooky looking.

326
00:25:56,380 --> 00:26:03,310
Here now is what happens when clang, or any compiler, literally compiles code like this.

327
00:26:03,310 --> 00:26:08,720
It converts it from this in C to this in assembly code.

328
00:26:08,720 --> 00:26:10,720
So this is among the scarier languages.

329
00:26:10,720 --> 00:26:12,580
I, myself, don't really have fond memories.

330
00:26:12,580 --> 00:26:14,805
This is not a language that many people program in.

331
00:26:14,805 --> 00:26:21,430
If you take a subsequent class in computer science, in systems, a higher level class, you might actually learn this or some variant thereof.

332
00:26:21,430 --> 00:26:29,320
But there's at least a few people out there that need to know this stuff because this is closer to what the computers themselves, nowadays, understand.

333
00:26:29,320 --> 00:26:37,960
The Intel CPUs or the AMD CPUs, the brains of today's computers and phones understand stuff that looks more like this and less like C.

334
00:26:37,960 --> 00:26:42,430
Now it's completely esoteric, but let me just highlight a few phrases.

335
00:26:42,430 --> 00:26:44,630
There's some stuff that's a little familiar.

336
00:26:44,630 --> 00:26:47,620
There is mention of main at the top there in yellow.

337
00:26:47,620 --> 00:26:49,750
There is mention of getString toward the bottom.

338
00:26:49,750 --> 00:26:52,070
There is mention of printf down below.

339
00:26:52,070 --> 00:27:00,130
So this is just another programming language called assembly language, that decades ago, humans-- myself included in school-- did write code in.

340
00:27:00,130 --> 00:27:06,070
And absolutely, some people still write this code, especially since you can write very, very efficient code.

341
00:27:06,070 --> 00:27:08,590
But it's a lot more arcane.

342
00:27:08,590 --> 00:27:11,380
It's a lot less user friendly.

343
00:27:11,380 --> 00:27:23,630
So you'll see in yellow now, these are the so-called instructions that a computer's brain or CPU understands, pushing values around, moving them, subtracting values, calling functions, and move, move,

344
00:27:23,630 --> 00:27:24,130
move.

345
00:27:24,130 --> 00:27:34,120
So really, the low-level operations that computers understand tend to be arithmetic operations-- subtraction, addition, and the like-- moving things in and out of memory.

346
00:27:34,120 --> 00:27:37,510
It's just a lot more tedious for folks like us to write code like this.

347
00:27:37,510 --> 00:27:40,450
This is why you and I tend to write stuff like this.

348
00:27:40,450 --> 00:27:46,520
And ideally, still, people like you and I tend to drag and drop puzzle pieces that sort of abstract all of that away further.

349
00:27:46,520 --> 00:27:49,420
But for now, this is, again, called assembly language.

350
00:27:49,420 --> 00:27:54,310
It is what happens when the compiler literally compiles your code.

351
00:27:54,310 --> 00:27:57,010
But of course, this, still not zeros and ones.

352
00:27:57,010 --> 00:27:58,580
So we got two steps to go.

353
00:27:58,580 --> 00:28:05,530
So when a compiler proceeds to step three, this is where things get converted to machine code.

354
00:28:05,530 --> 00:28:18,550
And when a compiler assembles your code for you, it converts what we just saw on the screen here to actual zeros and ones-- the so-called machine code that your phone or your computer understands.

355
00:28:18,550 --> 00:28:24,280
But it's worth noting that these are not necessarily all of the zeros and ones of your program.

356
00:28:24,280 --> 00:28:36,940
Yes, they are the zeros and ones that correspond to your Hello program or printf and getString and the like, but notice that here, we need one final step.

357
00:28:36,940 --> 00:28:40,100
In those zeros and ones are only your lines of code.

358
00:28:40,100 --> 00:28:43,540
But what about CS50's lines of code that we wrote to implement getString?

359
00:28:43,540 --> 00:28:46,990
What about the lines of code that humans wrote decades ago to implement printf?

360
00:28:46,990 --> 00:28:54,460
Those are somewhere on this hard drive, like on my Mac, my PC, or somewhere in the cloud, but we need to combine all of those zeros and ones

361
00:28:54,460 --> 00:29:02,420
together and link my code with CS50's code with standard I/O's code, all together.

362
00:29:02,420 --> 00:29:11,440
And so what happens in the last step, ultimately, is that if we have my code here in yellow, and then the code that CS50 wrote, and the code that the authors of C

363
00:29:11,440 --> 00:29:19,960
itself wrote, what really is happening is that somewhere, we have not only hello.c, which, obviously, I wrote, and wrote with us live here,

364
00:29:19,960 --> 00:29:28,210
there's also, let's assume, somewhere on the computer, a cs50.c file that, coincidentally, I and CS50 staff wrote years ago.

365
00:29:28,210 --> 00:29:30,790
And also, somewhere on the computer, there's another file.

366
00:29:30,790 --> 00:29:34,120
Let me oversimplify by just calling it stdio.c.

367
00:29:34,120 --> 00:29:36,850
In practice, it's probably specifically called printf.c.

368
00:29:36,850 --> 00:29:39,460
But they're somewhere, these two other files.

369
00:29:39,460 --> 00:29:48,100
And so this last step called linking takes my zeros and ones from the code I just wrote, namely this code on the screen here.

370
00:29:48,100 --> 00:29:50,810
It then grabs the zeros and ones that CS50 wrote.

371
00:29:50,810 --> 00:29:56,240
And it grabs the zeros and ones that the authors of C wrote, in order to implement the standard I/O library.

372
00:29:56,240 --> 00:30:00,750
And lastly, voila, links them all together.

373
00:30:00,750 --> 00:30:03,980
And this is the same blob of zeros and ones that we saw earlier.

374
00:30:03,980 --> 00:30:15,830
It's just now the result of preprocessing your code, compiling your code, assembling your code, linking your code, and my God, at this point, like if there were any fun in programming for you yet,

375
00:30:15,830 --> 00:30:19,620
we've just taken it all away, we just call this whole process compiling.

376
00:30:19,620 --> 00:30:20,120
Why?

377
00:30:20,120 --> 00:30:27,890
Because now that we know those steps exist-- and smart people solve that problem for us-- you and I can kind of operate at this level of abstraction

378
00:30:27,890 --> 00:30:32,420
and just assume that compiling converts source code to machine code.

379
00:30:32,420 --> 00:30:36,350
Questions, though, on any of these intermediate steps?

380
00:30:36,350 --> 00:30:37,360
Yeah?

381
00:30:37,360 --> 00:30:41,958
AUDIENCE: For linking, are different parts, like [INAUDIBLE]??

382
00:30:50,072 --> 00:30:51,280
DAVID MALAN: A good question.

383
00:30:51,280 --> 00:30:53,238
So where are all of these zeros and one stored?

384
00:30:53,238 --> 00:30:58,330
Because you and I, we've been using a browser, right? code.cs50.io, of course, is this web-based user interface.

385
00:30:58,330 --> 00:31:09,000
But again, recall from last week, even though you're using a web browser to access VS Code, that web-based version of VS code is connected to an actual server somewhere in the cloud.

386
00:31:09,000 --> 00:31:15,360
And on that server, you have your own account and your own files, and really, your own hard drive, virtually in the cloud.

387
00:31:15,360 --> 00:31:19,830
Think of it a little like Dropbox or Box or Google Drive or OneDrive or something like that.

388
00:31:19,830 --> 00:31:23,310
So you have a hard drive somewhere out there that we've provisioned for you.

389
00:31:23,310 --> 00:31:32,700
And it's on that hard drive that you have your code that you just wrote, or I just wrote, cs50.c, stdio.c, and all of the other code

390
00:31:32,700 --> 00:31:36,967
that implements the math functions and everything else that C supports.

391
00:31:36,967 --> 00:31:37,550
Good question.

392
00:31:37,550 --> 00:31:38,964
Yeah?

393
00:31:38,964 --> 00:31:51,935
AUDIENCE: So, say in the CS50 library, the line [INAUDIBLE] do we do the same exact thing [INAUDIBLE] copy paste them all the way over?

394
00:31:51,935 --> 00:31:53,060
DAVID MALAN: Good question.

395
00:31:53,060 --> 00:31:57,110
That hash includes cs50.h line at the top of my code.

396
00:31:57,110 --> 00:32:01,310
If I just replace that with the contents of cs50.c, would that work?

397
00:32:01,310 --> 00:32:03,590
Short answer, yes, that would work.

398
00:32:03,590 --> 00:32:05,400
You could copy all of the code there.

399
00:32:05,400 --> 00:32:08,577
However, there's some order of operations that might come into play.

400
00:32:08,577 --> 00:32:10,910
And so it's probably not quite as simple as copy, paste.

401
00:32:10,910 --> 00:32:13,190
But conceptually, yes, that's what's happening.

402
00:32:13,190 --> 00:32:25,670
Now with that said, in cs50.h, are only the prototypes of the functions, the hints as to how the functions look, what their return type is, what their name is, and what their arguments are.

403
00:32:25,670 --> 00:32:29,867
It's in the dot c file that actual code tends to be written.

404
00:32:29,867 --> 00:32:33,920
And this is a little confusing now because you and I have only written code in dot c files.

405
00:32:33,920 --> 00:32:40,460
But in the next few weeks, you'll actually start writing some of your own dot h files as well, just like CS50, just like standard I/O.

406
00:32:40,460 --> 00:32:46,020
But in essence, that line of code just makes it easier to use and reuse code that's already been written.

407
00:32:46,020 --> 00:32:47,750
And that's the whole point of a library.

408
00:32:47,750 --> 00:32:50,327
AUDIENCE: Does linking them [INAUDIBLE]?

409
00:32:50,327 --> 00:32:51,910
DAVID MALAN: Say that a little louder.

410
00:32:51,910 --> 00:32:54,472
AUDIENCE: Does linking happen when you use the compiler?

411
00:32:54,472 --> 00:32:55,180
DAVID MALAN: Yes.

412
00:32:55,180 --> 00:32:56,980
Does linking happen when you compile your code?

413
00:32:56,980 --> 00:32:57,480
Yes.

414
00:32:57,480 --> 00:33:04,570
When you run make, as we have been doing the past week now, all four of these steps are happening.

415
00:33:04,570 --> 00:33:07,780
Preprocessing converts the hash include lines to something else.

416
00:33:07,780 --> 00:33:14,290
Compiling technically converts it to assembly code, which the Mac, the PC, the server more closely understands.

417
00:33:14,290 --> 00:33:20,080
Assembly converts that language to binary machine code that this computer actually understands.

418
00:33:20,080 --> 00:33:22,540
And then linking combines everything together.

419
00:33:22,540 --> 00:33:32,860
And in fact, if you think back a few minutes ago to when I did this -lcs50, the reason I had to add that, and the reason my code did not compile at first, was because I

420
00:33:32,860 --> 00:33:38,650
forgot to tell clang to link in CS50's zeros and ones per that last step.

421
00:33:38,650 --> 00:33:44,480
I don't need to do -lstdio because it comes with C, so that would just be tedious for everyone in the world.

422
00:33:44,480 --> 00:33:47,140
But CS50 does not come with C, so we link that in.

423
00:33:47,140 --> 00:33:49,780
And to be clear, too, we won't always use CS50's library.

424
00:33:49,780 --> 00:33:53,072
That'll be yet another pair of training wheels we take off in the coming weeks.

425
00:33:53,072 --> 00:33:55,000
But for now, it makes a few things simpler.

426
00:33:55,000 --> 00:33:57,284
Yeah?

427
00:33:57,284 --> 00:33:59,750
AUDIENCE: What is the [INAUDIBLE]?

428
00:34:08,878 --> 00:34:10,170
DAVID MALAN: Short answer, yes.

429
00:34:10,170 --> 00:34:12,870
So what do the zeros and ones, the machine code, translate to?

430
00:34:12,870 --> 00:34:17,340
Yes, there is a one-to-one relationship between the machine code and the assembly code.

431
00:34:17,340 --> 00:34:21,510
Assembly code, it's not really English, but at least it's symbols I recognize.

432
00:34:21,510 --> 00:34:22,800
It's not zeros and ones.

433
00:34:22,800 --> 00:34:24,810
Machine code, of course, is just zeros and ones.

434
00:34:24,810 --> 00:34:30,630
So back in the day, before C existed, people were programming only in assembly code.

435
00:34:30,630 --> 00:34:34,469
Before assembly code existed, people were coding in zeros and ones.

436
00:34:34,469 --> 00:34:40,110
And you can imagine just how painful that was, and so each of these languages makes life, for us, sort of easier and easier.

437
00:34:40,110 --> 00:34:48,090
In a few weeks, we'll transition to Python, which will, in turn, make C even simpler-- or coding, in general, simpler to do too.

438
00:34:48,090 --> 00:34:55,060
All right, so with that said, what now can we-- what could go wrong with this?

439
00:34:55,060 --> 00:34:59,233
Well, it turns out that besides compiling, technically speaking, there's decompiling.

440
00:34:59,233 --> 00:35:01,150
And we've not done this, and we won't do this.

441
00:35:01,150 --> 00:35:04,080
But it's worth considering for just a moment.

442
00:35:04,080 --> 00:35:14,580
If you were to not compile your code, but decompile it-- as the word suggests, this just means reversing the process, converting it, ideally, from machine code-- zeros and ones--

443
00:35:14,580 --> 00:35:22,080
maybe back to C. Now this would be cool, perhaps, if all you have is a program, you can convert it and see the actual source code.

444
00:35:22,080 --> 00:35:28,650
What might a downside be, if anyone on the internet is able to decompile code on their machine?

445
00:35:28,650 --> 00:35:29,160
Yeah?

446
00:35:29,160 --> 00:35:30,270
AUDIENCE: [INAUDIBLE]

447
00:35:30,270 --> 00:35:35,430
DAVID MALAN: OK, so it's easier to find bugs in the code that-- oh, to exploit.

448
00:35:35,430 --> 00:35:45,080
So it might be easier to hack into the software by finding mistakes you and I made because, literally, they're staring at you in code, whereas the zeros and ones make it way less obvious.

449
00:35:45,080 --> 00:35:48,140
Other downsides of what I called decompiling?

450
00:35:48,140 --> 00:35:49,970
Yeah?

451
00:35:49,970 --> 00:35:53,690
AUDIENCE: If stuff is copyrighted or you don't even know how to get it--

452
00:35:53,690 --> 00:35:54,440
DAVID MALAN: Yeah.

453
00:35:54,440 --> 00:35:55,948
AUDIENCE: [INAUDIBLE]

454
00:35:55,948 --> 00:36:03,660
DAVID MALAN: Yeah, if your code, your work, is your intellectual property, copyrighted or otherwise, that's kind of obnoxious that someone can just run a command, and boom,

455
00:36:03,660 --> 00:36:05,577
they can see the original code that you wrote.

456
00:36:05,577 --> 00:36:08,490
Now, it turns out it's not quite as simple as that.

457
00:36:08,490 --> 00:36:19,400
And so even though, yes, you could take a program like Hello, or even Microsoft Word, and convert it from zeros and ones back to some form of source code-- be it in C or Java

458
00:36:19,400 --> 00:36:25,800
or Python or something else, whatever it was originally written in-- odds are it's going to be an utter mess to look at.

459
00:36:25,800 --> 00:36:26,300
Why?

460
00:36:26,300 --> 00:36:30,890
Because things variable names are not retained in the zeros and ones, typically.

461
00:36:30,890 --> 00:36:33,980
Function names might not be retained in the zeros and ones.

462
00:36:33,980 --> 00:36:42,890
The code is, the logic is, but the computer doesn't care what pretty variables you chose and how nicely named your functions were, it just needs to know them as zeros and ones.

463
00:36:42,890 --> 00:36:46,370
Moreover, if you think about last week, we introduced things like loops in C.

464
00:36:46,370 --> 00:36:49,745
And besides for loops, there's what other kind of loop, for instance?

465
00:36:49,745 --> 00:36:50,620
AUDIENCE: [INAUDIBLE]

466
00:36:50,620 --> 00:36:59,910
DAVID MALAN: So, a while loop-- and even though they look different and you have to write different code, they achieve exactly the same functionality, which is to say, when you compile a for loop

467
00:36:59,910 --> 00:37:07,420
or you compile a while loop, if they logically do the same thing, they might end up looking identical as zeros and ones.

468
00:37:07,420 --> 00:37:11,820
And so, therefore, it's not necessarily predictable that you'll get back the original code, why?

469
00:37:11,820 --> 00:37:19,350
Because the zeros and ones might not know, so to speak, whether it was a for loop or a while loop, so maybe compiling will show you one or the other.

470
00:37:19,350 --> 00:37:24,570
And honestly, decompiling, while possible-- and it's one way of reverse engineering someone's product.

471
00:37:24,570 --> 00:37:34,020
Odds are, if you're good enough to start reading code that's been decompiled and reading through the messiness of it, odds are you have the talent probably to just write that same program from scratch

472
00:37:34,020 --> 00:37:34,650
yourself.

473
00:37:34,650 --> 00:37:40,410
Now, that's an overstatement, perhaps, but it's not quite as easy or threatening as you might first think.

474
00:37:40,410 --> 00:37:50,040
So in general, once code is compiled, it's pretty challenging, time consuming, costly to reverse engineer it, much like it would be in the real world, right?

475
00:37:50,040 --> 00:37:52,860
Like all of us have some kind of phone, probably, nowadays in our pocket.

476
00:37:52,860 --> 00:37:57,060
There's nothing stopping you from opening it up somehow, poking around, recreating what's there.

477
00:37:57,060 --> 00:37:59,130
That's a huge amount of effort, most likely.

478
00:37:59,130 --> 00:38:03,310
And at that point, maybe you should just invent the phone, instead of trying to reverse engineer it.

479
00:38:03,310 --> 00:38:06,330
So same kind of idea in the physical world.

480
00:38:06,330 --> 00:38:13,050
Any questions, then, on compiling, or even decompiling in these forms?

481
00:38:13,050 --> 00:38:17,160
All right, so odds are, at this point, not only I, but you have made mistakes.

482
00:38:17,160 --> 00:38:26,490
And you've written buggy code-- a bug in a code is just a mistake, a logical error or otherwise, where the code just does not behave correctly as you intend.

483
00:38:26,490 --> 00:38:35,320
And up until now, odds are, your debugging techniques have been to maybe look back at what I did in class, maybe ask a question online or in-person.

484
00:38:35,320 --> 00:38:39,570
But ultimately, it'd be nice if you had some tools of your own with which to debug code.

485
00:38:39,570 --> 00:38:41,587
And this, honestly, is a lifelong skill.

486
00:38:41,587 --> 00:38:47,910
You're not going to emerge from CS50-- and even 20 years from now, you're not going to be writing-- if you're writing code at all-- correct code all of the time.

487
00:38:47,910 --> 00:38:50,820
Like, all of us on the staff continue to write bugs.

488
00:38:50,820 --> 00:38:55,540
Hopefully, they get a little more sophisticated, and not sort of like, oops, I missed a semicolon.

489
00:38:55,540 --> 00:38:57,660
But even those kinds of mistakes, we make too.

490
00:38:57,660 --> 00:39:03,550
But there's tools out there and techniques that can make your life easier when it comes to solving those problems.

491
00:39:03,550 --> 00:39:06,360
Now, the term bug has actually been around for decades.

492
00:39:06,360 --> 00:39:13,650
But a fun story to tell is that the first documented actual bug was actually somehow connected to Harvard.

493
00:39:13,650 --> 00:39:22,890
In fact, this is the logbook relating to the Harvard Mark II computer from 1947, whereby if you read the notes here-- and I'll Zoom in-- this

494
00:39:22,890 --> 00:39:29,160
was an actual moth discovered inside of this big mainframe computer that was causing some kind of problems.

495
00:39:29,160 --> 00:39:33,610
And the engineers there at the time actually thought it was funny that, wow, physical bug actually explains the issue.

496
00:39:33,610 --> 00:39:39,090
And it's been forever taped to this sheet of paper, which I believe now is on display in the Smithsonian.

497
00:39:39,090 --> 00:39:43,260
With that said, this is just representative, too, of a logical bug.

498
00:39:43,260 --> 00:39:53,640
And that story is actually-- that story was often retold by a famous mathematician, then computer scientist really, Dr. Grace Hopper, who actually worked not only on the Harvard Mark II

499
00:39:53,640 --> 00:39:57,210
computer, but its predecessor, the Harvard Mark I.

500
00:39:57,210 --> 00:40:04,103
And if you ever spent time, yet, in the engineering building across the river here, you can actually see much of this computer, which

501
00:40:04,103 --> 00:40:07,020
is along the wall when you first walk into the Science and Engineering

502
00:40:07,020 --> 00:40:07,530
Complex.

503
00:40:07,530 --> 00:40:11,070
And indeed, as you've probably heard growing up, this is a mainframe computer.

504
00:40:11,070 --> 00:40:18,240
This is what Macs and PCs, so to speak, looked like back in the day, with very physical things that essentially implemented the zeros

505
00:40:18,240 --> 00:40:22,410
and ones that you and I take for granted now being miniaturized in our laptops and phones.

506
00:40:22,410 --> 00:40:23,910
So there's a piece of history there.

507
00:40:23,910 --> 00:40:27,390
If you visit that side of campus sometime, do take a look.

508
00:40:27,390 --> 00:40:31,350
But let's consider, then, how we solve not, of course, physical bugs, but logical bugs.

509
00:40:31,350 --> 00:40:40,320
And let's consider something like this from last week, whereby, we were trying very simply to print like this column of three bricks using hashtags of sorts.

510
00:40:40,320 --> 00:40:44,400
So let me go over here in just a moment to VS Code.

511
00:40:44,400 --> 00:40:47,080
And I'm going to go ahead and open a program I wrote in advance.

512
00:40:47,080 --> 00:40:51,510
And I'm bringing it to class because there's a bug in it, and I'd like to figure out how to solve this bug.

513
00:40:51,510 --> 00:40:56,160
So let me open up a buggy0.c, which is version 0 of my code.

514
00:40:56,160 --> 00:40:58,200
And let's just take a quick peek at what's here.

515
00:40:58,200 --> 00:40:58,950
It's pretty short.

516
00:40:58,950 --> 00:41:07,797
It includes only stdio.h, it uses printf, it uses a for loop, and the goal, quite simply, is to print out that column of three bricks.

517
00:41:07,797 --> 00:41:13,360
Now, it's short enough that some of you, if you're getting comfy already with C, you might already see the logical bug.

518
00:41:13,360 --> 00:41:16,200
It's not a syntax error, like it will compile and run.

519
00:41:16,200 --> 00:41:17,280
But there's a bug there.

520
00:41:17,280 --> 00:41:27,745
And suppose that I'm very new to C, I'm very uncomfortable with C, it's 2:00 AM and I just can't see the bug, what are my recourses here for actually finding a mistake like this?

521
00:41:27,745 --> 00:41:29,370
Well, first, let's look at the symptom.

522
00:41:29,370 --> 00:41:31,740
Let me go down to my terminal window.

523
00:41:31,740 --> 00:41:36,120
I'm going to use make buggy0 because, again, the file is called buggyo.c.

524
00:41:36,120 --> 00:41:37,260
I'm not going to use clang.

525
00:41:37,260 --> 00:41:39,880
In fact, I'm never really going to use clang manually here on out.

526
00:41:39,880 --> 00:41:42,430
I'm just going to use make because it makes our lives easier.

527
00:41:42,430 --> 00:41:43,560
It does compile.

528
00:41:43,560 --> 00:41:45,390
No errors, so it's not syntax.

529
00:41:45,390 --> 00:41:47,670
It's not something silly like a missing semicolon.

530
00:41:47,670 --> 00:41:59,610
But when I run ./buggy0, I, of course, see one, two, three, four-- and this, of course, does not match the one, two, three bricks that I actually intended for that column.

531
00:41:59,610 --> 00:42:02,970
And yet, I'm starting counting at 0, as I usually do.

532
00:42:02,970 --> 00:42:03,930
I've got three.

533
00:42:03,930 --> 00:42:05,280
I'm going up to three.

534
00:42:05,280 --> 00:42:06,780
So where is my logical error?

535
00:42:06,780 --> 00:42:10,150
If it hasn't obviously jumped out at you already, well, how can I solve this?

536
00:42:10,150 --> 00:42:16,080
Well, first and foremost, perhaps the best technique for solving bugs, at least early on, is just use printf.

537
00:42:16,080 --> 00:42:20,020
Like thus far, we've used sprint say, Hello, and other things on the screen.

538
00:42:20,020 --> 00:42:22,530
But printf is just a function for printing anything.

539
00:42:22,530 --> 00:42:31,350
And there's no reason you can't temporarily use printf to print out the contents of variables, what's going on inside of your program, just to figure out where your mistake is.

540
00:42:31,350 --> 00:42:32,940
And then you can delete that line of code later.

541
00:42:32,940 --> 00:42:34,600
It doesn't have to stay there forever.

542
00:42:34,600 --> 00:42:35,740
So let me do this.

543
00:42:35,740 --> 00:42:45,690
Instead of just printing out in VS Code the hash symbol, let me do a little safety check here and print out the value of i.

544
00:42:45,690 --> 00:42:51,610
So let me go ahead and say something like, i is-- now I want to say i is this.

545
00:42:51,610 --> 00:42:54,540
But, of course, this is not how I print out the value of i.

546
00:42:54,540 --> 00:42:58,930
If I want to print out the value of i, what should I put here?

547
00:42:58,930 --> 00:43:02,160
So %i for integer, instead of %s for string.

548
00:43:02,160 --> 00:43:03,410
So they're still placeholders.

549
00:43:03,410 --> 00:43:04,930
But we use %s for integers.

550
00:43:04,930 --> 00:43:09,250
And now if I want to print out i, I just need the comma as the second argument, and then i.

551
00:43:09,250 --> 00:43:13,000
All right, let me go ahead and back to my terminal window.

552
00:43:13,000 --> 00:43:15,760
Let me recompile the program because I've changed it.

553
00:43:15,760 --> 00:43:18,880
That still works fine, ./buggy0.

554
00:43:18,880 --> 00:43:22,540
And now, let me increase the size of my terminal window here.

555
00:43:22,540 --> 00:43:25,510
You just see some diagnostic information, if you will.

556
00:43:25,510 --> 00:43:26,560
This is not the goal.

557
00:43:26,560 --> 00:43:30,070
This is not what you should be submitting for this homework problem, were it one.

558
00:43:30,070 --> 00:43:34,450
But it is helping us diagnostically know that, OK, when i is zero, here's a hash.

559
00:43:34,450 --> 00:43:36,182
When i is 1, here's a hash.

560
00:43:36,182 --> 00:43:37,390
When i is two, here's a hash.

561
00:43:37,390 --> 00:43:39,017
When i is 3, here's a hash.

562
00:43:39,017 --> 00:43:39,850
Well, wait a minute.

563
00:43:39,850 --> 00:43:41,530
That's one, two, three, four.

564
00:43:41,530 --> 00:43:44,360
So clearly, I'm printing it one too many times.

565
00:43:44,360 --> 00:43:48,130
So let me look back at the code here by shrinking my terminal window.

566
00:43:48,130 --> 00:43:53,080
And let me just ask the group, where is, in fact, the mistake?

567
00:43:53,080 --> 00:43:56,080
Or what, equivalently, would be the solution?

568
00:43:56,080 --> 00:43:57,561
Yeah, in the middle.

569
00:43:57,561 --> 00:44:00,020
AUDIENCE: [INAUDIBLE]

570
00:44:00,020 --> 00:44:03,550
DAVID MALAN: Yeah, instead of less than or equal to, use just less than.

571
00:44:03,550 --> 00:44:05,300
So you've got to kind of pick a lane here.

572
00:44:05,300 --> 00:44:10,880
If you're going to start counting from 0, you generally use less than, and go up to, but not through the value.

573
00:44:10,880 --> 00:44:17,300
Or if you prefer, like in the human world, counting from 1 on up, you can use less than or equal to, but you have to be consistent.

574
00:44:17,300 --> 00:44:22,610
And in general, as a programmer, just always start counting from 0 if you're doing something canonical like this.

575
00:44:22,610 --> 00:44:27,860
But the solution is, indeed, just to change this by changing the greater less than or equal to the less than.

576
00:44:27,860 --> 00:44:36,500
If I recompile this program with make buggy0, and then do .buggy0 again-- and let me increase the size of my terminal window.

577
00:44:36,500 --> 00:44:39,050
Now, you see, OK, almost the same output.

578
00:44:39,050 --> 00:44:44,330
But indeed, i starts at 0 and goes up to, but not through, three.

579
00:44:44,330 --> 00:44:48,920
All right, so printf, in short, can be your first diagnostic tool.

580
00:44:48,920 --> 00:44:51,500
Instead of just staring at the screen or raising your hand--

581
00:44:51,500 --> 00:44:57,287
I mean, use printf to see, literally, what's going on inside of your program by just printing out things of interest.

582
00:44:57,287 --> 00:45:02,840
And then once you've solved the problem, you can go back into your code, as I'll do here, by shrinking my terminal window.

583
00:45:02,840 --> 00:45:04,610
I'll delete the printf line.

584
00:45:04,610 --> 00:45:08,870
And now I'm ready to share this program with the world or submit it as homework or the like.

585
00:45:08,870 --> 00:45:11,390
It's just meant there to be temporary.

586
00:45:11,390 --> 00:45:15,440
Any questions on printf as a debugging tool?

587
00:45:18,010 --> 00:45:18,510
No?

588
00:45:18,510 --> 00:45:20,970
All right, well, that only gets us so far.

589
00:45:20,970 --> 00:45:28,860
And honestly, as your programs grow and grow and grow, it's going to actually get really annoying to start going in and adding printf's, then removing them, and figuring out,

590
00:45:28,860 --> 00:45:31,860
if you've got multiple printf's, well, which one printed what?

591
00:45:31,860 --> 00:45:34,560
It just gets messy, eventually, to rely on printf alone.

592
00:45:34,560 --> 00:45:41,040
So being a computer scientist, computer scientists have written software to make it easier to debug code.

593
00:45:41,040 --> 00:45:48,610
That software is what we would generally call a debugger, which would be the second tool of the trade that you can use to actually solve problems in your code.

594
00:45:48,610 --> 00:45:52,690
Now, in the world of VS code, there's actually a debugger built in.

595
00:45:52,690 --> 00:45:58,260
So the graphical user interface you're about to see in VS Code isn't specific to CS50, it actually comes with VS Code.

596
00:45:58,260 --> 00:46:03,030
And it supports C, and C++, and Java, and Python, and lots of other languages too.

597
00:46:03,030 --> 00:46:07,650
But it's, admittedly, a little complicated to just start using the debugger.

598
00:46:07,650 --> 00:46:13,480
You have to create a configuration file and do some annoying steps that just get in the way of solving real problems.

599
00:46:13,480 --> 00:46:17,070
So we have automated the process for you of just starting the debugger.

600
00:46:17,070 --> 00:46:19,680
And thereafter, it's sort of industry standard how you use it.

601
00:46:19,680 --> 00:46:23,380
But we save you the headache of having to create those configuration files.

602
00:46:23,380 --> 00:46:25,330
So, suppose I want to do this.

603
00:46:25,330 --> 00:46:30,330
Suppose I want to try to debug this program step by step using special software.

604
00:46:30,330 --> 00:46:31,810
Well, how can I do that?

605
00:46:31,810 --> 00:46:41,790
Well, let me propose that if I revert this back to the original version where i was less than or equal to 3, I'm pretty sure that I was printing too many hashes.

606
00:46:41,790 --> 00:46:45,160
So I'm going to do this-- and you might have done this accidentally or never at all.

607
00:46:45,160 --> 00:46:54,390
But notice if you hover over the gutter, so to speak, in VS Code, the part of it all the way to the left of the editor, you see this sort of grayed out red dot.

608
00:46:54,390 --> 00:46:57,240
If you click there, it becomes a brighter red dot.

609
00:46:57,240 --> 00:46:59,670
And this represents what we're going to call a breakpoint.

610
00:46:59,670 --> 00:47:07,350
And this is just a visual indicator that you've put like a stop sign equivalent there, and you're telling the debugger in a moment, stop running my code there.

611
00:47:07,350 --> 00:47:07,920
Why?

612
00:47:07,920 --> 00:47:14,380
Because I prefer to step through my code at sort of a human speed, and not as computer speed where it runs all at once.

613
00:47:14,380 --> 00:47:16,750
So I've set my breakpoint, which is step one.

614
00:47:16,750 --> 00:47:18,580
And then step two is quite simply this.

615
00:47:18,580 --> 00:47:26,010
Instead of running the program itself, run the command called debug50, and then ./buggy0.

616
00:47:26,010 --> 00:47:33,060
And now this will start your program, but inside of the debugger, which is a special program that smart people wrote that will empower

617
00:47:33,060 --> 00:47:38,970
you to now step through your code line by line, and again, at your own comfort pace.

618
00:47:38,970 --> 00:47:43,080
I'm going to hit Enter, some stuff's going to happen on the screen-- whoops.

619
00:47:43,080 --> 00:47:45,767
Notice, this is a common mistake that I made accidentally here.

620
00:47:45,767 --> 00:47:47,100
Looks like I've changed my code.

621
00:47:47,100 --> 00:47:49,892
I did because I went in and changed the less than or equal to sign.

622
00:47:49,892 --> 00:47:52,860
So let me go ahead and rerun make buggy0--

623
00:47:52,860 --> 00:47:53,520
Enter.

624
00:47:53,520 --> 00:47:55,590
Good, now let me rerun debug50--

625
00:47:55,590 --> 00:47:57,810
Enter.

626
00:47:57,810 --> 00:48:06,010
And now some stuff just happened on the screen and it takes a moment to get started but once it's started you'll see this you'll still see your code.

627
00:48:06,010 --> 00:48:09,410
But you'll see this yellow highlight, which you've probably not seen before.

628
00:48:09,410 --> 00:48:13,440
And notice that it's specifically highlighting the same line that I set a breakpoint on.

629
00:48:13,440 --> 00:48:13,950
Why?

630
00:48:13,950 --> 00:48:20,670
That just means the debugger has executed all of these lines, except for line 7.

631
00:48:20,670 --> 00:48:23,340
It has broken at-- not in a bad way.

632
00:48:23,340 --> 00:48:27,580
But it has paused execution on line 7, so it hasn't yet printed any hashes.

633
00:48:27,580 --> 00:48:30,450
And you can see that-- no hashes in the terminal window yet.

634
00:48:30,450 --> 00:48:31,980
It's paused execution.

635
00:48:31,980 --> 00:48:37,410
But what's interesting with the debugger is the stuff over here on the left-hand side.

636
00:48:37,410 --> 00:48:41,910
In the debugger here, you'll see, under variables, all of your so-called local variables.

637
00:48:41,910 --> 00:48:45,327
And we haven't really made a distinction between local and something called global.

638
00:48:45,327 --> 00:48:49,390
But for now, local variables just means all of the variables that exist in your function.

639
00:48:49,390 --> 00:48:52,110
So i currently has a value of 0.

640
00:48:52,110 --> 00:48:53,410
OK, and that makes sense.

641
00:48:53,410 --> 00:48:57,360
So now, how do I step through my code and see what it's doing?

642
00:48:57,360 --> 00:49:03,630
Well, at the top of the screen here, you'll see some playback icons, kind of like a video player, but they have special meaning.

643
00:49:03,630 --> 00:49:07,892
This first one will just play the rest of your program all the way to the end.

644
00:49:07,892 --> 00:49:13,110
So you only click that if you've sort of solved the problem and you just want to run it to completion like before.

645
00:49:13,110 --> 00:49:16,920
But the next three-- or next two, really, are really the juiciest.

646
00:49:16,920 --> 00:49:21,930
The second one here, if you hover over it, eventually, you'll see that it's called Step Over.

647
00:49:21,930 --> 00:49:28,630
Step Over means that the debugger will run this currently highlighted line of code, but it's not going to dive into it.

648
00:49:28,630 --> 00:49:32,827
So if it's a function like printf, it's not going to start stepping through printf line by line.

649
00:49:32,827 --> 00:49:33,327
Why?

650
00:49:33,327 --> 00:49:36,420
Because I can pretty much assume printf, written decades ago, is correct.

651
00:49:36,420 --> 00:49:38,050
Problem's probably with me.

652
00:49:38,050 --> 00:49:46,110
But this next line, if I did really want to step into the printf code to figure out how it works or find some problem in it all these years later,

653
00:49:46,110 --> 00:49:54,250
you can step into printf, and then the screen would change, and you'd see each of the lines for printf, line by line-- at least if you have the source code for printf installed.

654
00:49:54,250 --> 00:49:56,490
All right, I'm going to use the first one, Step Over.

655
00:49:56,490 --> 00:49:59,130
And watch as the yellow highlight moves.

656
00:49:59,130 --> 00:50:03,060
And watch as, in the terminal window, there's a hash symbol.

657
00:50:03,060 --> 00:50:03,780
Here we go.

658
00:50:03,780 --> 00:50:05,130
There's one hash.

659
00:50:05,130 --> 00:50:07,230
Now, notice line 5 is highlighted.

660
00:50:07,230 --> 00:50:09,480
That means it has paused on line 5.

661
00:50:09,480 --> 00:50:11,350
Line 5 has not yet been executed.

662
00:50:11,350 --> 00:50:12,600
So what does that mean?

663
00:50:12,600 --> 00:50:16,320
The value of i, per the top left-hand corner, is still 0.

664
00:50:16,320 --> 00:50:24,470
But as soon as I click Step Over again, watch what happens at the top left, where i is a variable on the screen.

665
00:50:24,470 --> 00:50:27,920
Now i-- and it flashed briefly-- has a value of 1.

666
00:50:27,920 --> 00:50:30,650
And now if I step over again, watch the terminal window.

667
00:50:30,650 --> 00:50:32,120
There's my second hash.

668
00:50:32,120 --> 00:50:36,380
Now, let me click Step Over on for loop, watch the variable at top left.

669
00:50:36,380 --> 00:50:38,567
Now 1 goes to 2.

670
00:50:38,567 --> 00:50:39,650
Now let me click it again.

671
00:50:39,650 --> 00:50:43,220
Third hash-- and here's where the logical error is perhaps revealed.

672
00:50:43,220 --> 00:50:45,210
Let me go ahead and step over the loop.

673
00:50:45,210 --> 00:50:46,520
Now i is 3.

674
00:50:46,520 --> 00:50:49,280
Wait a minute, I'm still going to print out a hash.

675
00:50:49,280 --> 00:50:49,810
There it is.

676
00:50:49,810 --> 00:50:50,810
There's the fourth hash.

677
00:50:50,810 --> 00:50:53,852
And at this point, hopefully, the light bulb, proverbially, has gone off.

678
00:50:53,852 --> 00:50:55,020
I realize, oh, I screwed up.

679
00:50:55,020 --> 00:51:02,493
I can either stop the program altogether with the red square, or I can just let it run all the way to the end, which just terminates everything.

680
00:51:02,493 --> 00:51:05,660
At this point, I just want to get back into my code and start fixing things.

681
00:51:05,660 --> 00:51:10,670
And you can close, for instance, as I will here, the File Explorer, just to hide the panel that opened.

682
00:51:10,670 --> 00:51:12,320
So that's debug50.

683
00:51:12,320 --> 00:51:19,520
But it's not a CS50 thing, that just starts the debugger for you, which is something you'd find in most any programming environment nowadays.

684
00:51:19,520 --> 00:51:23,670
Questions on debugging?

685
00:51:23,670 --> 00:51:24,170
Questions?

686
00:51:24,170 --> 00:51:24,670
Yeah?

687
00:51:24,670 --> 00:51:27,295
AUDIENCE: Where does it tell you where it went wrong?

688
00:51:27,295 --> 00:51:28,420
DAVID MALAN: Good question.

689
00:51:28,420 --> 00:51:30,310
Where does it tell you where it went wrong?

690
00:51:30,310 --> 00:51:33,190
So, sadly, it does not tell you any of that.

691
00:51:33,190 --> 00:51:39,580
The onus is still on you, the human, to use this tool productively to walk through your code at a saner pace.

692
00:51:39,580 --> 00:51:42,070
But your brain is the one that still needs to solve it.

693
00:51:42,070 --> 00:51:49,160
And I don't doubt, down the line, with artificial intelligence and more, programs like this will get all the more helpful, and start answering questions like that for us.

694
00:51:49,160 --> 00:51:52,990
And there are other tools we'll introduce you this semester that are even more powerful than this.

695
00:51:52,990 --> 00:51:57,820
But for now, it's just a tool, really, to slow things down and not have to change your code.

696
00:51:57,820 --> 00:52:06,820
The fact that I had that panel on the left that just showed me i's changing value is just an alternative to printf, and I can step through it a little more slowly.

697
00:52:06,820 --> 00:52:10,580
Other questions on debugging?

698
00:52:10,580 --> 00:52:11,080
No?

699
00:52:11,080 --> 00:52:14,950
Let me show you one final example with this debugger here.

700
00:52:14,950 --> 00:52:16,750
And this one, too, I wrote in advance.

701
00:52:16,750 --> 00:52:18,730
Let me close buggy0.c.

702
00:52:18,730 --> 00:52:22,327
And let me open up buggy1.c, my second version thereof.

703
00:52:22,327 --> 00:52:28,030
Let me close my terminal window for a second and give you a quick tour of this program, which similarly, has a mistake.

704
00:52:28,030 --> 00:52:32,830
Now, at the top of this program, some familiar includes, cs50.h and stdio.h.

705
00:52:32,830 --> 00:52:34,730
This is not something we've seen before.

706
00:52:34,730 --> 00:52:38,830
It's specific to this example-- a function called getNegativeInt.

707
00:52:38,830 --> 00:52:41,043
Takes no arguments, and it returns an integer.

708
00:52:41,043 --> 00:52:41,710
What does it do?

709
00:52:41,710 --> 00:52:45,040
It literally gets a negative integer, ideally, from the user.

710
00:52:45,040 --> 00:52:47,200
Fun fact, though, it doesn't correctly.

711
00:52:47,200 --> 00:52:50,090
That's the bug. getNegativeInt is broken at the moment.

712
00:52:50,090 --> 00:52:51,470
So what does main do?

713
00:52:51,470 --> 00:52:55,690
Well, main just calls this function, passing in nothing in parentheses, no inputs.

714
00:52:55,690 --> 00:52:58,240
And it stores the return value in i.

715
00:52:58,240 --> 00:53:00,260
And then it just prints out i on the screen.

716
00:53:00,260 --> 00:53:06,365
So honestly, just by eyeballing this, I feel comfortable enough with programming in C, I think main is correct.

717
00:53:06,365 --> 00:53:07,990
Let me just stipulate, main is correct.

718
00:53:07,990 --> 00:53:09,698
But there is going to be a bug down here.

719
00:53:09,698 --> 00:53:11,210
Now, what's the bug down here?

720
00:53:11,210 --> 00:53:14,830
Well, let me look at getNegativeInt's implementation.

721
00:53:14,830 --> 00:53:18,970
Notice, this first line, 12, is identical to the prototype up here.

722
00:53:18,970 --> 00:53:26,690
The prototype is sort of stupidly required up here because C reads things top to bottom, left to right-- the compiler technically does.

723
00:53:26,690 --> 00:53:36,820
So if you reference getNegativeInt here, but you don't implement it until down here, and you haven't told C in advance that it will exist, again, you get the error we saw last week.

724
00:53:36,820 --> 00:53:39,010
All right, so how does getNegativeInt work?

725
00:53:39,010 --> 00:53:40,960
We declare a variable called n.

726
00:53:40,960 --> 00:53:43,540
We've got to do while loop that does what?

727
00:53:43,540 --> 00:53:47,110
It uses getInt, which comes with the cs50 library, per last week.

728
00:53:47,110 --> 00:53:51,670
It prompts the user for negative integer, quote unquote, and stores the value in n.

729
00:53:51,670 --> 00:53:56,800
I then do all of this while n is less than 0, right?

730
00:53:56,800 --> 00:54:04,970
Remember, we used to do while loop last week to make sure the human cooperates and doesn't give us the wrong type of value, be it positive or negative or something else.

731
00:54:04,970 --> 00:54:06,400
And then we return n.

732
00:54:06,400 --> 00:54:07,570
And there's some subtleties.

733
00:54:07,570 --> 00:54:15,790
Anyone recall-- or have an intuition for why I've declared n on line 14, instead of line 17?

734
00:54:15,790 --> 00:54:17,620
This is a C specific thing.

735
00:54:17,620 --> 00:54:23,465
AUDIENCE: [INAUDIBLE]

736
00:54:23,465 --> 00:54:24,340
DAVID MALAN: Exactly.

737
00:54:24,340 --> 00:54:33,560
There's this notion of scope in C. And we'll continue to see this over time, whereby, a variable only exists inside of the most recent curly braces that you've opened.

738
00:54:33,560 --> 00:54:40,900
So if I've declared n here on line 14, I can use it anywhere between lines 13 and 21 because those are the nearest curly braces.

739
00:54:40,900 --> 00:54:53,470
If by contrast, as you note, if I instead said this, int n equals getInt and so forth, and didn't have the current line 14, well, n would exist inside of these curly braces, but not here, which

740
00:54:53,470 --> 00:54:55,340
is too late, and definitely not here.

741
00:54:55,340 --> 00:54:59,480
So you just have to declare it first, and then use and reuse it as such.

742
00:54:59,480 --> 00:55:01,545
Now, let me just show you how I can debug this.

743
00:55:01,545 --> 00:55:03,170
But let me show you the symptoms first.

744
00:55:03,170 --> 00:55:04,930
Let me open my terminal window.

745
00:55:04,930 --> 00:55:06,970
Let me run make buggy1.

746
00:55:06,970 --> 00:55:13,660
Compiles OK, so it's not something silly like a semicolon. ./buggy1, and I'm asked for a negative integer.

747
00:55:13,660 --> 00:55:15,280
All right, let me give it negative 1--

748
00:55:15,280 --> 00:55:16,710
Enter.

749
00:55:16,710 --> 00:55:20,880
Well, the main function is supposed to print out what I typed, but it clearly didn't.

750
00:55:20,880 --> 00:55:21,880
It's prompting me again.

751
00:55:21,880 --> 00:55:23,830
All right, so maybe it'll like negative 2.

752
00:55:23,830 --> 00:55:24,330
No?

753
00:55:24,330 --> 00:55:26,380
Maybe negative 3.

754
00:55:26,380 --> 00:55:27,570
50?

755
00:55:27,570 --> 00:55:29,160
OK, so it's definitely broken, right?

756
00:55:29,160 --> 00:55:31,528
It kind of seems logically to be doing the opposite.

757
00:55:31,528 --> 00:55:33,820
Now, you can perhaps see why this is happening already.

758
00:55:33,820 --> 00:55:37,170
These are deliberately simple programs for demonstrations sake.

759
00:55:37,170 --> 00:55:38,470
But let's do this.

760
00:55:38,470 --> 00:55:42,870
Let me go ahead and set a breakpoint in main, even though I'm pretty sure main is correct.

761
00:55:42,870 --> 00:55:47,010
But it just helps me start my thought process-- start with main, and then take it from there.

762
00:55:47,010 --> 00:55:51,840
Let me run now, debug50 ./buggy1--

763
00:55:51,840 --> 00:55:52,920
Enter.

764
00:55:52,920 --> 00:55:53,700
And let's see.

765
00:55:53,700 --> 00:55:56,880
With that breakpoint now, the GUI is going to reconfigure itself.

766
00:55:56,880 --> 00:56:01,260
It's going to pause on line 8 because that's the first interesting line inside of main.

767
00:56:01,260 --> 00:56:03,780
So I could have just put the breakpoint on line 8 too.

768
00:56:03,780 --> 00:56:09,570
It's smart enough to know that if I set it on 6, you really mean line 8 because that's the first actual line of code.

769
00:56:09,570 --> 00:56:11,280
And watch, now, what happens.

770
00:56:11,280 --> 00:56:19,470
If I step over this line, notice that i, which at the moment seems to have a default value of 0-- more on that another time.

771
00:56:19,470 --> 00:56:24,750
But if I click Step Over like before, I'm prompted for a negative integer.

772
00:56:24,750 --> 00:56:25,750
Let me type negative 1--

773
00:56:25,750 --> 00:56:27,300
Enter.

774
00:56:27,300 --> 00:56:32,470
And now, notice, there's no additional yellow highlight.

775
00:56:32,470 --> 00:56:32,970
Why?

776
00:56:32,970 --> 00:56:35,160
Where am I currently stuck, logically?

777
00:56:35,160 --> 00:56:37,937
AUDIENCE: [INAUDIBLE]

778
00:56:37,937 --> 00:56:40,770
DAVID MALAN: Yeah, just logically, I must be in that do, while loop.

779
00:56:40,770 --> 00:56:43,560
And even if you don't understand it, like that's the only explanation.

780
00:56:43,560 --> 00:56:46,143
If you keep getting prompted, surely, there's a loop going on.

781
00:56:46,143 --> 00:56:49,270
There's only one loop in my code, so there's probably a problem there.

782
00:56:49,270 --> 00:56:52,900
So I can't just set a breakpoint in main, and then wait for this to work.

783
00:56:52,900 --> 00:56:56,280
So let me just-- let me stop this with the red square.

784
00:56:56,280 --> 00:56:58,860
And let me think, all right, instead of--

785
00:56:58,860 --> 00:57:02,770
I can still set my breakpoint in main, but let me rerun the debugger instead.

786
00:57:02,770 --> 00:57:07,930
And this time, not step over that line of code, let me step into that line of code.

787
00:57:07,930 --> 00:57:09,270
So watch what happens now.

788
00:57:09,270 --> 00:57:14,610
Instead of clicking the second icon here, let me click the third, whose name is, indeed, Step Into.

789
00:57:14,610 --> 00:57:17,880
And watch as the yellow highlight does not move to line 9.

790
00:57:17,880 --> 00:57:25,170
It dives into line 8-- the function on line 8, thereby, bringing me down to line 17.

791
00:57:25,170 --> 00:57:28,270
It's kind of going down into that next function.

792
00:57:28,270 --> 00:57:34,380
Now, it didn't bother pausing on line 12 or 13 or 14 because there's nothing intellectually interesting there happening yet.

793
00:57:34,380 --> 00:57:37,080
The juicy part really starts, it would seem, in line 17.

794
00:57:37,080 --> 00:57:40,980
So, now notice, n is my variable at the top left.

795
00:57:40,980 --> 00:57:42,270
If I click--

796
00:57:42,270 --> 00:57:45,420
I don't want to click Step Into now, though.

797
00:57:45,420 --> 00:57:52,480
What would go wrong if I click on Step Into-- or what would it do that I don't think I want to do?

798
00:57:52,480 --> 00:57:52,990
Yeah?

799
00:57:52,990 --> 00:57:54,755
AUDIENCE: [INAUDIBLE]

800
00:57:54,755 --> 00:57:56,630
DAVID MALAN: Yeah, it would step into getInt.

801
00:57:56,630 --> 00:58:02,120
But I'd like to think that the staff's version of getInt is correct, and that's not our problem today, so I want to step over it.

802
00:58:02,120 --> 00:58:10,670
And watch now at top left that nothing happens yet to the value of n until I go to the terminal window now, and I type in something like negative 1.

803
00:58:10,670 --> 00:58:14,600
Now notice, it jumps to line 19, which is the next interesting line.

804
00:58:14,600 --> 00:58:17,240
Top left, n, indeed, is negative 1.

805
00:58:17,240 --> 00:58:22,760
And here's where I can now pause as a human and think, all right, so while n is less than 0.

806
00:58:22,760 --> 00:58:25,280
All right, n, per the top left corner, is negative 1.

807
00:58:25,280 --> 00:58:29,780
So all right, while negative 1 is less than 0, well, obviously that's true mathematically.

808
00:58:29,780 --> 00:58:30,930
So what's going to happen?

809
00:58:30,930 --> 00:58:32,130
It's a do while loop.

810
00:58:32,130 --> 00:58:39,410
So when I click on Step Over again, it's going to go to this line because it's at the end of the inside of that loop.

811
00:58:39,410 --> 00:58:42,710
And now here, it's looping through again and again.

812
00:58:42,710 --> 00:58:44,240
All right, let me do this once more.

813
00:58:44,240 --> 00:58:45,980
I'm going to step over, all right?

814
00:58:45,980 --> 00:58:48,777
I'm going to type in negative 2, and it's the exact same thing.

815
00:58:48,777 --> 00:58:50,360
Now is my chance, on the yellow line--

816
00:58:50,360 --> 00:58:51,260
OK, wait a minute.

817
00:58:51,260 --> 00:58:53,450
Negative 2 is obviously less than 0.

818
00:58:53,450 --> 00:58:56,080
Let me try this one more time.

819
00:58:56,080 --> 00:58:57,570
Click it once here.

820
00:58:57,570 --> 00:58:59,040
All right, let me give it 50.

821
00:58:59,040 --> 00:59:08,970
And now, OK, while 50 is less than 0, that's not true, so the loop is over because it's not going to do it while 50 is less than 0.

822
00:59:08,970 --> 00:59:09,730
That's not true.

823
00:59:09,730 --> 00:59:15,810
So now watch, when I click Step Over once more, it then finishes the loop, even though there's nothing more to do.

824
00:59:15,810 --> 00:59:17,610
It's now about to return n.

825
00:59:17,610 --> 00:59:21,360
It jumps back up to main, where I left off on line 9.

826
00:59:21,360 --> 00:59:23,778
It now prints, in my terminal window, the number 50.

827
00:59:23,778 --> 00:59:30,700
And hopefully, at this point, to your question earlier, my human brain has realized, oh, I'm an idiot, like I flipped my sign there.

828
00:59:30,700 --> 00:59:32,460
So I probably-- let me stop this.

829
00:59:32,460 --> 00:59:34,780
I probably want to do something like this.

830
00:59:34,780 --> 00:59:45,070
If the goal is to get a negative integer, I probably want to say, while n is, for instance, greater than or equal to 0 would work.

831
00:59:45,070 --> 00:59:48,630
So while n is greater than or equal to 0, keep doing this.

832
00:59:48,630 --> 00:59:50,430
And that's the logic I wanted to express.

833
00:59:50,430 --> 00:59:54,900
So the debugger just saves me from staring at the screen, raising a hand, sort of asking someone else.

834
00:59:54,900 --> 00:59:58,650
At least in this case, it allows me to go through it at a healthier pace.

835
00:59:58,650 --> 01:00:04,940
Questions now on debug50, which should be your new friend, even if it's not your first instinct after printf?

836
01:00:07,690 --> 01:00:09,190
Any questions on debug50?

837
01:00:09,190 --> 01:00:09,730
No?

838
01:00:09,730 --> 01:00:13,960
All right, well, there's one last technique we can equip you with here.

839
01:00:13,960 --> 01:00:22,720
And that is, in addition to printf and a debugger, no joke, a rubber duck is actually a reasonably recommended solution to finding bugs in your code.

840
01:00:22,720 --> 01:00:26,390
To your question earlier, the duck two is not going to solve the problem for you.

841
01:00:26,390 --> 01:00:33,760
But if you've wondered why this little guy has been here for so long, there's this technique, has its own Wikipedia article of called rubber duck debugging.

842
01:00:33,760 --> 01:00:42,820
The idea of which is that if you're home in your dorm room, wrestling with some bug in your code, printf didn't quite reveal the source to you, debugger isn't really helping,

843
01:00:42,820 --> 01:00:46,960
honestly, maybe it would help to just sound out what problem you're having.

844
01:00:46,960 --> 01:00:54,730
Similar to going to office hours, talking to a TA or a professor, just walking through your problems because in sort of talking to the duck about the fact

845
01:00:54,730 --> 01:01:01,180
that you're doing this while n is less than 0, and then if it is-- wait a minute.

846
01:01:01,180 --> 01:01:03,820
I'm an idiot, not just for talking to the rubber duck.

847
01:01:03,820 --> 01:01:11,860
You realize, hopefully, in expressing yourself, literally verbally, you probably will hear with non-zero probability, like some illogic in your statement.

848
01:01:11,860 --> 01:01:16,430
And just by sounding things out, you'll realize like, oh, that's my problem.

849
01:01:16,430 --> 01:01:19,720
And so, frankly, if you have roommates, you can also use a roommate for this.

850
01:01:19,720 --> 01:01:28,150
But the rubber duck is just sort of a go-to when your roommates have no interest in your C problem set, talking something through that as such.

851
01:01:28,150 --> 01:01:29,933
And this is an invaluable technique.

852
01:01:29,933 --> 01:01:34,510
I admittedly tend not to do it so much with a rubber duck, but ideally with colleagues, human colleagues.

853
01:01:34,510 --> 01:01:40,360
But just talking through things often will help you just realize, oh, I said something illogical.

854
01:01:40,360 --> 01:01:41,860
Now I can go back to the code.

855
01:01:41,860 --> 01:01:46,240
So don't solve problems by staring at your screen endlessly for minutes, for hours.

856
01:01:46,240 --> 01:01:52,900
At that point, it's time for a break, time to walk away, time to talk to the duck, if you've already exhausted some of those other tools.

857
01:01:52,900 --> 01:01:59,020
As an aside, on your way out today at the end of class, we have, clearly, plenty of rubber ducks for you.

858
01:01:59,020 --> 01:02:05,770
And it's become a thing over the years, at least among some, to bring the duck with them when they travel and send us photos.

859
01:02:05,770 --> 01:02:15,940
Here, for instance, is CS50's rubber duck debugger, A.K.A. DDB, for Duck Debugger, which is a pun on a geekier program called GDB, the GNU

860
01:02:15,940 --> 01:02:18,740
Debugger, which is an actual piece of software for debugging.

861
01:02:18,740 --> 01:02:25,270
This is CS50's debugger in the hills of Puerto Rico, also, here on the sea.

862
01:02:25,270 --> 01:02:28,310
He made its way to San Francisco here.

863
01:02:28,310 --> 01:02:30,640
Also, down by Fisherman's Wharf by the sea lions.

864
01:02:30,640 --> 01:02:31,660
Familiar?

865
01:02:31,660 --> 01:02:38,950
Here at Stanford, where there's a William Gates Computer Science building for computer science, down the road in SF at Google.

866
01:02:38,950 --> 01:02:41,650
And this is the Trevi Fountain in Rome.

867
01:02:41,650 --> 01:02:43,810
And lastly, the Colosseum.

868
01:02:43,810 --> 01:02:46,990
So we'll be curious to see in the coming years where your duck two travels.

869
01:02:46,990 --> 01:02:49,120
So that, then, was quite a bit.

870
01:02:49,120 --> 01:02:51,850
Why don't we go ahead here and take a short 5 minute break?

871
01:02:51,850 --> 01:02:52,760
No snacks yet.

872
01:02:52,760 --> 01:02:54,400
You're welcome to get up or sit down.

873
01:02:54,400 --> 01:02:56,620
We'll return in about five.

874
01:02:56,620 --> 01:03:00,020
All right, so we are back.

875
01:03:00,020 --> 01:03:09,190
And if the goal, ultimately, today is to have a better understanding of things like strings so that we can solve problems with text, let's consider some simpler types of data

876
01:03:09,190 --> 01:03:17,330
first, how we might represent those, and then see if that doesn't lead us to a discovery as to how strings, and just today's modern software is using things like that.

877
01:03:17,330 --> 01:03:27,640
So when we talked on week zero about representation of data, we had different ways of doing it, in terms of binary and decimal, and unary even.

878
01:03:27,640 --> 01:03:33,980
When we started talking about the same last week in code, we started talking about data types instead.

879
01:03:33,980 --> 01:03:45,070
And these data types were a way of telling the computer, like do you want an integer, do you want a character, do you want a floating point value, like a real number, or even a string, as we've seen?

880
01:03:45,070 --> 01:03:49,930
But it turns out that computers, of course, only have finite amounts of resources.

881
01:03:49,930 --> 01:03:53,740
Your computer only has a fixed amount of memory or RAM.

882
01:03:53,740 --> 01:03:55,910
And that actually has very real world implications.

883
01:03:55,910 --> 01:03:59,630
So for instance, here are some of the data types we've seen thus far.

884
01:03:59,630 --> 01:04:05,650
And it turns out that each of these in C has a specific number of bits allocated to it.

885
01:04:05,650 --> 01:04:08,350
Now, admittedly, this can vary by system.

886
01:04:08,350 --> 01:04:13,100
It's not so much the case nowadays, but for many years, for decades, computers were getting better and better.

887
01:04:13,100 --> 01:04:16,600
The earliest computers might have used fewer bits for some of these data types.

888
01:04:16,600 --> 01:04:18,663
More modern computers might use more bits.

889
01:04:18,663 --> 01:04:21,830
So the numbers you're about to see are pretty much where we are present day.

890
01:04:21,830 --> 01:04:32,380
So when it comes to these data types, a bool, which is true or false, somewhat curiously, uses a whole byte, even though that's way overkill because for a bool, true or false,

891
01:04:32,380 --> 01:04:33,940
you, of course, only need one bit.

892
01:04:33,940 --> 01:04:41,230
But it turns out, even though it's wasteful to use eight bits, or one byte, just to represent true or false, it's just easier for computers.

893
01:04:41,230 --> 01:04:42,820
So a bool tends to be one byte.

894
01:04:42,820 --> 01:04:47,590
An int, which we've been using a lot, uses 4 bytes, typically, or 32 bits.

895
01:04:47,590 --> 01:04:54,040
And if I do some quick math from week zero, with 32 bits, you have 4 billion possible values, roughly.

896
01:04:54,040 --> 01:05:01,020
But if you want to represent positive and negative, that means you can represent roughly negative 2 billion, all the way up to positive 2 billion.

897
01:05:01,020 --> 01:05:02,770
So that's the range, typically, with ints.

898
01:05:02,770 --> 01:05:06,820
If that's too few numbers for you, turns out there's things called longs.

899
01:05:06,820 --> 01:05:15,730
And longs use 64 bits, which allow you to have like a quintillion number of possibilities, which is a lot, certainly, a lot more than 4 billion.

900
01:05:15,730 --> 01:05:17,410
So sometimes you might use a long.

901
01:05:17,410 --> 01:05:18,670
But even that's finite.

902
01:05:18,670 --> 01:05:28,330
And so as we discussed at the end of last week, bad things can happen if you make certain assumptions as to the data because of things like integer overflow or the like, where things wrap around.

903
01:05:28,330 --> 01:05:31,538
Then there's a float, which is a real number, something with a decimal point.

904
01:05:31,538 --> 01:05:37,810
By convention, it's 4 bytes or 32 bits, which gives you, in short, only a specific amount of precision.

905
01:05:37,810 --> 01:05:41,620
It doesn't necessarily dictate how many numbers to the left or to the right.

906
01:05:41,620 --> 01:05:45,250
In the aggregate, ultimately, you have though,

907
01:05:45,250 --> 01:05:47,650
4 billion possible permutations still.

908
01:05:47,650 --> 01:05:57,700
If you need more precision for scientific, for medical, for financial applications, you might use 8 bytes, A.K.A. a double, which just gives you more digits of precision.

909
01:05:57,700 --> 01:06:03,610
They eventually get imprecise per the example we looked at last week, but it at least gets you further down the line.

910
01:06:03,610 --> 01:06:12,640
As an aside, in really, really important applications, in finance, in medicine, in military operations, and the like where you really can't have rounding errors--

911
01:06:12,640 --> 01:06:19,317
long story short, humans have developed libraries in C and other languages that use more, even, than 8 bytes.

912
01:06:19,317 --> 01:06:22,150
So there are solutions to these problems, but they're always finite.

913
01:06:22,150 --> 01:06:24,070
You have to pick an upper bound.

914
01:06:24,070 --> 01:06:29,470
Then there's char, which we saw briefly last week when I asked the user for y or n, for yes or no.

915
01:06:29,470 --> 01:06:34,360
And then there's a string, which I'm going to propose as a question mark because a string totally depends.

916
01:06:34,360 --> 01:06:35,380
Like, Hi!

917
01:06:35,380 --> 01:06:38,890
H-I, exclamation point, would seem to be three bytes.

918
01:06:38,890 --> 01:06:41,140
D-A-V-I-D, would seem to be five.

919
01:06:41,140 --> 01:06:45,400
So the strings, clearly, are variable based on what you or the human type in.

920
01:06:45,400 --> 01:06:48,140
So we'll see what this means, though, in just a bit.

921
01:06:48,140 --> 01:06:51,580
This though, is the thing inside of your Mac, your PC, your phone.

922
01:06:51,580 --> 01:06:56,187
It might not look exactly like this, but this is a memory module for a modern computer.

923
01:06:56,187 --> 01:06:57,520
And let's go ahead and use this.

924
01:06:57,520 --> 01:07:01,360
Really, it's just representative of the finite amount of memory that any computer, indeed, has.

925
01:07:01,360 --> 01:07:06,160
Let's zoom in on one of these little black chips on the circuit board here.

926
01:07:06,160 --> 01:07:16,750
Zoom in, and let me propose that this rectangle really represents some number of bytes, like tucked inside of this little black circuit on the board is maybe, I don't know, a gigabyte,

927
01:07:16,750 --> 01:07:19,300
a billion bytes, maybe it's 100 bytes-- some number of bytes.

928
01:07:19,300 --> 01:07:22,700
It totally depends on the computer and how much you paid for the stick of memory.

929
01:07:22,700 --> 01:07:32,410
But if there's a finite number of bytes physically implemented somehow digitally inside of this hardware, well, then it stands to reason that we could number those bytes.

930
01:07:32,410 --> 01:07:38,800
We can just arbitrarily decide that the top left corner is byte number one, or really byte number zero.

931
01:07:38,800 --> 01:07:46,090
The one next to it is number one, then number two, number 3, dot, dot, dot, number 2 billion or whatever it is, however big this memory is.

932
01:07:46,090 --> 01:07:50,530
So if you use a variable in a C program, that's only one byte.

933
01:07:50,530 --> 01:07:55,120
Like a char, it might literally be stored in that top left-hand corner of the memory.

934
01:07:55,120 --> 01:07:57,760
In practice, you don't care where, physically, it is.

935
01:07:57,760 --> 01:08:04,330
But really, the artist's rendition would be this-- a char might use one of those single bytes somewhere in the computer's memory.

936
01:08:04,330 --> 01:08:07,450
If you use an int, which is 4 bytes, it would give you

937
01:08:07,450 --> 01:08:10,840
4 bytes, contiguous-- that is left to right, top to bottom.

938
01:08:10,840 --> 01:08:16,149
But all 32 bits would be next to each other so the computer knows that those, indeed, all belong to the same int.

939
01:08:16,149 --> 01:08:21,140
If you need a long, or a double for that matter, then you might use a full 8 bytes in this case.

940
01:08:21,140 --> 01:08:29,845
And you just keep using and using this memory, kind of like a canvas, almost in Photoshop or a spreadsheet where you can just move pixels or you can move data around,

941
01:08:29,845 --> 01:08:36,702
that's really what your computer's memory is, a canvas for storing information in units of bytes or 8 bits.

942
01:08:36,702 --> 01:08:39,160
Now, we don't need to keep looking at these circuit boards.

943
01:08:39,160 --> 01:08:41,287
We can abstract it away, as we often do.

944
01:08:41,287 --> 01:08:45,740
And let's go ahead and zoom in on this grid, just to consider some very specific variables.

945
01:08:45,740 --> 01:08:51,580
So let me zoom in, and now I see fewer, but larger boxes on the screen, each of which, again, represents a byte.

946
01:08:51,580 --> 01:08:55,130
And now let me propose that we play with some actual code.

947
01:08:55,130 --> 01:09:01,060
So here in C, albeit without a full program, are three ints-- score1, score2, score3.

948
01:09:01,060 --> 01:09:09,040
I have, coincidentally, given myself two scores around 72 and 73, and then a pretty low score at 33.

949
01:09:09,040 --> 01:09:12,048
Of course, last week or two weeks ago, this would have been high.

950
01:09:12,048 --> 01:09:13,840
But now we're dealing with actual integers.

951
01:09:13,840 --> 01:09:17,750
So these are three so-so scores on my quizzes or tests or the like.

952
01:09:17,750 --> 01:09:19,250
So let me go to VS Code here.

953
01:09:19,250 --> 01:09:22,210
And let's make a program called scores.c.

954
01:09:22,210 --> 01:09:24,399
So I'm going to write, code scores.c.

955
01:09:24,399 --> 01:09:26,149
That's going to give me my new file.

956
01:09:26,149 --> 01:09:28,420
And let me go ahead and implement something like this.

957
01:09:28,420 --> 01:09:37,689
Include stdio.h, int main(void), and then inside of here, let me do int score1 will be 72.

958
01:09:37,689 --> 01:09:40,029
Int score2 will be 73.

959
01:09:40,029 --> 01:09:43,149
And int score3 will be 33.

960
01:09:43,149 --> 01:09:48,042
And then let me just do something like write a program to average my three test scores together, something like that.

961
01:09:48,042 --> 01:09:56,470
So let me do printf, quote unquote, my average is-- and I'm going to go ahead and do, say, %i, /n.

962
01:09:56,470 --> 01:09:58,290
And now, let me plug in the results.

963
01:09:58,290 --> 01:10:00,040
And this is kind of grade school math now.

964
01:10:00,040 --> 01:10:02,210
How do I compute the average of three values?

965
01:10:02,210 --> 01:10:14,457
Well, just like on paper, I can do score1 plus score2 plus score3 in parentheses, because of order of operations, divided by 3, since there's three total scores.

966
01:10:14,457 --> 01:10:16,040
All right, so I think this checks out.

967
01:10:16,040 --> 01:10:23,180
And indeed, you can use parentheses and operators like plus in your code like this in C. Let me go ahead now and do make scores.

968
01:10:23,180 --> 01:10:24,327
No syntax error.

969
01:10:24,327 --> 01:10:25,910
So that's good, nothing missing there.

970
01:10:25,910 --> 01:10:28,850
And now let me do ./scores and see what my test average is.

971
01:10:28,850 --> 01:10:32,270
All right, it's not great, but I think I still passed.

972
01:10:32,270 --> 01:10:36,050
And indeed, my average here is 59.

973
01:10:36,050 --> 01:10:38,360
Is it precisely 59 though?

974
01:10:38,360 --> 01:10:39,140
Well, let's see.

975
01:10:39,140 --> 01:10:44,870
Let's actually, instead of using an int, how about we go ahead and use something like a floating point value here?

976
01:10:44,870 --> 01:10:46,250
And let me go ahead and do this.

977
01:10:46,250 --> 01:10:48,710
So let me recompile my code, make scores.

978
01:10:48,710 --> 01:10:50,600
Huh, all right, I've got an issue.

979
01:10:50,600 --> 01:10:52,340
Let me zoom in on my terminal window.

980
01:10:52,340 --> 01:10:54,710
We've not seen this one, necessarily, before.

981
01:10:54,710 --> 01:10:56,510
But error on line 9.

982
01:10:56,510 --> 01:11:02,180
Format specifies type double, which is a lot of precision, but the argument has type int.

983
01:11:02,180 --> 01:11:03,300
So what does this mean?

984
01:11:03,300 --> 01:11:09,060
Well, it's showing me with these green squiggles that something's bad between the %f and this thing over here.

985
01:11:09,060 --> 01:11:13,020
Well, on the left, I'm implying a float, or a double for that matter.

986
01:11:13,020 --> 01:11:16,835
On the right, though, what data type are score1, score2, score3?

987
01:11:16,835 --> 01:11:17,960
All right, so they're ints.

988
01:11:17,960 --> 01:11:19,583
So clang does not like this.

989
01:11:19,583 --> 01:11:24,170
The compiler just doesn't like that I'm using ints on the right, but I want floats on the left.

990
01:11:24,170 --> 01:11:26,670
So there's going to be different ways of solving this.

991
01:11:26,670 --> 01:11:32,450
One way would be to just ignore the problem like I originally did, and just go back to %i.

992
01:11:32,450 --> 01:11:38,330
Or as an aside, %d is often an alternative to %i for a decimal number.

993
01:11:38,330 --> 01:11:42,358
But we use %i because it sounds like int, so %i is fine here too.

994
01:11:42,358 --> 01:11:44,150
But I don't want to just avoid the problem.

995
01:11:44,150 --> 01:11:46,500
I want to actually display a floating point value.

996
01:11:46,500 --> 01:11:47,730
So how can I fix this?

997
01:11:47,730 --> 01:11:50,272
Well, it turns out, I can solve this in a few different ways.

998
01:11:50,272 --> 01:11:59,330
The simplest is just to make sure that at least one number on the right is a floating point value, like 3.0 instead of just 3.

999
01:11:59,330 --> 01:12:01,700
Now I think clang will be happier.

1000
01:12:01,700 --> 01:12:03,320
Let me do make scores--

1001
01:12:03,320 --> 01:12:04,400
Enter.

1002
01:12:04,400 --> 01:12:05,330
And indeed, it's OK.

1003
01:12:05,330 --> 01:12:05,930
Why?

1004
01:12:05,930 --> 01:12:14,330
As soon as you have at least one more precise data type on the right, it just treats everything, at that point, as floating point value so that the math works out.

1005
01:12:14,330 --> 01:12:17,720
So ./scores, Enter-- and now, there we go, right?

1006
01:12:17,720 --> 01:12:20,390
Some of us might really want that 1/3 of a point.

1007
01:12:20,390 --> 01:12:21,980
Our average was not 59.

1008
01:12:21,980 --> 01:12:25,010
It's 59 1/3, as in this case here.

1009
01:12:25,010 --> 01:12:26,750
All right, so we've solved that there.

1010
01:12:26,750 --> 01:12:30,890
As an aside, though, there's one other technique to show here.

1011
01:12:30,890 --> 01:12:38,760
If you didn't want to change it to 3.0 because that's a little weird, because there were literally three scores, it's not like that needs to have a decimal point,

1012
01:12:38,760 --> 01:12:46,230
you could also explicitly convert the 3 to a float by saying, in parentheses, float.

1013
01:12:46,230 --> 01:12:48,050
This is what's called typecasting.

1014
01:12:48,050 --> 01:12:52,560
And this will just convert the thing right after it to that data type, if it's possible.

1015
01:12:52,560 --> 01:12:59,960
So if I do this again, make scores, no errors now. ./scores, and I get, in fact, the same result. There's a bit of a rounding issue here,

1016
01:12:59,960 --> 01:13:03,650
but we know the rounding relates to the imprecision from last week.

1017
01:13:03,650 --> 01:13:06,980
For now, let me just be happy with my 59.3 something.

1018
01:13:06,980 --> 01:13:08,360
I'll take that for now.

1019
01:13:08,360 --> 01:13:14,660
But this is as close to a good enough correct answer for me now.

1020
01:13:14,660 --> 01:13:18,650
But how do I-- think about now, what's going on inside of the computer's memory?

1021
01:13:18,650 --> 01:13:19,310
Well, let's consider.

1022
01:13:19,310 --> 01:13:20,643
Here's that same grid of memory.

1023
01:13:20,643 --> 01:13:22,490
Each box represents a byte.

1024
01:13:22,490 --> 01:13:25,790
Where are score1, score2, and score3 in my memory?

1025
01:13:25,790 --> 01:13:28,790
Well, score1, let me just propose, is at the top left.

1026
01:13:28,790 --> 01:13:32,060
But it's taking up four boxes for 4 bytes.

1027
01:13:32,060 --> 01:13:38,180
Score2 probably ends up right next to it in memory, though, this isn't always going to be the case, but I've chosen simple examples.

1028
01:13:38,180 --> 01:13:40,910
73 is next to it, also taking up 4 bytes.

1029
01:13:40,910 --> 01:13:45,320
And then lastly, 33 is in score3, down there underneath.

1030
01:13:45,320 --> 01:13:54,110
Now, if we really look at the computer's memory, look at it with some kind of microscope or the like, there's actually 32 bits, 32 bits, 32 bits

1031
01:13:54,110 --> 01:13:59,308
in each of those four groups of four bytes representing those values.

1032
01:13:59,308 --> 01:14:03,308
But again, for today's purposes onwards, we don't really need to think again and again in binary.

1033
01:14:03,308 --> 01:14:05,940
It's just, indeed, these decimal numbers being stored there.

1034
01:14:05,940 --> 01:14:08,240
But I claim now, this isn't the best design.

1035
01:14:08,240 --> 01:14:16,970
Even if you have never programmed before CS50, what you're looking at here on the screen, as an excerpt, in what sense is this perhaps bad design, even though it's

1036
01:14:16,970 --> 01:14:19,960
a correct way of storing three test scores?

1037
01:14:19,960 --> 01:14:20,960
What's kind of bad here?

1038
01:14:20,960 --> 01:14:21,882
Yeah?

1039
01:14:21,882 --> 01:14:26,220
AUDIENCE: The more scores you have, the more you [INAUDIBLE]..

1040
01:14:26,220 --> 01:14:31,740
DAVID MALAN: Yeah, always do exactly what you did-- extrapolate to 4 scores, 5 scores 50 scores.

1041
01:14:31,740 --> 01:14:36,300
This can't be that well-designed because now you're going to have 4 lines of code, 5 lines of code,

1042
01:14:36,300 --> 01:14:42,430
50 lines of code that are almost identical, except for this like arbitrary number that we're updating at the end of the variable.

1043
01:14:42,430 --> 01:14:48,690
So indeed, there's probably going to be a better way, even though, at least in C, we haven't yet seen that technique.

1044
01:14:48,690 --> 01:14:52,440
But the solution, today onward, is going to be something called an array.

1045
01:14:52,440 --> 01:15:03,960
An array is a way of storing your data back to back to back in the computer's memory in such a way that you can access each individual member easily.

1046
01:15:03,960 --> 01:15:08,530
Put another way, with an array, you can instead do something like this.

1047
01:15:08,530 --> 01:15:20,700
Instead of saying int score1, int score2, int score3, giving each a value, you can first tell the computer, please give me a variable called scores-- plural, though you can call it anything you want--

1048
01:15:20,700 --> 01:15:24,090
of size three, each of which will be an integer.

1049
01:15:24,090 --> 01:15:30,930
That is to say, this is how you declare an array in C that will have enough room to store three integers.

1050
01:15:30,930 --> 01:15:38,880
Put another way, this is the technical way of telling the computer, please give me 12 bytes in total--

1051
01:15:38,880 --> 01:15:42,660
3 times 4 each for an int, so give me 12 bytes in total.

1052
01:15:42,660 --> 01:15:47,350
And what the computer will do is guarantee that they're back to back to back in the computer's memory.

1053
01:15:47,350 --> 01:15:49,360
And that'll be useful in just a moment.

1054
01:15:49,360 --> 01:15:51,820
So let me go ahead and do something useful with this.

1055
01:15:51,820 --> 01:15:53,640
Let me store three actual scores.

1056
01:15:53,640 --> 01:15:58,500
Here's how I could now store those same numeric scores in this array.

1057
01:15:58,500 --> 01:16:03,040
Syntax is a little different, but there's one variable called scores.

1058
01:16:03,040 --> 01:16:14,280
But if you want to go to its first location, starting today, you use square brackets and go to location 0 first, which because things in C are 0 indexed, so to speak, you start counting at 0.

1059
01:16:14,280 --> 01:16:16,410
The first int is at [0].

1060
01:16:16,410 --> 01:16:18,030
Second int is at [1].

1061
01:16:18,030 --> 01:16:19,530
Third int is at [2].

1062
01:16:19,530 --> 01:16:20,730
So it's not one, two, three.

1063
01:16:20,730 --> 01:16:22,090
It's literally 0, 1, 2.

1064
01:16:22,090 --> 01:16:24,090
And this is not something you have control over.

1065
01:16:24,090 --> 01:16:26,250
You must start at 0.

1066
01:16:26,250 --> 01:16:33,510
So these lines now create an array of size three, and then insert one, two, three values into that array.

1067
01:16:33,510 --> 01:16:37,770
But the upside now is that you only have one name of the variable to remember.

1068
01:16:37,770 --> 01:16:39,240
It's just called scores.

1069
01:16:39,240 --> 01:16:43,380
Yes, you need to go into the array to get individual values.

1070
01:16:43,380 --> 01:16:46,618
You need to index into it using those square brackets.

1071
01:16:46,618 --> 01:16:53,050
But at least you don't have this hackish approach of declaring a separate variable for each and every one of these values.

1072
01:16:53,050 --> 01:16:56,070
So let me go back to scores.c here.

1073
01:16:56,070 --> 01:16:57,580
And let me propose that I do this.

1074
01:16:57,580 --> 01:17:00,580
Let me just use that same idea to do the following.

1075
01:17:00,580 --> 01:17:02,580
Let me get rid of these three separate integers.

1076
01:17:02,580 --> 01:17:06,210
Let me give myself an int scores array of size 3.

1077
01:17:06,210 --> 01:17:10,470
And then scores[0] will, as before, be 72.

1078
01:17:10,470 --> 01:17:14,070
Scores[1] will be 73.

1079
01:17:14,070 --> 01:17:16,830
And scores[2] will be 33.

1080
01:17:16,830 --> 01:17:18,780
And let me get rid of the little dot there.

1081
01:17:18,780 --> 01:17:23,490
All right, so now, if I go ahead and run this again with make scores--

1082
01:17:23,490 --> 01:17:24,642
Enter.

1083
01:17:24,642 --> 01:17:29,060
Huh, what did I do wrong here?

1084
01:17:29,060 --> 01:17:31,680
I think I got a little too ahead of myself.

1085
01:17:31,680 --> 01:17:36,100
Let me increase my terminal window.

1086
01:17:36,100 --> 01:17:38,830
Let's focus on line 10 here, first.

1087
01:17:38,830 --> 01:17:42,310
Error, use of undeclared identifier, score1.

1088
01:17:42,310 --> 01:17:44,170
What did I do here that was dumb?

1089
01:17:44,170 --> 01:17:45,430
Yeah?

1090
01:17:45,430 --> 01:17:47,440
AUDIENCE: You didn't declare it a variable.

1091
01:17:47,440 --> 01:17:49,420
DAVID MALAN: Right, so I didn't declare score1.

1092
01:17:49,420 --> 01:17:50,530
I've got old code.

1093
01:17:50,530 --> 01:17:53,798
So I just kind of, honestly, got ahead of myself here, not even intentionally.

1094
01:17:53,798 --> 01:17:56,090
So let me go ahead and shrink my terminal window again.

1095
01:17:56,090 --> 01:17:57,740
I need to finish my thought here.

1096
01:17:57,740 --> 01:17:58,960
So let me clear my terminal.

1097
01:17:58,960 --> 01:18:05,610
And let me change this now to be scores[0] plus scores[1] plus scores[2].

1098
01:18:05,610 --> 01:18:10,040
So it's a little more verbose because I've got these square brackets, so to speak.

1099
01:18:10,040 --> 01:18:12,220
But I think now my code is consistent.

1100
01:18:12,220 --> 01:18:13,870
So let me make scores now.

1101
01:18:13,870 --> 01:18:14,950
It now compiles.

1102
01:18:14,950 --> 01:18:19,870
./scores gives me, indeed, the same rough average with those same values.

1103
01:18:19,870 --> 01:18:24,280
All right, so let me go ahead and maybe enhance this a little bit.

1104
01:18:24,280 --> 01:18:31,610
It's a little silly to have to write a special program just to check your average of three test scores like 72, 73, 33.

1105
01:18:31,610 --> 01:18:37,250
Why don't I actually make the program dynamic and ask the human for those scores?

1106
01:18:37,250 --> 01:18:39,140
So instead, let me do this.

1107
01:18:39,140 --> 01:18:43,480
How about we get rid of the 72, and change this to getInt.

1108
01:18:43,480 --> 01:18:46,300
And I'll just prompt the user for a score.

1109
01:18:46,300 --> 01:18:52,510
Let me get rid of the 73 and get this to be getInt score, quote unquote.

1110
01:18:52,510 --> 01:19:03,680
And then lastly, get rid of the 33, and replace it with getInt, quote unquote, score. getInt is a CS50 thing for now, so I need to include cs50.h, as always.

1111
01:19:03,680 --> 01:19:08,680
But I think now, it's sort of a better program because now I can compile it once, I can even share it with my friends.

1112
01:19:08,680 --> 01:19:12,490
And now any of us can average three scores on some classes test.

1113
01:19:12,490 --> 01:19:16,910
They don't need to know the code or rewrite the code just to type in their scores.

1114
01:19:16,910 --> 01:19:19,150
So make scores worked.

1115
01:19:19,150 --> 01:19:26,320
./scores, now I can type anything I want-- maybe it's a 72, 73, 33, still get the same answer.

1116
01:19:26,320 --> 01:19:33,520
Or maybe I'm having a better semester, 100, 100, maybe 99, and now we get still a pretty high score there.

1117
01:19:33,520 --> 01:19:34,600
But now it's dynamic.

1118
01:19:34,600 --> 01:19:36,080
Now you don't need the source code.

1119
01:19:36,080 --> 01:19:37,747
You don't need to recompile the program.

1120
01:19:37,747 --> 01:19:39,670
It's just going to work again and again.

1121
01:19:39,670 --> 01:19:41,090
But this, too.

1122
01:19:41,090 --> 01:19:45,910
Let me propose that this code is correct if I want to get three scores from the user.

1123
01:19:45,910 --> 01:19:53,170
But these highlighted lines now, 6 through 9, are they well-designed, would you say?

1124
01:19:53,170 --> 01:19:53,680
Yeah?

1125
01:19:53,680 --> 01:19:54,898
AUDIENCE: Can you loop?

1126
01:19:54,898 --> 01:19:55,940
DAVID MALAN: Yeah, right?

1127
01:19:55,940 --> 01:19:58,220
This is-- we can use a loop, is the spoiler here.

1128
01:19:58,220 --> 01:19:58,820
Why?

1129
01:19:58,820 --> 01:20:01,590
I mean, my God, it's like the same code again and again and again.

1130
01:20:01,590 --> 01:20:03,465
The only thing that's changing is the number.

1131
01:20:03,465 --> 01:20:11,810
And this should have kind of had some code smell again, because if I keep typing the same thing again and again, that's clearly an opportunity to better design something.

1132
01:20:11,810 --> 01:20:13,650
So let me do this.

1133
01:20:13,650 --> 01:20:18,590
Let me go ahead and still create my array of size three.

1134
01:20:18,590 --> 01:20:26,610
But let me use our old friend, the for loop, for int i equals 0, i less than 3, i++.

1135
01:20:26,610 --> 01:20:32,920
And then in here, let me do scores bracket-- we haven't seen this before, but any intuition?

1136
01:20:32,920 --> 01:20:34,220
Scores bracket--

1137
01:20:34,220 --> 01:20:34,720
AUDIENCE: i.

1138
01:20:34,720 --> 01:20:40,720
DAVID MALAN: i, because that will use whatever i is, be it 0 or 1 or 2 in iteration.

1139
01:20:40,720 --> 01:20:47,000
And then I can get an int, asking the user for score, without having to repeat myself again and again.

1140
01:20:47,000 --> 01:20:50,560
So hopefully, if I didn't make any typos, make scores, all good.

1141
01:20:50,560 --> 01:20:54,665
./scores, 72, 73, 33, and we're back in business.

1142
01:20:54,665 --> 01:21:04,940
But the code is arguably now better designed, because now, I haven't actually hardcoded the scores, and I haven't actually copied and pasted any of that code.

1143
01:21:04,940 --> 01:21:10,510
Well, if we consider now what's going on inside of the computer's memory, it's pretty much the same in terms of the values.

1144
01:21:10,510 --> 01:21:17,210
But instead of the variables being, literally, score1, score2, score3, there's just one variable.

1145
01:21:17,210 --> 01:21:19,030
It's an array called scores.

1146
01:21:19,030 --> 01:21:28,810
But you can index into its three locations by using scores[0] to get the first, scores[1] to get the second, scores[2] to get the third.

1147
01:21:28,810 --> 01:21:29,990
But this is key.

1148
01:21:29,990 --> 01:21:33,040
The memory is contiguous.

1149
01:21:33,040 --> 01:21:35,380
The screen is only so large, so it wraps around.

1150
01:21:35,380 --> 01:21:40,270
But physically, digitally, the memory is contiguous-- top to bottom, left to right.

1151
01:21:40,270 --> 01:21:41,530
And that's important, why?

1152
01:21:41,530 --> 01:21:48,790
Because the brackets indicate 0, 1, 2, that each of these integers is just one integer away from the next.

1153
01:21:48,790 --> 01:21:51,220
It can't be randomly down here all of a sudden.

1154
01:21:51,220 --> 01:21:54,070
It's got to be back to back to back.

1155
01:21:54,070 --> 01:22:00,710
All right, now equipped with that paradigm, what more could we actually do here?

1156
01:22:00,710 --> 01:22:06,850
Well, it turns out, it's worth knowing that it's possible in code to even pass arrays around as arguments.

1157
01:22:06,850 --> 01:22:11,320
And let me just whip this program up somewhat quickly, just so you've seen it before long.

1158
01:22:11,320 --> 01:22:13,190
But let me go ahead and do this.

1159
01:22:13,190 --> 01:22:18,130
Let me propose that I create a function that does this averaging for me.

1160
01:22:18,130 --> 01:22:22,510
So I'm going to create a function called average that returns a float.

1161
01:22:22,510 --> 01:22:28,640
And the arguments this thing is going to take-- let's see, it's going to be the array.

1162
01:22:28,640 --> 01:22:33,050
So it turns out, if you want to take in an array of numbers-- you can call it anything you want.

1163
01:22:33,050 --> 01:22:39,790
This is how you tell C that a function takes, not an integer, but an array of integers.

1164
01:22:39,790 --> 01:22:41,290
And you don't have to call it array.

1165
01:22:41,290 --> 01:22:42,790
I'm doing that just for the sake of discussion.

1166
01:22:42,790 --> 01:22:43,660
It can be called x.

1167
01:22:43,660 --> 01:22:44,490
It can be numbers.

1168
01:22:44,490 --> 01:22:45,490
It can be anything else.

1169
01:22:45,490 --> 01:22:49,060
I'm just calling an array to be super explicit as to what it is there.

1170
01:22:49,060 --> 01:22:51,730
Now, how do I change my code down here?

1171
01:22:51,730 --> 01:22:55,130
What I think I'm going to do for the moment is just this.

1172
01:22:55,130 --> 01:22:59,110
I'm going to get rid of this code here, where I manually computed the average.

1173
01:22:59,110 --> 01:23:05,000
And let me just call the average function here by passing in the whole array of scores.

1174
01:23:05,000 --> 01:23:08,890
So this is just an example of abstraction, like now I have a function called average.

1175
01:23:08,890 --> 01:23:09,670
I don't care.

1176
01:23:09,670 --> 01:23:12,490
I don't have to remember how it works once I implement it.

1177
01:23:12,490 --> 01:23:15,010
It just kind of tightens up my main code a little bit.

1178
01:23:15,010 --> 01:23:17,030
But I do still have to implement this.

1179
01:23:17,030 --> 01:23:27,010
So later in my file-- let me repeat myself before, the only time it's OK in C to repeat yourself again and again, by typing out again, average, and then int array open bracket--

1180
01:23:27,010 --> 01:23:28,580
but now not a semicolon.

1181
01:23:28,580 --> 01:23:30,250
Now I have to implement this thing.

1182
01:23:30,250 --> 01:23:37,630
And I can implement this in a bunch of different ways, but I don't know in advance--

1183
01:23:37,630 --> 01:23:39,040
I can't just do this.

1184
01:23:39,040 --> 01:23:52,130
I can't just do array[0] plus array[1] plus array[2], unless this program's only ever going to work on three numbers.

1185
01:23:52,130 --> 01:23:55,460
So let me go ahead and do this.

1186
01:23:55,460 --> 01:23:58,570
Let me first propose that there's a poor design here.

1187
01:23:58,570 --> 01:24:01,930
In my main function, what value have I repeated twice?

1188
01:24:05,050 --> 01:24:07,550
Among the highlighted lines, what jumps out at you as twice?

1189
01:24:07,550 --> 01:24:09,020
AUDIENCE: The length of the array?

1190
01:24:09,020 --> 01:24:11,520
DAVID MALAN: Yeah, the length of the array, it's just three.

1191
01:24:11,520 --> 01:24:18,440
Now it's not a huge deal that I typed the number three on line 8 and line 9, but this is exactly the kind of like shortcut that's going to get you in trouble eventually.

1192
01:24:18,440 --> 01:24:18,860
Why?

1193
01:24:18,860 --> 01:24:26,270
Because, eventually, you or someone else is going to go in and make the array bigger or smaller, and you're not going to realize that magically, that same number is in two places.

1194
01:24:26,270 --> 01:24:29,270
And indeed, this is what a programmer would often call a magic number.

1195
01:24:29,270 --> 01:24:31,940
A magic number is one that just kind of appears magically.

1196
01:24:31,940 --> 01:24:36,688
And you're on the honor system to change it here, if you change it here, and then you change it over here.

1197
01:24:36,688 --> 01:24:43,190
That's not going to end well if the onus is on the programmer to remember where they hardcoded-- that is, wrote out three explicitly.

1198
01:24:43,190 --> 01:24:46,250
So any time you reuse a value like this, you know what?

1199
01:24:46,250 --> 01:24:56,990
We should probably do what we did last week, which was to declare a variable, perhaps at the very top of my program, so it's super obvious what it is, called, maybe n, and set that equal to 3.

1200
01:24:56,990 --> 01:25:02,390
Better yet, what did I do last week to make sure that I can't screw up and accidentally change that value?

1201
01:25:02,390 --> 01:25:03,440
Yeah, constant.

1202
01:25:03,440 --> 01:25:05,810
And the keyword there was just const for short.

1203
01:25:05,810 --> 01:25:11,870
And now I have a global variable-- global in the sense that I can access it anywhere-- that is called n.

1204
01:25:11,870 --> 01:25:12,680
It's an int.

1205
01:25:12,680 --> 01:25:14,450
And it's always going to be 3.

1206
01:25:14,450 --> 01:25:23,870
And now I can improve my main function a little bit by just changing the 3's to n, so now if I, if a colleague realized, oh, wait a minute, there's four tests this year.

1207
01:25:23,870 --> 01:25:31,190
You change n to four, recompile the code, and it just works everywhere else, except in my average function.

1208
01:25:31,190 --> 01:25:33,830
Let me change it back to 3, just for consistency.

1209
01:25:33,830 --> 01:25:43,610
This is not going to fly now, to just sum up things like this, for instance, and then return this divided by 3.

1210
01:25:43,610 --> 01:25:51,130
Why will this not work now as I've defined it?

1211
01:25:51,130 --> 01:25:52,159
Yeah?

1212
01:25:52,159 --> 01:25:58,030
AUDIENCE: [INAUDIBLE]

1213
01:25:58,030 --> 01:26:00,980
DAVID MALAN: OK, I might be returning an integer value when

1214
01:26:00,980 --> 01:26:02,870
I intend to return a float per this.

1215
01:26:02,870 --> 01:26:11,010
But I think I'm OK because I used that little trick where I made sure that at least one of the numbers in my arithmetic expression is, in fact, a floating point value.

1216
01:26:11,010 --> 01:26:15,650
And just by adding the point 0, make sure that everything gets treated as a float.

1217
01:26:15,650 --> 01:26:17,864
So I think that's OK.

1218
01:26:17,864 --> 01:26:19,034
AUDIENCE: [INAUDIBLE]

1219
01:26:19,034 --> 01:26:20,701
DAVID MALAN: I'm sorry, a little louder.

1220
01:26:20,701 --> 01:26:24,385
AUDIENCE: It just seems like you're [INAUDIBLE]..

1221
01:26:24,385 --> 01:26:25,260
DAVID MALAN: Exactly.

1222
01:26:25,260 --> 01:26:33,510
So left hand's not talking to the right hand here, in that my current implementation of average is still assuming that there's only going to be three tests or whatever.

1223
01:26:33,510 --> 01:26:39,480
But wait a minute, I just went through the trouble of modifying this to be n, generically.

1224
01:26:39,480 --> 01:26:46,690
And if I change this to 4, I'm not going to be happy, perhaps, with my average because now I'm going to ignore one of my test scores altogether.

1225
01:26:46,690 --> 01:26:48,450
So let me change this back to 3.

1226
01:26:48,450 --> 01:27:00,920
And unfortunately, if it's a variable now, n, and therefore, I have literally a variable number of scores, how do I take the average of a variable number of things?

1227
01:27:00,920 --> 01:27:02,630
I mean, what's my building block there?

1228
01:27:02,630 --> 01:27:03,170
Yeah?

1229
01:27:03,170 --> 01:27:10,100
AUDIENCE: [INAUDIBLE]

1230
01:27:10,100 --> 01:27:10,850
DAVID MALAN: Yeah.

1231
01:27:10,850 --> 01:27:14,880
Why don't I use a loop that goes through the array and adds things up as you go?

1232
01:27:14,880 --> 01:27:19,730
I mean, kind of like grade school, as you take the average on your calculator or paper and pencil, you just keep adding the numbers together,

1233
01:27:19,730 --> 01:27:22,380
and then you divide at the end by the total number of things.

1234
01:27:22,380 --> 01:27:23,520
So how can I do this?

1235
01:27:23,520 --> 01:27:30,515
Well, let me change my implementation of average to first declare a variable called sum, or whatever, set it equal to 0.

1236
01:27:30,515 --> 01:27:36,590
So this is like me on my piece of paper getting ready to count, or my calculator, of course, when you turn it on, typically defaults to zero.

1237
01:27:36,590 --> 01:27:46,730
And now, let me do for, int i equals 0. i is less than a-- well, no, I didn't do that. i is less than n, i++.

1238
01:27:46,730 --> 01:27:55,910
And now in here, let me go ahead and add to the current sum, whatever is in the array's location, i.

1239
01:27:55,910 --> 01:28:04,560
And then down here, I think I can just return some divided by 3.0-- not 3.0, n, perhaps here.

1240
01:28:04,560 --> 01:28:08,492
And actually, I think I'm going to get-- let's make sure it's a float.

1241
01:28:08,492 --> 01:28:15,540
Let's use the type casting trick just to make sure I don't accidentally shortchange someone and throw away everything after the decimal point.

1242
01:28:15,540 --> 01:28:17,300
So it just escalated quickly, right?

1243
01:28:17,300 --> 01:28:18,990
Average just got a lot more involved.

1244
01:28:18,990 --> 01:28:22,130
It's not just a single one line of code, but now it's dynamic.

1245
01:28:22,130 --> 01:28:25,070
I initialize a variable called sum to 0.

1246
01:28:25,070 --> 01:28:36,740
In this loop, I go through and just keep adding to sum, which is initially 0, whatever's in array[i]-- or specifically array[0], array[1], array[2].

1247
01:28:36,740 --> 01:28:40,970
That gives me a total sum that I return, divided by the total number of things.

1248
01:28:40,970 --> 01:28:42,560
Now, this I can tighten slightly.

1249
01:28:42,560 --> 01:28:45,650
Recall that this is syntactic sugar for just adding things.

1250
01:28:45,650 --> 01:28:48,620
I can't use plus plus because that only literally adds one.

1251
01:28:48,620 --> 01:28:52,630
But I can use here, plus equals.

1252
01:28:52,630 --> 01:28:54,880
Questions on this implementation here?

1253
01:28:54,880 --> 01:29:06,450
Really the only takeaway-- or the most important takeaway is that this is the syntax for how you tell a function that it expects a whole array, not a single variable like an int or the like.

1254
01:29:06,450 --> 01:29:11,530
You literally use square brackets, but you don't specify the length inside there.

1255
01:29:11,530 --> 01:29:12,748
Yeah?

1256
01:29:12,748 --> 01:29:16,410
AUDIENCE: What variable [INAUDIBLE] at the top?

1257
01:29:16,410 --> 01:29:18,410
DAVID MALAN: What about the variable at the top?

1258
01:29:18,410 --> 01:29:22,205
AUDIENCE: [INAUDIBLE]

1259
01:29:22,205 --> 01:29:23,330
DAVID MALAN: Good question.

1260
01:29:23,330 --> 01:29:25,220
What do I have it defined as at the top?

1261
01:29:25,220 --> 01:29:33,840
This variable, N, it must be an integer if you're going to use it inside of an arrays square brackets here.

1262
01:29:33,840 --> 01:29:38,360
So this line 10, notice, no longer says 3, it says N.

1263
01:29:38,360 --> 01:29:43,970
And so whatever N is 3 or 4 or something else, that's how many integers I will get in that array.

1264
01:29:43,970 --> 01:29:48,320
And it must be, by definition of an array, an integer that goes in those square brackets.

1265
01:29:48,320 --> 01:29:50,000
And here's a common source of confusion.

1266
01:29:50,000 --> 01:29:56,210
When you create the array, that is declare it, you use square brackets like this, where you put the total number of elements you want.

1267
01:29:56,210 --> 01:30:04,610
When you subsequently use the array, like I'm doing here, you don't mention int again-- just like you don't mention int again and again once a variable exists.

1268
01:30:04,610 --> 01:30:11,990
You use the square brackets still, but you don't use N. You use 0 or 1 or 2 or, generically here, i.

1269
01:30:11,990 --> 01:30:17,060
So when C was designed, they sometimes used the same syntax for two different ideas or contexts.

1270
01:30:17,060 --> 01:30:17,984
Yeah?

1271
01:30:17,984 --> 01:30:22,645
AUDIENCE: Do you have to include line 6 [INAUDIBLE]??

1272
01:30:22,645 --> 01:30:23,770
DAVID MALAN: Good question.

1273
01:30:23,770 --> 01:30:25,900
Do I have to include line 6?

1274
01:30:25,900 --> 01:30:29,290
Short answer, yes, because of the reason we ran into last week.

1275
01:30:29,290 --> 01:30:32,750
C, or clang really, reads your code top to bottom, left to right.

1276
01:30:32,750 --> 01:30:43,610
And so if the compiler sees some mention of this function average on line 16, but you haven't told the compiler that average exists, you're going to get an error on the screen.

1277
01:30:43,610 --> 01:30:51,260
So the conventional way to do that is you just copy paste the first line of code from the function, it's so-called prototype or declaration.

1278
01:30:51,260 --> 01:30:51,760
Yeah?

1279
01:30:51,760 --> 01:30:55,662
AUDIENCE: Is there a library if you don't know the size of the array?

1280
01:30:55,662 --> 01:30:58,120
DAVID MALAN: Really good question, and a perfect segue way.

1281
01:30:58,120 --> 01:31:01,078
Is there a library you can use if you don't know the size of the array?

1282
01:31:01,078 --> 01:31:01,720
No.

1283
01:31:01,720 --> 01:31:11,020
And so if any of you have programmed in Java or Python or other languages, you can actually just ask the array, how big is it?

1284
01:31:11,020 --> 01:31:13,778
In C, you and I, the programmers, have to remember it.

1285
01:31:13,778 --> 01:31:17,445
And so short answer, no, there's no function that will just automatically do this for us.

1286
01:31:17,445 --> 01:31:25,160
And in fact, let me make a more subtle claim that it's fine to use global variables like this if they're really for configuration options.

1287
01:31:25,160 --> 01:31:25,660
Why?

1288
01:31:25,660 --> 01:31:32,440
It's just convenient to put them at the very top of the file because everyone, you, your colleagues, your TAs are going to see them at the top of the code.

1289
01:31:32,440 --> 01:31:36,130
But you really shouldn't be using them everywhere throughout your code.

1290
01:31:36,130 --> 01:31:40,610
It'd be better if the average function, itself, were independent of that special variable.

1291
01:31:40,610 --> 01:31:42,025
So by that, I mean this.

1292
01:31:42,025 --> 01:31:46,240
You know what I should really do, if I really want to be well-designed?

1293
01:31:46,240 --> 01:31:51,400
I should pass in the length of the array to the average function.

1294
01:31:51,400 --> 01:31:54,310
I should give the average function a second argument--

1295
01:31:54,310 --> 01:31:57,800
I'll call it length, for instance, but I could call it anything I want.

1296
01:31:57,800 --> 01:32:05,745
And so rather than putting N all the way down here at the bottom of my file, let me just dynamically say length instead.

1297
01:32:05,745 --> 01:32:08,620
And this is a subtlety-- and no need to get too tripped up over this.

1298
01:32:08,620 --> 01:32:13,690
But this, now, is just an example of how the same function can take not one, but two arguments.

1299
01:32:13,690 --> 01:32:19,900
But indeed, in C, you must remember, yourself, what the length of an array is.

1300
01:32:19,900 --> 01:32:26,560
You can't just ask the array via some syntax like you can, those of you who've programmed before in Java or Python.

1301
01:32:26,560 --> 01:32:27,070
Yeah?

1302
01:32:27,070 --> 01:32:35,115
AUDIENCE: [INAUDIBLE]

1303
01:32:35,115 --> 01:32:36,240
DAVID MALAN: Good question.

1304
01:32:36,240 --> 01:32:39,198
Would it be better designed to write a function that computes the size?

1305
01:32:39,198 --> 01:32:48,180
Short answer, can't do that in C. As soon as you pass an array into a function in C, you cannot figure out its size if it's a generic array like that of integers.

1306
01:32:48,180 --> 01:32:51,040
There are special cases that you can do that.

1307
01:32:51,040 --> 01:32:53,283
But in general, no, it's just not possible in C.

1308
01:32:53,283 --> 01:32:57,180
And if that's some frustration, honestly, this is why more modern languages add that feature.

1309
01:32:57,180 --> 01:32:57,680
Why?

1310
01:32:57,680 --> 01:33:01,560
Because it was really annoying, as I'm alluding here to not having that information.

1311
01:33:01,560 --> 01:33:07,540
Now, just to make sure I didn't screw up anywhere, let me compile this final version of scores.

1312
01:33:07,540 --> 01:33:08,620
Suspense.

1313
01:33:08,620 --> 01:33:14,030
All good. ./scores, 72, 73, 33, and we're still back in business.

1314
01:33:14,030 --> 01:33:15,530
So this version is more complicated.

1315
01:33:15,530 --> 01:33:18,738
And as always, we'll have this version on the course's website for reference.

1316
01:33:18,738 --> 01:33:30,440
But the point, really, is that arrays, not only can be used as containers to store multiple values-- three or more in this case-- you can also even pass them around as arguments, as such.

1317
01:33:30,440 --> 01:33:36,100
All right, now besides that, let's simplify for just a moment, and consider now the world of chars.

1318
01:33:36,100 --> 01:33:39,200
If we've just got single bytes, where does this lead us?

1319
01:33:39,200 --> 01:33:44,170
And how does this get us, ultimately, to strings to solve problems like readability and cryptography and the like?

1320
01:33:44,170 --> 01:33:48,967
Well here, for instance, are three lines of code, out of context, that simply store three chars.

1321
01:33:48,967 --> 01:33:50,800
And you can already see where this is going.

1322
01:33:50,800 --> 01:33:57,470
Having three variables called c1, c2, c3 is clearly going to end up being bad design because of all the silly redundancy here.

1323
01:33:57,470 --> 01:34:01,330
But notice, I'm using single quotes like last week because these are single chars.

1324
01:34:01,330 --> 01:34:03,647
What does this look like in the computer's memory?

1325
01:34:03,647 --> 01:34:05,480
Well, it looks a little something like this.

1326
01:34:05,480 --> 01:34:12,562
If we clear out the old memory, c1, c2, c3 probably will end up here, maybe not literally in the top left-hand corner.

1327
01:34:12,562 --> 01:34:14,020
This is just an artist's rendition.

1328
01:34:14,020 --> 01:34:18,440
But c1, c2, c3 will probably end up like that.

1329
01:34:18,440 --> 01:34:20,020
Now, what's really there?

1330
01:34:20,020 --> 01:34:21,730
It's really those same three numbers--

1331
01:34:21,730 --> 01:34:23,350
72, 73, 33.

1332
01:34:23,350 --> 01:34:27,920
But how many bits does a byte have?

1333
01:34:27,920 --> 01:34:28,880
Just eight.

1334
01:34:28,880 --> 01:34:35,330
So if we were to look at the binary representation of these characters, it would only be eight bits each.

1335
01:34:35,330 --> 01:34:39,140
That's enough to store small numbers like 72, 73, 33.

1336
01:34:39,140 --> 01:34:41,580
We're not dealing with Unicode and emoji and the like.

1337
01:34:41,580 --> 01:34:42,837
But the point is the same.

1338
01:34:42,837 --> 01:34:45,170
You don't have to use four bytes to store these numbers.

1339
01:34:45,170 --> 01:34:51,420
You can use a different data type like chars, and underneath the hood, it's, indeed, going to use just single bytes for each.

1340
01:34:51,420 --> 01:34:55,850
But this is sort of like a-- this isn't really how we implement strings, right?

1341
01:34:55,850 --> 01:34:59,270
When you wanted to say, hi, last week, or this, we used double quotes.

1342
01:34:59,270 --> 01:35:02,900
And we wrote all of the things together and used one variable, not three, right?

1343
01:35:02,900 --> 01:35:06,260
When I typed in David, I didn't have a variable for D-A-V-I-D.

1344
01:35:06,260 --> 01:35:09,750
I had one variable called name that stored the whole thing.

1345
01:35:09,750 --> 01:35:13,310
So in C, we keep talking about these things called strings.

1346
01:35:13,310 --> 01:35:17,427
We'll see, eventually, that strings are not necessarily what they seem to be.

1347
01:35:17,427 --> 01:35:22,070
But for now, the key thing about strings is that they're variable length, so to speak, right?

1348
01:35:22,070 --> 01:35:28,250
They might be three characters, Hi, or five characters, David, or anything smaller or larger.

1349
01:35:28,250 --> 01:35:33,110
So how do we go about implementing strings, if all we have at the end of the day is my memory?

1350
01:35:33,110 --> 01:35:41,900
Well, here is an example of just creating, declaring, and defining a string called s. s because it's just a simple string, and quote unquote, HI!, in double quotes.

1351
01:35:41,900 --> 01:35:44,090
What does this look like in the computer's memory?

1352
01:35:44,090 --> 01:35:45,230
Well, let's clear it again.

1353
01:35:45,230 --> 01:35:50,960
And here, now, because it's technically stored in one variable, s, here is how I might draw it as an artist.

1354
01:35:50,960 --> 01:35:52,520
It's three bytes in total--

1355
01:35:52,520 --> 01:35:53,990
H-I exclamation point.

1356
01:35:53,990 --> 01:35:59,630
But there's no c1, c2, c3, it's just, the whole thing is s.

1357
01:35:59,630 --> 01:36:06,990
But it turns out that a string, fun fact, is really just what underneath the hood?

1358
01:36:06,990 --> 01:36:12,090
Kind of leading up to this-- what is a string, if this is how it's laid out in memory?

1359
01:36:12,090 --> 01:36:13,190
AUDIENCE: An array.

1360
01:36:13,190 --> 01:36:15,830
DAVID MALAN: Literally, it's just an array of characters.

1361
01:36:15,830 --> 01:36:18,590
And we didn't have to know about arrays last week to use strings.

1362
01:36:18,590 --> 01:36:21,382
This is where, again, the training wheels are starting to come off.

1363
01:36:21,382 --> 01:36:23,730
But a string is just an array of characters.

1364
01:36:23,730 --> 01:36:26,040
H-I exclamation point, for instance.

1365
01:36:26,040 --> 01:36:38,150
So technically, an array-- or a string called s is really a variable called s that allows you to get at the first character with s[0], if you want-- s[1], s[2].

1366
01:36:38,150 --> 01:36:47,000
You can literally get individual characters just by treating s as though it's an array, which it really is underneath the hood, in this case.

1367
01:36:47,000 --> 01:36:48,560
But there's a catch.

1368
01:36:48,560 --> 01:36:51,500
How do you know where strings end?

1369
01:36:51,500 --> 01:36:54,560
In the past, when I drew some integers on the screen,

1370
01:36:54,560 --> 01:36:57,080
I know, I claim they always take up 4 bytes.

1371
01:36:57,080 --> 01:37:00,200
If I had drawn a long, it always takes up 8 bytes.

1372
01:37:00,200 --> 01:37:03,530
If I had drawn a character, it always takes up 1 byte.

1373
01:37:03,530 --> 01:37:06,533
But how many bytes does a string take up?

1374
01:37:06,533 --> 01:37:08,450
Yeah, I mean, that's kind of the right answer.

1375
01:37:08,450 --> 01:37:10,490
In this case, three, it would seem.

1376
01:37:10,490 --> 01:37:13,490
But if it's David, that's a good five characters.

1377
01:37:13,490 --> 01:37:16,173
But where do we put the number three?

1378
01:37:16,173 --> 01:37:17,840
Where do you put the number five, right?

1379
01:37:17,840 --> 01:37:20,190
This is literally all that's inside your computer.

1380
01:37:20,190 --> 01:37:23,430
This is all our building blocks in front of us.

1381
01:37:23,430 --> 01:37:25,490
So how can we-- where does the three go?

1382
01:37:25,490 --> 01:37:26,540
Where does the five go?

1383
01:37:26,540 --> 01:37:29,420
Well, it turns out you can solve this in a couple of different ways.

1384
01:37:29,420 --> 01:37:41,840
But the way humans decided to implement strings years ago is, indeed, an array, but they added one extra byte at the end of every such string array, just to make clear, with a so-called sentinel value,

1385
01:37:41,840 --> 01:37:44,480
that the string ends here.

1386
01:37:44,480 --> 01:37:45,050
Why?

1387
01:37:45,050 --> 01:37:54,590
So that if you have two strings in the computer's memory like, HI! and bye, you know where the barrier is between the exclamation point of one and the letter B in the next, right?

1388
01:37:54,590 --> 01:37:56,000
You need some kind of delimiter.

1389
01:37:56,000 --> 01:38:00,110
And so what really is underneath the hood is this.

1390
01:38:00,110 --> 01:38:07,040
When you store a string in memory, when you type in a string-- as the user, if you type in 3 characters, it's going to use

1391
01:38:07,040 --> 01:38:10,280
3 plus 1 equals 4 bytes in total.

1392
01:38:10,280 --> 01:38:14,130
If you type in David, it's going to use 5 plus 1 equals 6 bytes in total.

1393
01:38:14,130 --> 01:38:14,630
Why?

1394
01:38:14,630 --> 01:38:20,210
Because C automatically adds this special 0 at the end of the string.

1395
01:38:20,210 --> 01:38:25,710
I've drawn it with backslash 0 because this is how you represent 0 as a char, as a character.

1396
01:38:25,710 --> 01:38:28,230
But this is literally just 0, as we'll soon see.

1397
01:38:28,230 --> 01:38:36,197
So any time there's a string in memory, it always takes up one more byte than you, yourself, as the programmer or human typed in.

1398
01:38:36,197 --> 01:38:45,170
In fact, if we convert this again, just for discussion's sake, to those integers, what's literally stored in the computer's memory is going to be 72, 73, 33, and now a 0.

1399
01:38:45,170 --> 01:38:54,530
And the computer, because of C and how it was invented, it's just smart enough to know that when you print out a string, it prints out every character until it sees a 0,

1400
01:38:54,530 --> 01:38:56,150
and then it just stops printing.

1401
01:38:56,150 --> 01:38:58,470
In particular, printf knows how this works.

1402
01:38:58,470 --> 01:39:02,050
And this is why printf knows when to stop printing.

1403
01:39:02,050 --> 01:39:03,800
Decimal numbers are not that enlightening.

1404
01:39:03,800 --> 01:39:05,940
We'll generally write the characters like this.

1405
01:39:05,940 --> 01:39:09,350
And again, backslash 0 is just special symbology.

1406
01:39:09,350 --> 01:39:13,190
It's what the programmer types to make clear that you're not saying, HI!, 0.

1407
01:39:13,190 --> 01:39:15,980
You're saying HI!, and then it's a special 0.

1408
01:39:15,980 --> 01:39:22,220
Specifically, it is eight 0 bits that indicate that it's the end of the string.

1409
01:39:22,220 --> 01:39:26,330
Technically, that backslash zero, if you want to be fancy, it's called null,

1410
01:39:26,330 --> 01:39:27,320
N-U-L-L.

1411
01:39:27,320 --> 01:39:30,320
And it turns out, you've seen this before, though we didn't call it out.

1412
01:39:30,320 --> 01:39:33,230
Here's that same ASCII chart from the past couple of weeks.

1413
01:39:33,230 --> 01:39:39,080
If I highlight this, what is decimal number 0 mapping to?

1414
01:39:39,080 --> 01:39:42,830
NUL, which is just programmer speak for the special null character.

1415
01:39:42,830 --> 01:39:46,550
All 0 bits that means the string ends here.

1416
01:39:46,550 --> 01:39:48,510
This all happens automatically for you.

1417
01:39:48,510 --> 01:39:53,420
You do not need to create these null characters or these zeros.

1418
01:39:53,420 --> 01:40:00,030
Any questions then, on this implementation thus far?

1419
01:40:00,030 --> 01:40:01,820
Any questions here?

1420
01:40:01,820 --> 01:40:02,320
No?

1421
01:40:02,320 --> 01:40:03,195
Well, let me do this.

1422
01:40:03,195 --> 01:40:05,310
Let me go back to VS Code in a second.

1423
01:40:05,310 --> 01:40:07,770
And let's actually corroborate this with some code.

1424
01:40:07,770 --> 01:40:10,830
Let me go ahead and create a small program called hi.c.

1425
01:40:10,830 --> 01:40:12,070
And how about we do this?

1426
01:40:12,070 --> 01:40:14,550
Let me include stdio.h.

1427
01:40:14,550 --> 01:40:18,670
Let me include-- let me type out int main void, as always.

1428
01:40:18,670 --> 01:40:24,960
And now let me do something simple and kind of bad, but char c1 equals quote unquote, h, in single quotes.

1429
01:40:24,960 --> 01:40:28,590
Char c2 equals quote unquote, I, in single quotes.

1430
01:40:28,590 --> 01:40:32,830
And lastly, char c3 equals exclamation point, in single quotes.

1431
01:40:32,830 --> 01:40:34,500
And now, let me just print this out.

1432
01:40:34,500 --> 01:40:36,960
I can't use %s because that is not a string.

1433
01:40:36,960 --> 01:40:40,290
That's literally three chars, because that's the design decision I made.

1434
01:40:40,290 --> 01:40:41,430
But I could do this--

1435
01:40:41,430 --> 01:40:48,600
%c, %c, %c, which we haven't seen before, but %s is string, %i is int,

1436
01:40:48,600 --> 01:40:51,060
%c is, indeed, char.

1437
01:40:51,060 --> 01:40:56,280
So let me put a backslash n at the end for cleanliness, and now do, c1, c2, c3.

1438
01:40:56,280 --> 01:41:00,430
So this is like a char-based version of printing string.

1439
01:41:00,430 --> 01:41:01,650
So let me make HI!

1440
01:41:01,650 --> 01:41:05,880
And then let me do ./hi, and it looks like I used printf with %s.

1441
01:41:05,880 --> 01:41:09,750
But I did things very manually by printing out each individual character.

1442
01:41:09,750 --> 01:41:16,560
What's cool now, though, is that once you know that characters are just numbers and strings are just characters, you can kind of poke around.

1443
01:41:16,560 --> 01:41:21,970
Let me change all three placeholders to %i instead.

1444
01:41:21,970 --> 01:41:23,860
And this is totally fine, too.

1445
01:41:23,860 --> 01:41:26,310
Let me rerun this, make hi.

1446
01:41:26,310 --> 01:41:31,570
Actually, let me make one change, just so we can see this.

1447
01:41:31,570 --> 01:41:40,350
Let me add spaces, just for aesthetics sake, let me do make hi, ./hi, Enter, and voila, like now, you can actually see the numbers,

1448
01:41:40,350 --> 01:41:44,085
that I claimed back in week zero, were in fact happening underneath the hood.

1449
01:41:44,085 --> 01:41:45,960
Well, this is not how you would make strings.

1450
01:41:45,960 --> 01:41:50,790
It'd be incredibly tedious to have three variables for three letter words, five variables for five letter words.

1451
01:41:50,790 --> 01:41:54,450
We've been using, of course, strings since last week, so let's do that instead.

1452
01:41:54,450 --> 01:41:59,370
String s equals quote unquote, double quotes "HI!"

1453
01:41:59,370 --> 01:42:02,520
For this, no, because of these training wheels,

1454
01:42:02,520 --> 01:42:04,560
I need to include the CS50 library.

1455
01:42:04,560 --> 01:42:06,580
But we'll come back to that in the coming weeks.

1456
01:42:06,580 --> 01:42:10,530
But for now, I'm going to go ahead and create a string s called quote unquote,

1457
01:42:10,530 --> 01:42:11,580
"HI!"

1458
01:42:11,580 --> 01:42:17,610
And now I'm going to change this to be my familiar %s, and now just print out s itself.

1459
01:42:17,610 --> 01:42:24,750
This, of course, is the same thing as last week, ./hi, gives me the exact same thing, but now, we're dealing, of course, with strings.

1460
01:42:24,750 --> 01:42:27,610
But how can we see a little beyond that?

1461
01:42:27,610 --> 01:42:28,810
Well, how about this?

1462
01:42:28,810 --> 01:42:31,530
Let's poke around further with today's primitives.

1463
01:42:31,530 --> 01:42:39,000
Even though s is a string, I could technically print out its first character with %c by doing s[0].

1464
01:42:39,000 --> 01:42:43,110
I could technically print out its second character with %c by doing s[1].

1465
01:42:43,110 --> 01:42:47,820
I could print out its third character with %c and printing out s[2].

1466
01:42:47,820 --> 01:42:52,770
So again, this just derives logically from my understanding now that strings are arrays, as you note.

1467
01:42:52,770 --> 01:42:57,300
Let me do make-- let me do make hi, ./hi.

1468
01:42:57,300 --> 01:43:00,760
And no visual change, but I'm just kind of now tinkering around.

1469
01:43:00,760 --> 01:43:03,400
And in fact, if you're really curious, let me do this.

1470
01:43:03,400 --> 01:43:08,250
Let me change these back to i, back to i-- oops, back to i.

1471
01:43:08,250 --> 01:43:14,490
And let me add a fourth one because if I'm really curious now, let's see what's in s[3].

1472
01:43:14,490 --> 01:43:16,020
This is the fourth byte.

1473
01:43:16,020 --> 01:43:18,990
And even though the string itself is H-I,

1474
01:43:18,990 --> 01:43:21,840
I think we can corroborate this whole null thing.

1475
01:43:21,840 --> 01:43:26,248
Make hi, ./hi, Enter, and there it is.

1476
01:43:26,248 --> 01:43:29,580
You could have done this last week, if you really wanted to geek out on strings.

1477
01:43:29,580 --> 01:43:33,060
But for now, it's just revealing what's going on underneath the hood.

1478
01:43:33,060 --> 01:43:36,480
Questions then, on what these strings are?

1479
01:43:36,480 --> 01:43:37,498
Yeah?

1480
01:43:37,498 --> 01:43:41,293
AUDIENCE: [INAUDIBLE]

1481
01:43:41,293 --> 01:43:42,960
DAVID MALAN: Why do we need the bracket?

1482
01:43:42,960 --> 01:43:45,430
AUDIENCE: [INAUDIBLE]

1483
01:43:45,430 --> 01:43:47,180
DAVID MALAN: Why do you not need brackets?

1484
01:43:47,180 --> 01:43:47,780
Good question.

1485
01:43:47,780 --> 01:43:51,620
Why do I not need brackets on line 6?

1486
01:43:51,620 --> 01:43:53,300
Because s is a string.

1487
01:43:53,300 --> 01:44:02,240
We'll see in a couple of weeks that s is, essentially, implemented underneath the hood, indeed, as an array, but that happens automatically for you.

1488
01:44:02,240 --> 01:44:06,800
You can treat s as just a variable name without square brackets.

1489
01:44:06,800 --> 01:44:13,730
You will use square brackets when you have arrays of ints or you manually create arrays of chars or doubles or floats or anything else.

1490
01:44:13,730 --> 01:44:14,900
But strings are special.

1491
01:44:14,900 --> 01:44:15,440
Why?

1492
01:44:15,440 --> 01:44:19,190
I mean, every program you write seems to use strings, text in some form.

1493
01:44:19,190 --> 01:44:21,930
We're humans we like text, not just numbers and such.

1494
01:44:21,930 --> 01:44:28,580
So this is just treated a little specially in C and many other languages as well.

1495
01:44:28,580 --> 01:44:31,170
Other questions on this here?

1496
01:44:31,170 --> 01:44:31,670
No?

1497
01:44:31,670 --> 01:44:33,530
Let's add then, one other string to the mix.

1498
01:44:33,530 --> 01:44:38,660
So instead of just saying, HI!, why don't we consider a version of the program that says both, HI! and BYE!.

1499
01:44:38,660 --> 01:44:48,570
And I claim now that that backslash zero, that null character is going to be ever more important now if we've got two strings in memory, so that C knows how to distinguish one from the other.

1500
01:44:48,570 --> 01:44:51,487
So let me go ahead and just get rid of these two lines for the moment.

1501
01:44:51,487 --> 01:44:55,430
Let me recreate string s equals, quote unquote double quotes, "HI!"

1502
01:44:55,430 --> 01:44:56,780
Let me give myself another one.

1503
01:44:56,780 --> 01:44:59,905
And because I'm just playing around, I'll choose very short variable names.

1504
01:44:59,905 --> 01:45:04,410
String t equals quote unquote, "BYE!"

1505
01:45:04,410 --> 01:45:06,470
And then let me just print them both out.

1506
01:45:06,470 --> 01:45:16,910
Let me go ahead and print out %s, backslash n, comma s, and then printf %s backslash n, and then t.

1507
01:45:16,910 --> 01:45:19,970
So very simple demonstration of just these two variables.

1508
01:45:19,970 --> 01:45:26,090
Make hi, ./hi, and of course, it prints out two lines, one after the other.

1509
01:45:26,090 --> 01:45:27,980
What's actually going on underneath the hood?

1510
01:45:27,980 --> 01:45:29,510
Well, let's go back to the computer's memory.

1511
01:45:29,510 --> 01:45:32,160
HI!, I think, is going to be, I claim, pretty much the same.

1512
01:45:32,160 --> 01:45:36,170
So s, I'll claim, is in the top left, followed by the backslash zero.

1513
01:45:36,170 --> 01:45:40,035
And that's important now because BYE! probably is going to end up there.

1514
01:45:40,035 --> 01:45:44,330
And visually, it wraps just by nature of how I've drawn this grid of bytes, but it's contiguous.

1515
01:45:44,330 --> 01:45:58,580
B-Y-E-! null, A.K.A. backslash zero, this is now helpful to printf because now printf knows where one begins and ends by way of that special null character.

1516
01:45:58,580 --> 01:46:00,230
But we can poke around now, too.

1517
01:46:00,230 --> 01:46:01,620
What else can I do here?

1518
01:46:01,620 --> 01:46:02,840
How about this?

1519
01:46:02,840 --> 01:46:15,410
How about I go into my code here, back to VS code, and let me go ahead and say something like, well, if I've got two of these strings, you know, let's put them in an array.

1520
01:46:15,410 --> 01:46:20,520
Let's kind of do this sort of arrays in arrays, sort of inception-style here.

1521
01:46:20,520 --> 01:46:23,060
So string words[2].

1522
01:46:23,060 --> 01:46:25,100
So give me an array of two strings is what

1523
01:46:25,100 --> 01:46:28,100
I'm saying here in code, even though we've not done it with strings yet.

1524
01:46:28,100 --> 01:46:29,270
We only did it with ints.

1525
01:46:29,270 --> 01:46:30,770
And now let me do this.

1526
01:46:30,770 --> 01:46:35,480
The first word A.K.A. words[0] will equal, as before, HI!

1527
01:46:35,480 --> 01:46:40,940
And now words[1] will equal quote unquote, "BYE!"

1528
01:46:40,940 --> 01:46:48,650
And now I've done the exact same thing, but again, I'm just avoiding having s, t, q, r, and all these different variables in my code.

1529
01:46:48,650 --> 01:46:52,790
I just now am treating them as one single array of strings.

1530
01:46:52,790 --> 01:46:54,750
How do I change my code down here?

1531
01:46:54,750 --> 01:46:57,380
Well, if I want to print the first word, I do words[0].

1532
01:46:57,380 --> 01:46:59,900
And if I want to print the second word, I do words[1].

1533
01:46:59,900 --> 01:47:04,130
This is not a useful exercise at the moment because I'm just making my code more complicated.

1534
01:47:04,130 --> 01:47:09,530
But again, it allows us to poke around and see what's going on because there is that HI! and BYE!.

1535
01:47:09,530 --> 01:47:10,700
But watch this.

1536
01:47:10,700 --> 01:47:14,670
If I really want to be cool, I can do this.

1537
01:47:14,670 --> 01:47:25,700
Let's print out %c, %c, %c, backslash n, and then here, %c, %c, %c, %c, so four of those.

1538
01:47:25,700 --> 01:47:28,430
And now here's where things get interesting.

1539
01:47:28,430 --> 01:47:30,620
Words is an array of strings.

1540
01:47:30,620 --> 01:47:33,400
Again, if I may, what's a string?

1541
01:47:33,400 --> 01:47:35,060
An array of characters.

1542
01:47:35,060 --> 01:47:36,790
So just use the same logic.

1543
01:47:36,790 --> 01:47:41,110
If words is an array of strings, you get at the first string with words[0].

1544
01:47:41,110 --> 01:47:44,530
How do you get at the first character in the first string?

1545
01:47:44,530 --> 01:47:52,150
Bracket 0, words[0][1], and lastly, words[0][2].

1546
01:47:52,150 --> 01:47:57,460
And now down here, words[1], but the first character is there.

1547
01:47:57,460 --> 01:48:00,400
Word[1], the second character is here.

1548
01:48:00,400 --> 01:48:04,720
Words[1], the third character is here-- whoops-- third character's here.

1549
01:48:04,720 --> 01:48:07,898
And words[1], the fourth character is here.

1550
01:48:07,898 --> 01:48:09,190
This is not how people program.

1551
01:48:09,190 --> 01:48:10,840
This is only for demonstrations sake.

1552
01:48:10,840 --> 01:48:13,060
My God, it's so tedious and verbose already.

1553
01:48:13,060 --> 01:48:22,990
But if I make hi now, ./hi, now, I'm manually reinventing %s, if I forgot it existed, using %c alone.

1554
01:48:22,990 --> 01:48:25,900
But you can indeed manipulate arrays in this way.

1555
01:48:25,900 --> 01:48:32,200
But because strings are arrays of characters, you can manipulate strings in this way too.

1556
01:48:32,200 --> 01:48:34,675
Any question now on this syntax?

1557
01:48:37,210 --> 01:48:38,800
Any questions here?

1558
01:48:38,800 --> 01:48:39,970
No?

1559
01:48:39,970 --> 01:48:45,830
All right, well, let's go ahead and propose that we solve a couple of other problems we might not have as before.

1560
01:48:45,830 --> 01:48:49,150
But first, a quick visual of what's been going on underneath the hood here.

1561
01:48:49,150 --> 01:49:00,880
If here, again, is where we left off on the screen, HI! and BYE! back to back, here is really how I just treated these things. s bracket 0, 1, 2, 3 and then t 0, 1, 2, 3, 4.

1562
01:49:00,880 --> 01:49:04,840
But really, once I put them in an array, the picture becomes this.

1563
01:49:04,840 --> 01:49:07,030
Words[0] is the whole HI!.

1564
01:49:07,030 --> 01:49:08,680
Words[1] is the whole BYE!.

1565
01:49:08,680 --> 01:49:20,710
But if I really get into the weeds and start indexing into individual characters in those strings, all I'm using is new syntax in order to represent these same values here.

1566
01:49:20,710 --> 01:49:28,710
Questions then, on these representations before we forge ahead?

1567
01:49:28,710 --> 01:49:29,430
No?

1568
01:49:29,430 --> 01:49:30,030
Yeah?

1569
01:49:30,030 --> 01:49:33,390
AUDIENCE: Does the new line character not [INAUDIBLE]??

1570
01:49:33,390 --> 01:49:36,030
DAVID MALAN: Does the new line character-- say that once more?

1571
01:49:36,030 --> 01:49:38,597
AUDIENCE: Does the new line character take up any space?

1572
01:49:38,597 --> 01:49:40,180
DAVID MALAN: Ah, really good question.

1573
01:49:40,180 --> 01:49:42,730
Does the new line character take up any space?

1574
01:49:42,730 --> 01:49:45,340
It does, so far as printf is concerned.

1575
01:49:45,340 --> 01:49:53,460
But I'm not storing the backslash n in my strings, printf is being manually handed that thing instead.

1576
01:49:53,460 --> 01:50:00,680
All right, so let's go ahead then and consider how we might solve some problems that have arisen now with these strings, as follows here.

1577
01:50:00,680 --> 01:50:02,760
Suppose I-- let's do this.

1578
01:50:02,760 --> 01:50:04,400
Let me go back to VS Code here.

1579
01:50:04,400 --> 01:50:09,980
And let me go ahead and open up a new file called, how about, length.c.

1580
01:50:09,980 --> 01:50:16,130
And let's consider for a moment how I might actually figure out what the length of a string is, which is distinct from the length of an array.

1581
01:50:16,130 --> 01:50:20,180
I claimed earlier, you cannot figure out dynamically what the length of an array is.

1582
01:50:20,180 --> 01:50:26,960
But I can figure out the length of a string, specifically, because of this implementation detail of that null character.

1583
01:50:26,960 --> 01:50:28,500
So let me go ahead and do this.

1584
01:50:28,500 --> 01:50:31,940
Let me include cs50.h in this second program here.

1585
01:50:31,940 --> 01:50:35,090
Let me include stdio.h, as before.

1586
01:50:35,090 --> 01:50:40,970
And let me do this, int main void-- and the first thing I'll do is just get a string from the user.

1587
01:50:40,970 --> 01:50:43,250
I'll ask the user, as always, for their name.

1588
01:50:43,250 --> 01:50:48,170
So I'll call getString, and say, what's your name, question mark, as always.

1589
01:50:48,170 --> 01:50:58,465
And then down here, if I want to figure out the length of this string and print the length out on the screen, well, I can kind of do this similar in spirit to the average,

1590
01:50:58,465 --> 01:50:59,840
where I'm accumulating something.

1591
01:50:59,840 --> 01:51:02,600
Let me go ahead and initialize N to 0.

1592
01:51:02,600 --> 01:51:07,035
Let me give myself-- it's not a for loop because I don't have a--

1593
01:51:07,035 --> 01:51:08,660
I don't know in advance how long it is.

1594
01:51:08,660 --> 01:51:09,980
But what if I do this?

1595
01:51:09,980 --> 01:51:25,590
While the value at name[n] does not equal '/0'-- crazy syntax at the moment, but it's just the culmination of these various building blocks.

1596
01:51:25,590 --> 01:51:28,970
Let me just finish the thought here, n++.

1597
01:51:28,970 --> 01:51:43,220
And then down here, let's just print out, with printf and %i, that value of N. So I claim this is going to show me the length of any string I type in, whether it's hi or bye or David or anything else.

1598
01:51:43,220 --> 01:51:47,535
I initialize a variable to zero, and that's good because that's where you start counting in general.

1599
01:51:47,535 --> 01:51:50,990
While name[0] does not equal backslash zero.

1600
01:51:50,990 --> 01:51:51,930
What is this saying?

1601
01:51:51,930 --> 01:51:59,390
Well, if name is the string the user typed in-- and name is just an array, as you noted-- the name[0] is going to be the first character.

1602
01:51:59,390 --> 01:52:03,680
And I'm asking the question, well, does the first character not equal backslash zero?

1603
01:52:03,680 --> 01:52:08,750
And if I type in David, D, it's not, so I keep going and I add 1 to N.

1604
01:52:08,750 --> 01:52:10,750
Then I'm going to check name[1].

1605
01:52:10,750 --> 01:52:13,895
Well, if I typed in David, name[1] is going to be A.

1606
01:52:13,895 --> 01:52:18,740
A does not equal backslash zero, and so it's going to go again and again and again.

1607
01:52:18,740 --> 01:52:23,090
But five steps in total later, it's going to get to the byte after

1608
01:52:23,090 --> 01:52:26,480
D-A-V-I-D, realize, wait a minute, that is a backslash n.

1609
01:52:26,480 --> 01:52:29,750
The loop finishes, and I print out the total length.

1610
01:52:29,750 --> 01:52:33,050
Arrays, in general, do not have this null character.

1611
01:52:33,050 --> 01:52:34,910
However, strings do.

1612
01:52:34,910 --> 01:52:39,590
Again, strings are special versus all of the other data types we've talked about thus far.

1613
01:52:39,590 --> 01:52:43,220
But how could I, for instance, do this differently?

1614
01:52:43,220 --> 01:52:47,220
Well, let's actually factor this out as a function, as I've commonly done.

1615
01:52:47,220 --> 01:52:50,540
But rather than implement it myself, you know what?

1616
01:52:50,540 --> 01:52:57,260
It turns out what's nice about strings being so common, there are many other people who have solved these problems before.

1617
01:52:57,260 --> 01:53:00,290
And in fact, there's a whole string library in C.

1618
01:53:00,290 --> 01:53:04,190
It is used by way of a header file called string.h.

1619
01:53:04,190 --> 01:53:08,400
And what string.h is, is a library of string-related functions.

1620
01:53:08,400 --> 01:53:18,050
In fact, you can see in CS50's manual pages for C, the string.h functions, at least those that we recommend as most useful, and in particular, if you poke around there,

1621
01:53:18,050 --> 01:53:20,290
you'll see that there's a function called strlen.

1622
01:53:20,290 --> 01:53:22,055
It means string length.

1623
01:53:22,055 --> 01:53:25,850
It was named very succinctly, just because it's a little easier to type than string length.

1624
01:53:25,850 --> 01:53:28,800
But strlen tells you the length of a string.

1625
01:53:28,800 --> 01:53:30,990
So how might I use this in my code here?

1626
01:53:30,990 --> 01:53:34,020
Well, it turns out, I can simplify this quite a bit.

1627
01:53:34,020 --> 01:53:45,630
Let me get rid of my loop, get rid of my accounting manually, and do something like this-- int n equals strlen of the humans name, name.

1628
01:53:45,630 --> 01:53:51,290
And now I'll just use printf, as before, with %i backslash n, and output the value of n.

1629
01:53:51,290 --> 01:53:54,380
But there's a bug at the moment.

1630
01:53:54,380 --> 01:53:58,480
What have I forgotten to do?

1631
01:53:58,480 --> 01:54:03,260
Yeah, I have to include the header file at the top of the screen, so let me-- at the top of the code.

1632
01:54:03,260 --> 01:54:10,970
So let me also include string.h at the top of my file, so that C knows that, in fact, strlen exists.

1633
01:54:10,970 --> 01:54:14,170
Let me go ahead and make length, as before.

1634
01:54:14,170 --> 01:54:18,670
./length-- or actually, really for the first time, what's your name?

1635
01:54:18,670 --> 01:54:22,360
D-A-V-I-D. And hopefully, I'm going to see, in fact, 5.

1636
01:54:22,360 --> 01:54:26,950
By contrast, if I run it again and type in HI!, now I see three.

1637
01:54:26,950 --> 01:54:29,785
So strlen is just one of the functions in that library.

1638
01:54:29,785 --> 01:54:30,910
And there are so many more.

1639
01:54:30,910 --> 01:54:40,580
In fact, yet another library that might be useful moving forward is this one, ctype, which relates to C data types and lots of functions therein that can be useful.

1640
01:54:40,580 --> 01:54:49,460
For instance, if you review its documentation in the manual pages online, you'll see that there are functions via which we can solve problems like this.

1641
01:54:49,460 --> 01:54:53,680
Let me go ahead and propose here-- let me see.

1642
01:54:53,680 --> 01:55:06,700
Let's do an example here involving-- how about checking if something is uppercase or lowercase, and converting it to uppercase only.

1643
01:55:06,700 --> 01:55:10,810
Let me go back to VS Code, and code a program called uppercase.c.

1644
01:55:10,810 --> 01:55:15,220
In this, file I'm going to start by including now, as always, cs50.h.

1645
01:55:15,220 --> 01:55:17,710
I'm going to include stdio.h.

1646
01:55:17,710 --> 01:55:26,230
And I'm going to add one other to the mix, which is string.h now too, so I can access the length of things as needed.

1647
01:55:26,230 --> 01:55:28,570
Int main void comes next.

1648
01:55:28,570 --> 01:55:32,230
And then within my main function, I'm going to go ahead and declare a string called s.

1649
01:55:32,230 --> 01:55:34,240
I'm going to call getString, as before.

1650
01:55:34,240 --> 01:55:38,170
And I'm going to go ahead and just ask the user for a string called before.

1651
01:55:38,170 --> 01:55:39,670
I want to do a before and after.

1652
01:55:39,670 --> 01:55:41,350
Whatever the user types in is before.

1653
01:55:41,350 --> 01:55:44,770
But I want to force everything to uppercase, thereafter.

1654
01:55:44,770 --> 01:55:48,740
Let me now, in this loop here, do this.

1655
01:55:48,740 --> 01:55:53,800
Let me printf quote unquote, "After," just so we can see this on the screen.

1656
01:55:53,800 --> 01:56:02,440
And let me do four int i gets 0, i is less than strlen of s, i++.

1657
01:56:02,440 --> 01:56:03,610
What am I about to do?

1658
01:56:03,610 --> 01:56:11,230
I'm about to iterate over every character in the string from left to right, from 0 on up to, but not through, the length of s.

1659
01:56:11,230 --> 01:56:16,990
And how do I check if something is lowercase, so that I can actually force it to uppercase?

1660
01:56:16,990 --> 01:56:19,630
Well, it turns out, I could do this literally.

1661
01:56:19,630 --> 01:56:31,780
If the character in s at location i is greater than or equal to capital A, ampersand, ampersand, which means and instead of or, which we saw

1662
01:56:31,780 --> 01:56:41,800
in the past, s[i] is less than or equal to little z, that means, logically in English, that this is indeed lowercase.

1663
01:56:41,800 --> 01:56:44,830
How do I now convert it to uppercase, this character?

1664
01:56:44,830 --> 01:56:48,160
Well, I could just literally print out the same character.

1665
01:56:48,160 --> 01:56:52,280
But that would not be the answer here because that's not changing the value.

1666
01:56:52,280 --> 01:56:54,470
But what could I do instead?

1667
01:56:54,470 --> 01:57:03,220
Well, let me actually pull up here real fast the ASCII chart as before, and let's see if we can't glean some insight.

1668
01:57:03,220 --> 01:57:09,790
If I pull up the same ASCII chart, and suppose the human has typed in a lowercase a, that's 97.

1669
01:57:09,790 --> 01:57:13,240
What letter-- I want to convert it to uppercase

1670
01:57:13,240 --> 01:57:18,660
A, so what number do I want to convert the 97 to, per week zero?

1671
01:57:18,660 --> 01:57:21,000
So 65, we keep coming back to that one.

1672
01:57:21,000 --> 01:57:23,010
What if the user types in lowercase b?

1673
01:57:23,010 --> 01:57:27,550
I want to change the 98 value to 66, and so forth.

1674
01:57:27,550 --> 01:57:30,130
And any quick math, how far apart are those?

1675
01:57:30,130 --> 01:57:37,990
So it's always 32, like uppercase to lowercase is always, wonderfully, good design, 32 away, one from the other.

1676
01:57:37,990 --> 01:57:39,100
So what does this mean?

1677
01:57:39,100 --> 01:57:42,600
Well, I think we saw earlier that underneath the hood, a char is just a number.

1678
01:57:42,600 --> 01:57:44,340
You can certainly do arithmetic on it.

1679
01:57:44,340 --> 01:57:48,180
And here, again, if you understand these lower level primitives, what if I do this?

1680
01:57:48,180 --> 01:57:57,048
Whatever s[i] is, if I know on line 13 that it's lowercase, do I want to add or subtract 32?

1681
01:57:57,048 --> 01:57:57,840
AUDIENCE: Subtract.

1682
01:57:57,840 --> 01:58:06,560
DAVID MALAN: So I want to subtract because I want to go from like 97 to 65 or 98 to 66, so indeed, if you do some quick math, that gives you 32.

1683
01:58:06,560 --> 01:58:16,370
So it's suffices to just treat chars as numbers, subtract the 32, and printing it with %c, I think, will just convert lowercase to uppercase.

1684
01:58:16,370 --> 01:58:24,980
If you now fast forward to the real world, Microsoft Word or Google Docs, if you've ever chosen the menu option that forces things to uppercase or lowercase on occasion, literally, that's

1685
01:58:24,980 --> 01:58:26,480
what Microsoft and Google have done.

1686
01:58:26,480 --> 01:58:33,810
They iterate over every character in the document, check if it's lowercase, and if so, they subtract 32 from it and show you the new value.

1687
01:58:33,810 --> 01:58:36,650
What if, though, it is not a lowercase letter?

1688
01:58:36,650 --> 01:58:46,490
I think I can keep it easy and just print out the current letter unchanged, if my goal is to simply force things to all uppercase, and that letter, then would be s[i].

1689
01:58:46,490 --> 01:58:50,750
So let me go ahead now and make uppercase, hopefully, no errors.

1690
01:58:50,750 --> 01:58:57,120
./uppercase, and I'll now type in David with an uppercase D, but lowercase everything else.

1691
01:58:57,120 --> 01:59:01,190
But now the after version is DAVID-- an aesthetic bug.

1692
01:59:01,190 --> 01:59:05,930
Notice here, I forgot to include, just for prettiness sake, a backslash n at the end.

1693
01:59:05,930 --> 01:59:07,640
No problem, I'll add that.

1694
01:59:07,640 --> 01:59:08,870
Let me fix my mistake.

1695
01:59:08,870 --> 01:59:12,050
Make uppercase, ./uppercase, Enter.

1696
01:59:12,050 --> 01:59:14,240
D-A-V-I-D, Enter, and voila.

1697
01:59:14,240 --> 01:59:22,070
And I deliberately added another space after, just so they would line up pretty, even though before and after have different numbers of letters.

1698
01:59:22,070 --> 01:59:28,380
Questions then, on this implementation of forcing something to uppercase, which in and of itself is not all that enlightening,

1699
01:59:28,380 --> 01:59:33,990
but is representative now of how you can leverage these low level primitives.

1700
01:59:33,990 --> 01:59:35,880
Question?

1701
01:59:35,880 --> 01:59:36,380
No?

1702
01:59:36,380 --> 01:59:38,633
All right, well, this honestly is tedious.

1703
01:59:38,633 --> 01:59:43,550
My God, like does Microsoft, Google, everyone, you have to literally write out this code just to do something simple?

1704
01:59:43,550 --> 01:59:46,310
Well, no, that's, again, why we have things like libraries.

1705
01:59:46,310 --> 01:59:55,940
And increasingly now, for problem sets, projects, and beyond, well, you just use libraries more often off-the-shelf so as to solve problems that, surely, other people have had before you.

1706
01:59:55,940 --> 01:59:59,570
So how can I now use this library, ctype.h?

1707
01:59:59,570 --> 02:00:01,320
Well, let me go back into my code.

1708
02:00:01,320 --> 02:00:05,090
Let me include this among my header files here.

1709
02:00:05,090 --> 02:00:08,030
Just so I can skim things easily, I tend to alphabetize my headers.

1710
02:00:08,030 --> 02:00:13,400
But that's not strictly necessary, but it allows me, at a glance, to realize, did I or did I not include something I need?

1711
02:00:13,400 --> 02:00:15,570
Now, let me go ahead and do this.

1712
02:00:15,570 --> 02:00:28,910
It turns out if you read the documentation for the C type library, there's a function, wonderfully called, if islower, that takes in a character as its argument, essentially, so s[i].

1713
02:00:28,910 --> 02:00:33,890
And if that returns true, a Boolean value, if you will, well, I'm going to force it to lowercase.

1714
02:00:33,890 --> 02:00:36,560
But I don't have to do this math anymore.

1715
02:00:36,560 --> 02:00:45,060
Turns out, in the C type library, there's also a function called to upper that takes a character as input, like s[i], and it just does the math for you.

1716
02:00:45,060 --> 02:00:50,400
So that you can abstract away the 32 thing, and just know that someone else has solved that problem for you.

1717
02:00:50,400 --> 02:00:55,200
Otherwise, I can leave my code unchanged down below because I'm not changing anything else.

1718
02:00:55,200 --> 02:01:03,710
So if I do make uppercase now, and then ./uppercase, D-a-v-i-d, with just a capital D, and now it still works.

1719
02:01:03,710 --> 02:01:07,520
But if you read the documentation further, it turns out that to upper is smart.

1720
02:01:07,520 --> 02:01:13,040
If you pass in a character to to upper, that's lowercase, it obviously converts it to uppercase by doing that math.

1721
02:01:13,040 --> 02:01:21,540
But if you pass in a character to to upper that's already uppercase, the documentation you would see tells you that it leaves it unchanged.

1722
02:01:21,540 --> 02:01:23,910
So I can tighten all of this up.

1723
02:01:23,910 --> 02:01:25,880
I can get rid of the whole else.

1724
02:01:25,880 --> 02:01:33,620
I can get rid of the whole if, and arguably now, implement a program that's just as correct, but better designed.

1725
02:01:33,620 --> 02:01:34,250
Why?

1726
02:01:34,250 --> 02:01:39,740
Fewer lines of code easier to read, lower probability of mistakes, assuming the library is correct.

1727
02:01:39,740 --> 02:01:43,160
It just makes it easier and faster for me, now, to write code.

1728
02:01:43,160 --> 02:01:50,190
So if I now do, one last time, make uppercase, Enter, ./uppercase, and type in my name, still working.

1729
02:01:50,190 --> 02:01:57,740
But now notice, we've whittled this down to far fewer lines of code, albeit, using now this additional library.

1730
02:01:57,740 --> 02:02:00,140
Questions then on how we did this?

1731
02:02:03,930 --> 02:02:09,120
Well, even though this code, I daresay, is correct, it's not necessarily well-designed just yet.

1732
02:02:09,120 --> 02:02:17,900
In fact, there's one line of code, one function call in this current implementation that's more inefficient than it needs to be.

1733
02:02:17,900 --> 02:02:24,320
And allow me to draw your attention to this here, line 10, wherein we're calling strlen.

1734
02:02:24,320 --> 02:02:29,000
But we're calling it inside of this for loop, specifically, inside of the condition.

1735
02:02:29,000 --> 02:02:33,720
And why might that not necessarily be the best idea?

1736
02:02:33,720 --> 02:02:36,810
Well, is the length of the string as changing, ever?

1737
02:02:36,810 --> 02:02:38,950
I mean, certainly not within the span of this loop.

1738
02:02:38,950 --> 02:02:45,242
And so here we are within our for loop on line 10, 11, 12, and 13, asking on every iteration that same question.

1739
02:02:45,242 --> 02:02:48,330
What's the length of s?

1740
02:02:48,330 --> 02:02:52,660
And in turn, we're calling strlen every time, even though we're getting back the same answer.

1741
02:02:52,660 --> 02:02:59,490
So I daresay a better solution here would be to maybe figure out the length of s earlier on in my code, and maybe declare a variable.

1742
02:02:59,490 --> 02:03:07,860
Or perhaps do something that's syntactically a little more elegant, and in fact, a very common design in a loop like this, would be to declare not just one variable like i,

1743
02:03:07,860 --> 02:03:16,530
but to actually declare a second variable called n, for instance, where n is just some number, set n equal to the length of s.

1744
02:03:16,530 --> 02:03:24,540
But thereafter, inside of this condition, instead of calling strlen of s again and again and again, what might I now do?

1745
02:03:24,540 --> 02:03:32,730
I could instead just compare i against n itself, because n now will only be calculated once when it's initialized, just as i is initialize to zero.

1746
02:03:32,730 --> 02:03:37,350
And thereafter, we're going to be comparing i, which is changing, against n, which will not be.

1747
02:03:37,350 --> 02:03:40,330
So it's going to be marginally more efficient by design.

1748
02:03:40,330 --> 02:03:47,100
Now with that said, a good compiler could also recognize that there is this optimization possibility, and maybe do it for us.

1749
02:03:47,100 --> 02:03:54,010
But for now, best to get into the habit, best to develop the muscle memory for making those better design decisions yourselves.

1750
02:03:54,010 --> 02:03:56,380
Questions, then, on how we did this?

1751
02:03:58,900 --> 02:03:59,650
No?

1752
02:03:59,650 --> 02:04:03,050
All right, a few final building blocks for the day.

1753
02:04:03,050 --> 02:04:13,090
So we started by talking about those command line arguments that clang uses, whereby, anything after the command that you type at a prompt, be it make

1754
02:04:13,090 --> 02:04:21,350
or clang or even CD in Linux, any word thereafter, or something cryptic like -o is a command line argument.

1755
02:04:21,350 --> 02:04:22,840
It's an input to the command.

1756
02:04:22,840 --> 02:04:27,280
It's different from a function argument because a function argument, of course, is an input to a function.

1757
02:04:27,280 --> 02:04:28,345
But it's the same idea.

1758
02:04:28,345 --> 02:04:30,970
It's just different syntax after the dollar sign at the prompt.

1759
02:04:30,970 --> 02:04:41,800
Well, it turns out that command line arguments are something you can now use in your own programs by accessing words after the prompt.

1760
02:04:41,800 --> 02:04:45,410
And let me propose that we invent this as follows.

1761
02:04:45,410 --> 02:04:53,560
Let me propose that we switch back to VS Code here, and I'll open a new file here called greet.c.

1762
02:04:53,560 --> 02:04:57,070
So in greet.c, it's going to be a program that very simply greets the user.

1763
02:04:57,070 --> 02:04:59,440
Had we written this last week, we would have done this.

1764
02:04:59,440 --> 02:05:15,980
Include cs50.h, and then include stdio.h, and then int main void, and then we might do something simple like string name equals getString, quote unquote, "What's your name?"

1765
02:05:15,980 --> 02:05:21,490
And then we would have printed out, as always, Hello, %s, and then plugging in that name.

1766
02:05:21,490 --> 02:05:29,140
So this is the same program we've implemented many times, just to make sure it works-- although, nope, that's not quite the same program.

1767
02:05:29,140 --> 02:05:30,940
Semicolon's in the wrong place.

1768
02:05:30,940 --> 02:05:32,960
This now is the same program.

1769
02:05:32,960 --> 02:05:37,610
So make greet, dot ./greet, and I'll type in my own name. hello, David.

1770
02:05:37,610 --> 02:05:38,770
So we're back there.

1771
02:05:38,770 --> 02:05:44,110
Now, what's arguably a little annoying about this program, if I type in something else like, Carter,

1772
02:05:44,110 --> 02:05:48,910
Enter, I have to run the program, wait for the prompt, type in my name, hit Enter.

1773
02:05:48,910 --> 02:05:52,360
And that's fine, but imagine if every program worked like this.

1774
02:05:52,360 --> 02:05:58,540
Like make, suppose you could only type make, then you wait for a prompt, then you type the name of the program you want to make, then you hit Enter.

1775
02:05:58,540 --> 02:06:07,930
Or worse, in Linux when you have to change directories, as you might have for problem set one, what if you had to type CD, Enter, now type the name of the folder you want to change into, Enter--

1776
02:06:07,930 --> 02:06:09,710
I mean, it just slows life down.

1777
02:06:09,710 --> 02:06:11,470
And so it just gets annoying quickly.

1778
02:06:11,470 --> 02:06:16,070
So command line arguments just let you express your whole thought all at once.

1779
02:06:16,070 --> 02:06:18,200
So how can I do this?

1780
02:06:18,200 --> 02:06:22,450
Well, if I want to express the notion of command line arguments in my code,

1781
02:06:22,450 --> 02:06:25,640
I could do something like this.

1782
02:06:25,640 --> 02:06:34,780
I could, for the very first time, go up and get rid of this void, which as of today means, this program takes no command line arguments.

1783
02:06:34,780 --> 02:06:37,540
And I can change it to exactly this.

1784
02:06:37,540 --> 02:06:43,490
Int argc, string argv, with brackets.

1785
02:06:43,490 --> 02:06:44,950
Now it's cryptic, admittedly.

1786
02:06:44,950 --> 02:06:46,150
And let me zoom in.

1787
02:06:46,150 --> 02:06:49,300
But I think we can perhaps infer now, what's going on.

1788
02:06:49,300 --> 02:06:59,230
If main now does not have void as its input, which means it takes no arguments, surely, the spoiler here is that now main will take command line arguments somehow.

1789
02:06:59,230 --> 02:07:05,180
Any guesses as to what argv is or will be?

1790
02:07:05,180 --> 02:07:08,330
What might this represent?

1791
02:07:08,330 --> 02:07:11,390
It's an array of strings, right, by way of the syntax.

1792
02:07:11,390 --> 02:07:13,223
Yeah?

1793
02:07:13,223 --> 02:07:15,480
AUDIENCE: All the characters will be typed out.

1794
02:07:15,480 --> 02:07:16,050
DAVID MALAN: Exactly.

1795
02:07:16,050 --> 02:07:19,830
It will be all of the characters, or really all of the words that you type at the prompt.

1796
02:07:19,830 --> 02:07:21,765
Argc, as an int, any guess?

1797
02:07:24,360 --> 02:07:30,290
Argument count is what it generally stands for, though technically, you could call these things anything.

1798
02:07:30,290 --> 02:07:31,520
But this is the convention.

1799
02:07:31,520 --> 02:07:41,420
Because I claimed earlier that arrays don't keep track of their own length, if you want to know how many words the human typed at the prompt after your program's name, you have to be told,

1800
02:07:41,420 --> 02:07:45,650
not just the array of the words, but the length of that array.

1801
02:07:45,650 --> 02:07:55,020
The strings, you can figure out the length of using strlen, but you can't figure out the length of the array of strings, the collection of words that the human typed in.

1802
02:07:55,020 --> 02:07:56,760
So how can I now use this?

1803
02:07:56,760 --> 02:07:59,190
Well, let me go ahead and do this.

1804
02:07:59,190 --> 02:08:04,190
Let me go ahead and change this program now just to be printf, quote unquote,

1805
02:08:04,190 --> 02:08:11,630
"hello, %2 /n", then argv[1].

1806
02:08:11,630 --> 02:08:14,780
So this is not the best version of my code yet, but it's my first.

1807
02:08:14,780 --> 02:08:21,020
Make greet, and now let me do ./greet, David all at once.

1808
02:08:21,020 --> 02:08:23,210
Enter, hello, David.

1809
02:08:23,210 --> 02:08:25,820
Now let me run it again, ./greet, Carter.

1810
02:08:25,820 --> 02:08:27,620
Enter, hello, Carter.

1811
02:08:27,620 --> 02:08:32,330
It's a marginal improvement, but I don't have to wait for getString to prompt me to hit Enter.

1812
02:08:32,330 --> 02:08:34,370
It's just speeding things up, twice as fast.

1813
02:08:34,370 --> 02:08:36,890
One less command to type in.

1814
02:08:36,890 --> 02:08:41,390
But I deliberately did [1], but what's the beginning of argv?

1815
02:08:41,390 --> 02:08:42,170
It would be [0].

1816
02:08:44,730 --> 02:08:45,780
Well, what's that?

1817
02:08:45,780 --> 02:08:48,840
This is sometimes useful, though for now, it's not.

1818
02:08:48,840 --> 02:08:54,110
Suppose I recompile my code and run this program now, greet David.

1819
02:08:54,110 --> 02:08:58,598
Anyone want to guess what's in argv[0]?

1820
02:08:58,598 --> 02:08:59,530
AUDIENCE: [INAUDIBLE]

1821
02:08:59,530 --> 02:09:00,220
DAVID MALAN: Say again?

1822
02:09:00,220 --> 02:09:01,230
AUDIENCE: Greet, hello.

1823
02:09:01,230 --> 02:09:04,530
DAVID MALAN: Greet, Enter, hello, ./greet.

1824
02:09:04,530 --> 02:09:14,460
So if you want to sort of inception style your program to figure out what its own name is, or at least how it was executed at the command line, at the terminal, you can look at argv[0].

1825
02:09:14,460 --> 02:09:21,900
In general, probably not that useful, probably better to start looking at [1], which was the first word after the program name.

1826
02:09:21,900 --> 02:09:27,690
And if there were more, I could do this how about argv[2], let me add in a second %s.

1827
02:09:27,690 --> 02:09:29,550
Let me recompile greet.

1828
02:09:29,550 --> 02:09:37,112
Let me do ./greet David Malan, Enter, and that, too, now works, taking in two words at the prompt.

1829
02:09:37,112 --> 02:09:38,820
If I really want to be smart at this now,

1830
02:09:38,820 --> 02:09:40,445
I could do something like this, though.

1831
02:09:40,445 --> 02:09:58,440
How about if the count of arguments, A.K.A. argc, equals equals to, then assume that the human typed in only their first name, and do printf hello comma %s /n, and then argv[1].

1832
02:09:58,440 --> 02:10:07,890
Else, if the human did not provide exactly two arguments, the name of the program and their own name, let's just print out a default value, lest they forgot their name

1833
02:10:07,890 --> 02:10:09,990
or they typed in two names or three names.

1834
02:10:09,990 --> 02:10:13,110
Let's just do, hello comma world as a default.

1835
02:10:13,110 --> 02:10:15,270
And we'll just ignore what the human typed in.

1836
02:10:15,270 --> 02:10:20,850
If I recompile this, make greet, I can do ./greet and David again, Enter.

1837
02:10:20,850 --> 02:10:24,840
Oops-- sorry, what am I missing?

1838
02:10:24,840 --> 02:10:26,640
Yeah, so newbie mistake.

1839
02:10:26,640 --> 02:10:30,090
Else, all right, make greet again.

1840
02:10:30,090 --> 02:10:34,050
./greet, David, Enter, there's my hello, David.

1841
02:10:34,050 --> 02:10:37,870
But if I omit my name, I just get the generic, like a default value.

1842
02:10:37,870 --> 02:10:41,590
And if I get a little curious and I type in both names, then I get ignored too.

1843
02:10:41,590 --> 02:10:42,090
Why?

1844
02:10:42,090 --> 02:10:44,880
Because I just haven't built in support for argc of three.

1845
02:10:44,880 --> 02:10:50,730
I could do anything I want, but now we have access to these kinds of building blocks.

1846
02:10:50,730 --> 02:10:52,780
All right, what else might I do here?

1847
02:10:52,780 --> 02:10:57,660
Well, it turns out there might be some final features for us to now execute.

1848
02:10:57,660 --> 02:11:06,180
Notice, though, that in C, despite what you might see in books or online tutorials, nowadays, the two official formats for defining a main function

1849
02:11:06,180 --> 02:11:17,880
are either this, which we've been using now for two plus weeks or now this, whereby, you change the void to int argc, and then for now, string argv, and then empty brackets.

1850
02:11:17,880 --> 02:11:21,400
And we'll see that this, too, is a simplification, some training wheels if you will.

1851
02:11:21,400 --> 02:11:27,840
But for now, those are the two forms, even though you will see in online tutorials and even books, some people use main in different ways.

1852
02:11:27,840 --> 02:11:30,142
These are the two now to keep in mind.

1853
02:11:30,142 --> 02:11:33,360
And I'll note that these command line arguments are kind of all over the place.

1854
02:11:33,360 --> 02:11:35,590
Didn't probably expect to see this word on the screen here.

1855
02:11:35,590 --> 02:11:36,490
And what does it mean?

1856
02:11:36,490 --> 02:11:41,880
Well, it turns out that for decades-- there's actually this program that comes with Linux systems in particular called cowsay.

1857
02:11:41,880 --> 02:11:42,510
Why?

1858
02:11:42,510 --> 02:11:51,520
Probably because someone had too much free time once and decided to write a program that creates ASCII art out of a cow saying something textually on the screen.

1859
02:11:51,520 --> 02:11:55,780
But you use cowsay, just for fun, by way of command line arguments.

1860
02:11:55,780 --> 02:12:04,770
So for instance, let me propose that I go back to VS Code here, not because I want to write any code, but I just want to use my terminal window.

1861
02:12:04,770 --> 02:12:07,320
And let me maximize my terminal window here.

1862
02:12:07,320 --> 02:12:13,170
And let me go ahead and type in something like, how about cowsay, space moo?

1863
02:12:13,170 --> 02:12:14,822
So cowsay is not a program I wrote.

1864
02:12:14,822 --> 02:12:16,030
It's been around for decades.

1865
02:12:16,030 --> 02:12:18,870
But we installed it in VS Code for you in the cloud.

1866
02:12:18,870 --> 02:12:21,330
It takes at least one command line argument.

1867
02:12:21,330 --> 02:12:23,070
What do you want the cow to say?

1868
02:12:23,070 --> 02:12:29,490
I can say, cowsay moo, and hit Enter, and voila, there is my ASCII art of a cow saying moo on the screen.

1869
02:12:29,490 --> 02:12:31,090
It can say multiple words.

1870
02:12:31,090 --> 02:12:33,960
So I can say, Hello, world, Enter.

1871
02:12:33,960 --> 02:12:35,800
And now it says, Hello, world.

1872
02:12:35,800 --> 02:12:40,470
So this is just an example of a silly program that uses command line arguments, but it takes others too.

1873
02:12:40,470 --> 02:12:45,750
Just like clang, use this convention of hyphens to change the output of the program.

1874
02:12:45,750 --> 02:12:53,520
Dash something is just a super common convention with command line arguments when you want a very terse notation for some option like output.

1875
02:12:53,520 --> 02:13:03,460
In cowsay, I read the documentation, and it turns out there's a dash f command line argument that allows you to change the appearance of the cow, if you will.

1876
02:13:03,460 --> 02:13:11,640
So if I do cowsay dash f, duck, and then some other word like quack, it's no longer a cow.

1877
02:13:11,640 --> 02:13:15,850
That command line argument turns it into a tiny, adorable duck instead.

1878
02:13:15,850 --> 02:13:20,790
And then lastly, just for fun, because I spent way too much time playing with command line arguments.

1879
02:13:20,790 --> 02:13:27,910
Cowsay dash f, dragon, and then how about, rawr, Enter, you can even get this on the screen here.

1880
02:13:27,910 --> 02:13:34,230
So this, too, is just an example of what you can do with these command line arguments now that we have this building block.

1881
02:13:34,230 --> 02:13:36,960
And there's one final thing we can now do with code.

1882
02:13:36,960 --> 02:13:48,450
There's one last feature today that we'll introduce before we now connect all of these dots to readability and encryption by talking, lastly, about something called exit status.

1883
02:13:48,450 --> 02:13:58,260
It turns out that whenever your main function exits, it returns a secret integer that you can figure out, as the programmer or an advanced user, what it was.

1884
02:13:58,260 --> 02:14:02,398
And these exit codes, exit statuses, are typically used to indicate errors.

1885
02:14:02,398 --> 02:14:08,560
So for instance, over the past couple of years, if you've used zoom and you ever got some kind of error, you might have seen a screen like this.

1886
02:14:08,560 --> 02:14:11,040
It's usually not that helpful, maybe tells you to click

1887
02:14:11,040 --> 02:14:13,050
Report Problem or Contact Support.

1888
02:14:13,050 --> 02:14:23,640
But very often in our human world on Macs, PCs, and phones, you see cryptic error codes, like literally numbers that probably only Zoom knows, or Microsoft or Google or whatever company

1889
02:14:23,640 --> 02:14:25,050
wrote the software you're using.

1890
02:14:25,050 --> 02:14:32,070
But that number corresponds to a specific error that some human somewhere knows might very well happen.

1891
02:14:32,070 --> 02:14:38,260
These are used similarly, although under a different name that we'll talk about later in the term, on the web as well.

1892
02:14:38,260 --> 02:14:41,350
Have you ever seen this-- maybe not character, but number?

1893
02:14:41,350 --> 02:14:43,485
So, 404 means what?

1894
02:14:43,485 --> 02:14:44,880
AUDIENCE: Error.

1895
02:14:44,880 --> 02:14:47,790
DAVID MALAN: So error, yes, but really, not found.

1896
02:14:47,790 --> 02:14:48,410
So, why?

1897
02:14:48,410 --> 02:14:49,993
I mean, this is the most arcane thing.

1898
02:14:49,993 --> 02:14:57,500
And we'll talk in a few weeks about what this and other numbers mean, but numbers are all around us in technology, and they very often mean something to the technical people who

1899
02:14:57,500 --> 02:15:00,270
wrote the software, less so to humans like you and me.

1900
02:15:00,270 --> 02:15:05,900
Why so many of us recognize 404 is kind of weird, that like that's been around long enough that we all know it.

1901
02:15:05,900 --> 02:15:10,250
But it really is just a special number that represents an error of some sort.

1902
02:15:10,250 --> 02:15:18,200
So it turns out, the last thing we'll reveal today about what we've been taking for granted for two weeks, is what the int is in main.

1903
02:15:18,200 --> 02:15:24,680
We've seen, just a moment ago, that the thing in the parentheses, which up until now has been void, which means no command line arguments.

1904
02:15:24,680 --> 02:15:29,690
now int argc string argv brackets just means, yes, command line arguments.

1905
02:15:29,690 --> 02:15:31,290
And we've seen how to access them.

1906
02:15:31,290 --> 02:15:37,460
So the last piece of the puzzle, honestly, of all the cryptic syntax the past two weeks, is just what int means.

1907
02:15:37,460 --> 02:15:46,010
Int is always there for main, and it indicates that main will always return an integer, even though you and I have never done so explicitly.

1908
02:15:46,010 --> 02:15:53,928
Usually, main returns 0, by default. But it would be weird if you saw an error message saying 0, so 0 is just hidden.

1909
02:15:53,928 --> 02:15:55,470
You would never see it on the screen.

1910
02:15:55,470 --> 02:15:58,670
But it's happening automatically by way of how C is designed.

1911
02:15:58,670 --> 02:16:01,550
So let me write one final program here.

1912
02:16:01,550 --> 02:16:05,750
I'll call it, for instance, status.c to show you these exit statuses.

1913
02:16:05,750 --> 02:16:21,350
Code of status.c, and then up here, let me do something simple like include cs50.h, then include stdio.h, and then int main-- actually, let's use a command line argument. int argc, string argv[],

1914
02:16:21,350 --> 02:16:23,180
so that's copy, paste.

1915
02:16:23,180 --> 02:16:26,000
But now let's do this.

1916
02:16:26,000 --> 02:16:30,780
If argc does not equal to-- why don't we do something like this?

1917
02:16:30,780 --> 02:16:33,740
Let's not just default to hello, world like last time.

1918
02:16:33,740 --> 02:16:34,770
Let's yell at the user.

1919
02:16:34,770 --> 02:16:43,160
So let's say something like printf missing command line argument, so that they know they screwed up and they need to run the program again correctly.

1920
02:16:43,160 --> 02:16:56,730
Else, let's go ahead and say, print out, as before, Hello, comma %s, and then plug in argv[1], so the human's name from the prompt.

1921
02:16:56,730 --> 02:17:03,590
Now at this point, let me go ahead and run status, ./status, and I'll type nothing first.

1922
02:17:03,590 --> 02:17:04,700
I get yelled at.

1923
02:17:04,700 --> 02:17:10,170
This time, I'll type it again. ./status David, and it works properly.

1924
02:17:10,170 --> 02:17:14,090
But now let me show you a somewhat secret, cryptic command.

1925
02:17:14,090 --> 02:17:18,740
You can type this at your prompt, and it's just a coincidence that there's another dollar sign.

1926
02:17:18,740 --> 02:17:25,490
Echo $?, totally arcane, but it allows you to see what exit status your program has ended with.

1927
02:17:25,490 --> 02:17:27,558
So let me run this again the wrong way.

1928
02:17:27,558 --> 02:17:31,039
./status, I get the error message.

1929
02:17:31,040 --> 02:17:32,780
What was secretly returned?

1930
02:17:32,780 --> 02:17:33,440
I can't see it.

1931
02:17:33,440 --> 02:17:37,280
There's obviously no error screen, but by typing echo $?,

1932
02:17:37,280 --> 02:17:42,170
I can see that, oh, my program automatically, by default, returns zero.

1933
02:17:42,170 --> 02:17:48,690
However, if I run it again correctly, ./status David, Enter, this is the correct version.

1934
02:17:48,690 --> 02:17:52,879
But if I run echo $? status again, it's still entered with 0.

1935
02:17:52,879 --> 02:17:55,879
And long story short, this is just a missed opportunity.

1936
02:17:55,879 --> 02:17:59,570
When something goes wrong, why don't I return a value other than 0?

1937
02:17:59,570 --> 02:18:01,070
0, by default, means success.

1938
02:18:01,070 --> 02:18:02,690
And it's always there automatically.

1939
02:18:02,690 --> 02:18:04,940
But you can control this.

1940
02:18:04,940 --> 02:18:11,160
I can go into my code here and return 1, else, if something works fine,

1941
02:18:11,160 --> 02:18:17,129
I can return 0, by default. And honestly, if I omit the return zero, again, zero automatically is returned.

1942
02:18:17,129 --> 02:18:20,718
So let me go ahead and go be explicit, just so I know what's going on.

1943
02:18:20,718 --> 02:18:26,359
Make status again, ./status, and let's do this correctly with David.

1944
02:18:26,360 --> 02:18:28,520
Enter, hello, David.

1945
02:18:28,520 --> 02:18:32,058
Echo $?, zero.

1946
02:18:32,058 --> 02:18:33,269
So all is well.

1947
02:18:33,270 --> 02:18:38,240
But now if I do ./status and nothing, or multiple things, but not just David,

1948
02:18:38,240 --> 02:18:40,530
Enter, I get the error message.

1949
02:18:40,530 --> 02:18:45,230
But now if I do echo $?, voila, there now is the one.

1950
02:18:45,230 --> 02:18:47,330
So what does this now mean?

1951
02:18:47,330 --> 02:18:52,459
This is, in the graphical world, we would just show something like this on the screen, which is a little more informative to the user.

1952
02:18:52,459 --> 02:18:58,549
But even in the Linux world where you don't have a GUI, necessarily, even for the programs we've written, you can check these exit statuses.

1953
02:18:58,549 --> 02:19:07,339
And in fact, more comfortable, more advanced programmers, when they write code that calls programs, be it cowsay or anything else, you can encode,

1954
02:19:07,340 --> 02:19:13,170
check what the exit status is of a program, and then decide, did my program work or did it not?

1955
02:19:13,170 --> 02:19:19,069
And now let's connect the final dots before we adjourn for some fruit snacks.

1956
02:19:19,070 --> 02:19:27,650
Cryptography, namely one of the applications this week via which you'll be able to send, if you will, secret messages, and better yet, decrypt secret messages.

1957
02:19:27,650 --> 02:19:34,040
This will be in addition to perhaps analyzing the readability of text using heuristics, like we identified at the start of class two.

1958
02:19:34,040 --> 02:19:45,980
So cryptography is just the art, the science of encrypting information, scrambling information so that if you have a secret message to send in so-called plaintext, you can run it through some algorithm

1959
02:19:45,980 --> 02:19:49,910
and turn it into what's called ciphertext, thereby, encrypting it.

1960
02:19:49,910 --> 02:19:59,880
And only someone who knows what algorithm you've used and what input you've used to the algorithm, theoretically, can decrypt that process and convert it back to the original message.

1961
02:19:59,880 --> 02:20:03,030
So if we use our mental model from last week, here is a problem.

1962
02:20:03,030 --> 02:20:04,910
Here is an input and output.

1963
02:20:04,910 --> 02:20:13,640
The goal I claim here is to take some plain text, like the message you want to send, think back to grade school if you ever passed a note to a friend or to your crush saying, I love you,

1964
02:20:13,640 --> 02:20:16,910
it's a little awkward if the teacher or someone else intercepts the paper.

1965
02:20:16,910 --> 02:20:19,490
And in English, it just says, I love you, or whatever it is.

1966
02:20:19,490 --> 02:20:22,350
It'd be nice if you had at least encrypted it in some way.

1967
02:20:22,350 --> 02:20:32,040
But the other person needs to know what algorithm you used and what inputs you use to that algorithm so that, ultimately, they can decode the so-called ciphertext, which is the output.

1968
02:20:32,040 --> 02:20:34,190
So what goes inside of the box today?

1969
02:20:34,190 --> 02:20:37,970
Well, an algorithm, as it relates to cryptography, is called a cipher.

1970
02:20:37,970 --> 02:20:43,250
And a cipher is a fancy name for an algorithm that encrypts text from plaintext to ciphertext.

1971
02:20:43,250 --> 02:20:48,750
The catch is, there needs to be not just the algorithm, there needs to be an input to it.

1972
02:20:48,750 --> 02:20:53,090
And so, for instance, you might draw the picture like this for the first time today.

1973
02:20:53,090 --> 02:20:54,257
And we've seen this in code.

1974
02:20:54,257 --> 02:20:57,180
You can give multiple inputs or arguments to functions.

1975
02:20:57,180 --> 02:21:02,510
So in this black box, can you imagine passing in the message you want to send, and then some secret.

1976
02:21:02,510 --> 02:21:10,310
So for instance, suppose that, the simplest thing I could think of as a kid was instead of sending the letter A, why don't I write the letter B?

1977
02:21:10,310 --> 02:21:13,070
Instead of the letter B, why don't I write the letter C?

1978
02:21:13,070 --> 02:21:16,280
So I can kind of shift the English alphabet by one space.

1979
02:21:16,280 --> 02:21:18,740
So A becomes B, B becomes C, dot, dot, dot,

1980
02:21:18,740 --> 02:21:21,690
Z becomes A. You can wrap around at the end.

1981
02:21:21,690 --> 02:21:24,120
And let's assume no punctuation in this part of the story.

1982
02:21:24,120 --> 02:21:32,090
So that's a very simple algorithm-- add a value to each letter and send the value as the ciphertext.

1983
02:21:32,090 --> 02:21:41,300
And now the teacher, the classmate, they have to know that you use, not only this rotational algorithm, also known as a Caesar cipher, they also need to know what number you use.

1984
02:21:41,300 --> 02:21:45,200
Did you add 1 to every letter, 2 to every letter, 25 to every letter?

1985
02:21:45,200 --> 02:21:51,165
Now if they're super smart and probably not the young age in this story, they could also just try all possibilities.

1986
02:21:51,165 --> 02:21:53,040
And that would be an attack on the algorithm.

1987
02:21:53,040 --> 02:21:56,970
This is not a sophisticated algorithm, but it's enough to send a message in class.

1988
02:21:56,970 --> 02:22:06,950
So if the two inputs now are HI! as the plain text message, and 1 as the so-called key, the secret number that only you and the other person know, you

1989
02:22:06,950 --> 02:22:11,040
might be able to encrypt a message from one way to the other.

1990
02:22:11,040 --> 02:22:16,198
And so in this case, for instance, HI! would become I-J-!.

1991
02:22:16,198 --> 02:22:19,823
In this version of the algorithm, we're not going to bother with numbers or punctuation.

1992
02:22:19,823 --> 02:22:23,090
We'll only operate on A through Z, be it uppercase or lowercase.

1993
02:22:23,090 --> 02:22:33,440
So now if you were to receive a slip of paper in class with I-J on it, you, the recipient, would know what it is so long as you know that the sender used one,

1994
02:22:33,440 --> 02:22:36,500
because you just reverse the algorithm and you subtract one instead.

1995
02:22:36,500 --> 02:22:42,975
The teacher, they probably don't know what this means, and they're not going to spend time hacking the message, so it just looks scrambled to them.

1996
02:22:42,975 --> 02:22:44,600
And that's what we get from encryption.

1997
02:22:44,600 --> 02:22:52,700
Someone who intercepts it, be it in class or in the real world, on the internet or anywhere else, can't actually figure out, ideally, what it is you have sent.

1998
02:22:52,700 --> 02:22:56,300
The opposite, of course, is indeed called decryption, but the process is the same.

1999
02:22:56,300 --> 02:22:58,370
We now pass in negative 1.

2000
02:22:58,370 --> 02:23:00,300
And so how about this?

2001
02:23:00,300 --> 02:23:02,840
Why don't we end with a demonstration here?

2002
02:23:02,840 --> 02:23:08,360
UIJT XBT DT50-- there's a bit of a tell there.

2003
02:23:08,360 --> 02:23:14,180
If we pass that in and do negative 1, well, how do we get out the plaintext originally?

2004
02:23:14,180 --> 02:23:18,200
Well, if this is the ciphertext, and we subtract 1 from each letter,

2005
02:23:18,200 --> 02:23:28,010
I think U becomes T, I becomes H, J becomes I, T becomes S, X becomes W,

2006
02:23:28,010 --> 02:23:37,580
B becomes A, T becomes S, D becomes C, T becomes S, and this was, indeed, CS50.

2007
02:23:37,580 --> 02:23:40,250
Have a duck on your way out, and some snacks in the lobby.

2008
02:23:40,250 --> 02:23:42,350
[APPLAUSE]

2009
02:23:42,350 --> 02:23:43,850
[FILM ROLLING]

2010
02:23:43,850 --> 02:23:47,500
[MUSIC PLAYING]

