1
00:00:00,000 --> 00:00:02,982
[FILM REEL]

2
00:00:02,982 --> 00:00:06,461
[MUSIC PLAYING]

3
00:01:12,660 --> 00:01:15,420
DAVID MALAN: All right, this is CS50.

4
00:01:15,420 --> 00:01:21,400
And this is Week 3 already, wherein we'll take a look back actually at Week 0 where we first began.

5
00:01:21,400 --> 00:01:24,930
And in Week 0, recall that everything was very intuitive, in a sense.

6
00:01:24,930 --> 00:01:28,000
We talked not just about representation of information, but algorithms.

7
00:01:28,000 --> 00:01:30,450
And we talked about tearing a phone book again and again.

8
00:01:30,450 --> 00:01:32,860
And that somehow got us to a better solution.

9
00:01:32,860 --> 00:01:41,650
But today, we'll try to start formalizing some of those ideas and capturing some of those same ideas not in pseudocode just yet, but in actual code as well.

10
00:01:41,650 --> 00:01:48,372
But we'll also consider the efficiency of those algorithms, like just how good, how well-designed our algorithms actually are.

11
00:01:48,372 --> 00:01:56,460
And if you recall, when we did the phone book example wherein I first had an algorithm searching one page at a time, and then second one two pages at a time, and then third,

12
00:01:56,460 --> 00:02:01,900
started tearing the thing in half, recall that we, with a wave of the hand, kind of analyzed it as follows.

13
00:02:01,900 --> 00:02:11,430
We proposed that if the x-axis here is the size of the problem, like number of pages in a phone book, and the y-axis is the time required to solve the problem in seconds, minutes,

14
00:02:11,430 --> 00:02:19,620
page tears, whatever your unit of measure is, recall that the first algorithm, which is the straight line such that if you had n pages in the phone book, it might have this slope of n--

15
00:02:19,620 --> 00:02:23,280
and there's this one-to-one relationship between pages and tears.

16
00:02:23,280 --> 00:02:33,570
Two pages at a time, of course, was twice as fast, but still really the same shape, the yellow line here indicating that yeah, it's n over 2, maybe plus 1 if you have to double back, as we discussed.

17
00:02:33,570 --> 00:02:38,370
But it's really still fundamentally the same algorithm one or two pages at a time.

18
00:02:38,370 --> 00:02:45,660
But the third algorithm, recall, was this one here in green, where we called it logarithmic in terms of how fast or how slow it was.

19
00:02:45,660 --> 00:02:53,280
And indeed, the implication of this algorithm was that we could even double the size of the phone book, and no big deal-- one additional page tear,

20
00:02:53,280 --> 00:02:55,990
and we take yet another 1,000 page bite out of the phone book.

21
00:02:55,990 --> 00:03:01,530
So today, we'll revisit some of these ideas, formalize them a bit, but also translate some of them, ultimately, to code.

22
00:03:01,530 --> 00:03:07,600
And all of that now is possible because we have this lower-level understanding, perhaps, of what's actually inside of your computer.

23
00:03:07,600 --> 00:03:10,170
This, of course, is your computer's RAM or memory.

24
00:03:10,170 --> 00:03:15,420
And recall that if we start to abstract this away, your computer's memory is really just a grid of bytes.

25
00:03:15,420 --> 00:03:17,730
In fact, we don't have to look at the hardware anymore.

26
00:03:17,730 --> 00:03:27,460
And we looked at a grid of bytes like this, whereby each of these bytes could be used to store a char, an int, a long, or even an entire string, at that.

27
00:03:27,460 --> 00:03:34,830
But let's focus perhaps just on a subset of this because last week, of course, we emphasized, really, arrays, storing things in arrays.

28
00:03:34,830 --> 00:03:44,770
And that allowed us to start storing entire strings, sequences of characters, and even arrays of integers if we wanted to have multiple ones and not just multiple variables as well.

29
00:03:44,770 --> 00:03:53,850
But the catch is that if you look inside of an array in the computer's memory-- and for instance, suppose these integers here are stored-- it's pretty easy for us humans to glance at this

30
00:03:53,850 --> 00:03:55,698
and immediately find the number 50.

31
00:03:55,698 --> 00:03:59,700
You sort of have this bird's eye view from where you're seated of everything on the screen.

32
00:03:59,700 --> 00:04:02,500
And so it's pretty obvious how you get to the number 50.

33
00:04:02,500 --> 00:04:06,720
But in the world of computers, of course, it turns out that this is hardware.

34
00:04:06,720 --> 00:04:10,440
And computers, for today's purposes, can only do one thing at a time.

35
00:04:10,440 --> 00:04:14,820
They can't just take it all in and find instantly some number like 50.

36
00:04:14,820 --> 00:04:22,500
So perhaps a decent metaphor is to consider the array of memory inside of your computer really is a sequence of closed doors.

37
00:04:22,500 --> 00:04:30,730
And if the computer wants to find some value in an array, it has to do the digital equivalent of opening each of these doors one at a time.

38
00:04:30,730 --> 00:04:32,410
Now how can code do that?

39
00:04:32,410 --> 00:04:39,900
Well, of course, we introduced indices or indexes last week, whereby we, by convention, call the first element of an array location 0,

40
00:04:39,900 --> 00:04:45,150
the second location 1, the third location 2, and so forth-- so-called 0 indexed.

41
00:04:45,150 --> 00:04:51,510
And this allowed us to now bridge this conceptual world of what's going on in memory with actual code, because now we had this square bracket

42
00:04:51,510 --> 00:04:55,710
syntax via which we could go searching for something if we so choose.

43
00:04:55,710 --> 00:05:07,170
And it turns out, if I now paint these red instead of yellow, it would seem that we actually have a pretty good physical metaphor here standing in place for what would be a computer's array of memory

44
00:05:07,170 --> 00:05:10,390
if, for instance, you're storing some seven numbers like that.

45
00:05:10,390 --> 00:05:13,710
And so today we begin with a look of a specific type of algorithm.

46
00:05:13,710 --> 00:05:14,910
That is for searching.

47
00:05:14,910 --> 00:05:16,270
Searching is all over the place.

48
00:05:16,270 --> 00:05:21,090
All of us have probably gone to google.com or some equivalent already multiple times per day.

49
00:05:21,090 --> 00:05:25,110
And getting back answers fast is what companies like Google are really good at.

50
00:05:25,110 --> 00:05:26,700
So how are they doing that?

51
00:05:26,700 --> 00:05:29,882
How are they storing information in computers' memory?

52
00:05:29,882 --> 00:05:31,590
Well, let's consider what this really is.

53
00:05:31,590 --> 00:05:34,500
It's really just a problem as it was back in Week 0.

54
00:05:34,500 --> 00:05:38,253
The input, though, to the problem, for now, might be this array of seven lockers.

55
00:05:38,253 --> 00:05:40,920
So that's the input to the problem, inside of which is a number.

56
00:05:40,920 --> 00:05:51,250
And maybe for simplicity now, we just want a yes/no, a true/false answer-- a bool, that is to say-- of whether or not some number like 50 is in that array.

57
00:05:51,250 --> 00:05:52,680
It's not quite as fancy as Google.

58
00:05:52,680 --> 00:05:55,500
That doesn't just tell you yes, we have search results.

59
00:05:55,500 --> 00:05:57,300
It actually gives you the search results.

60
00:05:57,300 --> 00:06:06,090
But for, now we'll keep it simple, and just output as part of this problem yes or no, true or false, we have found the number we're looking for given an input like that array.

61
00:06:06,090 --> 00:06:12,385
But it turns out inside of this black box that we keep coming back to, there's all sorts of possible algorithms.

62
00:06:12,385 --> 00:06:15,860
And we talked about this at a high level conceptually in Week 0 with the phone book.

63
00:06:15,860 --> 00:06:22,648
But today, let's consider it a little more concretely by way of a game that some of you might have grown up with, namely Monopoly.

64
00:06:22,648 --> 00:06:26,800
And so behind these doors, it turns out, will be hidden some denominations of monopoly money.

65
00:06:26,800 --> 00:06:28,690
But for this, we now have two volunteers.

66
00:06:28,690 --> 00:06:30,483
If you'd like to greet the world?

67
00:06:30,483 --> 00:06:31,525
JACKSON: Hi, I'm Jackson.

68
00:06:35,440 --> 00:06:37,220
STEPHANIE: Hi, my name is Stephanie.

69
00:06:37,220 --> 00:06:40,570
DAVID MALAN: And do you want to say a little something about yourselves-- years, house, dorm?

70
00:06:40,570 --> 00:06:43,030
STEPHANIE: I'm a first year living in Matthews.

71
00:06:43,030 --> 00:06:43,780
DAVID MALAN: Nice.

72
00:06:43,780 --> 00:06:45,580
JACKSON: And I'm a first year in Canaday.

73
00:06:45,580 --> 00:06:46,330
DAVID MALAN: Nice.

74
00:06:46,330 --> 00:06:48,670
Well, welcome to our two volunteers.

75
00:06:48,670 --> 00:06:50,710
So why don't we do this?

76
00:06:50,710 --> 00:06:54,460
Would one of you like to volunteer the other to go first?

77
00:06:54,460 --> 00:06:55,510
STEPHANIE: I'll go.

78
00:06:55,510 --> 00:06:56,560
DAVID MALAN: OK.

79
00:06:56,560 --> 00:06:58,300
All right, so Stephanie's up first.

80
00:06:58,300 --> 00:07:02,560
And behind one of these doors here, we've hidden the monopoly money 50.

81
00:07:02,560 --> 00:07:04,180
And so we'd like you to find the 50.

82
00:07:04,180 --> 00:07:06,490
We'll tell you nothing more about the lockers.

83
00:07:06,490 --> 00:07:08,900
But we would like you to execute a certain algorithm.

84
00:07:08,900 --> 00:07:11,020
And in fact, I'm going to give you some pseudocode for this.

85
00:07:11,020 --> 00:07:12,770
And I'm going to give you the name for it.

86
00:07:12,770 --> 00:07:13,900
It's called linear search.

87
00:07:13,900 --> 00:07:17,980
And as the name implies, you're pretty much going to end up walking in sort of a straight line.

88
00:07:17,980 --> 00:07:19,220
But how are you going to do this?

89
00:07:19,220 --> 00:07:23,170
Well, let me propose that in a moment, your first step will be to think kind of like a loop.

90
00:07:23,170 --> 00:07:27,280
For each door from left to right, what do we want you to do on each iteration?

91
00:07:27,280 --> 00:07:33,070
Well, if 50 is behind that door, then we want to go ahead and have you return true.

92
00:07:33,070 --> 00:07:35,860
And hold up the 50 proudly, if you will, for the group.

93
00:07:35,860 --> 00:07:42,640
Otherwise, if you get through that whole loop and you haven't found the number 50, you can just throw up your hands in disappointment.

94
00:07:42,640 --> 00:07:45,190
False-- you've not found the number 50.

95
00:07:45,190 --> 00:07:50,293
So to be clear, step one is going to be for each door from left to right.

96
00:07:50,293 --> 00:07:51,460
How would you like to begin?

97
00:07:55,610 --> 00:07:56,495
Yep.

98
00:07:56,495 --> 00:07:57,840
Oh, and then-- yep.

99
00:07:57,840 --> 00:07:58,340
There we go.

100
00:07:58,340 --> 00:08:00,365
Yep.

101
00:08:00,365 --> 00:08:04,040
And if you'd like to at least tell-- good, good acting here.

102
00:08:04,040 --> 00:08:06,140
What have you found instead?

103
00:08:06,140 --> 00:08:07,970
STEPHANIE: It's not 50, but 20.

104
00:08:07,970 --> 00:08:08,900
DAVID MALAN: Oh, OK.

105
00:08:08,900 --> 00:08:10,280
So step one was a fail.

106
00:08:10,280 --> 00:08:11,870
So let's move on to step two.

107
00:08:11,870 --> 00:08:14,453
Inside of this loop, what are you going to do next?

108
00:08:14,453 --> 00:08:16,370
STEPHANIE: I'm going to move to the next door.

109
00:08:16,370 --> 00:08:17,037
DAVID MALAN: OK.

110
00:08:20,790 --> 00:08:22,100
STEPHANIE: Almost.

111
00:08:22,100 --> 00:08:23,100
DAVID MALAN: OK, almost.

112
00:08:23,100 --> 00:08:23,790
Sort of.

113
00:08:23,790 --> 00:08:25,110
A 500 instead.

114
00:08:25,110 --> 00:08:26,280
Next locker?

115
00:08:26,280 --> 00:08:30,200
STEPHANIE: I would rather take that.

116
00:08:30,200 --> 00:08:30,700
No.

117
00:08:33,840 --> 00:08:36,558
DAVID MALAN: OK, we're not telling the audience?

118
00:08:36,558 --> 00:08:38,260
STEPHANIE: It was a 10.

119
00:08:38,260 --> 00:08:39,789
DAVID MALAN: OK, so keep going.

120
00:08:39,789 --> 00:08:40,974
This is step three now.

121
00:08:45,470 --> 00:08:46,310
STEPHANIE: Oh, man.

122
00:08:49,850 --> 00:08:51,260
DAVID MALAN: Five, OK.

123
00:08:51,260 --> 00:08:52,670
A few more lockers to check.

124
00:08:57,296 --> 00:08:58,790
STEPHANIE: A little sad, guys.

125
00:09:02,527 --> 00:09:04,360
DAVID MALAN: All right, second-to-last step.

126
00:09:07,710 --> 00:09:09,070
STEPHANIE: It's 1.

127
00:09:09,070 --> 00:09:10,022
Kind of close.

128
00:09:10,022 --> 00:09:10,980
DAVID MALAN: All right.

129
00:09:10,980 --> 00:09:12,780
And finally, the last step.

130
00:09:12,780 --> 00:09:15,780
Clearly you've been, perhaps, set up here.

131
00:09:15,780 --> 00:09:17,340
STEPHANIE: Let's go!

132
00:09:17,340 --> 00:09:19,920
DAVID MALAN: All right, so the number 50.

133
00:09:23,500 --> 00:09:25,870
And Stephanie, if I may, let me ask you a question here.

134
00:09:25,870 --> 00:09:28,890
So on the screen, this is the pseudocode you just executed.

135
00:09:28,890 --> 00:09:34,770
Suppose, though, I had done what many of us have gotten to the habit of doing when you have an if condition.

136
00:09:34,770 --> 00:09:36,730
You often have an else branch as well.

137
00:09:36,730 --> 00:09:38,760
Suppose that I had done this now.

138
00:09:38,760 --> 00:09:41,680
And I'm marking it in red to be clear this is wrong.

139
00:09:41,680 --> 00:09:47,040
But what would have been bad about this code using an if and an else, might you say?

140
00:09:47,040 --> 00:09:48,360
Any instincts?

141
00:09:55,620 --> 00:10:00,210
STEPHANIE: Then you would end up canceling the code before you found the 50.

142
00:10:00,210 --> 00:10:01,020
DAVID MALAN: Yeah, exactly.

143
00:10:01,020 --> 00:10:02,070
STEPHANIE: I mean, you'd just be eternally sad.

144
00:10:02,070 --> 00:10:02,460
DAVID MALAN: Indeed.

145
00:10:02,460 --> 00:10:05,127
When Stephanie had opened the first locker, she'd have found 20.

146
00:10:05,127 --> 00:10:06,630
20, of course, is not 50.

147
00:10:06,630 --> 00:10:07,838
She would have decreed false.

148
00:10:07,838 --> 00:10:10,547
But of course, she hadn't checked all of the rest of the lockers.

149
00:10:10,547 --> 00:10:18,810
So that would seem to be a key detail that, with this implementation of the pseudocode, we actually do go through-- as we did-- and only return false not even with an else,

150
00:10:18,810 --> 00:10:25,245
but just at the end of the loop such that we only reach that line if we don't return true earlier than that.

151
00:10:25,245 --> 00:10:26,620
Well, let's go ahead and do this.

152
00:10:26,620 --> 00:10:27,360
Let me take the mic from you.

153
00:10:27,360 --> 00:10:28,930
If you'd like to take a seat next to Jackson?

154
00:10:28,930 --> 00:10:31,180
And Jackson, in just a moment, we'll have you come up.

155
00:10:31,180 --> 00:10:34,170
Carter, if you don't mind reorganizing the lockers for us.

156
00:10:34,170 --> 00:10:38,010
But in the meantime, let me point out how we might now translate that same idea to code.

157
00:10:38,010 --> 00:10:44,910
Pretty high level, pretty English-oriented with that pseudocode-- but really now, as of last week, we have syntax via which Stephanie

158
00:10:44,910 --> 00:10:51,250
and, soon, Jackson could treat this locker, this set of lockers, as really indeed an array using bracket notation.

159
00:10:51,250 --> 00:10:54,480
So we can now get a little closer in our pseudocode to actual code.

160
00:10:54,480 --> 00:11:03,720
And the way a computer scientist, for instance, would translate fairly high level English pseudocode like this to something that's a little closer to C or any language

161
00:11:03,720 --> 00:11:06,600
that supports arrays would be a little more cryptically like this.

162
00:11:06,600 --> 00:11:09,060
But you'll see more of this syntax in the coming days.

163
00:11:09,060 --> 00:11:13,260
For i from 0 to n minus 1-- this is still pseudocode.

164
00:11:13,260 --> 00:11:17,730
But that's the English-like way of expressing what we've known come to know as a for loop.

165
00:11:17,730 --> 00:11:26,503
If 50 is behind doors bracket i-- so I'm assuming for the sake of discussion that doors, now, is the name of my variable, this array of seven doors.

166
00:11:26,503 --> 00:11:30,370
But then the rest of the logic, the rest of the pseudocode really is the same way.

167
00:11:30,370 --> 00:11:40,170
And so you'll find in time that programmers, computer scientists more generally, when you start expressing ideas, algorithms to someone else, instead of maybe operating at this level here,

168
00:11:40,170 --> 00:11:47,380
you now have a new vocabulary, really a new syntax that you can be a little more specific, not getting so into the weeds of writing actual C code,

169
00:11:47,380 --> 00:11:51,810
but at least now doing something that's a little closer to manipulating an array like this.

170
00:11:51,810 --> 00:11:55,140
So Jackson, would you like to stand on up?

171
00:11:55,140 --> 00:11:56,760
All right.

172
00:11:56,760 --> 00:11:57,360
Yes, yes.

173
00:11:57,360 --> 00:11:59,010
Support for Jackson here, too.

174
00:11:59,010 --> 00:12:00,780
Nice.

175
00:12:00,780 --> 00:12:04,470
And here now, I'm going to allow you an assumption that Stephanie did not have.

176
00:12:04,470 --> 00:12:10,050
Stephanie clearly was really doing her best searching from left to right using linear search, as we'll now call it.

177
00:12:10,050 --> 00:12:12,180
But they were pretty much in a random order, right?

178
00:12:12,180 --> 00:12:15,030
There was a 20 over there, there was 1 over there, and then a 50.

179
00:12:15,030 --> 00:12:19,110
So we deliberately jumbled things up and did not sort the numbers for her.

180
00:12:19,110 --> 00:12:24,510
But Carter kindly has just come up to give you a leg up, Jackson, by sorting the numbers in advance.

181
00:12:24,510 --> 00:12:32,250
And we'd like you this time, much like in week 0, to do something again and again, but this time using what we'll now call binary search.

182
00:12:32,250 --> 00:12:35,580
It's exactly the same algorithm conceptually as we did in Week 0.

183
00:12:35,580 --> 00:12:40,450
But if we translate it to the context of this array, we now might say something like this.

184
00:12:40,450 --> 00:12:48,570
The first step for Jackson might be to ask the question-- if 50 is behind the middle door, where presumably he's done some mental math to figure out what the middle is,

185
00:12:48,570 --> 00:12:50,610
then he's going to just return true.

186
00:12:50,610 --> 00:12:53,070
And hopefully we'll get lucky and 50 will be right there.

187
00:12:53,070 --> 00:12:58,290
Of course, there's two other possibilities at least, which would be what?

188
00:12:58,290 --> 00:13:01,290
50 is, with respect to these doors?

189
00:13:01,290 --> 00:13:03,930
Yeah, so to the left or to the right, alternatively.

190
00:13:03,930 --> 00:13:07,722
So if 50 is less than the middle door, then presumably,

191
00:13:07,722 --> 00:13:09,180
Jackson's going to want to go left.

192
00:13:09,180 --> 00:13:17,910
Else, if 50 is greater than the middle door, he's going to want to go right, much like I did physically last week with the phone book, dividing and conquering left to right.

193
00:13:17,910 --> 00:13:20,020
But there's actually a fourth case.

194
00:13:20,020 --> 00:13:21,540
Let's put it on the board first.

195
00:13:21,540 --> 00:13:25,530
What else might happen here that Jackson should consider?

196
00:13:25,530 --> 00:13:26,170
Yeah.

197
00:13:26,170 --> 00:13:28,590
Oh, it's not there.

198
00:13:28,590 --> 00:13:39,080
So let me actually go back and amend my pseudocode here and just say Jackson, if we don't hand you any doors at all, or eventually, as he's dividing and conquering, if he's left with no more doors,

199
00:13:39,080 --> 00:13:42,380
we have to handle that situation so that the behavior is defined.

200
00:13:42,380 --> 00:13:48,650
All right, so with that said, Jackson, do you want to go ahead and find us the number 50 and walk us through verbally what you're doing and finding?

201
00:13:48,650 --> 00:13:52,860
JACKSON: All right, so it looks like this one is the middle door.

202
00:13:52,860 --> 00:13:55,290
So I'm going to open it.

203
00:13:55,290 --> 00:13:57,030
But it's 20, not 50.

204
00:13:57,030 --> 00:13:59,622
DAVID MALAN: Aw.

205
00:13:59,622 --> 00:14:01,080
What's going through your head now?

206
00:14:01,080 --> 00:14:06,490
JACKSON: So now I'm looking-- because 50 is higher than 20, I want to look to the right.

207
00:14:06,490 --> 00:14:07,440
DAVID MALAN: Good.

208
00:14:07,440 --> 00:14:10,270
JACKSON: And look for the new middle door, which would be here.

209
00:14:10,270 --> 00:14:11,700
DAVID MALAN: Nice.

210
00:14:11,700 --> 00:14:13,740
JACKSON: And it's 100-- bad.

211
00:14:13,740 --> 00:14:16,560
But 50 is less than 100.

212
00:14:16,560 --> 00:14:20,520
So now we to look left, which would be here.

213
00:14:20,520 --> 00:14:21,240
And ta-da.

214
00:14:21,240 --> 00:14:21,990
DAVID MALAN: Nice.

215
00:14:21,990 --> 00:14:25,680
Very well done this time around, too.

216
00:14:25,680 --> 00:14:29,680
So thank you, first, to our volunteers here.

217
00:14:29,680 --> 00:14:36,743
And in fact, since you're a fan of Monopoly, as we're so informed, we have the Cambridge edition of Monopoly with all your Harvard favorites.

218
00:14:36,743 --> 00:14:37,410
JACKSON: No way.

219
00:14:37,410 --> 00:14:38,460
DAVID MALAN: Here you go.

220
00:14:38,460 --> 00:14:38,970
STEPHANIE: Thank you.

221
00:14:38,970 --> 00:14:40,095
JACKSON: Thank you so much.

222
00:14:40,095 --> 00:14:42,570
DAVID MALAN: Thank you to our volunteers for finding us 50.

223
00:14:42,570 --> 00:14:46,940
So-- that was more popular than we expected.

224
00:14:46,940 --> 00:14:52,060
So here, we can translate this one more time into something a little closer to code.

225
00:14:52,060 --> 00:14:59,380
And again, still pseudocode-- but here, now, might be another formulation of exactly what Jackson just did, just using the nomenclature now of arrays,

226
00:14:59,380 --> 00:15:04,640
where you can be a little more precise with your instructions and still leave it to someone else to translate this, finally, to code.

227
00:15:04,640 --> 00:15:06,640
But here we have same question at the beginning.

228
00:15:06,640 --> 00:15:08,650
If no doors left, return false.

229
00:15:08,650 --> 00:15:19,480
If 50 is behind doors bracket middle-- so I'm assuming here, because this is pseudocode-- that somewhere I've done the mental math or the actual math to figure out what the index of middle is.

230
00:15:19,480 --> 00:15:27,310
For instance, if these are seven doors in an array, this would be location 0, 1, 2, 3, 4, 5, 6.

231
00:15:27,310 --> 00:15:33,520
So somehow I've taken the total number of doors, 7, divided by 2 to find the middle.

232
00:15:33,520 --> 00:15:34,430
That's 3 and 1/2.

233
00:15:34,430 --> 00:15:35,680
We have to deal with rounding.

234
00:15:35,680 --> 00:15:39,910
But suffice it to say there's a well-defined formula for finding the middle index.

235
00:15:39,910 --> 00:15:43,280
Given the total number of lockers, divide by 2 and then round accordingly.

236
00:15:43,280 --> 00:15:48,790
So that's presumably what Jackson did just by counting or in his head to find us door number 3.

237
00:15:48,790 --> 00:15:52,210
Not the third door, the 4th door, but door bracket 3.

238
00:15:52,210 --> 00:15:56,200
So this is just saying if 50 is behind doors bracket middle, return true.

239
00:15:56,200 --> 00:15:57,200
That was not the case.

240
00:15:57,200 --> 00:15:58,960
He found a $20 bill instead.

241
00:15:58,960 --> 00:16:10,660
Else, if 50 is less than the doors bracket middle, go ahead-- and now it gets interesting-- search doors 0 through doors middle minus 1.

242
00:16:10,660 --> 00:16:12,730
So it's getting a little more into the weeds now.

243
00:16:12,730 --> 00:16:24,340
But if middle is 3, this one here, what we want to now have Jackson search if 50 had been-- if the number had been less, we want to start at bracket 0 and go up through this one.

244
00:16:24,340 --> 00:16:28,297
And we deliberately subtract 1 because what's the point of looking in the same locker again?

245
00:16:28,297 --> 00:16:31,270
We might as well do 0 through middle minus 1.

246
00:16:31,270 --> 00:16:37,120
Else if 50 is greater than doors bracket middle, which it was, what did we then do?

247
00:16:37,120 --> 00:16:43,295
So Jackson intuitively searched for doors middle plus 1 through doors n minus 1.

248
00:16:43,295 --> 00:16:46,420
And honestly, it gets a little annoying having the pluses and minuses here.

249
00:16:46,420 --> 00:16:47,780
But just think of what it means.

250
00:16:47,780 --> 00:16:49,090
This is the middle door.

251
00:16:49,090 --> 00:16:56,150
And Jackson then did proceed to search through doors middle plus 1 because there's no point in searching this one again.

252
00:16:56,150 --> 00:17:05,352
And then the last element in any array of size n where n is just our go-to number for the size is always going to be n minus 1.

253
00:17:05,352 --> 00:17:06,310
It's not going to be n.

254
00:17:06,310 --> 00:17:10,839
It's going to be n minus 1 because we always start counting arrays at 0.

255
00:17:10,839 --> 00:17:16,430
So here then we have a translation into pseudocode that's a little closer to C of this exact same idea.

256
00:17:16,430 --> 00:17:18,490
And here, we come full circle to Week 0.

257
00:17:18,490 --> 00:17:23,420
In Week 0, it was pretty intuitive to imagine dividing and conquering a problem like this.

258
00:17:23,420 --> 00:17:29,920
But if you now think back to actual your iPhone, your Android phone, or the like, when you're doing autocomplete and searching the list,

259
00:17:29,920 --> 00:17:34,840
it's possible, if you don't have many friends or family or colleagues in the phone, you know what?

260
00:17:34,840 --> 00:17:40,720
Linear search, just checking every name for the person you're searching for, might be perfectly fine.

261
00:17:40,720 --> 00:17:47,770
But odds are your phone's being smarter than that, especially if you start to have dozens, hundreds, thousands of people in your contacts over the years.

262
00:17:47,770 --> 00:17:49,540
What would be better than linear search?

263
00:17:49,540 --> 00:17:51,340
Well, perhaps binary search.

264
00:17:51,340 --> 00:17:55,180
But, but, but-- there's an assumption, a requirement, which is what?

265
00:17:55,180 --> 00:18:04,830
Why was Jackson ultimately able to find the 50 in just three steps instead of a full seven, like Stephanie?

266
00:18:04,830 --> 00:18:06,570
Because the array was sorted.

267
00:18:06,570 --> 00:18:09,990
And so this is sort of a teaser for what we'll have to come back to later today.

268
00:18:09,990 --> 00:18:12,780
Well, how much effort did it take someone like Carter?

269
00:18:12,780 --> 00:18:17,040
How much effort does it take your phone to sort all of those names and numbers in advance?

270
00:18:17,040 --> 00:18:19,650
Because maybe it's not actually worth the amount of time.

271
00:18:19,650 --> 00:18:24,210
Now someone like Google probably somehow keeps the database of web pages sorted.

272
00:18:24,210 --> 00:18:32,280
You can imagine it being super slow if, when you type in cats or something else into google.com, if they searched linearly over their entire data set.

273
00:18:32,280 --> 00:18:35,430
Ideally, they're doing something a little smarter than that.

274
00:18:35,430 --> 00:18:38,820
So we'll formalize, now, exactly this kind of analysis.

275
00:18:38,820 --> 00:18:42,180
And it's not going to be so much mathy as it still will be intuitive.

276
00:18:42,180 --> 00:18:50,550
But we'll introduce you to some jargon, some terminology that most any programmer or computer scientists might use when analyzing their own algorithms.

277
00:18:50,550 --> 00:18:53,670
Let's formalize now what this kind of analysis is.

278
00:18:53,670 --> 00:18:56,910
So right now, I claim binary search better than linear search.

279
00:18:56,910 --> 00:18:59,100
But how much better and why, exactly?

280
00:18:59,100 --> 00:19:01,120
Well, it all comes back to this kind of graph.

281
00:19:01,120 --> 00:19:04,830
So this, recall, is how we analyzed the phone book back in Week 0.

282
00:19:04,830 --> 00:19:13,740
And recall that, indeed, we had these formulas, rough formulas that described the running time of those three algorithms-- one page at a time, two pages at a time, and then

283
00:19:13,740 --> 00:19:15,720
tearing the thing again and again in half.

284
00:19:15,720 --> 00:19:26,700
And precisely, if you counted up the number of pages I was touching or the number of pages I was tearing, it's fair to say that the first algorithm, in the worst case, might have taken n total pages.

285
00:19:26,700 --> 00:19:31,260
It didn't because I was searching for John Harvard at the time, which is somewhat early in the alphabet.

286
00:19:31,260 --> 00:19:34,340
But if I were searching for someone with the last name of Z,

287
00:19:34,340 --> 00:19:38,430
I would have had to keep going and going, in the worst case, through all n pages.

288
00:19:38,430 --> 00:19:41,940
Not as bad for the second algorithm, and that's why we do n divided by 2.

289
00:19:41,940 --> 00:19:43,920
And even that's a bit of a white lie.

290
00:19:43,920 --> 00:19:48,270
It's probably n divided by 2 plus 1 in case I have to double back.

291
00:19:48,270 --> 00:19:52,030
But again, I'm sort of doing this more generally to capture the essence of these things.

292
00:19:52,030 --> 00:19:54,363
And then we really got into the weeds with like log base

293
00:19:54,363 --> 00:19:56,940
2 event for that third and final algorithm.

294
00:19:56,940 --> 00:20:04,200
And at the time, we claimed any time you're dividing something in half, in half, in half, odds are there's going to be some kind of logarithm involved.

295
00:20:04,200 --> 00:20:05,340
And we'll see that today.

296
00:20:05,340 --> 00:20:09,010
But today, we're going to actually start using computer science terminology.

297
00:20:09,010 --> 00:20:13,590
And we're going to formalize this imprecision, if you will.

298
00:20:13,590 --> 00:20:20,820
We are not going to care, generally, about exactly how many steps some algorithm takes because that's not going to be that enlightening,

299
00:20:20,820 --> 00:20:24,630
especially if maybe you have a faster computer tomorrow than you did today.

300
00:20:24,630 --> 00:20:27,510
It wouldn't really be fair to compare numbers too precisely.

301
00:20:27,510 --> 00:20:33,930
We really want to, with the wave of a hand, just get a sense of roughly how slow or how fast an algorithm is.

302
00:20:33,930 --> 00:20:36,000
So the notation here is deliberate.

303
00:20:36,000 --> 00:20:40,620
That is literally a capital O, often italicized, refer to as big O.

304
00:20:40,620 --> 00:20:43,920
And so the first algorithm is in big O of n.

305
00:20:43,920 --> 00:20:47,760
The second algorithm is in big O of n divided by 2.

306
00:20:47,760 --> 00:20:51,480
The third algorithm is in big O of log base 2 of n.

307
00:20:51,480 --> 00:20:54,690
But even that is kind of unnecessary detail.

308
00:20:54,690 --> 00:21:01,230
When using big O notation, you really don't care about, we'll see, the smaller order terms.

309
00:21:01,230 --> 00:21:04,500
We're not going to care about the divided by 2 because you know what?

310
00:21:04,500 --> 00:21:07,720
The shape of these algorithms are is almost the same.

311
00:21:07,720 --> 00:21:11,340
And really, the idea-- the algorithm itself is sort of fundamentally the same.

312
00:21:11,340 --> 00:21:13,620
Instead of one page at a time, I'm doing two.

313
00:21:13,620 --> 00:21:22,085
But if you throw millions of pages, billions of pages at me, those algorithms are really going to kind of perform the same as n gets really large, goes off toward infinity.

314
00:21:22,085 --> 00:21:23,585
And the same is true for logarithms.

315
00:21:23,585 --> 00:21:33,040
Even if you're a little rusty, it turns out that whether you do the math with log base 2, log base 3, log base 10, you can just multiply one by the other to really get the same formula.

316
00:21:33,040 --> 00:21:39,270
So this is only to say a computer scientist would generally say that the first two algorithms are on the order of n steps.

317
00:21:39,270 --> 00:21:42,690
The third algorithm is on the order of log n steps.

318
00:21:42,690 --> 00:21:46,350
And we don't really care precisely what we mean beyond that.

319
00:21:46,350 --> 00:21:49,770
And this big O notation, as we'll see-- and actually, let me zoom out.

320
00:21:49,770 --> 00:21:58,320
If you can imagine suddenly making the x-axis much longer-- so more pages on the screen at once-- it is indeed going to be the shapes of these curves

321
00:21:58,320 --> 00:22:07,470
that matter, because imagine in your mind's eye as you zoom out, zoom out, zoom out, zoom out, and as n gets much, much, much bigger on the x-axis, the red and the yellow line

322
00:22:07,470 --> 00:22:11,400
are essentially going to look the same once n is sufficiently large.

323
00:22:11,400 --> 00:22:14,378
But the green line is never going to look the same.

324
00:22:14,378 --> 00:22:16,420
It's going to be a fundamentally different shape.

325
00:22:16,420 --> 00:22:23,200
And so that's the intuition of big O, to get a sense of these rates of performance like this.

326
00:22:23,200 --> 00:22:32,490
So here, then, is big O. Here is, perhaps, a cheat sheet of the common formulas that a computer scientist, certainly in an introductory context, might use when analyzing algorithms.

327
00:22:32,490 --> 00:22:39,040
And let's consider for a moment which of our first two algorithms-- linear search and binary search-- fall into these categories.

328
00:22:39,040 --> 00:22:44,318
So I've ordered them from slowest to fastest, so order of n squared.

329
00:22:44,318 --> 00:22:48,392
It's not something we've actually seen yet, but it tends to be slow because it's quadratic.

330
00:22:48,392 --> 00:22:49,350
You're doing n times n.

331
00:22:49,350 --> 00:22:51,090
That's got to add up to a lot of steps.

332
00:22:51,090 --> 00:22:53,190
Better today is going to be n log n.

333
00:22:53,190 --> 00:22:54,630
Even better is going to be n.

334
00:22:54,630 --> 00:22:56,190
Even better than that is log n.

335
00:22:56,190 --> 00:23:08,200
And best is so-called order of 1, like one step or maybe two steps, maybe even 1,000 steps, but a fixed, finite number of steps that never changes no matter how big n is.

336
00:23:08,200 --> 00:23:13,570
So given this chart, just to be clear, linear search-- let's consider the worst case.

337
00:23:13,570 --> 00:23:23,500
In the worst case, how many steps did it take someone like Stephanie to find the solution to the problem, assuming not seven doors but n doors?

338
00:23:23,500 --> 00:23:25,160
Yeah?

339
00:23:25,160 --> 00:23:26,540
So on the order of n.

340
00:23:26,540 --> 00:23:28,280
And in this case, it's exactly n.

341
00:23:28,280 --> 00:23:33,530
But you know what, maybe it's arguably 2n because it took Stephanie a couple of steps.

342
00:23:33,530 --> 00:23:34,460
She had to lift the latch.

343
00:23:34,460 --> 00:23:35,360
She had to open the door.

344
00:23:35,360 --> 00:23:36,318
Maybe it's three steps.

345
00:23:36,318 --> 00:23:37,530
She had to show the money.

346
00:23:37,530 --> 00:23:39,170
So now it's 3n, 2n.

347
00:23:39,170 --> 00:23:41,990
But we don't really care about that level of precision.

348
00:23:41,990 --> 00:23:45,660
We really just care about the fundamental number of operations.

349
00:23:45,660 --> 00:23:47,540
So we'll say yes, on the order of n.

350
00:23:47,540 --> 00:23:51,320
So that might be an upper bound, we'll call this, for linear search.

351
00:23:51,320 --> 00:23:53,030
And how about binary search?

352
00:23:53,030 --> 00:24:02,910
In Jackson's case, or in general, me in Week 0, if there's n doors, how many steps did it take Jackson or me using binary search?

353
00:24:02,910 --> 00:24:04,860
In this case, it was literally three.

354
00:24:04,860 --> 00:24:07,200
But that's not a formula.

355
00:24:07,200 --> 00:24:09,690
Yeah so it's on the order of log n.

356
00:24:09,690 --> 00:24:14,250
And indeed, if there are seven doors, well, that's almost eight, if you just do a little bit of rounding.

357
00:24:14,250 --> 00:24:18,480
And indeed, if you take log base 2 of 8, that does actually give us 3.

358
00:24:18,480 --> 00:24:19,813
So the math actually checks out.

359
00:24:19,813 --> 00:24:22,272
And if you're not comfortable with logarithms, no big deal.

360
00:24:22,272 --> 00:24:23,670
Just think about it intuitively.

361
00:24:23,670 --> 00:24:27,010
Logarithm of base 2 is just dividing something again and again.

362
00:24:27,010 --> 00:24:38,610
So on this chart, when we consider big O, which to be clear, allows you to describe the order of an algorithm's running time-- like the magnitude of it-- but it also describes, more specifically,

363
00:24:38,610 --> 00:24:40,090
an upper bound.

364
00:24:40,090 --> 00:24:49,270
So in the worst case, for instance, these are pretty good measures of how good-- or rather, of how bad-- linear search and binary search might be.

365
00:24:49,270 --> 00:24:49,770
Why?

366
00:24:49,770 --> 00:24:56,320
Well, suppose you're searching a 1,000-page phonebook and the person's name starts with Z. The algorithm is still going to be on the order of n steps.

367
00:24:56,320 --> 00:24:56,820
Why?

368
00:24:56,820 --> 00:25:01,080
Because it might take you as many as all n steps to find it.

369
00:25:01,080 --> 00:25:05,250
Now that's not necessarily going to be the case in practice.

370
00:25:05,250 --> 00:25:16,180
If I use big O as an upper bound, well, it would be nice if there's a corresponding lower bound, especially if you want to consider not just worst cases, but maybe best cases.

371
00:25:16,180 --> 00:25:18,040
So what might we use here?

372
00:25:18,040 --> 00:25:20,200
Well, this is a capital Greek omega symbol.

373
00:25:20,200 --> 00:25:28,710
So omega is the symbol that a computer scientist uses generally to describe a lower bound on an algorithm, often in the context of best case, though not necessarily.

374
00:25:28,710 --> 00:25:32,490
So a lower bound means how few steps might an algorithm take?

375
00:25:32,490 --> 00:25:33,990
And here, too, same formulas.

376
00:25:33,990 --> 00:25:36,270
And we'll fill in these blanks over time.

377
00:25:36,270 --> 00:25:41,370
Some algorithms might always take a minimum of n squared steps, or on the order of n steps.

378
00:25:41,370 --> 00:25:45,660
Some might only take n log n, or n, or log n, or 1.

379
00:25:45,660 --> 00:25:52,980
So something like a linear search-- when Stephanie started with linear search, she didn't get lucky this time on stage.

380
00:25:52,980 --> 00:25:57,720
But what if she had, and the first door she opened were 50?

381
00:25:57,720 --> 00:26:08,290
How might you then describe the lower bound on linear search in this so-called best case, using this list of possible answers?

382
00:26:08,290 --> 00:26:09,530
Yeah?

383
00:26:09,530 --> 00:26:11,060
Yeah, so omega of 1.

384
00:26:11,060 --> 00:26:18,990
So in the best case, the lower bound on how many steps it might take linear search to find something might just be one step.

385
00:26:18,990 --> 00:26:19,490
Why?

386
00:26:19,490 --> 00:26:28,460
Because maybe if Stephanie had gotten lucky and we had prefilled these lockers with the numbers in some other order such that she might have opened the first locker, and voila,

387
00:26:28,460 --> 00:26:34,610
the number 50 could have been there, so a lower bound arguably could indeed be omega of 1 for linear search.

388
00:26:34,610 --> 00:26:35,990
And how about now for Jackson?

389
00:26:35,990 --> 00:26:37,440
He used binary search.

390
00:26:37,440 --> 00:26:40,940
So he dived right into the middle of the problem.

391
00:26:40,940 --> 00:26:45,020
But what would be a lower bound on binary search using this logic?

392
00:26:45,020 --> 00:26:45,980
Yeah?

393
00:26:45,980 --> 00:26:47,460
Yeah, so again, omega of 1.

394
00:26:47,460 --> 00:26:47,960
Why?

395
00:26:47,960 --> 00:26:49,580
Because maybe he just gets lucky.

396
00:26:49,580 --> 00:26:53,300
And indeed, right in the middle of the lockers could have been the number 50.

397
00:26:53,300 --> 00:26:54,060
It wasn't.

398
00:26:54,060 --> 00:27:00,050
And so more germane in Jackson's actual practice would have been the big O discussion.

399
00:27:00,050 --> 00:27:08,670
But big O and omega, upper bound and lower bound, just allow a computer scientist to kind of wrestle with what could happen maybe in the worst case, what can happen in the best case?

400
00:27:08,670 --> 00:27:12,267
And you can even get even more precise like the average case or the like.

401
00:27:12,267 --> 00:27:21,380
And this is, indeed, what engineers might do at a whiteboard in a company, in a university when designing an algorithm and trying to make arguments as to why their algorithm is better than someone

402
00:27:21,380 --> 00:27:24,080
else's, by way of these kinds of analyses.

403
00:27:24,080 --> 00:27:35,880
And just so you've seen it, it turns out that if some algorithm happens to have an identical upper bound and lower bound, you can actually use a capital Greek theta as well.

404
00:27:35,880 --> 00:27:38,210
And this is the last of the Greek symbols today.

405
00:27:38,210 --> 00:27:43,130
But a Greek theta indicates a coincidence of both upper bound and lower bound.

406
00:27:43,130 --> 00:27:44,702
That is, they are one and the same.

407
00:27:44,702 --> 00:27:49,220
That was not the case for our discussion a second ago of linear search, not the case for binary search.

408
00:27:49,220 --> 00:27:56,970
But you could use the same kinds of formulas if it turns out that your upper bound and lower bound are the same.

409
00:27:56,970 --> 00:28:09,080
So for instance, if I were to count everyone literally in this room-- one, two, three, four, five, six and so forth-- you could actually say that counting in that way is in theta of n

410
00:28:09,080 --> 00:28:13,468
because in the best case, it's going to take me n points, people in the audience.

411
00:28:13,468 --> 00:28:15,260
In the worst case, it's going to take me n.

412
00:28:15,260 --> 00:28:18,380
It's always going to take me n steps if I want to count everyone in the room.

413
00:28:18,380 --> 00:28:20,930
You can't really do better than that unless you skip people.

414
00:28:20,930 --> 00:28:26,150
So that would be an example of the cuff of something where theta is instead germane.

415
00:28:26,150 --> 00:28:38,730
Are any questions now on big O, on omega, or theta, which are now just more formal tools in the toolkit for talking about the design of our algorithms?

416
00:28:38,730 --> 00:28:42,050
Any questions?

417
00:28:42,050 --> 00:28:42,860
No?

418
00:28:42,860 --> 00:28:44,720
Seeing none.

419
00:28:44,720 --> 00:28:45,560
Oh, is this-- yes?

420
00:28:45,560 --> 00:28:46,840
No?

421
00:28:46,840 --> 00:28:48,250
OK, so we're good.

422
00:28:48,250 --> 00:28:52,000
So let's go ahead and translate this, perhaps, to some actual code.

423
00:28:52,000 --> 00:28:53,900
Let me go over to VS Code here.

424
00:28:53,900 --> 00:29:00,280
And let's see if we can't now translate some of these ideas to some actual code, not so much using new syntax yet.

425
00:29:00,280 --> 00:29:03,320
We're going to still operate in this world of arrays like last week.

426
00:29:03,320 --> 00:29:09,280
So let me go ahead and create a program called search.c by executing code space search.c in my terminal.

427
00:29:09,280 --> 00:29:14,740
And then up here, let's go ahead and include our usual, so include cs50.h so I can get some input.

428
00:29:14,740 --> 00:29:18,370
Include standard io.h so I can print some output.

429
00:29:18,370 --> 00:29:23,140
We'll do int main void, the meaning of which we did start to tease apart last week.

430
00:29:23,140 --> 00:29:26,650
The fact that it's void again today just means no command line arguments.

431
00:29:26,650 --> 00:29:28,580
And let me go ahead and do this.

432
00:29:28,580 --> 00:29:34,840
Let me go ahead and declare, just for discussion's sake, a static array, like an array that never changes.

433
00:29:34,840 --> 00:29:41,290
And the syntax for this is going to be give me an array called numbers using the square bracket notation.

434
00:29:41,290 --> 00:29:50,060
And I'm going to immediately initialize it to 20, 500, 10, 5, 100, 1, and 50, reminiscent of those same denominations as before.

435
00:29:50,060 --> 00:29:54,080
So this is a slightly new syntax that we've perhaps not seen.

436
00:29:54,080 --> 00:30:00,820
And the curly braces here, which are different from for loops and while loops and functions, just tell the compiler please give me

437
00:30:00,820 --> 00:30:05,380
an array of whatever size this is containing those numbers left to right.

438
00:30:05,380 --> 00:30:10,220
I could alternatively use last week's syntax of saying something like this.

439
00:30:10,220 --> 00:30:13,090
Let's see, 1, 2, 3, 4, 5, 6, 7 denominations.

440
00:30:13,090 --> 00:30:15,250
I could alternatively do this.

441
00:30:15,250 --> 00:30:21,910
And then I could say numbers bracket 0 equals

442
00:30:21,910 --> 00:30:25,570
20, numbers bracket 1 equals 500.

443
00:30:25,570 --> 00:30:27,572
And I could do this five more times.

444
00:30:27,572 --> 00:30:28,780
That's just a little tedious.

445
00:30:28,780 --> 00:30:32,530
If you know the numbers in advance, you don't have to tell the compiler how many there are.

446
00:30:32,530 --> 00:30:37,420
You can just let it figure it out that your numbers will be 10, 500, 10, 5,

447
00:30:37,420 --> 00:30:39,430
100, 1, and 50.

448
00:30:39,430 --> 00:30:42,550
So this is how you statically define an array.

449
00:30:42,550 --> 00:30:45,380
All right, let me just go ahead and ask the user now for a number.

450
00:30:45,380 --> 00:30:50,020
We'll call it n by using get_int and prompting them for a number-- so nothing new there.

451
00:30:50,020 --> 00:30:53,680
And now let me go ahead and implement linear search.

452
00:30:53,680 --> 00:30:57,520
And the pseudocode we had for this before used some array-like notation.

453
00:30:57,520 --> 00:30:59,620
Let me go ahead, then, and start similarly.

454
00:30:59,620 --> 00:31:04,270
For int i-- and you almost always start counting at i by convention.

455
00:31:04,270 --> 00:31:06,490
So that's perhaps a good starting point.

456
00:31:06,490 --> 00:31:09,790
I'm going to do this so long as i is less than 7.

457
00:31:09,790 --> 00:31:15,560
Not the best design to hard code the 7, but this is just for demonstration's sake for now, because I know how many numbers I put in there.

458
00:31:15,560 --> 00:31:16,992
And then I'm going to i++.

459
00:31:16,992 --> 00:31:21,550
So now I have the beginnings of a loop that will just allow me to iterate over the entire array.

460
00:31:21,550 --> 00:31:22,760
And let me ask this.

461
00:31:22,760 --> 00:31:36,190
If the current number at location i equals equals n, which is the number the human typed in, then let's go ahead and do something simple like printf, quote unquote, found, backslash n.

462
00:31:36,190 --> 00:31:40,240
And then per our discussion last week, to indicate that this is successful,

463
00:31:40,240 --> 00:31:42,610
I'm going to return 0 if I found it.

464
00:31:42,610 --> 00:31:48,640
And if I don't find it, I'm just going to go down here and, by default, say not found, backslash n.

465
00:31:48,640 --> 00:31:52,610
And just for convention-- whoops, just for good measure, per convention,

466
00:31:52,610 --> 00:31:55,630
I'll return 1 or, really, any value other than 0.

467
00:31:55,630 --> 00:31:57,130
0, recall, means success.

468
00:31:57,130 --> 00:32:02,690
And any other integer tends to mean error of some sort, irrespective of the number I'm looking for.

469
00:32:02,690 --> 00:32:06,670
So just to revisit, the only thing that's new here is the syntax.

470
00:32:06,670 --> 00:32:09,980
We're creating an array of seven numbers, these numbers.

471
00:32:09,980 --> 00:32:16,090
And then after that we have really highlighted here an implementation of linear search.

472
00:32:16,090 --> 00:32:22,540
I mean this is the C version, I daresay, of what Stephanie did on the board, whereas now the array is called numbers instead of doors.

473
00:32:22,540 --> 00:32:25,460
But I think it's pretty much the same.

474
00:32:25,460 --> 00:32:30,380
Let me go ahead and open my terminal window and run make search.

475
00:32:30,380 --> 00:32:32,518
Seems to compile, ./search.

476
00:32:32,518 --> 00:32:34,310
And let's go ahead and search for a number.

477
00:32:34,310 --> 00:32:36,230
We'll start with what we did before, 50.

478
00:32:36,230 --> 00:32:37,340
And it's found.

479
00:32:37,340 --> 00:32:39,770
Let's go ahead and run it again, ./search.

480
00:32:39,770 --> 00:32:42,500
Let's search for maybe 20 at the beginning.

481
00:32:42,500 --> 00:32:43,670
That one, too, is found.

482
00:32:43,670 --> 00:32:50,720
Let's run it one more time searching for like 1,000, which is not among the denominations.

483
00:32:50,720 --> 00:32:52,980
And that one, indeed, is not found.

484
00:32:52,980 --> 00:32:59,300
So we've taken an idea from Week 0, now formalized in Week 3, and just translated it now to code.

485
00:32:59,300 --> 00:33:05,500
Questions on this implementation of linear search?

486
00:33:05,500 --> 00:33:07,570
Linear search.

487
00:33:07,570 --> 00:33:08,680
Nothing.

488
00:33:08,680 --> 00:33:11,810
Oh, so successful so far today.

489
00:33:11,810 --> 00:33:19,270
So let's see if we can't maybe make this a little more interesting and see if we can't trip over a detail that's going to be important in C.

490
00:33:19,270 --> 00:33:23,330
And instead of doing numbers, let me go ahead and do this.

491
00:33:23,330 --> 00:33:25,030
We'll stay on theme with Monopoly.

492
00:33:25,030 --> 00:33:27,730
And I went down the rabbit hole of reading the Wikipedia article on Monopoly.

493
00:33:27,730 --> 00:33:33,740
And the original pieces or tokens that came with Monopoly-- and it turns out we can represent those with strings.

494
00:33:33,740 --> 00:33:39,170
So I'm going to create an array called strings, plural, of whatever size I defined here.

495
00:33:39,170 --> 00:33:54,700
And the very first monopoly pieces back in the day were a battleship that you could play with, a boot, a cannon, an iron, a thimble, and a top hat, some of which you might from the game nowadays.

496
00:33:54,700 --> 00:33:57,890
Turns out they've been changing these-- had no idea-- over the years.

497
00:33:57,890 --> 00:34:00,170
So here is, now, an array of strings.

498
00:34:00,170 --> 00:34:03,940
Let me go ahead and prompt the user now not for an integer anymore.

499
00:34:03,940 --> 00:34:07,970
I want to now search for one of these strings still using linear search.

500
00:34:07,970 --> 00:34:13,840
So let me create a string s, set it equal to get_string, prompt the user for a string to search for.

501
00:34:13,840 --> 00:34:19,540
And then I think my code here is almost the same, except for one detail.

502
00:34:19,540 --> 00:34:21,850
I now have an array called strings.

503
00:34:21,850 --> 00:34:24,040
I now have a variable called s.

504
00:34:24,040 --> 00:34:31,030
But it turns out, for reasons we'll explore in more detail next week, this line of code is not going to work.

505
00:34:31,030 --> 00:34:36,880
And it turns out the reason has to do with what we discussed last week of what a string really is.

506
00:34:36,880 --> 00:34:39,355
And what is a string, again?

507
00:34:39,355 --> 00:34:41,000
A string is an array.

508
00:34:41,000 --> 00:34:51,949
And it turns out, though, that equals equals is not going to generously compare all of the characters in an array for you just because you use equal equals.

509
00:34:51,949 --> 00:34:54,650
It turns out it's not going to compare every letter.

510
00:34:54,650 --> 00:35:03,058
And so thankfully, there is, in the string library that we introduced last week, a solution to this problem.

511
00:35:03,058 --> 00:35:05,850
The reason for the problem, we'll explore in more detail next week.

512
00:35:05,850 --> 00:35:15,680
But for now, just know that when you want to compare strings in C-- especially if you've come into the class knowing a bit of Java or Python or some other language-- you cannot use equals equals.

513
00:35:15,680 --> 00:35:18,500
Even though you could in Scratch, you cannot in C.

514
00:35:18,500 --> 00:35:21,620
So what I have to actually do here is this.

515
00:35:21,620 --> 00:35:36,050
I have to ask the question, does the return value of a function called str compare, or strcomp, equal 0 when passed in the current string and that's user input?

516
00:35:36,050 --> 00:35:44,500
So if you read the documentation for this function called str compare, you'll see that it takes two strings as input, first one and second one.

517
00:35:44,500 --> 00:35:51,910
It then-- someone decades ago wrote the code that probably uses a for loop or a while loop to compare every character in each of those strings.

518
00:35:51,910 --> 00:35:56,290
And it turns out it returns 0 if they are, in fact, equal.

519
00:35:56,290 --> 00:36:02,440
Turns out, too, it will return a positive number or a negative number in other situations.

520
00:36:02,440 --> 00:36:10,810
Any intuition for why it might actually be useful to have a function that allows you to check if two strings are equal?

521
00:36:10,810 --> 00:36:14,830
If they're not equal, what else might be interesting to know when comparing two strings?

522
00:36:18,474 --> 00:36:19,391
If certain values are?

523
00:36:19,391 --> 00:36:23,347
STUDENT: [INAUDIBLE]

524
00:36:23,347 --> 00:36:24,430
DAVID MALAN: OK, possibly.

525
00:36:24,430 --> 00:36:26,950
Maybe you want to just how similar they are.

526
00:36:26,950 --> 00:36:28,810
And that's indeed an algorithm unto itself.

527
00:36:28,810 --> 00:36:31,410
But str compare is a little simpler than that.

528
00:36:31,410 --> 00:36:33,040
STUDENT: [INAUDIBLE]

529
00:36:35,850 --> 00:36:41,950
DAVID MALAN: Exactly, if you're trying to alphabetize a whole list of strings, just like your phone probably is for your contacts or address book.

530
00:36:41,950 --> 00:36:53,800
It turns out that str compare will actually return a positive number or a negative number or a 0 based on whether, maybe it comes alphabetically first or later, or in fact, equal.

531
00:36:53,800 --> 00:36:55,130
So that can be a useful thing.

532
00:36:55,130 --> 00:36:58,880
And that's just a teaser for a lower level explanation that we'll see next week.

533
00:36:58,880 --> 00:37:01,750
So now, let me cross my fingers and see if I got this right.

534
00:37:01,750 --> 00:37:05,410
Let me go ahead and do make search.

535
00:37:05,410 --> 00:37:08,590
Did compile, albeit slowly.

536
00:37:08,590 --> 00:37:11,920
Dot slash search, and let's search for something like the thimble.

537
00:37:11,920 --> 00:37:14,048
And we see that that's, indeed, found.

538
00:37:14,048 --> 00:37:19,060
Otherwise, let's search for something that I know isn't there, like a race car, which was there when I grew up.

539
00:37:19,060 --> 00:37:23,227
But huh, segmentation fault, core dumped.

540
00:37:23,227 --> 00:37:25,810
And actually, some of you have tripped over this error before.

541
00:37:25,810 --> 00:37:27,220
Anyone want to admit seeing this?

542
00:37:27,220 --> 00:37:32,170
So yeah, not something we've talked about, and honestly, not something I intended just now.

543
00:37:32,170 --> 00:37:34,450
But that too, we'll see next week.

544
00:37:34,450 --> 00:37:39,920
Any intuition for why my program just broke.

545
00:37:39,920 --> 00:37:41,900
I didn't really change the logic.

546
00:37:41,900 --> 00:37:43,550
It's still linear search.

547
00:37:43,550 --> 00:37:46,280
Let me hide the terminal so you can see all of the code at once.

548
00:37:46,280 --> 00:37:49,850
The only thing I did was switched from integers to strings.

549
00:37:49,850 --> 00:37:52,310
And I switched to str compare here.

550
00:37:52,310 --> 00:37:54,205
But segmentation fault happened.

551
00:37:54,205 --> 00:37:57,080
And the teaser is that that somehow relates to the computer's memory.

552
00:37:57,080 --> 00:37:57,996
Yeah.

553
00:37:57,996 --> 00:38:00,690
STUDENT: [INAUDIBLE]

554
00:38:01,470 --> 00:38:03,670
DAVID MALAN: Yeah, and this is subtle, but spot on.

555
00:38:03,670 --> 00:38:12,810
So one, two, three, four, five, six elements total in this array, versus the seven numbers of monopoly denominations that we had earlier.

556
00:38:12,810 --> 00:38:13,888
And this is where, see?

557
00:38:13,888 --> 00:38:15,930
Sort of case in point, this came back to bite me.

558
00:38:15,930 --> 00:38:26,610
The fact that I hardcoded this value as opposed to maybe separating it out as a constant or declaring it higher up, kind of bit me here, because now, I'm iterating over an array of size 6.

559
00:38:26,610 --> 00:38:32,250
But clearly, I'm going one step too far, because I'm literally going to iterate seven times, not six.

560
00:38:32,250 --> 00:38:35,580
So it's as though I'm looking at memory that's over here.

561
00:38:35,580 --> 00:38:37,530
And indeed, next week, we'll focus on memory.

562
00:38:37,530 --> 00:38:38,860
And that's just a bad thing.

563
00:38:38,860 --> 00:38:47,280
So odds are, not even seeing your code from this past week, if any of you have had segmentation faults, odds are, you touched memory that you shouldn't have.

564
00:38:47,280 --> 00:38:49,290
You maybe looped too many times.

565
00:38:49,290 --> 00:38:52,770
You might have used a negative number to get into your array.

566
00:38:52,770 --> 00:38:55,220
In general, you touched memory that you shouldn't have.

567
00:38:55,220 --> 00:38:57,720
And you touched a segment of memory that you shouldn't have.

568
00:38:57,720 --> 00:39:00,060
The fix, though, at least in my case, is simple.

569
00:39:00,060 --> 00:39:01,300
Just don't do that.

570
00:39:01,300 --> 00:39:03,210
So let me go ahead and recompile this.

571
00:39:03,210 --> 00:39:06,870
Make search dot slash search.

572
00:39:06,870 --> 00:39:10,320
And I'll search again for race car, Enter.

573
00:39:10,320 --> 00:39:11,850
And now it does not crash.

574
00:39:11,850 --> 00:39:13,630
But it does tell me it's not found.

575
00:39:13,630 --> 00:39:17,040
So subtle, but something you might yourself have tripped over already.

576
00:39:17,040 --> 00:39:23,190
Questions then, on what I just did, intentionally or otherwise.

577
00:39:23,190 --> 00:39:24,423
Yeah, in front.

578
00:39:24,423 --> 00:39:31,275
STUDENT: One thing is the program still works if you do return-- if you don't do return 0, return 1.

579
00:39:31,275 --> 00:39:33,220
So what is the purpose of doing [INAUDIBLE]??

580
00:39:33,220 --> 00:39:34,720
DAVID MALAN: A really good question.

581
00:39:34,720 --> 00:39:38,920
So the program will still work even if I don't return 0 or return 1.

582
00:39:38,920 --> 00:39:43,930
In fact, let me go ahead and do that and just hide my terminal window for a second.

583
00:39:43,930 --> 00:39:48,040
Let's get rid of the return here.

584
00:39:48,040 --> 00:39:50,810
However, watch what happens here.

585
00:39:50,810 --> 00:39:53,710
Let me go ahead and recompile this, make search.

586
00:39:53,710 --> 00:39:55,610
Let me scroll up in my code here.

587
00:39:55,610 --> 00:39:57,560
Let me go ahead and do dot slash search.

588
00:39:57,560 --> 00:40:02,800
And let me go ahead and search for the first thing in the list, battle ship, so I know that this should be found.

589
00:40:02,800 --> 00:40:04,690
I hit Enter.

590
00:40:04,690 --> 00:40:05,858
Huh, interesting.

591
00:40:05,858 --> 00:40:07,150
So it's saying found not found.

592
00:40:07,150 --> 00:40:11,496
But do you see why, logically, in this case?

593
00:40:11,496 --> 00:40:12,980
STUDENT: Is the loop still running?

594
00:40:12,980 --> 00:40:13,910
DAVID MALAN: Exactly.

595
00:40:13,910 --> 00:40:15,302
So the loop is still running.

596
00:40:15,302 --> 00:40:17,010
So there's a couple of solutions to this.

597
00:40:17,010 --> 00:40:21,080
I could, for instance, somehow break out of the code here.

598
00:40:21,080 --> 00:40:24,200
But that's going to still result in line 18 executing.

599
00:40:24,200 --> 00:40:26,600
I could then instead just return here.

600
00:40:26,600 --> 00:40:29,390
I don't strictly need to return 1 down at the bottom.

601
00:40:29,390 --> 00:40:39,300
But I made this claim last week that it tends to be helpful as your programs get more sophisticated, to at least signify, just like a real world programmer, error codes when something goes wrong.

602
00:40:39,300 --> 00:40:44,090
So returning 0 in main is the easiest way to signify my code is done.

603
00:40:44,090 --> 00:40:46,340
I'm ready to exit successfully, that's it.

604
00:40:46,340 --> 00:40:50,280
But down here, I could absolutely still return 0, because that's not a huge deal.

605
00:40:50,280 --> 00:40:55,200
It's not really an error that deserves annoying the user with some kind of pop up that something went wrong.

606
00:40:55,200 --> 00:41:00,330
But return 1 is just a lower level way of signaling, eh, it didn't really find what I was looking for.

607
00:41:00,330 --> 00:41:03,510
And remember from last week, you can see this as follows.

608
00:41:03,510 --> 00:41:08,060
If I recompile this again, now that I've reverted those changes, so make search.

609
00:41:08,060 --> 00:41:19,790
And if I do a dot slash search and search for battle ship, which is indeed found, recall I can execute this magical command, echo dollar sign question mark, which you're not going to often execute.

610
00:41:19,790 --> 00:41:22,790
But it shows you what main returned.

611
00:41:22,790 --> 00:41:27,770
If I run search again and search for race car, which is not found,

612
00:41:27,770 --> 00:41:32,150
I see not found, but I can also run this command again and see that, oh, it returned 1.

613
00:41:32,150 --> 00:41:40,100
So now if you fast forward a few months, a few years, when you're actually writing code in a company or for larger projects, you might want to be automating software.

614
00:41:40,100 --> 00:41:43,100
You might not want the human to necessarily be running it manually.

615
00:41:43,100 --> 00:41:48,360
You might want code to be automated by some nightly process or something like that.

616
00:41:48,360 --> 00:41:55,910
Using these exit codes, can a program determine yes or no that other code succeeded or failed.

617
00:41:55,910 --> 00:42:01,850
Other questions on linear search in this way.

618
00:42:01,850 --> 00:42:02,350
No?

619
00:42:02,350 --> 00:42:11,590
All right, well, let's translate this to one other feature of C here by incorporating these two ideas now into one other program.

620
00:42:11,590 --> 00:42:16,605
So I'm going to create a phone book in C by doing code space phonebook dot C.

621
00:42:16,605 --> 00:42:23,030
And let's combine some of these ideas and implement this notion of searching a phonebook for an actual name and getting back a number.

622
00:42:23,030 --> 00:42:30,860
So I'm going to go ahead and quickly include some of the same things, cs50.h so we can get input. standard io dot h so we can print output.

623
00:42:30,860 --> 00:42:39,010
And I'm going to preemptively include string.h in case we need that one as well. int main void, no need for command line arguments today.

624
00:42:39,010 --> 00:42:42,650
And let me give myself, now, an array of names for this phone book.

625
00:42:42,650 --> 00:42:45,040
So string names equals.

626
00:42:45,040 --> 00:42:50,840
And then in curly braces, how about Carter will be one person in the phone book, and David, myself, will be the other.

627
00:42:50,840 --> 00:42:53,465
So we'll keep it short so we don't have to type too many names.

628
00:42:53,465 --> 00:42:55,840
But this is a phone book with two people thus far.

629
00:42:55,840 --> 00:42:59,628
Suppose, now, we want to also store Carter's phone number in mind.

630
00:42:59,628 --> 00:43:01,420
So it's not just saying found or not found.

631
00:43:01,420 --> 00:43:05,320
It's literally looking up our phone numbers like a proper phone book.

632
00:43:05,320 --> 00:43:09,440
Well, at the moment, there's really no way to do this.

633
00:43:09,440 --> 00:43:16,510
I could do something hackish like I could put a number like 617-495-1000 after Carter.

634
00:43:16,510 --> 00:43:22,460
I could maybe do something like 949-468-2750 after me.

635
00:43:22,460 --> 00:43:25,300
But now you're kind of doing the whole apples and oranges thing.

636
00:43:25,300 --> 00:43:26,470
Now, it's not strings.

637
00:43:26,470 --> 00:43:28,420
It's a string int, string int.

638
00:43:28,420 --> 00:43:31,240
All right, so maybe I could just make all of these strings.

639
00:43:31,240 --> 00:43:34,600
But now it's just a conceptual mixing of apples and oranges.

640
00:43:34,600 --> 00:43:36,425
Like yes, that's an array of four strings.

641
00:43:36,425 --> 00:43:43,100
But now you're on the honor system to know that the first string is a name, the second string is a number, the third string is-- you can do it.

642
00:43:43,100 --> 00:43:45,110
But it's a bit of a hack, so to speak.

643
00:43:45,110 --> 00:43:47,300
So what might be cleaner than this?

644
00:43:47,300 --> 00:43:55,480
Instead of combining our phone numbers into the same array as our names, what else might we do that's perhaps a little better?

645
00:43:55,480 --> 00:43:56,440
Say it little louder.

646
00:43:58,960 --> 00:44:01,197
A 2D array, possibly something we could do.

647
00:44:01,197 --> 00:44:07,823
I'm going to keep it even simpler now, because we haven't used those by name, even though that is, we saw last week, technically what argv is.

648
00:44:07,823 --> 00:44:10,240
What else could I do if I want to store names and numbers?

649
00:44:10,240 --> 00:44:11,147
Yeah.

650
00:44:11,147 --> 00:44:12,220
STUDENT: [INAUDIBLE]

651
00:44:12,220 --> 00:44:13,690
DAVID MALAN: Yeah, let me go with this suggestion.

652
00:44:13,690 --> 00:44:14,607
It's a little simpler.

653
00:44:14,607 --> 00:44:18,970
Rather than complicate things in literally different dimensions, let me go ahead and do string.

654
00:44:18,970 --> 00:44:21,730
Well, I could do int numbers.

655
00:44:21,730 --> 00:44:22,690
But you know what?

656
00:44:22,690 --> 00:44:29,200
So that we can support punctuation like dashes or even parentheses or country codes, I'm going to do this instead.

657
00:44:29,200 --> 00:44:40,390
I'm going to do string numbers so that I can represent Carter's number as quote unquote plus 1 for the US, 617-495-1000, complete with hyphens, as is US convention.

658
00:44:40,390 --> 00:44:47,930
And then for mine I'll go ahead and do +1-949-468-2750 semicolon.

659
00:44:47,930 --> 00:44:53,860
And now down below, let's actually enable the user to search this phone book, just like in week 0 we did.

660
00:44:53,860 --> 00:44:55,960
String name equals get string.

661
00:44:55,960 --> 00:44:59,990
And let's ask the user for a name, presumably David or Carter or someone else.

662
00:44:59,990 --> 00:45:01,850
And now let's re-implement linear search.

663
00:45:01,850 --> 00:45:05,920
So 4, int i get 0. i is less than 2.

664
00:45:05,920 --> 00:45:07,510
And do as I say, not as I do.

665
00:45:07,510 --> 00:45:13,220
I think we should beware this hard coding, but we'll keep it simple for now. i++.

666
00:45:13,220 --> 00:45:17,150
And then in this for loop, I think we have all of the ingredients to solve this.

667
00:45:17,150 --> 00:45:28,810
So if the return value of str compare of all of the names bracket i comparing against the name that the human typed in, if all of that equals

668
00:45:28,810 --> 00:45:36,770
equals 0, that is, all of the characters in those two strings are equal, then I think we can go ahead and say found, just like last time.

669
00:45:36,770 --> 00:45:37,520
But you know what?

670
00:45:37,520 --> 00:45:40,130
Let's actually print Carter's or my phone number.

671
00:45:40,130 --> 00:45:44,770
So found percent s, and we'll plug in numbers, bracket i.

672
00:45:44,770 --> 00:45:47,800
And then just for consistency, I'll return 0 here.

673
00:45:47,800 --> 00:45:53,600
And down here, how about I'll say something like printf not found, just to be clear.

674
00:45:53,600 --> 00:45:56,240
And then I'll return 1 as well.

675
00:45:56,240 --> 00:45:58,120
So just to recap, here's all of the code.

676
00:45:58,120 --> 00:46:01,610
It's almost the same as before, except now it's useful.

677
00:46:01,610 --> 00:46:03,460
I'm not just saying found or not found.

678
00:46:03,460 --> 00:46:07,180
I found a number in monopoly, or I found a piece in monopoly.

679
00:46:07,180 --> 00:46:09,880
I'm looking up in one array, one of the strings.

680
00:46:09,880 --> 00:46:12,730
And then I'm printing from the other array, the answer.

681
00:46:12,730 --> 00:46:19,480
So let me go ahead here and run the compiler, make phone book, Enter.

682
00:46:19,480 --> 00:46:21,070
OK, that's promising, no errors.

683
00:46:21,070 --> 00:46:22,720
Dot slash phonebook now.

684
00:46:22,720 --> 00:46:26,350
And let's search, for instance, Carter Enter.

685
00:46:26,350 --> 00:46:28,060
All right, so we found Carter's number.

686
00:46:28,060 --> 00:46:29,393
All right, let me do that again.

687
00:46:29,393 --> 00:46:30,960
Phone book, let's search for David.

688
00:46:30,960 --> 00:46:32,960
All right, we seem to have found David's number.

689
00:46:32,960 --> 00:46:34,502
All right, let's do it one last time.

690
00:46:34,502 --> 00:46:35,410
Phone book, Enter.

691
00:46:35,410 --> 00:46:37,360
And now we'll search for John Harvard.

692
00:46:37,360 --> 00:46:40,060
Enter, not found.

693
00:46:40,060 --> 00:46:45,520
All right, so I daresay, albeit with minimal testing, this code is correct.

694
00:46:45,520 --> 00:46:48,190
Would anyone now like to critique the design?

695
00:46:48,190 --> 00:46:51,910
Does something rub you the wrong way, perhaps, about this approach here?

696
00:46:55,120 --> 00:47:01,510
And as always, think about how, if the program maybe gets longer, more complicated, how decisions like this might unfold.

697
00:47:01,510 --> 00:47:02,448
Yeah.

698
00:47:02,448 --> 00:47:04,400
STUDENT: If i is less than 2.

699
00:47:04,400 --> 00:47:10,080
DAVID MALAN: OK, so if i is less than 2, so technically, if I change the number of people in this phone book,

700
00:47:10,080 --> 00:47:11,330
I'm going to have to update i.

701
00:47:11,330 --> 00:47:13,290
And we've already seen that I get myself into trouble.

702
00:47:13,290 --> 00:47:14,165
So that's bad design.

703
00:47:14,165 --> 00:47:15,005
Good.

704
00:47:15,005 --> 00:47:20,710
STUDENT: Say you add someone's name to the phonebook, but you don't have the corresponding number.

705
00:47:20,710 --> 00:47:24,730
So then when you go to pull their number, it [INAUDIBLE] someone's number.

706
00:47:24,730 --> 00:47:25,480
DAVID MALAN: Yeah.

707
00:47:25,480 --> 00:47:28,180
So again, I'm sort of trusting myself not to screw up.

708
00:47:28,180 --> 00:47:36,640
If I add John or anyone else to the first array but I forget to add their number to the second array, eventually things are going to drift and be inconsistent.

709
00:47:36,640 --> 00:47:39,010
And then code will be incorrect at that point.

710
00:47:39,010 --> 00:47:43,420
So sort of a poor design setting me up for future failure, if you will.

711
00:47:43,420 --> 00:47:44,860
Other thoughts?

712
00:47:44,860 --> 00:47:45,460
Yeah.

713
00:47:45,460 --> 00:47:52,848
STUDENT: [INAUDIBLE] so if you were to switch the order of the numbers but not the main [INAUDIBLE]

714
00:47:52,848 --> 00:47:54,140
DAVID MALAN: Yeah, really good.

715
00:47:54,140 --> 00:47:55,550
We're assuming the same order.

716
00:47:55,550 --> 00:47:59,452
From left to right, the names go, and from left to right, the numbers go.

717
00:47:59,452 --> 00:48:01,160
But that's kind of just the honor system.

718
00:48:01,160 --> 00:48:07,047
Like, there's literally nothing in code preventing me from reversing the order for whatever reason, or maybe sorting the names.

719
00:48:07,047 --> 00:48:10,130
Like, they're sorted now, and maybe that's deliberate, but maybe it's not.

720
00:48:10,130 --> 00:48:12,920
So this honor system here, too, is just not good.

721
00:48:12,920 --> 00:48:19,490
I could put a comment in here to remind myself, note to self, always update arrays the same way.

722
00:48:19,490 --> 00:48:26,090
But like, something's going to happen eventually, especially when we have not two, but three, but 30, 300 names and numbers.

723
00:48:26,090 --> 00:48:29,670
It would be nice to keep all of the related data together.

724
00:48:29,670 --> 00:48:37,970
And so in fact, the one new feature of C we'll introduce today is one that actually allows us to implement our very own data structures.

725
00:48:37,970 --> 00:48:45,930
You can think of arrays as a very lightweight data structure, in that it allows you to cluster related data back to back to back to back.

726
00:48:45,930 --> 00:48:48,170
And this is how strings are implemented.

727
00:48:48,170 --> 00:48:51,560
They are a data structure effectively implemented with an array.

728
00:48:51,560 --> 00:48:59,870
But with C and with other languages, it turns out you can invent your own data types, whether they're one dimensional, two dimensional even, or beyond.

729
00:48:59,870 --> 00:49:07,200
And with C, can you specifically create your own types that have their own names?

730
00:49:07,200 --> 00:49:16,380
So for instance, wouldn't it have been nice if C came with, not just char and int and floats and long and others.

731
00:49:16,380 --> 00:49:19,970
Wouldn't it be nice if C came with a data type called person?

732
00:49:19,970 --> 00:49:22,790
And ideally, a person would have a name and a number.

733
00:49:22,790 --> 00:49:24,860
Now, that's a little naive and unrealistic.

734
00:49:24,860 --> 00:49:28,460
Like, why would they define a person to have just those two fields.

735
00:49:28,460 --> 00:49:30,950
Certainly, people could have disagreed what a person is.

736
00:49:30,950 --> 00:49:32,300
So they leave it to us.

737
00:49:32,300 --> 00:49:36,810
The authors of C gave us all of these primitives, ints and floats and strings and so forth.

738
00:49:36,810 --> 00:49:48,150
But it's up to us now to use those in a more interesting way so that we can create an array of person variables, if you will, inside of an array called people, just to pluralize it here.

739
00:49:48,150 --> 00:49:49,740
So how are we going to do this?

740
00:49:49,740 --> 00:49:58,010
Well, for now, let's just stipulate that a person in the world will have a name and a number that we could argue all day long what else a person should have.

741
00:49:58,010 --> 00:49:58,677
And that's fine.

742
00:49:58,677 --> 00:50:01,790
You can invent your own person eventually.

743
00:50:01,790 --> 00:50:06,500
At the moment, I'm using just two variables to define a person's name and number.

744
00:50:06,500 --> 00:50:14,660
But wouldn't it be nice to encapsulate, that is, combine these two data types, into a new and improved data type called person.

745
00:50:14,660 --> 00:50:17,360
And the syntax for that is going to be this.

746
00:50:17,360 --> 00:50:18,800
So it's a bit of a mouthful.

747
00:50:18,800 --> 00:50:21,960
But you can, perhaps, infer what some of this is doing here.

748
00:50:21,960 --> 00:50:24,500
So it turns out C has a keyword called typedef.

749
00:50:24,500 --> 00:50:28,310
As the name kind of suggests, this allows you to define your own type.

750
00:50:28,310 --> 00:50:31,550
Struct is an indication that it's a structure.

751
00:50:31,550 --> 00:50:36,710
It's like a structure that has multiple values inside of it that you are trying to define.

752
00:50:36,710 --> 00:50:42,270
And then at the very bottom here outside of the curly braces, is the name of the type that you want to create.

753
00:50:42,270 --> 00:50:46,790
So you don't have discretion over using typedef or struct in this particular case.

754
00:50:46,790 --> 00:50:48,665
But you can name the thing whatever you want.

755
00:50:48,665 --> 00:50:52,590
And you can put anything in the structure that you want as well.

756
00:50:52,590 --> 00:51:05,760
And as soon as the semicolon is executed at the bottom of the code, every line thereafter can now have access to a person data type, whether as a single variable, or as an entire array.

757
00:51:05,760 --> 00:51:10,260
So if I want to build on this then, let me go ahead and do this.

758
00:51:10,260 --> 00:51:12,230
Let me go back to my C code here.

759
00:51:12,230 --> 00:51:17,610
And I'm going to go ahead and change just a couple of things.

760
00:51:17,610 --> 00:51:19,110
Let's go ahead and do this.

761
00:51:19,110 --> 00:51:23,240
I'm going to go ahead and, first, get rid of those two hardcoded arrays.

762
00:51:23,240 --> 00:51:30,180
And let me go ahead and, at the top of my file, invent this type, so typedef struct.

763
00:51:30,180 --> 00:51:34,470
Inside of it will be a string name and then a string number.

764
00:51:34,470 --> 00:51:36,780
And then the name of the structure will be person.

765
00:51:36,780 --> 00:51:44,530
And best practice would have me define it at the very top of my file so that any of my functions, in fact, could use it, even though I just have main in this case.

766
00:51:44,530 --> 00:51:47,100
Now, if I wanted, I could do this.

767
00:51:47,100 --> 00:51:50,370
Person P1 and person P2.

768
00:51:50,370 --> 00:51:53,040
But we know from last week, that already is bad design.

769
00:51:53,040 --> 00:52:00,044
If you want to have multiple instances of the same type of variable, we should probably use what instead?

770
00:52:00,044 --> 00:52:01,046
STUDENT: [INAUDIBLE]

771
00:52:01,046 --> 00:52:01,796
DAVID MALAN: And--

772
00:52:01,796 --> 00:52:02,470
STUDENT: An array.

773
00:52:02,470 --> 00:52:03,637
DAVID MALAN: Yeah, an array.

774
00:52:03,637 --> 00:52:05,230
So let me not even go down that road.

775
00:52:05,230 --> 00:52:06,700
Let me instead just do this.

776
00:52:06,700 --> 00:52:09,727
Person will be the type of the array.

777
00:52:09,727 --> 00:52:10,810
But I'm going to call it--

778
00:52:10,810 --> 00:52:11,980
I could call it persons.

779
00:52:11,980 --> 00:52:13,720
But in English, we typically say people.

780
00:52:13,720 --> 00:52:15,190
So I'll call the array people.

781
00:52:15,190 --> 00:52:20,920
And I want two people to exist in this array, though I could certainly change that number to be anything I want.

782
00:52:20,920 --> 00:52:27,190
How, now, do you put a name inside of a person and then put the number inside of that same person?

783
00:52:27,190 --> 00:52:28,990
Well, slightly new syntax today.

784
00:52:28,990 --> 00:52:30,520
I'm going to go ahead and say this.

785
00:52:30,520 --> 00:52:34,420
People bracket 0 just gives me the first person in the array.

786
00:52:34,420 --> 00:52:35,570
That's not new.

787
00:52:35,570 --> 00:52:40,840
But if you want to go inside of that person in memory, you use a dot.

788
00:52:40,840 --> 00:52:44,870
And then you just specify the name of the attribute therein.

789
00:52:44,870 --> 00:52:47,410
So if I want to set the first person's name to Carter,

790
00:52:47,410 --> 00:52:49,480
I just use that so-called dot notation.

791
00:52:49,480 --> 00:52:52,780
And then if I want to set Carter's number using dot notation,

792
00:52:52,780 --> 00:52:56,680
I would do this, +1-617-495-1000.

793
00:52:56,680 --> 00:52:58,880
And then if I want to do the same for myself,

794
00:52:58,880 --> 00:53:03,730
I would now do people bracket 1 dot name equals quote unquote David.

795
00:53:03,730 --> 00:53:08,440
And then people bracket 1 still dot number equals quote unquote

796
00:53:08,440 --> 00:53:13,030
+1-949-468-2750.

797
00:53:13,030 --> 00:53:18,610
And now, at the bottom of my file, I think my logic can pretty much stay the same.

798
00:53:18,610 --> 00:53:24,370
I can still, on this line here, prompt the user for the name of the person they want to look up.

799
00:53:24,370 --> 00:53:26,620
For now, even though I admit it's not the best design,

800
00:53:26,620 --> 00:53:28,495
I'm just doing this for demonstration's sake,

801
00:53:28,495 --> 00:53:31,360
I'm going to leave the two there, because I know I have two people.

802
00:53:31,360 --> 00:53:34,100
But down here, this is going to have to change.

803
00:53:34,100 --> 00:53:37,000
I don't want to compare names bracket i anymore.

804
00:53:37,000 --> 00:53:42,190
What do I want to type here as the first argument to str compare?

805
00:53:42,190 --> 00:53:43,900
What do I want to do here?

806
00:53:43,900 --> 00:53:44,960
Yeah.

807
00:53:44,960 --> 00:53:46,800
STUDENT: People i dot name.

808
00:53:46,800 --> 00:53:49,140
DAVID MALAN: So people i dot name, yeah.

809
00:53:49,140 --> 00:53:54,480
So I want to go into the people array at the ith location, because that's what my loop is doing.

810
00:53:54,480 --> 00:53:55,890
It's updating i again and again.

811
00:53:55,890 --> 00:53:58,087
And then look at name, and that's good.

812
00:53:58,087 --> 00:53:59,670
I think now I need to change this too.

813
00:53:59,670 --> 00:54:01,890
What do I want to print if the person is found?

814
00:54:01,890 --> 00:54:02,445
Someone else?

815
00:54:05,070 --> 00:54:08,850
What do I want to print here, if I found the person's name?

816
00:54:08,850 --> 00:54:09,360
Yeah.

817
00:54:09,360 --> 00:54:10,890
STUDENT: [INAUDIBLE]

818
00:54:10,890 --> 00:54:12,390
DAVID MALAN: Say it a little louder.

819
00:54:12,390 --> 00:54:13,795
STUDENT: People i dot number.

820
00:54:13,795 --> 00:54:14,670
DAVID MALAN: Perfect.

821
00:54:14,670 --> 00:54:20,310
So people bracket i dot number, if indeed I want to print the corresponding number to this person.

822
00:54:20,310 --> 00:54:22,930
And then I think the rest of my code can stay the same.

823
00:54:22,930 --> 00:54:27,150
So let me go ahead and rerun make phone book to recompile this version.

824
00:54:27,150 --> 00:54:28,170
So far so good.

825
00:54:28,170 --> 00:54:29,400
Dot slash phone book.

826
00:54:29,400 --> 00:54:31,598
Let's go ahead and type in Carter's name, found.

827
00:54:31,598 --> 00:54:33,390
All right, let's go ahead and run it again.

828
00:54:33,390 --> 00:54:35,273
David's name, found.

829
00:54:35,273 --> 00:54:36,940
Let's go ahead and run it one more time.

830
00:54:36,940 --> 00:54:40,260
Type in John Harvard, for instance, not found, in this case.

831
00:54:40,260 --> 00:54:43,710
So fundamentally, the code isn't all that different.

832
00:54:43,710 --> 00:54:46,090
Linear search is still behaving the same way.

833
00:54:46,090 --> 00:54:48,690
And I admit, this is kind of ugly looking.

834
00:54:48,690 --> 00:54:52,350
We've kind of made a two line solution five lines of code now.

835
00:54:52,350 --> 00:55:03,892
But if we fast forward a week or two when we start saving information to files, we'll introduce you to files like csv files, comma separated values, or spreadsheet files, which

836
00:55:03,892 --> 00:55:06,600
you've surely opened on your Mac or PC at some point in the past.

837
00:55:06,600 --> 00:55:11,790
Suffice it to say we'll soon learn techniques for storing information, like names and numbers, in files.

838
00:55:11,790 --> 00:55:19,080
And at that point, we're not going to do any of this hackish sort of hard coding of the number 2 and manually typing my name and Carter's name and number into our program.

839
00:55:19,080 --> 00:55:21,750
We'll read the information dynamically from a file.

840
00:55:21,750 --> 00:55:25,180
And in a few weeks, we'll read it dynamically from a database instead.

841
00:55:25,180 --> 00:55:32,190
But this is, for now, just syntactically how we can create an array of size 2 containing one person each.

842
00:55:32,190 --> 00:55:41,610
We can update the name and number of the first person, update the name and the number of the second person, and then later search across those names and print out the corresponding numbers.

843
00:55:41,610 --> 00:55:44,220
And in this sense, this is a better design.

844
00:55:44,220 --> 00:55:44,730
Why?

845
00:55:44,730 --> 00:55:53,400
Because my person data type encapsulates, now, everything that it means to be a person, at least in this narrow world.

846
00:55:53,400 --> 00:55:57,580
And if I want to add something to the notion of a person, for instance,

847
00:55:57,580 --> 00:56:03,743
I could go up to my type def, and tomorrow, add an address to every person and start reading that in as well.

848
00:56:03,743 --> 00:56:05,160
And now it's not the honor system.

849
00:56:05,160 --> 00:56:12,210
It's not a names array, a numbers array, an addresses array, and everything else you might imagine related to a person.

850
00:56:12,210 --> 00:56:17,223
It's all encapsulated, which is a term of art inside of the same type.

851
00:56:17,223 --> 00:56:21,660
Reminiscent, if some of you have programmed before, of something called object-oriented programming.

852
00:56:21,660 --> 00:56:23,190
But we're not there yet.

853
00:56:23,190 --> 00:56:24,690
C is not that.

854
00:56:24,690 --> 00:56:35,037
Questions on this use of struct or this new syntax, the dot operator being really the juicy part here.

855
00:56:35,037 --> 00:56:35,620
Any questions?

856
00:56:35,620 --> 00:56:36,522
Yeah.

857
00:56:36,522 --> 00:56:39,414
STUDENT: [INAUDIBLE]

858
00:56:42,800 --> 00:56:44,420
DAVID MALAN: On what line number?

859
00:56:44,420 --> 00:56:46,063
STUDENT: 16.

860
00:56:46,063 --> 00:56:46,730
DAVID MALAN: 16?

861
00:56:46,730 --> 00:56:51,230
So yes, so syntactically, we introduced the square brackets last week.

862
00:56:51,230 --> 00:56:55,310
So doing people bracket 0 just means go to the first person in the array.

863
00:56:55,310 --> 00:56:58,400
That was like when Stephanie literally opened this door.

864
00:56:58,400 --> 00:56:59,990
That's doors bracket 0.

865
00:56:59,990 --> 00:57:02,330
But this is, of course, people bracket 0 instead.

866
00:57:02,330 --> 00:57:04,580
Today, the dot is a new piece of syntax.

867
00:57:04,580 --> 00:57:13,297
It means go inside of that person in memory and look at the name they're in and set it equal to Carter and do the same for number.

868
00:57:13,297 --> 00:57:13,880
So that's all.

869
00:57:13,880 --> 00:57:18,410
It's like, open the locker door, go inside of it, and check or set the name and the number.

870
00:57:18,410 --> 00:57:19,040
Yeah.

871
00:57:19,040 --> 00:57:29,280
STUDENT: [INAUDIBLE] can you set default values for each of the [INAUDIBLE]??

872
00:57:29,280 --> 00:57:30,840
DAVID MALAN: Attributes is fine.

873
00:57:30,840 --> 00:57:31,530
Good question.

874
00:57:31,530 --> 00:57:34,050
In the struct, can you set default values?

875
00:57:34,050 --> 00:57:35,100
Short answer, no.

876
00:57:35,100 --> 00:57:42,580
And this is where C becomes less feature-able than more modern languages like Python and Java and others, where you can, in fact, do that.

877
00:57:42,580 --> 00:57:47,140
So when we transition to Python in a few weeks' time, we'll see how we can start solving problems like that.

878
00:57:47,140 --> 00:57:51,450
But for now, it's up to you to initialize name and number to something.

879
00:57:51,450 --> 00:57:52,832
Yeah.

880
00:57:52,832 --> 00:57:55,540
STUDENT: [INAUDIBLE]

881
00:58:04,123 --> 00:58:05,540
DAVID MALAN: Really good question.

882
00:58:05,540 --> 00:58:08,470
How can we adjust or critique the design of what I'm doing?

883
00:58:08,470 --> 00:58:13,780
This is one of the few situations where I would say, hypocritically, do as I say, not as I do.

884
00:58:13,780 --> 00:58:17,710
I am using pretty ugly lines like this, just to introduce the syntax.

885
00:58:17,710 --> 00:58:26,230
But my claim, pedagogically today, is that eventually, when we start storing names and numbers or other things in files or in databases, you won't have this redundancy.

886
00:58:26,230 --> 00:58:34,630
You'll have one line of code or two lines of code that read the information from the file or database and then fill the entire array with that data.

887
00:58:34,630 --> 00:58:39,400
For now, I'm just doing it manually so as to keep our focus only on the new syntax, but that's it.

888
00:58:39,400 --> 00:58:42,640
So forgive the bad design by design today.

889
00:58:42,640 --> 00:58:45,740
Other questions on this?

890
00:58:45,740 --> 00:58:47,595
All right, that's been a lot already.

891
00:58:47,595 --> 00:58:50,470
Why don't we go ahead and take our 10 minute break with snacks first.

892
00:58:50,470 --> 00:58:53,020
We have some delightful brownies in the lobby.

893
00:58:53,020 --> 00:58:55,900
All right, we are back.

894
00:58:55,900 --> 00:59:02,350
And up until now, it clearly seems to be a good thing if your data is sorted, because you can use binary search.

895
00:59:02,350 --> 00:59:05,540
You know a little something more about the data.

896
00:59:05,540 --> 00:59:10,420
But it turns out that sorting in and of itself is kind of a problem to solve too.

897
00:59:10,420 --> 00:59:20,237
And you might think, well, if sorting is going to be pretty fast, we absolutely should do it before we start searching, because that will just speed up all of our searches.

898
00:59:20,237 --> 00:59:28,090
But if sorting is slow, that kind of invites the question, well, should we bother sorting our data if we're only going to search the data maybe once, maybe twice?

899
00:59:28,090 --> 00:59:30,550
And so here is going to be, potentially, a trade off.

900
00:59:30,550 --> 00:59:33,250
So let's consider what it means really to sort data.

901
00:59:33,250 --> 00:59:35,950
In our case, it's just going to be simple and use numbers.

902
00:59:35,950 --> 00:59:40,880
But it might, in the case of the Googles of the world, be actual web pages or persons or the like.

903
00:59:40,880 --> 00:59:46,090
So here is our typical picture for sorting, for solving any problem.

904
00:59:46,090 --> 00:59:48,190
Input at left and output at right.

905
00:59:48,190 --> 00:59:54,340
The input to our sort problem is going to be some unsorted set of values.

906
00:59:54,340 --> 00:59:57,940
And the output, ideally, will be the same set of values sorted.

907
00:59:57,940 --> 01:00:04,786
And if we do this concretely, let's suppose that we want to go about sorting this list of numbers, 7, 2, 5, 4, 1, 6, 0,

908
01:00:04,786 --> 01:00:05,860
3.

909
01:00:05,860 --> 01:00:07,810
So it's all of the numbers from 0 to 7.

910
01:00:07,810 --> 01:00:09,757
But they're somehow jumbled up randomly.

911
01:00:09,757 --> 01:00:11,590
That's going to be the input to the problem.

912
01:00:11,590 --> 01:00:17,990
And the goal is now to sort those so that you, indeed, get out 0, 1, 2, 3, 4, 5, 6, 7 instead.

913
01:00:17,990 --> 01:00:23,900
So it turns out there's lots of different ways we can actually sort numbers like these here.

914
01:00:23,900 --> 01:00:32,410
And in fact, just to complement our search example earlier, could we perhaps quickly get some eight volunteers to come up if you're comfortable appearing on the internet?

915
01:00:32,410 --> 01:00:39,100
If you want to do 1, 2, 3, 4, 5, 6, 7, 8, how about?

916
01:00:39,100 --> 01:00:40,255
All right, come on down.

917
01:00:45,040 --> 01:00:47,970
All right.

918
01:00:47,970 --> 01:00:50,560
Come on over here, and I'll give you each a number.

919
01:00:50,560 --> 01:00:58,390
And if you want to start to organize yourselves in the same order you see the numbers on the board.

920
01:00:58,390 --> 01:01:04,460
So look up on the overhead and organize yourselves from left to right in that same order.

921
01:01:04,460 --> 01:01:06,210
And let's have the first of you-- perfect.

922
01:01:06,210 --> 01:01:10,420
If you want to come right over here, how about right in line with this?

923
01:01:10,420 --> 01:01:13,990
All right, and a few more numbers.

924
01:01:13,990 --> 01:01:14,980
All right.

925
01:01:14,980 --> 01:01:19,810
Number 2, 6, and perfect.

926
01:01:19,810 --> 01:01:21,625
Just the right number, all right.

927
01:01:21,625 --> 01:01:22,858
Uh oh.

928
01:01:22,858 --> 01:01:24,400
All right, there we go, number three.

929
01:01:24,400 --> 01:01:24,968
All right.

930
01:01:24,968 --> 01:01:26,260
So let's just do a quick check.

931
01:01:26,260 --> 01:01:30,867
We have 7, 2, 5, 4, 1, 6, 0, 3, very good so far.

932
01:01:30,867 --> 01:01:34,510
Do you want to just scootch a little this way just to make a little more room?

933
01:01:34,510 --> 01:01:38,090
All right, and let's consider now who we have here on stage.

934
01:01:38,090 --> 01:01:40,780
You want to each say a quick hello to the audience?

935
01:01:40,780 --> 01:01:42,070
RYAN: Hi, my name is Ryan.

936
01:01:42,070 --> 01:01:45,597
I'm a first year from Pennypacker.

937
01:01:45,597 --> 01:01:46,930
ITSELLE: Hi, my name is Itselle.

938
01:01:46,930 --> 01:01:49,177
I'm a first year at Strauss.

939
01:01:49,177 --> 01:01:50,260
LUCY: Hi, my name is Lucy.

940
01:01:50,260 --> 01:01:52,400
And I'm a first year from Greenough.

941
01:01:52,400 --> 01:01:53,650
SHILOH: Hi, my name is Shiloh.

942
01:01:53,650 --> 01:01:55,927
I'm a first year in Wigglesworth.

943
01:01:55,927 --> 01:01:57,010
JACK: Hi, my name is Jack.

944
01:01:57,010 --> 01:01:59,877
And I'm a first year in Strauss.

945
01:01:59,877 --> 01:02:01,210
KATHRYN: Hi, my name is Kathryn.

946
01:02:01,210 --> 01:02:02,787
I'm a first year at Strauss.

947
01:02:02,787 --> 01:02:04,120
MICHAEL: Hi, my name is Michael.

948
01:02:04,120 --> 01:02:06,063
I'm a first year at Pennypacker.

949
01:02:06,063 --> 01:02:07,480
MUHAMMAD: Hi, my name is Muhammad.

950
01:02:07,480 --> 01:02:09,047
I'm a first year in Matthews.

951
01:02:09,047 --> 01:02:10,630
DAVID MALAN: Hi, nice, welcome aboard.

952
01:02:10,630 --> 01:02:11,240
All right.

953
01:02:11,240 --> 01:02:21,160
So let's consider, now, how we might go about sorting our kind volunteers here, the goal being to get them into order from smallest to largest so that,

954
01:02:21,160 --> 01:02:24,160
presumably then, we can use something smarter than just linear search.

955
01:02:24,160 --> 01:02:27,878
We can actually use binary search, assuming that they are already then sorted.

956
01:02:27,878 --> 01:02:32,600
So let me propose that we first consider an algorithm that actually has a name called selection sort.

957
01:02:32,600 --> 01:02:43,610
And selection sort is going to be one that literally has me, or really you, as the programmer, selecting the smallest element again and again, and then putting them into the appropriate place.

958
01:02:43,610 --> 01:02:47,115
So let me go ahead and start this here, starting with the number 7.

959
01:02:47,115 --> 01:02:49,240
At the moment, 7 is the smallest number I've found.

960
01:02:49,240 --> 01:02:52,610
So I'm going to make mental note of that with a mental variable, if you will.

961
01:02:52,610 --> 01:02:53,710
I'm going to move on now.

962
01:02:53,710 --> 01:03:01,555
Number 2 is obviously smaller, so I'm just going to update my mental reminder that 2 is now the smallest, effectively forgetting, for now, number 7.

963
01:03:01,555 --> 01:03:02,440
5, not smaller.

964
01:03:02,440 --> 01:03:03,370
4, not smaller.

965
01:03:03,370 --> 01:03:04,170
1, smaller.

966
01:03:04,170 --> 01:03:05,920
And I'm going to make mental note of that.

967
01:03:05,920 --> 01:03:07,030
6, not smaller.

968
01:03:07,030 --> 01:03:08,200
0, even smaller.

969
01:03:08,200 --> 01:03:11,140
I'll make mental note of that, having forgotten now everything else.

970
01:03:11,140 --> 01:03:13,180
And now number 3 is not smaller.

971
01:03:13,180 --> 01:03:14,290
So what's your name again?

972
01:03:14,290 --> 01:03:14,630
MICHAEL: Michael.

973
01:03:14,630 --> 01:03:16,240
DAVID MALAN: So Michael is number 0.

974
01:03:16,240 --> 01:03:18,310
He belongs, of course, way down there.

975
01:03:18,310 --> 01:03:20,740
But unfortunately-- you are--

976
01:03:20,740 --> 01:03:21,550
RYAN: Ryan.

977
01:03:21,550 --> 01:03:23,360
DAVID MALAN: Ryan is in the way.

978
01:03:23,360 --> 01:03:24,580
So what should we do?

979
01:03:24,580 --> 01:03:27,570
How should we start to sort this list?

980
01:03:27,570 --> 01:03:30,510
Where should number 0 go?

981
01:03:30,510 --> 01:03:31,012
Yeah.

982
01:03:31,012 --> 01:03:32,220
Do you want to say it louder?

983
01:03:32,220 --> 01:03:34,545
STUDENT: I will swap, I think.

984
01:03:34,545 --> 01:03:36,670
DAVID MALAN: Yeah, so let's just go ahead and swap.

985
01:03:36,670 --> 01:03:39,190
So if you want to go ahead and 0, go on where 7 is.

986
01:03:39,190 --> 01:03:41,170
We need to make room for number 7.

987
01:03:41,170 --> 01:03:45,530
It would kind of be cheating if maybe everyone kind of politely stepped over to the side.

988
01:03:45,530 --> 01:03:46,030
Why?

989
01:03:46,030 --> 01:03:54,190
Because if we imagine all of our volunteers here to be an array, like, that's a crazy amount of work to have every element in the array shift to the left just to make room.

990
01:03:54,190 --> 01:03:57,340
So we're going to keep it simple and just evict whoever's there now.

991
01:03:57,340 --> 01:04:00,880
Now, maybe we get lucky, and number 7 is actually closer to its destination.

992
01:04:00,880 --> 01:04:03,250
Maybe we get unlucky, and it goes farther away.

993
01:04:03,250 --> 01:04:05,260
But we've at least solved one problem.

994
01:04:05,260 --> 01:04:10,280
If we had n problems at first, now we have n minus 1, because number 0 is indeed in the right place.

995
01:04:10,280 --> 01:04:15,130
So if I continue to act this out, let me go ahead and say 2, currently the smallest.

996
01:04:15,130 --> 01:04:18,040
5, no, 4, no, 1 currently the smallest.

997
01:04:18,040 --> 01:04:19,000
I'll make mental note.

998
01:04:19,000 --> 01:04:22,690
6, 7, 3, and now let me pause.

999
01:04:22,690 --> 01:04:26,000
1 is obviously the now smallest element.

1000
01:04:26,000 --> 01:04:27,760
So did I need to keep going?

1001
01:04:27,760 --> 01:04:30,550
Well, turns out, at least as I've defined selection sort,

1002
01:04:30,550 --> 01:04:36,550
I do need to keep going, because I only claim that I'm using one variable in my mind to remember the then smallest element.

1003
01:04:36,550 --> 01:04:39,970
I'm not smart enough like us humans to remember, wait a minute,

1004
01:04:39,970 --> 01:04:41,590
1 is definitely the smallest now.

1005
01:04:41,590 --> 01:04:43,190
I don't have that whole recollection.

1006
01:04:43,190 --> 01:04:45,590
So I just am keeping track of the now smallest.

1007
01:04:45,590 --> 01:04:46,910
So number 1, your name was?

1008
01:04:46,910 --> 01:04:47,410
JACK: Jack.

1009
01:04:47,410 --> 01:04:49,300
DAVID MALAN: Jack, where should Jack go?

1010
01:04:49,300 --> 01:04:50,380
Probably there.

1011
01:04:50,380 --> 01:04:51,670
And what's your name?

1012
01:04:51,670 --> 01:04:51,880
ITSELLE: Itselle.

1013
01:04:51,880 --> 01:04:57,430
DAVID MALAN: OK, so Jack and Itselle, if you want to swap places, we've now solved two of the n total problems.

1014
01:04:57,430 --> 01:04:58,990
And now we'll do it a little faster.

1015
01:04:58,990 --> 01:05:03,880
If each of you want to start to swap as I find the right person, so 5 smallest,

1016
01:05:03,880 --> 01:05:06,340
4 smaller, 2 is smaller.

1017
01:05:06,340 --> 01:05:07,750
Got to keep checking.

1018
01:05:07,750 --> 01:05:09,572
OK, 2 was smaller.

1019
01:05:09,572 --> 01:05:11,780
All right, now I'm going to go back to the beginning.

1020
01:05:11,780 --> 01:05:13,090
All right, 4 is small.

1021
01:05:13,090 --> 01:05:14,050
5 is not.

1022
01:05:14,050 --> 01:05:14,740
6 is not.

1023
01:05:14,740 --> 01:05:16,120
7-- oh, 3 is small.

1024
01:05:16,120 --> 01:05:17,770
Where do you want to go?

1025
01:05:17,770 --> 01:05:18,670
OK, good.

1026
01:05:18,670 --> 01:05:19,810
I'm going to go back here.

1027
01:05:19,810 --> 01:05:21,060
And I can be a little smart.

1028
01:05:21,060 --> 01:05:24,950
I don't have to go all the way to the end, because I know these folks are already sorted.

1029
01:05:24,950 --> 01:05:26,630
So I can at least optimize slightly.

1030
01:05:26,630 --> 01:05:27,970
So now 5 is small.

1031
01:05:27,970 --> 01:05:28,720
6 is small.

1032
01:05:28,720 --> 01:05:30,160
7 is 4, 4 is smaller.

1033
01:05:30,160 --> 01:05:33,080
If you want to go in place there.

1034
01:05:33,080 --> 01:05:34,810
And now, here things get interesting.

1035
01:05:34,810 --> 01:05:39,340
I can optimize by not looking at these folks anymore, because they're obviously problem solved.

1036
01:05:39,340 --> 01:05:42,970
But now 5 is small, 6 is not, 7 is not.

1037
01:05:42,970 --> 01:05:45,010
OK, 5, you can stay where you are.

1038
01:05:45,010 --> 01:05:49,420
Now, a human in the room is obviously going to question why I'm wasting any more time.

1039
01:05:49,420 --> 01:05:52,090
But with selection sort, as I've defined it thus far,

1040
01:05:52,090 --> 01:05:55,840
I still have to, now, check 6 is smallest, not 7.

1041
01:05:55,840 --> 01:05:58,520
And now my final step, OK, they're all in place.

1042
01:05:58,520 --> 01:06:05,060
So here, too, is this dichotomy between what we all have is this bird's eye view of the whole problem, where it's obvious where everyone needs to go.

1043
01:06:05,060 --> 01:06:09,137
But a computer implementing this with an array really has to be more methodical.

1044
01:06:09,137 --> 01:06:10,720
And we're actually saving a step here.

1045
01:06:10,720 --> 01:06:13,780
If we were really doing this, none of these numbers would be visible.

1046
01:06:13,780 --> 01:06:16,840
All eight of our volunteers would be inside of a locked door.

1047
01:06:16,840 --> 01:06:19,220
And only then could we see them one at a time.

1048
01:06:19,220 --> 01:06:21,670
But we're focusing now just on the sorting aspect.

1049
01:06:21,670 --> 01:06:29,620
So let me just, before we do one other demonstration here, propose that what I really just did here in pseudocode was something like this.

1050
01:06:29,620 --> 01:06:38,110
For i from 0 to n minus 1, keeping in mind that 0 is always the left of the array. n minus 1 is always the right end of the array.

1051
01:06:38,110 --> 01:06:45,730
For i from 0 to n minus 1, I found the smallest number between numbers bracket i and numbers bracket n minus 1.

1052
01:06:45,730 --> 01:06:48,610
And that's the very geeky way of expressing this optimization.

1053
01:06:48,610 --> 01:06:51,490
I'm always starting from numbers bracket i wherever I am.

1054
01:06:51,490 --> 01:06:53,200
And then everything else to the right.

1055
01:06:53,200 --> 01:06:56,890
And that's what was allowing me to ignore the already sorted volunteers.

1056
01:06:56,890 --> 01:07:05,470
If, though, my last line says swap smallest number with numbers i, think that implements what our humans were doing by physically walking to another spot.

1057
01:07:05,470 --> 01:07:09,220
All right, so that, then, would be what we'll call selection sort.

1058
01:07:09,220 --> 01:07:13,360
Let's go ahead and take a second approach here using an algorithm that I'm going to call bubble sort.

1059
01:07:13,360 --> 01:07:16,090
But to do this, we need you all to reset to your original locations.

1060
01:07:16,090 --> 01:07:19,750
We have a little cheat sheet on the board if you'd like to go back to this position here.

1061
01:07:19,750 --> 01:07:26,780
And let me take a fundamentally different approach, because I'm not really liking selection sort as is, because it's kind of a lot of walking back and forth.

1062
01:07:26,780 --> 01:07:30,620
And the lot of walking suggests a lot of, lot of steps again and again.

1063
01:07:30,620 --> 01:07:32,090
So what might I do instead?

1064
01:07:32,090 --> 01:07:36,730
Well, bubble sort is going to have me focus a little more intuitively on just smaller problems.

1065
01:07:36,730 --> 01:07:38,605
And let's see if this gets me somewhere else.

1066
01:07:38,605 --> 01:07:43,670
So if I just look at this list without looking at everyone else, 7 and 2, this is obviously a problem.

1067
01:07:43,670 --> 01:07:44,170
Why?

1068
01:07:44,170 --> 01:07:45,500
Because you're out of order.

1069
01:07:45,500 --> 01:07:47,810
So let's just solve one tiny problem first.

1070
01:07:47,810 --> 01:07:49,570
So 7 and 2, why don't you swap?

1071
01:07:49,570 --> 01:07:54,160
I know 2 is in a better place now, because she's definitely less than 7.

1072
01:07:54,160 --> 01:07:55,540
So I think I can now move on.

1073
01:07:55,540 --> 01:07:57,350
7 and 5, problem.

1074
01:07:57,350 --> 01:07:58,390
So let's solve that.

1075
01:07:58,390 --> 01:07:59,830
7 and 4, problem.

1076
01:07:59,830 --> 01:08:02,380
Let's solve that, 7 and 1, let's solve that.

1077
01:08:02,380 --> 01:08:03,970
7 and 6, let's solve that.

1078
01:08:03,970 --> 01:08:05,080
7 and 0, solve that.

1079
01:08:05,080 --> 01:08:06,550
7 and 3, solve that.

1080
01:08:06,550 --> 01:08:07,330
OK, done.

1081
01:08:07,330 --> 01:08:09,130
Sorted, right?

1082
01:08:09,130 --> 01:08:11,780
Or obviously not, if you just glance at these numbers here.

1083
01:08:11,780 --> 01:08:14,530
But we have, fundamentally, taken a bite out of the problem.

1084
01:08:14,530 --> 01:08:17,020
7 is indeed in the right place.

1085
01:08:17,020 --> 01:08:21,170
So we maximally have n minus 1 other problems to solve.

1086
01:08:21,170 --> 01:08:23,660
So how do I do this?

1087
01:08:23,660 --> 01:08:25,700
I think I can just repeat the same logic.

1088
01:08:25,700 --> 01:08:26,770
Let me go over here.

1089
01:08:26,770 --> 01:08:28,210
2 and 5, good.

1090
01:08:28,210 --> 01:08:29,800
5 and 4, no.

1091
01:08:29,800 --> 01:08:31,330
5 and 1, no.

1092
01:08:31,330 --> 01:08:32,590
5 and 6, yes.

1093
01:08:32,590 --> 01:08:34,660
6 and 0, no.

1094
01:08:34,660 --> 01:08:36,760
6 and 3, no.

1095
01:08:36,760 --> 01:08:39,191
So now we've solved two of the problems.

1096
01:08:39,191 --> 01:08:42,707
And what's nice about bubble sort, at least as this glance, it's nice and simple.

1097
01:08:42,707 --> 01:08:43,540
It's nice and local.

1098
01:08:43,540 --> 01:08:46,510
And you just keep incrementally solving more and more problems.

1099
01:08:46,510 --> 01:08:48,010
So let's go ahead and do this again.

1100
01:08:48,010 --> 01:08:50,080
And I'll do it-- we can do it faster.

1101
01:08:50,080 --> 01:08:51,760
2 and 4, we know are good.

1102
01:08:51,760 --> 01:08:59,200
4 and 1, 4 and 5, 5 and 0, 5 and 3, 5 and 6, 6 and 7, good.

1103
01:08:59,200 --> 01:09:01,390
So we go back, 2 and 1.

1104
01:09:01,390 --> 01:09:03,340
Ah, now another problem solve.

1105
01:09:03,340 --> 01:09:09,939
2, and 4, 4 and 0, 4 and 3, 4 and 5, 5 and 6, 6 and 7.

1106
01:09:09,939 --> 01:09:14,895
And so notice 2, as per its name, the largest elements have bubbled their way up to the top.

1107
01:09:14,895 --> 01:09:18,340
And that's what seems to be happening just as we're fixing some remaining problems.

1108
01:09:18,340 --> 01:09:19,120
So almost done.

1109
01:09:19,120 --> 01:09:27,550
1 and 2, 2 and 0, 2 and 3, 3 and 4, 4 and 5, 5 and 6, 6 and 7, almost done.

1110
01:09:27,550 --> 01:09:29,830
Obviously, to us humans, it looks done.

1111
01:09:29,830 --> 01:09:32,529
How do I know as the computer for sure?

1112
01:09:32,529 --> 01:09:36,370
What would be the most surefire way for me to now go, it's not done, sorry.

1113
01:09:36,370 --> 01:09:38,080
That's a bug.

1114
01:09:38,080 --> 01:09:43,390
OK, 1 and 0, 1 and 2, 2 and 3, 3 and 4, 4 and 5, 5 and 6, 6 and 7.

1115
01:09:43,390 --> 01:09:47,899
OK, so now it's obviously sorted to the rest of us on stage.

1116
01:09:47,899 --> 01:09:50,290
How could I confirm as much as code?

1117
01:09:50,290 --> 01:09:52,670
You're doing it with your mind, just glancing at this.

1118
01:09:52,670 --> 01:09:56,080
How would the computer, the code, know for sure that this list is now sorted?

1119
01:09:56,080 --> 01:09:57,000
Yeah.

1120
01:09:57,000 --> 01:09:58,500
STUDENT: [INAUDIBLE] one more time.

1121
01:09:58,500 --> 01:10:00,000
DAVID MALAN: Let's do one more time.

1122
01:10:00,000 --> 01:10:03,512
And look, draw what conclusion?

1123
01:10:03,512 --> 01:10:05,490
STUDENT: That nothing has to switch at all.

1124
01:10:05,490 --> 01:10:08,860
DAVID MALAN: Yeah, let's do it one more time, even though it's a little wasteful.

1125
01:10:08,860 --> 01:10:19,133
But logically, if I go through the whole list comparing pairs again, again, and again, and I don't do any work that time, now it's obviously logically safe to just stop, because otherwise, I'm

1126
01:10:19,133 --> 01:10:22,933
wasting my time doing the same thing again and again if no one's actually moving.

1127
01:10:22,933 --> 01:10:25,350
So I'm afraid we don't have monopoly games for all of you.

1128
01:10:25,350 --> 01:10:26,767
But we do have eight stress balls.

1129
01:10:26,767 --> 01:10:30,090
And round of applause, if we could, for our volunteers.

1130
01:10:30,090 --> 01:10:33,910
If you want to put your numbers on the shelf there.

1131
01:10:33,910 --> 01:10:36,720
So if we consider for a moment-- thank you.

1132
01:10:36,720 --> 01:10:39,340
Thank you so much.

1133
01:10:39,340 --> 01:10:42,150
Sure.

1134
01:10:42,150 --> 01:10:43,170
Thank you.

1135
01:10:43,170 --> 01:10:44,230
Thanks.

1136
01:10:44,230 --> 01:10:44,730
Sure.

1137
01:10:44,730 --> 01:10:48,870
So if we consider now these two algorithms, which one is better?

1138
01:10:48,870 --> 01:10:55,950
Any intuition for whether selection sort the first is better or worse than bubble sort the second?

1139
01:10:55,950 --> 01:10:58,020
Any thoughts?

1140
01:10:58,020 --> 01:10:58,860
Yeah.

1141
01:10:58,860 --> 01:11:03,620
STUDENT: Bubble sort's even better because it's less work [INAUDIBLE]..

1142
01:11:03,620 --> 01:11:08,930
DAVID MALAN: So bubble sort seems like less work, especially since I was focusing on those localized problems.

1143
01:11:08,930 --> 01:11:11,460
Other intuition?

1144
01:11:11,460 --> 01:11:14,580
Selection sort versus bubble sort.

1145
01:11:14,580 --> 01:11:19,420
Well, let me propose that we try to quantize this so we can actually analyze it in some way.

1146
01:11:19,420 --> 01:11:22,590
And this is not an exercise we'll do constantly for lots of algorithms.

1147
01:11:22,590 --> 01:11:24,940
But these are pretty representative of algorithms.

1148
01:11:24,940 --> 01:11:28,960
So we can wrap our minds around, indeed, the performance or the design of these things.

1149
01:11:28,960 --> 01:11:34,350
So here is my pseudocode for selection sort, whereby as per its name,

1150
01:11:34,350 --> 01:11:38,500
I just iteratively select the next smallest element again and again.

1151
01:11:38,500 --> 01:11:41,890
So how can we go about analyzing something like this?

1152
01:11:41,890 --> 01:11:48,030
Well, we could just do it on paper pencil and count up the number of steps that seem to be implied logically by the code.

1153
01:11:48,030 --> 01:11:52,890
We could literally count the number of steps I was taking again and again, left to right.

1154
01:11:52,890 --> 01:11:55,830
We could also just count the number of comparisons

1155
01:11:55,830 --> 01:11:58,302
I was making with each of the persons involved.

1156
01:11:58,302 --> 01:12:00,510
And I was doing it kind of quickly in selection sort.

1157
01:12:00,510 --> 01:12:04,950
But every time I was looking at a person trying to decide, do I want to remember that number is smallest?

1158
01:12:04,950 --> 01:12:11,700
That number, I was comparing two values with an equals equals or less than or greater than sign, at least if we had done this in code.

1159
01:12:11,700 --> 01:12:13,110
So that tends to be the norm.

1160
01:12:13,110 --> 01:12:23,490
When analyzing algorithms like these, counting the number of comparisons, because it's kind of a global unit of measure we can use to compare different algorithms entirely.

1161
01:12:23,490 --> 01:12:35,220
So think, too, that in the general case, when we have more than eight volunteers, more than seven doors, we can generalize our array in general, as this is the first element at bracket 0.

1162
01:12:35,220 --> 01:12:37,770
And the end of it is always n minus 1.

1163
01:12:37,770 --> 01:12:47,200
So arrays or doors, in this case, or volunteers, are always numerically indexed from 0 on up to n minus 1, if there's n of them in total.

1164
01:12:47,200 --> 01:12:50,940
So how do we analyze the code of selection sort?

1165
01:12:50,940 --> 01:12:56,370
Well, how many steps did it take me to find the first smallest element?

1166
01:12:56,370 --> 01:13:06,100
Or more precisely, how many comparisons did I need to make when I walked to left to right to find our first-smallest person, which ended up being 0?

1167
01:13:06,100 --> 01:13:09,310
How many comparisons did I do when walking left to right?

1168
01:13:09,310 --> 01:13:15,850
If there were eight people on stage, how many total comparisons that I do?

1169
01:13:15,850 --> 01:13:18,280
Like if there's eight people, I compared these folks.

1170
01:13:18,280 --> 01:13:22,210
Then this person, this person, yeah.

1171
01:13:22,210 --> 01:13:23,412
Yeah, so seven total, right?

1172
01:13:23,412 --> 01:13:29,960
Because if there's eight people on stage, you can only do seven comparisons total, because otherwise you'd be comparing one number to itself.

1173
01:13:29,960 --> 01:13:38,560
So it seems like, in the general case, if you've got n numbers that you're trying to sort, finding the smallest element first takes n minus 1 comparisons.

1174
01:13:38,560 --> 01:13:41,275
Maybe n total steps left to right.

1175
01:13:41,275 --> 01:13:46,030
But the number of comparisons, which I claim, is just a useful unit of measure, is n minus 1.

1176
01:13:46,030 --> 01:13:48,490
How about finding the next smallest person?

1177
01:13:48,490 --> 01:13:53,200
How many steps did it take me to find the next smallest number, which ended up being the number 1?

1178
01:13:55,790 --> 01:13:56,855
Yeah.

1179
01:13:56,855 --> 01:13:58,340
STUDENT: [INAUDIBLE] n minus 2.

1180
01:13:58,340 --> 01:13:59,600
DAVID MALAN: Yeah, so just n minus 2.

1181
01:13:59,600 --> 01:13:59,870
Why?

1182
01:13:59,870 --> 01:14:01,610
Because I'd already solved one problem.

1183
01:14:01,610 --> 01:14:03,210
Someone was already in the right position.

1184
01:14:03,210 --> 01:14:05,490
It would be silly to keep counting them again and again.

1185
01:14:05,490 --> 01:14:09,200
So I can whittle down my number of comparisons for the next pass to n minus 2.

1186
01:14:09,200 --> 01:14:12,350
The third pass to find the third smallest number would be n minus 3.

1187
01:14:12,350 --> 01:14:19,620
And then dot, dot, dot, presumably this story, this formula, ends when you have just one final pair, the people at the end, to compare.

1188
01:14:19,620 --> 01:14:28,220
So if this is looking a little reminiscent of some kind of recurrence from high school or high school math or physics or the like, let me just stipulate that if you actually do out this math

1189
01:14:28,220 --> 01:14:33,392
and generalize it, that is the same thing as n times n minus 1 divided by 2.

1190
01:14:33,392 --> 01:14:35,100
And if you're rusty on that, no big deal.

1191
01:14:35,100 --> 01:14:42,302
Just kind of commit to memory that any time you add up this kind of series, something plus something slightly smaller, plus something slightly smaller, each of which

1192
01:14:42,302 --> 01:14:46,520
differs by 1, you're going to get this formula. n times n minus 1 over 2.

1193
01:14:46,520 --> 01:14:51,680
If we, of course, multiply that out, that's really n squared minus n, all divided by 2.

1194
01:14:51,680 --> 01:14:56,540
If we keep multiplying it out, that's n squared divided by 2 minus n over 2.

1195
01:14:56,540 --> 01:15:03,140
And now, we have kind of a vocabulary with which we can talk about the efficiency, the design of this algorithm.

1196
01:15:03,140 --> 01:15:09,560
But honestly, I don't really care about this level of precision, like n squared divided by 2 minus n divided by 2.

1197
01:15:09,560 --> 01:15:20,190
As n gets really large, which of these symbols, which of these terms is really going to dominate, become the biggest influencer on the total value of steps?

1198
01:15:20,190 --> 01:15:20,690
Right?

1199
01:15:20,690 --> 01:15:21,890
It's the square, right?

1200
01:15:21,890 --> 01:15:23,382
It's definitely not n divided by 2.

1201
01:15:23,382 --> 01:15:24,590
That's shaving some time off.

1202
01:15:24,590 --> 01:15:27,800
But n squared, as n gets big, is going to get really big.

1203
01:15:27,800 --> 01:15:29,990
If n is 100, then n squared is bigger.

1204
01:15:29,990 --> 01:15:32,570
If n is a million, n squared is really bigger.

1205
01:15:32,570 --> 01:15:43,130
And so at the end of the day, when we're really just talking about a wave of the hand analysis and upper bound, if you will, let's just say that selection sort, as analyzed here,

1206
01:15:43,130 --> 01:15:45,860
it's on the order of n squared steps.

1207
01:15:45,860 --> 01:15:47,690
It's not precisely n squared steps.

1208
01:15:47,690 --> 01:15:58,570
But you know what? n squared divided by 2, the intuition here might be that, well, it's half of that. n squared is what really matters as n gets really, really large.

1209
01:15:58,570 --> 01:16:02,445
And that's when you start thinking about and trying to solve the Google problems of the world.

1210
01:16:02,445 --> 01:16:07,490
When n gets large, that's when you have to be smarter than just sort of naive implementations of any algorithm.

1211
01:16:07,490 --> 01:16:12,480
So where, then, does this algorithm fall into this categorization here?

1212
01:16:12,480 --> 01:16:19,610
Well, n squared, it turns out, is on the order of n squared steps, in the worst case, whether it's sorted or not.

1213
01:16:19,610 --> 01:16:28,670
It turns out, though, lower bound, if we consider this same code, suppose the best case scenario, like our eight volunteers came up on stage.

1214
01:16:28,670 --> 01:16:32,240
And just because they already sorted themselves, so 0 through 7.

1215
01:16:32,240 --> 01:16:34,490
Suppose they just happened to be in that state.

1216
01:16:34,490 --> 01:16:42,670
How many steps would selection store take to sort an already-sorted list of volunteers?

1217
01:16:42,670 --> 01:16:43,420
Any intuition?

1218
01:16:43,420 --> 01:16:44,318
Yeah.

1219
01:16:44,318 --> 01:16:47,186
STUDENT: Would it still be [INAUDIBLE]?

1220
01:16:47,186 --> 01:16:49,717
DAVID MALAN: Would it still be n--

1221
01:16:49,717 --> 01:16:51,180
STUDENT: Still be 7 [INAUDIBLE].

1222
01:16:51,180 --> 01:16:55,710
DAVID MALAN: So for the first pass, it would still be 7 for the first pass across the humans.

1223
01:16:55,710 --> 01:16:58,530
Because even though, yeah, I'm claiming 0 is here,

1224
01:16:58,530 --> 01:17:03,990
I don't know that 0 is the smallest until I make my way all the way over there doing all seven comparisons.

1225
01:17:03,990 --> 01:17:08,220
OK, fine, first pass took seven or more generally n minus 1 steps.

1226
01:17:08,220 --> 01:17:14,370
What if I look for the next smallest element, and the humans in this story are already sorted 0 through 7?

1227
01:17:14,370 --> 01:17:17,580
Well, yes, the number 1 is here, and I see them first.

1228
01:17:17,580 --> 01:17:22,530
But I don't know they're the smallest until I compare against everyone else get to the end of the list.

1229
01:17:22,530 --> 01:17:24,238
And we're like, oh, well that was stupid.

1230
01:17:24,238 --> 01:17:26,550
I already had the smallest person in hand then.

1231
01:17:26,550 --> 01:17:31,650
And so this pseudocode, this implementation of selection sort, is sort of fixed like this.

1232
01:17:31,650 --> 01:17:35,490
There's no special case that says, if already sorted, quit early.

1233
01:17:35,490 --> 01:17:37,860
It's always going to take n squared steps.

1234
01:17:37,860 --> 01:17:50,790
And so in this case, if we borrow our jargon from earlier using omega notation, just to be clear, selection sort is also going to be in this incarnation in omega of n squared,

1235
01:17:50,790 --> 01:17:59,040
because even in the best case, where the list is already sorted, you're going to waste a huge amount of time essentially verifying as much or discovering as much,

1236
01:17:59,040 --> 01:18:01,750
even though we humans of course could see it right away.

1237
01:18:01,750 --> 01:18:08,425
So selection sort would seem to take both n squared steps in the worst case, n squared steps in the best case.

1238
01:18:08,425 --> 01:18:09,300
And so you know what?

1239
01:18:09,300 --> 01:18:11,280
We can use our theta terminology for that.

1240
01:18:11,280 --> 01:18:19,652
Here would be an algorithm, just like counting earlier, that always takes n squared steps, no matter whether the array is sorted or not from the get go.

1241
01:18:19,652 --> 01:18:21,360
All right, so hopefully we can do better.

1242
01:18:21,360 --> 01:18:25,618
And someone proposed earlier that bubble sort felt like it was using fewer steps.

1243
01:18:25,618 --> 01:18:26,910
Well, let's consider that next.

1244
01:18:26,910 --> 01:18:30,630
With bubble sort, we had this pseudocode, I claim.

1245
01:18:30,630 --> 01:18:33,780
Whereby, let's focus on the inside of the code first.

1246
01:18:33,780 --> 01:18:36,120
Down here, what was I doing?

1247
01:18:36,120 --> 01:18:39,960
For i from 0 to n minus 2.

1248
01:18:39,960 --> 01:18:40,740
That's curious.

1249
01:18:40,740 --> 01:18:42,360
We've never seen n minus 2 before.

1250
01:18:42,360 --> 01:18:44,040
But I asked this question.

1251
01:18:44,040 --> 01:18:50,160
If numbers bracket i and numbers bracket i plus 1 are out of order, swap them.

1252
01:18:50,160 --> 01:18:53,610
So that was when I was pointing at our first two volunteers here.

1253
01:18:53,610 --> 01:18:57,090
I saw that they were out of order, so I swapped them.

1254
01:18:57,090 --> 01:19:09,670
How come I'm doing that again and again up to n minus 2, though, instead of n minus 1, which we've always used up until now as our rightmost boundary?

1255
01:19:09,670 --> 01:19:14,170
Any intuition for why I'm doing this from 0 to n minus 2?

1256
01:19:14,170 --> 01:19:14,700
Yeah.

1257
01:19:14,700 --> 01:19:18,540
STUDENT: [INAUDIBLE] number, you can't get rid of the ith number.

1258
01:19:18,540 --> 01:19:21,005
There's no benign character you can swap with.

1259
01:19:21,005 --> 01:19:21,880
DAVID MALAN: Exactly.

1260
01:19:21,880 --> 01:19:31,550
Because I'm looking at the ith person per this pseudocode here and the ith plus 1 person, I better make sure I don't go step beyond the boundaries of my array.

1261
01:19:31,550 --> 01:19:33,010
So if you think of my left hand.

1262
01:19:33,010 --> 01:19:41,350
When my back was to you here, pointing at the current person at the first position, my right hand for this if conditioner is essentially pointing at the person next to them.

1263
01:19:41,350 --> 01:19:44,740
And you want to iterate with your left hand all through these people.

1264
01:19:44,740 --> 01:19:47,620
But you don't want your left hand to point at the last person.

1265
01:19:47,620 --> 01:19:50,000
You want it to point at the second to last person.

1266
01:19:50,000 --> 01:19:54,220
But we know that the last person is always at n minus 1.

1267
01:19:54,220 --> 01:19:57,820
So the second to last person, just mathematically, is at n minus 2.

1268
01:19:57,820 --> 01:19:58,780
So it's a subtlety.

1269
01:19:58,780 --> 01:20:00,880
But this is a seg fault waiting to happen.

1270
01:20:00,880 --> 01:20:08,170
If you implemented bubble sort using n minus 1, you will, my right hand would go beyond the boundaries of the array, so just bad.

1271
01:20:08,170 --> 01:20:10,490
All right, so why am I saying this n times?

1272
01:20:10,490 --> 01:20:13,070
Well, we did it very organically with humans.

1273
01:20:13,070 --> 01:20:19,840
But each time someone-- each pass I did through the array, someone bubbled their way up to the end.

1274
01:20:19,840 --> 01:20:22,870
Number 7, then number 6, then number 5.

1275
01:20:22,870 --> 01:20:26,600
So if on each pass through the array of volunteers,

1276
01:20:26,600 --> 01:20:36,940
I was solving at least one problem, it seems like bubble sort can just run n times total to solve all n problems, because the first pass will get at least one number into place.

1277
01:20:36,940 --> 01:20:38,470
Second pass, second number into place.

1278
01:20:38,470 --> 01:20:39,970
You might get lucky, and it would do more.

1279
01:20:39,970 --> 01:20:41,740
But worst case, this feels like enough.

1280
01:20:41,740 --> 01:20:46,240
Just do this blindly n times, and they'll all line up together.

1281
01:20:46,240 --> 01:20:49,780
Well, technically-- all right, now we're getting into the weeds.

1282
01:20:49,780 --> 01:20:58,900
Technically, you can just repeat it in minus 1 times, because if you solve all n minus 1 other problems, and you're left with 1, literally that person's where they need to be, just logically.

1283
01:20:58,900 --> 01:21:02,540
If you've already sorted everything else and you've got just the 1 left, it's already bubbled up.

1284
01:21:02,540 --> 01:21:03,980
So how do we analyze this?

1285
01:21:03,980 --> 01:21:06,670
Well in bubble sort, we might do something like this.

1286
01:21:06,670 --> 01:21:11,015
I'm essentially doing n minus 1 things n minus 1 times.

1287
01:21:11,015 --> 01:21:14,980
Now, let me back up to the pseudocode, because this one's a little less obvious.

1288
01:21:14,980 --> 01:21:21,110
This is where you can actually mathematically infer from your loop how many steps you're taking.

1289
01:21:21,110 --> 01:21:24,585
So this first line literally says, repeat the following n minus 1 times.

1290
01:21:24,585 --> 01:21:28,240
So that's going to translate very straightforwardly to our mathematical formula.

1291
01:21:28,240 --> 01:21:30,190
Do something n minus 1 times.

1292
01:21:30,190 --> 01:21:35,840
This loop, just because I'm using for loop terminology, it's framed a little differently.

1293
01:21:35,840 --> 01:21:43,258
But if you're iterating from 0 to n minus 2, you're iterating a total of n minus 1 times.

1294
01:21:43,258 --> 01:21:45,550
And again, the arithmetic is getting a little annoying.

1295
01:21:45,550 --> 01:21:48,470
But this just means do the following n minus 1 times.

1296
01:21:48,470 --> 01:21:51,670
So do n minus 1 things n minus 1 times.

1297
01:21:51,670 --> 01:21:54,440
We can now run out the math as follows.

1298
01:21:54,440 --> 01:21:57,940
We have the formula n minus 1 times n minus 1.

1299
01:21:57,940 --> 01:22:03,100
We do our little FOIL method here, n squared minus 1 times n, minus 1 times n, plus 1.

1300
01:22:03,100 --> 01:22:06,550
We can combine like terms. n squared minus 2n plus 1.

1301
01:22:06,550 --> 01:22:10,900
But at this point, when n gets really large, which term are we really going to care about?

1302
01:22:10,900 --> 01:22:13,390
This is on the order of?

1303
01:22:13,390 --> 01:22:14,870
Yeah, n squared.

1304
01:22:14,870 --> 01:22:16,780
So at least asymptotically.

1305
01:22:16,780 --> 01:22:20,830
Asymptotically means, as n approaches infinity, gets really large.

1306
01:22:20,830 --> 01:22:25,430
Turns out that the upper bound on selection sort and bubble sort are essentially the same.

1307
01:22:25,430 --> 01:22:29,680
Now, if we really nitpicked and compared the total number of comparisons, they might differ slightly.

1308
01:22:29,680 --> 01:22:36,350
But as n gets large, honestly, you're barely going to notice the difference, it would seem, between these two algorithms.

1309
01:22:36,350 --> 01:22:39,550
But what about the lower bound?

1310
01:22:39,550 --> 01:22:45,470
If the upper bound on bubble sort is also big O of n, what about the lower bound here?

1311
01:22:45,470 --> 01:22:50,170
Well, with this pseudocode, what would the lower bound be on bubble sort?

1312
01:22:50,170 --> 01:22:53,890
Even in the best case when all of the volunteers are sorted.

1313
01:22:53,890 --> 01:22:56,830
Any intuition?

1314
01:22:56,830 --> 01:22:57,670
In this pseudo code.

1315
01:22:57,670 --> 01:22:58,538
Yeah, in the middle.

1316
01:22:58,538 --> 01:22:59,830
STUDENT: Sorry, quick question.

1317
01:22:59,830 --> 01:23:05,955
Isn't bubble sort structured such that you wouldn't need to compare numbers that have already bubbled up?

1318
01:23:05,955 --> 01:23:07,080
DAVID MALAN: Good question.

1319
01:23:07,080 --> 01:23:12,860
Isn't bubble sort designed such that you wouldn't need to compare numbers that have already bubbled up?

1320
01:23:12,860 --> 01:23:17,000
That's what's happening here in the middle, implicitly.

1321
01:23:17,000 --> 01:23:19,220
I'm always going from left to right.

1322
01:23:19,220 --> 01:23:27,140
But remember that even when I screwed up at the end and the last two people were out of order, I do always need to restart at the beginning, because the big numbers are

1323
01:23:27,140 --> 01:23:29,691
going that way, and the small numbers are coming this way.

1324
01:23:29,691 --> 01:23:32,892
STUDENT: [INAUDIBLE]

1325
01:23:32,892 --> 01:23:34,100
DAVID MALAN: So that is true.

1326
01:23:34,100 --> 01:23:37,460
There are some slight optimizations that I'm kind of glossing over here.

1327
01:23:37,460 --> 01:23:40,700
Let me stipulate that it would still end up being on the order of n squared.

1328
01:23:40,700 --> 01:23:43,910
But that would definitely shave off some actual running time here.

1329
01:23:43,910 --> 01:23:46,340
But what if the list is already sorted?

1330
01:23:46,340 --> 01:23:51,020
Our pseudocode, at the moment, has no allowance for if list is already sorted, quit early.

1331
01:23:51,020 --> 01:23:58,850
So we're going to blindly do n minus 1 things and minus 1 times unless we modify our pseudocode, as I did verbally earlier,

1332
01:23:58,850 --> 01:23:59,960
I proposed this.

1333
01:23:59,960 --> 01:24:08,990
Inside of that outer loop, if you make a pass across all of the volunteers, and your mental counter has made no swaps, you have to keep track with some kind of variable,

1334
01:24:08,990 --> 01:24:10,518
well then, you might as well stop.

1335
01:24:10,518 --> 01:24:17,550
Because if you do a whole pass and make no swaps, why would you waste time doing it again expecting different behavior?

1336
01:24:17,550 --> 01:24:26,640
So to help visualize these, whereby now bubble sort can be advantageous if the data is already sorted or mostly sorted.

1337
01:24:26,640 --> 01:24:27,140
Why?

1338
01:24:27,140 --> 01:24:29,510
Because it does have this short circuit detail.

1339
01:24:29,510 --> 01:24:36,263
At least if we implement it like that, how can we go about visualizing these things a little more clearly?

1340
01:24:36,263 --> 01:24:37,680
Well, let me go ahead and do this.

1341
01:24:37,680 --> 01:24:46,850
Let me pull up, here, a visualization of exactly these algorithms, thanks to a third party tool here that's going to help us visualize these sorting algorithms as follows.

1342
01:24:46,850 --> 01:24:48,740
Small bars represent small numbers.

1343
01:24:48,740 --> 01:24:50,480
Big bars represent big numbers.

1344
01:24:50,480 --> 01:24:56,843
And so the idea, now, is when I hit a button here to get all of the small bars this way, all of the big bars this way.

1345
01:24:56,843 --> 01:24:58,010
So just like our volunteers.

1346
01:24:58,010 --> 01:25:02,370
But instead of holding lighted numbers, it's bars representing their magnitude.

1347
01:25:02,370 --> 01:25:07,190
So let's go ahead and start with, for instance, selection sort.

1348
01:25:07,190 --> 01:25:14,820
And you'll see in pink, is being highlighted the current number that is being selected and then pulled all the way to the left.

1349
01:25:14,820 --> 01:25:16,220
So this is selection sort.

1350
01:25:16,220 --> 01:25:20,420
And again, it's selecting the next smallest element.

1351
01:25:20,420 --> 01:25:27,450
But you can see here, all the more visibly, that just like my human feet, we're taking a lot of steps.

1352
01:25:27,450 --> 01:25:32,430
So is this algorithm touching these elements, again and again and again.

1353
01:25:32,430 --> 01:25:34,970
And this is why the n squared is really a thing.

1354
01:25:34,970 --> 01:25:37,322
There's got to be some inherent redundancy here.

1355
01:25:37,322 --> 01:25:40,280
Like, why do we keep looking at the same darn elements again and again?

1356
01:25:40,280 --> 01:25:43,070
We do, in terms of our pseudocode need to do so.

1357
01:25:43,070 --> 01:25:48,782
But it's this redundant comparisons that kind of explains why n squared is indeed the case.

1358
01:25:48,782 --> 01:25:49,490
So now it's done.

1359
01:25:49,490 --> 01:25:50,977
Small bars here, big bars there.

1360
01:25:50,977 --> 01:25:54,650
And I had to just keep talking there to kill time, because it's relatively slow.

1361
01:25:54,650 --> 01:25:58,640
Well, let me re-randomize the array, just so we start with a different order.

1362
01:25:58,640 --> 01:26:00,380
And now let me click on bubble sort.

1363
01:26:00,380 --> 01:26:03,240
And you'll see similar idea, but different algorithm.

1364
01:26:03,240 --> 01:26:09,995
So now, the two bars in pink are the two that are being compared and fixed, potentially, if they're out of order.

1365
01:26:09,995 --> 01:26:14,420
And you can see already that the biggest bars are bubbling their way up to the top.

1366
01:26:14,420 --> 01:26:22,740
But now, you can also see this redundancy, like we keep swooping through the list again and again, just like I kept walking back and forth.

1367
01:26:22,740 --> 01:26:23,795
And this is n squared.

1368
01:26:23,795 --> 01:26:24,920
This is not that many bars.

1369
01:26:24,920 --> 01:26:25,420
What?

1370
01:26:25,420 --> 01:26:27,830
10, 20, there's like 40 or something bars, I'm guessing.

1371
01:26:27,830 --> 01:26:31,560
That's pretty slow already just to sort 40 numbers.

1372
01:26:31,560 --> 01:26:34,310
And I think it's going to get tedious if I keep talking over this.

1373
01:26:34,310 --> 01:26:37,590
So let's just assume that this too is relatively slow.

1374
01:26:37,590 --> 01:26:43,310
Had I gotten lucky and the list were almost sorted already, bubble sort would have been pretty fast.

1375
01:26:43,310 --> 01:26:46,040
But this was a truly random array, so we did not get lucky.

1376
01:26:46,040 --> 01:26:50,010
So indeed, the worst case might be what's kicking in here.

1377
01:26:50,010 --> 01:26:55,980
So I feel like it'll be anticlimactic, like holding in a sneeze, if I don't let you see the end of this.

1378
01:26:55,980 --> 01:26:57,890
So here we go.

1379
01:26:57,890 --> 01:27:00,110
Nothing interesting is about to happen.

1380
01:27:00,110 --> 01:27:02,330
Almost done.

1381
01:27:02,330 --> 01:27:03,080
OK, done.

1382
01:27:03,080 --> 01:27:05,890
All right, so thank you.

1383
01:27:05,890 --> 01:27:06,710
[APPLAUSE]

1384
01:27:06,710 --> 01:27:09,110
Thank you.

1385
01:27:09,110 --> 01:27:12,500
So still somewhat slow though.

1386
01:27:12,500 --> 01:27:15,800
How though can we, perhaps, do a little better fundamentally?

1387
01:27:15,800 --> 01:27:19,070
So we can do so if we introduce yet another technique.

1388
01:27:19,070 --> 01:27:22,130
And this one isn't so much a function of code as it is concept.

1389
01:27:22,130 --> 01:27:27,500
And it's something that you might have seen in the real world, but perhaps not so obviously so.

1390
01:27:27,500 --> 01:27:34,970
So it turns out, in programming, recursion refers to the ability of a function to call itself.

1391
01:27:34,970 --> 01:27:43,850
In the world of mathematics, if you have a function f, if f appears on both the left side and the right side of a formula, that would be a recursive function in the math world too.

1392
01:27:43,850 --> 01:27:53,660
Whenever f is defined in terms of itself, or in our case, in compute-- in programming, any time a function calls itself, that function is said to be recursive.

1393
01:27:53,660 --> 01:27:57,373
And this is actually something we've seen already in class, even though we didn't call it as much.

1394
01:27:57,373 --> 01:28:07,760
So for instance, consider this pseudocode from earlier, whereby this was the pseudocode for searching via binary search, a whole bunch of doors.

1395
01:28:07,760 --> 01:28:12,600
If no doors are left returned false, that was the additional conditional we added.

1396
01:28:12,600 --> 01:28:20,780
But then if number behind middle door returned true, and here's the interesting part, if number is less than middle door, search the left half.

1397
01:28:20,780 --> 01:28:24,020
Else if number is greater than middle door, search the right half.

1398
01:28:24,020 --> 01:28:27,800
This pseudocode earlier was, itself, recursive.

1399
01:28:27,800 --> 01:28:28,340
Why?

1400
01:28:28,340 --> 01:28:30,590
Because here is an algorithm for searching.

1401
01:28:30,590 --> 01:28:32,650
But what's the algorithm telling us?

1402
01:28:32,650 --> 01:28:37,280
Well, on this line and this line, it's telling us to search something else.

1403
01:28:37,280 --> 01:28:47,650
So even though it's not explicitly defined in code as having a name, if this is a search algorithm, and yet the search algorithm is using a search algorithm, this pseudocode is recursive.

1404
01:28:47,650 --> 01:28:53,410
Now, that could quickly get you into trouble if a function just calls itself again and again and again.

1405
01:28:53,410 --> 01:29:01,840
But why, intuitively, is it not problematic that this code, this pseudocode, calls itself?

1406
01:29:01,840 --> 01:29:03,460
Why will the algorithm still stop?

1407
01:29:03,460 --> 01:29:03,970
Yeah.

1408
01:29:03,970 --> 01:29:07,525
STUDENT: It has an exit condition, as in if there is no doors left, [INAUDIBLE]..

1409
01:29:07,525 --> 01:29:08,400
DAVID MALAN: Exactly.

1410
01:29:08,400 --> 01:29:10,860
It has some exit condition, like if no doors left.

1411
01:29:10,860 --> 01:29:17,120
And more importantly, any time you search the left half, you're searching a smaller version of the problem.

1412
01:29:17,120 --> 01:29:22,330
Any time you search the right half, you're searching a smaller version of the problem, literally half the size.

1413
01:29:22,330 --> 01:29:24,270
So this is why, in the phone book, obviously

1414
01:29:24,270 --> 01:29:29,560
I couldn't tear the phone book in half infinitely many times, because it was literally getting smaller each time.

1415
01:29:29,560 --> 01:29:33,580
So recursion is this ability to call yourself, if you will.

1416
01:29:33,580 --> 01:29:42,010
But what's important is that you do it on a smaller, smaller problem, so that eventually, you have no more problems to solve or no more data, no more doors at all.

1417
01:29:42,010 --> 01:29:46,210
So these two lines here would be the recursive elements here.

1418
01:29:46,210 --> 01:29:49,690
But if we go back to week 0, we could have used recursion in some other way.

1419
01:29:49,690 --> 01:29:53,040
So this was our pseudocode for the phone book back in week 0.

1420
01:29:53,040 --> 01:29:59,050
And recall that we described these yellow lines as really representing a loop, some kind of cycle again and again.

1421
01:29:59,050 --> 01:30:01,080
But there was a missed opportunity here.

1422
01:30:01,080 --> 01:30:05,670
What if I had re-implemented this code to do this?

1423
01:30:05,670 --> 01:30:14,610
Instead of saying open to middle of left half of book and then go back to line 3, like literally inducing a loop, or open to middle of right half a book and go back

1424
01:30:14,610 --> 01:30:23,730
to line 3 inducing another loop, why don't I just recognize that what I'm staring at now is a algorithm for searching a phone book?

1425
01:30:23,730 --> 01:30:30,750
And if you want to search a smaller phone book, like A through M or N through Z, we'll just use this same algorithm.

1426
01:30:30,750 --> 01:30:35,100
So I can replace these yellow lines with just this, casually speaking.

1427
01:30:35,100 --> 01:30:37,282
Search left half of book, search right half of book.

1428
01:30:37,282 --> 01:30:43,633
This would be implicitly, and now I can shorten the whole thing, a recursive implementation of the phone book pseudocode from week 0.

1429
01:30:43,633 --> 01:30:48,900
And it's recursive, because if this is a search algorithm, and you're saying go search something else, that's fine.

1430
01:30:48,900 --> 01:30:49,890
That's recursive.

1431
01:30:49,890 --> 01:30:55,710
But because you're searching half of the phone book, it's indeed going to get smaller and smaller.

1432
01:30:55,710 --> 01:31:03,820
Even in the real world or the real real virtual world, you can see recursive data structures in the wild, or at least in Super Mario Brothers like this.

1433
01:31:03,820 --> 01:31:10,860
Let me get rid of all the distractions here and focus on this pyramid, where you have one block, then two, then three, then four.

1434
01:31:10,860 --> 01:31:16,590
Well, this itself, is technically recursively-defined in the sense that, well, what is a pyramid of height for?

1435
01:31:16,590 --> 01:31:18,420
Well, it's really, what?

1436
01:31:18,420 --> 01:31:25,743
How would you describe a pyramid of height 4 is actually the same thing as a pyramid of--

1437
01:31:25,743 --> 01:31:28,200
STUDENT: Height 3.

1438
01:31:28,200 --> 01:31:30,750
DAVID MALAN: --of height 3, plus 1 additional layer.

1439
01:31:30,750 --> 01:31:32,370
Well, what's a pyramid of height 3?

1440
01:31:32,370 --> 01:31:36,250
Well, it's technically a pyramid of height 2 plus 1 additional layer.

1441
01:31:36,250 --> 01:31:40,630
And so even physical structures can be recursive if you can define them in terms of itself.

1442
01:31:40,630 --> 01:31:46,090
Now, at some point, you have to say that if the pyramid is of height 1, there's just one block.

1443
01:31:46,090 --> 01:31:50,440
You can't forever say it's defined in terms of a height negative 1, negative 2, you would never stop.

1444
01:31:50,440 --> 01:31:52,752
So you have to kind of have a special case there.

1445
01:31:52,752 --> 01:31:55,710
But let's go ahead and translate something like this, in fact, to code.

1446
01:31:55,710 --> 01:32:03,090
Let me go back to VS code here, and let me implement a program called iteration that refers to a loop iterating.

1447
01:32:03,090 --> 01:32:05,620
And let me implement a very simple pyramid like that.

1448
01:32:05,620 --> 01:32:08,370
So let me go ahead and include the CS50 library.

1449
01:32:08,370 --> 01:32:14,918
I'll include our standard io.h int main void, no command line arguments today.

1450
01:32:14,918 --> 01:32:16,210
And let's go ahead and do this.

1451
01:32:16,210 --> 01:32:21,150
Let's declare a variable called height, ask the human for the height of this pyramid.

1452
01:32:21,150 --> 01:32:25,300
And then let's go ahead and draw a pyramid of that height.

1453
01:32:25,300 --> 01:32:27,580
Now, of course, draw does not yet exist.

1454
01:32:27,580 --> 01:32:30,090
So I'm going to need to invent the draw function.

1455
01:32:30,090 --> 01:32:33,180
Let me go ahead and define a function that doesn't have a return value.

1456
01:32:33,180 --> 01:32:34,722
It's just going to have side effects.

1457
01:32:34,722 --> 01:32:37,230
It's just going to print bricks on the screen, called draw.

1458
01:32:37,230 --> 01:32:40,240
And it takes in an integer, n, as its input.

1459
01:32:40,240 --> 01:32:41,950
And how am I going to implement this?

1460
01:32:41,950 --> 01:32:46,530
Well again, I want to print one block, then two, then three, then four.

1461
01:32:46,530 --> 01:32:49,680
That's pretty straightforward, at least once you're comfortable with loops.

1462
01:32:49,680 --> 01:32:51,370
Let me go back to the code here.

1463
01:32:51,370 --> 01:32:58,260
Let me go ahead and say 4, int i, get 0. i is less than n. i plus plus.

1464
01:32:58,260 --> 01:33:01,170
And that's going to iterate, essentially row by row.

1465
01:33:01,170 --> 01:33:06,060
And on each row, I want to print out one, then two, then three, then four bricks.

1466
01:33:06,060 --> 01:33:08,815
But I'm iterating from 0 to 1 to 2 to 3.

1467
01:33:08,815 --> 01:33:09,690
So I think that's OK.

1468
01:33:09,690 --> 01:33:19,380
I can just say something like 4 int j get 0. j, let's be clever about this, is less than i. j++.

1469
01:33:19,380 --> 01:33:22,560
And now, let me go ahead and, inside of this loop,

1470
01:33:22,560 --> 01:33:27,130
I think I can get away with just printing out a single hash sign.

1471
01:33:27,130 --> 01:33:30,270
But then outside of that loop, similar to last week,

1472
01:33:30,270 --> 01:33:32,920
I'm going to print my new line separately.

1473
01:33:32,920 --> 01:33:34,470
So a little non-obvious at first.

1474
01:33:34,470 --> 01:33:38,790
But this outer loop iterates row by row, line by line, if you will.

1475
01:33:38,790 --> 01:33:46,890
And then the inner loop just makes sure that when i equals zero, let's see.

1476
01:33:46,890 --> 01:33:48,960
Oh nope, there's a bug.

1477
01:33:48,960 --> 01:33:52,170
I need to make sure that it's j is less than i plus 1.

1478
01:33:52,170 --> 01:33:55,500
So when i is 0 on my first line of output,

1479
01:33:55,500 --> 01:33:57,600
I'm going to print out one brick.

1480
01:33:57,600 --> 01:34:02,350
When i is 1, I'm going to print out two bricks and so forth.

1481
01:34:02,350 --> 01:34:05,460
So let me go ahead and run make iteration.

1482
01:34:05,460 --> 01:34:09,090
All right, and now, seems to compile.

1483
01:34:09,090 --> 01:34:10,770
Uh oh, huh.

1484
01:34:10,770 --> 01:34:12,900
Implicit declaration of function draw.

1485
01:34:12,900 --> 01:34:16,100
So I'm making week one mistakes again.

1486
01:34:16,100 --> 01:34:16,660
What?

1487
01:34:16,660 --> 01:34:17,570
Say again.

1488
01:34:17,570 --> 01:34:18,450
STUDENT: [INAUDIBLE]

1489
01:34:18,450 --> 01:34:19,200
DAVID MALAN: Yeah.

1490
01:34:19,200 --> 01:34:20,320
The prototype is missing.

1491
01:34:20,320 --> 01:34:21,300
I didn't declare it at the top.

1492
01:34:21,300 --> 01:34:23,550
That's an easy fix, and the only time, really, it's

1493
01:34:23,550 --> 01:34:25,530
OK and necessary to copy paste.

1494
01:34:25,530 --> 01:34:29,050
Let me copy the functions declaration there and it with a semicolon.

1495
01:34:29,050 --> 01:34:32,370
So that clang now knows that draw will exist.

1496
01:34:32,370 --> 01:34:33,240
Make iteration.

1497
01:34:33,240 --> 01:34:33,930
Now it works.

1498
01:34:33,930 --> 01:34:36,090
Thank you. dot slash iteration.

1499
01:34:36,090 --> 01:34:37,830
We'll type in something like 4.

1500
01:34:37,830 --> 01:34:43,340
And there we have it, our pyramid of height one, two, three, four, that looks pretty similar to this, albeit using hashes.

1501
01:34:43,340 --> 01:34:49,110
So that's how we would have implemented this, like, two weeks ago in week one, maybe last week, but just using arrays.

1502
01:34:49,110 --> 01:34:53,640
But let me propose that we could do something recursively instead.

1503
01:34:53,640 --> 01:34:55,480
Let me close this version of the code.

1504
01:34:55,480 --> 01:35:01,800
And let me go back to VS Code and open up recursion.c, just to demonstrate something recursively.

1505
01:35:01,800 --> 01:35:04,420
And I'll do it incorrectly deliberately the first time.

1506
01:35:04,420 --> 01:35:06,630
So let me include cs50.h.

1507
01:35:06,630 --> 01:35:08,850
Let me include standard io.h.

1508
01:35:08,850 --> 01:35:12,000
Let me do int main void.

1509
01:35:12,000 --> 01:35:17,910
And let me just blindly draw a pyramid initially of height 1.

1510
01:35:17,910 --> 01:35:21,910
But now in my draw function, let me re-implement it a little differently.

1511
01:35:21,910 --> 01:35:24,840
So my draw function this time is still going to take a number n.

1512
01:35:24,840 --> 01:35:26,860
But that's how many hashes it's going to print.

1513
01:35:26,860 --> 01:35:34,050
So let's do 4, int i get 0. i is less than n. i++.

1514
01:35:34,050 --> 01:35:38,440
Then let's go ahead and print out a single hash mark here.

1515
01:35:38,440 --> 01:35:44,290
And then after that, let's print out the end of the line, just as before.

1516
01:35:44,290 --> 01:35:49,770
But now this, of course, is only going to draw a single row.

1517
01:35:49,770 --> 01:35:54,750
It's going to print out one hash or two hashes or three hashes, but only on one line.

1518
01:35:54,750 --> 01:35:58,560
Let me now, incorrectly, but just kind of curiously say, all right.

1519
01:35:58,560 --> 01:36:04,860
Well, if this draws a pyramid of height 1, let's just use ourselves to draw a pyramid of height n plus 1.

1520
01:36:04,860 --> 01:36:08,370
So the first time I call draw, it will print out one hash.

1521
01:36:08,370 --> 01:36:13,770
Then the second time I call draw, it will print out two hashes, then three, then four.

1522
01:36:13,770 --> 01:36:18,000
So we're kind of laying these bricks down from top to bottom.

1523
01:36:18,000 --> 01:36:20,670
Make recursion.

1524
01:36:20,670 --> 01:36:22,420
Whoops, I screwed up again.

1525
01:36:22,420 --> 01:36:24,630
So let's copy the prototype here.

1526
01:36:24,630 --> 01:36:27,260
Let's put this down over here, semicolon.

1527
01:36:27,260 --> 01:36:28,600
Let's do this again.

1528
01:36:28,600 --> 01:36:30,010
Make recursion.

1529
01:36:30,010 --> 01:36:32,410
All right, all good, dot slash recursion.

1530
01:36:32,410 --> 01:36:37,310
And now let me increase the size of my terminal window, just so you can see more of the output.

1531
01:36:37,310 --> 01:36:39,490
And here we have.

1532
01:36:39,490 --> 01:36:41,480
OK, bad, but thank you.

1533
01:36:41,480 --> 01:36:43,525
So we have an infinitely tall pyramid.

1534
01:36:43,525 --> 01:36:47,020
And it's just flying across the screen, which is why it looks kind of like a mess.

1535
01:36:47,020 --> 01:36:51,670
But I printed out a pyramid of height 1, and then 2, and then 3, and then 4.

1536
01:36:51,670 --> 01:36:59,353
And unfortunately, what am I lacking any sort of quick condition, any kind of condition that says, wait a minute, when it's too tall, stop altogether.

1537
01:36:59,353 --> 01:37:00,520
So this is an infinite loop.

1538
01:37:00,520 --> 01:37:01,570
But it's not a loop.

1539
01:37:01,570 --> 01:37:03,250
It's a recursive call.

1540
01:37:03,250 --> 01:37:05,780
And actually, doing this in general, is very bad.

1541
01:37:05,780 --> 01:37:14,050
We'll see next week that if you call a function too many times, you can actually trigger yet another of those segmentation faults, because you're using too much memory, essentially.

1542
01:37:14,050 --> 01:37:16,300
But for now, I haven't triggered that yet.

1543
01:37:16,300 --> 01:37:17,927
Control C is your friend to cancel.

1544
01:37:17,927 --> 01:37:22,750
And as an aside, if you're playing along at home or playing with this code later, I actually cheated here.

1545
01:37:22,750 --> 01:37:29,350
We have a special clang configuration feature that prevents you from calling a function like that and creating a problem.

1546
01:37:29,350 --> 01:37:31,598
I overrode it just for demonstration sake.

1547
01:37:31,598 --> 01:37:34,640
But odds are at home, you wouldn't be able to compile this code yourself.

1548
01:37:34,640 --> 01:37:39,050
But let me do a proper version recursively of this code as follows.

1549
01:37:39,050 --> 01:37:41,870
Let me go back into the code here.

1550
01:37:41,870 --> 01:37:46,540
Let me go ahead and, not just blindly start drawing one, then two, then three layers of bricks.

1551
01:37:46,540 --> 01:37:53,350
Let me prompt the human as before for the height of the pyramid they want using our get int function.

1552
01:37:53,350 --> 01:37:55,670
And now let me call draw of height again.

1553
01:37:55,670 --> 01:37:58,330
So now I'm going back to the loop-like version.

1554
01:37:58,330 --> 01:38:04,120
But instead of using a loop now, this is where recursion gets rather elegant, if you will.

1555
01:38:04,120 --> 01:38:10,690
Let me go ahead and execute and code the draw function as follows.

1556
01:38:10,690 --> 01:38:18,520
Per your definition, if a pyramid of height 4 is really just a pyramid of height 3 plus another row, well, let's take that literally.

1557
01:38:18,520 --> 01:38:19,990
Let me go back to my code.

1558
01:38:19,990 --> 01:38:29,380
And if you want to draw a pyramid of height 4, well go right ahead and draw a pyramid of height 3 first, or more generally, n minus 1.

1559
01:38:29,380 --> 01:38:30,640
But what's the second step?

1560
01:38:30,640 --> 01:38:34,510
Well, once you've drawn a pyramid of height 3, draw an extra row.

1561
01:38:34,510 --> 01:38:37,190
So I at least have to bite off that part of the problem myself.

1562
01:38:37,190 --> 01:38:41,530
So let me just do for int i get 0. i is less than n i++.

1563
01:38:41,530 --> 01:38:46,010
And let me, the programmer of this function, print out my hashes.

1564
01:38:46,010 --> 01:38:50,350
And then at the very bottom, print out a new line so the cursor moves to the next line.

1565
01:38:50,350 --> 01:38:58,570
But this is kind of elegant now, I dare say, in that draw is recursive, because I'm literally translating from English to C code,

1566
01:38:58,570 --> 01:39:02,050
this idea that a pyramid of height 4 is really just a pyramid of height 3.

1567
01:39:02,050 --> 01:39:03,640
So I do that first.

1568
01:39:03,640 --> 01:39:06,560
And I'm sort of trusting that this will work.

1569
01:39:06,560 --> 01:39:09,800
Then I just have to lay one more layer of bricks, four of them.

1570
01:39:09,800 --> 01:39:15,520
So if n is 4, this is just a simple for loop, a la week 1, that will print out an additional layer.

1571
01:39:15,520 --> 01:39:18,610
But this, of course, is going to be problematic eventually.

1572
01:39:18,610 --> 01:39:20,030
Why?

1573
01:39:20,030 --> 01:39:22,670
It's not done yet, this program.

1574
01:39:22,670 --> 01:39:27,644
How many times will draw call itself in this model?

1575
01:39:27,644 --> 01:39:28,640
STUDENT: It's infinite.

1576
01:39:28,640 --> 01:39:30,098
DAVID MALAN: Infinitely many times.

1577
01:39:30,098 --> 01:39:30,814
Why?

1578
01:39:30,814 --> 01:39:34,170
STUDENT: Because there's no quit function.

1579
01:39:34,170 --> 01:39:36,450
DAVID MALAN: Yeah, there's no equivalent of quit.

1580
01:39:36,450 --> 01:39:41,050
Like, if you've printed enough already, then quit, well, how do we capture that?

1581
01:39:41,050 --> 01:39:43,320
Well, I don't think we want this to go negative.

1582
01:39:43,320 --> 01:39:46,570
It would make no sense to draw a negative height pyramid.

1583
01:39:46,570 --> 01:39:53,650
So I think we can just pluck off, as the programmer, an easy case, an easy answer, a so-called base case.

1584
01:39:53,650 --> 01:39:54,900
And I'm just going to do this.

1585
01:39:54,900 --> 01:40:02,830
At the top of my draw function, let me just say, if n is less than or, heck, less than or equal to 0, that's it.

1586
01:40:02,830 --> 01:40:04,530
Go ahead and just return.

1587
01:40:04,530 --> 01:40:06,030
There's nothing more to do.

1588
01:40:06,030 --> 01:40:13,290
And that simple condition, technically known as a base case, will ensure that the code doesn't run forever.

1589
01:40:13,290 --> 01:40:13,860
Why?

1590
01:40:13,860 --> 01:40:17,730
Well, suppose that draw is called with an argument of 4.

1591
01:40:17,730 --> 01:40:20,580
4 is, of course, not less than 0, so we don't return.

1592
01:40:20,580 --> 01:40:22,590
But we do draw a pyramid of height 3.

1593
01:40:22,590 --> 01:40:24,870
And here's where things get a little mentally tricky.

1594
01:40:24,870 --> 01:40:28,320
You don't move on to line 20 until draw has been called.

1595
01:40:28,320 --> 01:40:34,230
So when draw is called with an argument of 3, it's as though you're executing from the top of this function again.

1596
01:40:34,230 --> 01:40:35,520
3 is not less than 0.

1597
01:40:35,520 --> 01:40:36,330
So what do you do?

1598
01:40:36,330 --> 01:40:38,490
You draw 2.

1599
01:40:38,490 --> 01:40:39,540
How do you draw 2?

1600
01:40:39,540 --> 01:40:41,950
Well, 2 is not less than 0, so you don't return.

1601
01:40:41,950 --> 01:40:43,050
So you draw 1.

1602
01:40:43,050 --> 01:40:44,370
Got to be careful here.

1603
01:40:44,370 --> 01:40:45,240
Draw 1.

1604
01:40:45,240 --> 01:40:47,340
And now, we go ahead back to the beginning.

1605
01:40:47,340 --> 01:40:48,090
How do you draw 1?

1606
01:40:48,090 --> 01:40:50,430
Well, 1 is not less than 0, so you don't return.

1607
01:40:50,430 --> 01:40:53,400
You draw height 0.

1608
01:40:53,400 --> 01:40:54,510
How do you draw height 0?

1609
01:40:54,510 --> 01:40:55,110
Wait a minute.

1610
01:40:55,110 --> 01:40:57,660
0 is less than or equal to 0.

1611
01:40:57,660 --> 01:40:58,980
And you return.

1612
01:40:58,980 --> 01:41:02,100
And so it's kind of like this mental stack, this to do list.

1613
01:41:02,100 --> 01:41:12,840
You keep postponing, executing these lower lines of code, because you keep restarting, restarting, restarting the draw function until, finally, one of those function calls says there's nothing to do,

1614
01:41:12,840 --> 01:41:13,530
return.

1615
01:41:13,530 --> 01:41:16,530
And now the whole thing starts to unravel, if you will.

1616
01:41:16,530 --> 01:41:18,330
And you pick back up where you left off.

1617
01:41:18,330 --> 01:41:20,300
And this is, perhaps, the best scenario.

1618
01:41:20,300 --> 01:41:21,300
We won't do it in class.

1619
01:41:21,300 --> 01:41:31,480
But if you'd like to wrestle through this on your own using debug50 to keep stepping into, step into, step into, each of those lines, logically, you'll see exactly what's actually happening.

1620
01:41:31,480 --> 01:41:37,740
So let me go to my terminal and do make recursion, which is now this correct version of the code, dot slash recursion.

1621
01:41:37,740 --> 01:41:39,240
Let's type in a height of 4.

1622
01:41:39,240 --> 01:41:47,910
And voila, now we have that same pyramid, not using iteration per se, though admittedly, we're using iteration to print the additional layer.

1623
01:41:47,910 --> 01:41:55,120
We're now using draw recursively to print all of the smaller pyramids that need come before it.

1624
01:41:55,120 --> 01:41:57,370
STUDENT: Can you only use recursion for void function?

1625
01:41:57,370 --> 01:41:58,123
[INAUDIBLE]

1626
01:41:58,123 --> 01:41:58,790
DAVID MALAN: No.

1627
01:41:58,790 --> 01:42:01,070
Question is, can you only use recursion with a void function?

1628
01:42:01,070 --> 01:42:01,920
No, not at all.

1629
01:42:01,920 --> 01:42:11,360
In fact, it's very common to have a return value like an integer or something else so that you can actually do something constructively with that actual value.

1630
01:42:11,360 --> 01:42:13,190
Other questions on this.

1631
01:42:13,190 --> 01:42:15,290
STUDENT: When is line 21 getting executed?

1632
01:42:15,290 --> 01:42:16,790
DAVID MALAN: Say it a little louder.

1633
01:42:16,790 --> 01:42:18,770
STUDENT: When is line 21 getting executed?

1634
01:42:18,770 --> 01:42:20,850
DAVID MALAN: When is line 21 getting executed?

1635
01:42:20,850 --> 01:42:26,600
So if you continue to-- let me scroll down a bit more so you can see the top of the code.

1636
01:42:26,600 --> 01:42:35,310
So line 21 will be executed once line 19 is done executing itself.

1637
01:42:35,310 --> 01:42:40,790
Now, in the story I told, we kept calling draw again, again, again.

1638
01:42:40,790 --> 01:42:48,510
But as soon as one of those function calls where n equals 0 returns immediately, then we don't keep drawing again and again.

1639
01:42:48,510 --> 01:42:59,303
So now if you kind of think of the process as reversing, then you continue to line 21, then line 21 again, then line 21 again, and as the sort of logic unravels.

1640
01:42:59,303 --> 01:43:03,530
And next week, we'll actually paint a picture of what's actually happening in the computer's memory.

1641
01:43:03,530 --> 01:43:07,950
But for now, it's just, it's very similar to the pseudocode for the phone book.

1642
01:43:07,950 --> 01:43:09,680
You're just searching again and again.

1643
01:43:09,680 --> 01:43:14,408
But you're waiting until the very end to get back the final result.

1644
01:43:14,408 --> 01:43:18,830
Google now, who I keep mentioning by coincidence today, is full of programmers of course.

1645
01:43:18,830 --> 01:43:20,600
Here's a fun exercise.

1646
01:43:20,600 --> 01:43:23,432
Let me go back to a browser.

1647
01:43:23,432 --> 01:43:27,980
I'm going to go ahead and search for recursion, because I want to learn a little something about recursion.

1648
01:43:27,980 --> 01:43:30,230
Here is kind of an internet meme or joke.

1649
01:43:30,230 --> 01:43:35,360
If I zoom in here, the engineers at Google are kind of funny.

1650
01:43:35,360 --> 01:43:37,902
See why?

1651
01:43:37,902 --> 01:43:38,798
STUDENT: Ah.

1652
01:43:38,798 --> 01:43:40,540
DAVID MALAN: Ah, there you go.

1653
01:43:40,540 --> 01:43:41,740
Yes.

1654
01:43:41,740 --> 01:43:43,030
Yes, this is recursion.

1655
01:43:43,030 --> 01:43:48,490
And there's going to be so many memes you'll come across now, where recursion, like if you've ever pointed a camera at the TV that's

1656
01:43:48,490 --> 01:43:52,660
showing the camera, and you sort of see yourself or the image again and again, that's really recursion.

1657
01:43:52,660 --> 01:43:56,320
And in that case, it only stops once you hit the base case of a single pixel.

1658
01:43:56,320 --> 01:44:01,880
But this is a very funny joke in some circles when it comes to recursion and Google.

1659
01:44:01,880 --> 01:44:08,050
So how can we actually use Google, or rather, how can we actually use recursion constructively?

1660
01:44:08,050 --> 01:44:16,870
Well, let me propose that we actually introduced a third and final algorithm for sorting that hopefully does better than the two sorts thus far.

1661
01:44:16,870 --> 01:44:19,480
We've done selection sort and bubble sort.

1662
01:44:19,480 --> 01:44:24,220
Bubble sort, we liked a little better, at least insofar as in the best case where the list is already sorted.

1663
01:44:24,220 --> 01:44:30,490
Bubble sort's at least smarter, and it will actually terminate early, giving us a better lower bound, in terms of our omega notation.

1664
01:44:30,490 --> 01:44:36,250
But it turns out that recursion, and this is not necessarily a feature of recursion, but something we can now leverage.

1665
01:44:36,250 --> 01:44:47,560
It turns out, using recursion, we can take a fundamentally different approach to sorting a whole bunch of numbers in such a way that we can do far fewer comparisons and, ideally, speed up

1666
01:44:47,560 --> 01:44:49,010
our final results.

1667
01:44:49,010 --> 01:44:54,010
So here is the pseudocode for what we're about to see for something called merge sort.

1668
01:44:54,010 --> 01:44:56,230
And it really is this terse.

1669
01:44:56,230 --> 01:44:58,330
Sort the left half of numbers.

1670
01:44:58,330 --> 01:45:00,550
Sort the right half of numbers.

1671
01:45:00,550 --> 01:45:02,950
Merge the sorted halves.

1672
01:45:02,950 --> 01:45:10,960
This is almost sort of nonsensical, because if you're asked for an algorithm to sort, and you respond with, well, sort the left half, sort the right half.

1673
01:45:10,960 --> 01:45:14,230
That's being difficult, because well, I'm asking for a sorting algorithm.

1674
01:45:14,230 --> 01:45:16,897
You're just telling me to sort the left half and the right half.

1675
01:45:16,897 --> 01:45:21,760
But implicit in that last line, merging is a pretty powerful feature of this sort.

1676
01:45:21,760 --> 01:45:23,908
Now, we do need another base case at the top.

1677
01:45:23,908 --> 01:45:24,700
So let me add this.

1678
01:45:24,700 --> 01:45:29,807
If we find ourselves with a list, an array, of size 1, well, that array is obviously sorted.

1679
01:45:29,807 --> 01:45:32,390
If there's only one element in it, there's no work to be done.

1680
01:45:32,390 --> 01:45:33,890
So that's going to be our base case.

1681
01:45:33,890 --> 01:45:40,900
But allowing us now, in just these, what, four, six lines of pseudocode, to actually sort some elements.

1682
01:45:40,900 --> 01:45:43,652
But let's focus first on just a subset of this.

1683
01:45:43,652 --> 01:45:46,360
Let's consider for a moment what it means to merge sorted halves.

1684
01:45:46,360 --> 01:45:50,170
So Carter has wonderfully come up to volunteer here just to help us reset these numbers.

1685
01:45:50,170 --> 01:45:56,020
Suppose that in the middle of the story we're about to tell, we have two sorted halves.

1686
01:45:56,020 --> 01:46:01,630
I've already sorted the left half of these numbers, and indeed, 2, 4, 5, 7 is sorted from smallest to largest.

1687
01:46:01,630 --> 01:46:06,100
And the right half appears to be already sorted, 0, 1, 3, 6, already sorted.

1688
01:46:06,100 --> 01:46:10,630
So in my pseudocode, we're already done sorting the left half and the right half somehow.

1689
01:46:10,630 --> 01:46:12,160
But we'll see how in a moment.

1690
01:46:12,160 --> 01:46:14,980
Well, how do I go about merging these two halves?

1691
01:46:14,980 --> 01:46:18,490
Well, because they're sorted already, and you want to merge them in order,

1692
01:46:18,490 --> 01:46:20,110
I think we can flip down.

1693
01:46:20,110 --> 01:46:25,030
We can hide all but the first numbers in each of these sublists.

1694
01:46:25,030 --> 01:46:28,125
So here, we have a half that starts with 2.

1695
01:46:28,125 --> 01:46:32,060
And I don't really care what the other numbers are, because they're clearly larger than 2.

1696
01:46:32,060 --> 01:46:35,043
I can focus only on 2, and 0 too, 0 also.

1697
01:46:35,043 --> 01:46:39,293
We know that 0 is the smallest there, so let's just ignore the numbers that Carter kindly flipped down.

1698
01:46:39,293 --> 01:46:44,360
So how do I merge these two lists into a new sorted larger list?

1699
01:46:44,360 --> 01:46:50,470
Well, I compare the two on my left with the 0 on my right, obviously, which comes first, the 0.

1700
01:46:50,470 --> 01:46:51,963
So let me put this down here.

1701
01:46:51,963 --> 01:46:54,130
And Carter, if you want to give us the next element.

1702
01:46:54,130 --> 01:46:55,960
Now I have two sorted halves.

1703
01:46:55,960 --> 01:46:57,650
But I've already plucked one off.

1704
01:46:57,650 --> 01:47:00,010
So now I compare the two against the 1.

1705
01:47:00,010 --> 01:47:01,580
1 obviously comes next.

1706
01:47:01,580 --> 01:47:04,843
So I'm going to take out the 1 and put it in place here.

1707
01:47:04,843 --> 01:47:06,760
Now I'm going to compare the two halves again.

1708
01:47:06,760 --> 01:47:08,830
2 and 3, which do I merge first?

1709
01:47:08,830 --> 01:47:10,660
Obviously the 2 comes next.

1710
01:47:10,660 --> 01:47:15,220
And now, notice, each time I do this, my hands are theoretically making forward progress.

1711
01:47:15,220 --> 01:47:20,290
I'm not doubling back like I kept doing with selection sort or bubble sort, back and forth, back and forth.

1712
01:47:20,290 --> 01:47:24,310
My fingers are constantly advancing forward, and that's going to be a key detail.

1713
01:47:24,310 --> 01:47:27,340
So I compare 4 and 3, 3 obviously.

1714
01:47:27,340 --> 01:47:32,560
I compare 4 and 6, 4 obviously.

1715
01:47:32,560 --> 01:47:36,520
I compare 5 and 6, 5 obviously.

1716
01:47:36,520 --> 01:47:40,810
And then I compare 7 and 6, 6 of course.

1717
01:47:40,810 --> 01:47:43,000
And then lastly, we have just one element left.

1718
01:47:43,000 --> 01:47:48,160
And even though I'm kind of moving awkwardly as a human, my hands technically were only moving to the right.

1719
01:47:48,160 --> 01:47:51,130
I was never looping back doing something again and again.

1720
01:47:51,130 --> 01:47:54,430
And that's, perhaps, the intuition, and just enough room for the 7.

1721
01:47:54,430 --> 01:47:58,210
So that, then, is how you would merge two sorted halves.

1722
01:47:58,210 --> 01:48:00,610
We started with left half sorted, right half sorted.

1723
01:48:00,610 --> 01:48:02,860
And merging is just like what you would do as a human.

1724
01:48:02,860 --> 01:48:08,620
And Carter just flipped the numbers down, so our focus was only on the smallest elements in each.

1725
01:48:08,620 --> 01:48:17,120
Any questions before we forge ahead with what it means, then, to be merged in this way?

1726
01:48:17,120 --> 01:48:18,777
So now, here is an original list.

1727
01:48:18,777 --> 01:48:22,480
We deliberately put it at the top, because there's one detail of merge sort that's key.

1728
01:48:22,480 --> 01:48:25,490
Merge sort is technically going to use a little more space.

1729
01:48:25,490 --> 01:48:32,110
And so whereas, previously, we just kept moving our humans around and swapping people and making sure they stayed ultimately in the original positions.

1730
01:48:32,110 --> 01:48:36,700
With merge sort, pretends that here's our original array of memory.

1731
01:48:36,700 --> 01:48:38,970
I'm going to need at least one other array of memory.

1732
01:48:38,970 --> 01:48:41,160
And I'm going to cheat, and I'm going to use even more memory.

1733
01:48:41,160 --> 01:48:45,540
But technically, I could actually go back and forth between 1 array and a secondary array.

1734
01:48:45,540 --> 01:48:48,370
But it is going to take me more space.

1735
01:48:48,370 --> 01:48:53,130
So how do I go about implementing merge sort on this code?

1736
01:48:53,130 --> 01:48:54,930
Well, let's consider this.

1737
01:48:54,930 --> 01:48:57,060
Here is a array of size 8.

1738
01:48:57,060 --> 01:48:59,590
If only one number quit, obviously not applicable.

1739
01:48:59,590 --> 01:49:01,230
So let's focus on the juicy part there.

1740
01:49:01,230 --> 01:49:02,880
Sort the left half of the numbers.

1741
01:49:02,880 --> 01:49:05,130
All right, how do I sort the left half of the numbers?

1742
01:49:05,130 --> 01:49:09,240
I'm going to just nudge them over just to be clear, which is the left half.

1743
01:49:09,240 --> 01:49:11,850
Here is now a sublist of size 4.

1744
01:49:11,850 --> 01:49:14,860
How do I sort the left half?

1745
01:49:14,860 --> 01:49:17,380
Well, do I have an algorithm for sorting?

1746
01:49:17,380 --> 01:49:18,430
Yeah, what do I do?

1747
01:49:18,430 --> 01:49:19,492
Here's a list of size 4.

1748
01:49:19,492 --> 01:49:20,200
How do I sort it?

1749
01:49:20,200 --> 01:49:22,000
What's step one?

1750
01:49:22,000 --> 01:49:23,330
Sort the left half.

1751
01:49:23,330 --> 01:49:28,060
So I now sort of, conceptually in my mind, take this sublist of size 4.

1752
01:49:28,060 --> 01:49:32,740
And I sort it by first sorting the left half, focusing now on the 7 and 2.

1753
01:49:32,740 --> 01:49:34,330
All right, here's a list of size 2.

1754
01:49:34,330 --> 01:49:37,060
How do I sort a list of size 2?

1755
01:49:37,060 --> 01:49:38,740
STUDENT: [INAUDIBLE]

1756
01:49:38,740 --> 01:49:40,170
DAVID MALAN: Sorry?

1757
01:49:40,170 --> 01:49:42,360
I think we just keep following our instructions.

1758
01:49:42,360 --> 01:49:43,650
Sort the left half.

1759
01:49:43,650 --> 01:49:45,630
All right, here is a list of size 1.

1760
01:49:45,630 --> 01:49:48,417
How do I sort a list of size 1?

1761
01:49:48,417 --> 01:49:49,803
STUDENT: [INAUDIBLE]

1762
01:49:49,803 --> 01:49:50,720
DAVID MALAN: I'm done.

1763
01:49:50,720 --> 01:49:51,360
It's done.

1764
01:49:51,360 --> 01:49:52,740
So I leave this alone.

1765
01:49:52,740 --> 01:49:54,740
What was the next step in the story?

1766
01:49:54,740 --> 01:49:58,160
I've just sorted the left half of the left half of the left half.

1767
01:49:58,160 --> 01:49:59,580
What comes next?

1768
01:49:59,580 --> 01:50:06,260
I sort the right half of the left half of the left half, and I'm done, because it's just a list of size 1.

1769
01:50:06,260 --> 01:50:09,280
What comes after this?

1770
01:50:09,280 --> 01:50:09,972
Merge.

1771
01:50:09,972 --> 01:50:16,187
So this is where it gets a little trippy, because you have to remember where we're pausing the story to do things recursively again and again.

1772
01:50:16,187 --> 01:50:20,890
But if I've just sorted the left half and I've just sorted the right half, now I merge them together.

1773
01:50:20,890 --> 01:50:25,040
This is a super short list, so we don't need Carter's help here as before.

1774
01:50:25,040 --> 01:50:27,640
But I think the first number I take here is the 2.

1775
01:50:27,640 --> 01:50:31,660
And then the second number I take, because it's the only option, is the 7.

1776
01:50:31,660 --> 01:50:40,270
But what's nice now is that, notice, the left half of the left half is indeed sorted, because I trivially sorted the left half of it and the right half of it.

1777
01:50:40,270 --> 01:50:42,760
But then merging is really where the magic happens.

1778
01:50:42,760 --> 01:50:51,300
All right, again, if you rewind now in your mind, if I've just sorted the left half of the left half, what happens next?

1779
01:50:51,300 --> 01:50:55,000
Sort the right half of the left half.

1780
01:50:55,000 --> 01:50:56,980
So again, you kind of rewind in time.

1781
01:50:56,980 --> 01:50:58,290
So how do I do this?

1782
01:50:58,290 --> 01:50:59,520
I've got a list of size 2.

1783
01:50:59,520 --> 01:51:01,920
I sort the left half, just the 5, done.

1784
01:51:01,920 --> 01:51:04,200
Sort the right half, 4, done.

1785
01:51:04,200 --> 01:51:11,380
Now the interesting part, I merge the left half and the right half of the right half of the left half.

1786
01:51:11,380 --> 01:51:12,450
So what do I do?

1787
01:51:12,450 --> 01:51:14,280
4 comes down here.

1788
01:51:14,280 --> 01:51:16,260
5 comes down here.

1789
01:51:16,260 --> 01:51:19,860
And now, notice what I have.

1790
01:51:19,860 --> 01:51:21,600
Left half is sorted.

1791
01:51:21,600 --> 01:51:23,130
Right half is sorted.

1792
01:51:23,130 --> 01:51:26,610
If you rewind in time, where is my next step, 3?

1793
01:51:26,610 --> 01:51:27,742
Merge the two halves.

1794
01:51:27,742 --> 01:51:29,700
And so this is what Carter helped me do before.

1795
01:51:29,700 --> 01:51:32,665
Let's focus only on the smallest elements, just so there's less distraction.

1796
01:51:32,665 --> 01:51:34,020
I compare the 2 and the 4.

1797
01:51:34,020 --> 01:51:36,520
2 comes first, so let's obviously put that here.

1798
01:51:36,520 --> 01:51:41,280
Now, I compare the new beginning of this list and the old beginning of this list.

1799
01:51:41,280 --> 01:51:43,050
4 obviously comes next.

1800
01:51:43,050 --> 01:51:45,940
And now, I compare the 7 against the 5.

1801
01:51:45,940 --> 01:51:47,430
5 obviously comes next.

1802
01:51:47,430 --> 01:51:49,240
And now, lastly, I'm left with one number.

1803
01:51:49,240 --> 01:51:50,970
So now I'm down to the 7.

1804
01:51:50,970 --> 01:51:58,260
So even if you've kind of lost track of some of the nuances here, if you just kind of take a step back, we have the original right half here still untouched.

1805
01:51:58,260 --> 01:52:08,940
But the left half of the original input is now, indeed, sorted, all by way of doing sorting left half, right half, left half, right half, but with those merges in between.

1806
01:52:08,940 --> 01:52:13,590
All right, so if we've just sorted the left half, we rewind all the way to the beginning.

1807
01:52:13,590 --> 01:52:15,590
What do I now do?

1808
01:52:15,590 --> 01:52:17,120
All right, so sort the right half.

1809
01:52:17,120 --> 01:52:18,410
So sort the right half.

1810
01:52:18,410 --> 01:52:20,180
How do I sort a list of size 4?

1811
01:52:20,180 --> 01:52:22,550
Well, I first sort the left half, the 1 and the 6.

1812
01:52:22,550 --> 01:52:24,560
How do I sort a list of size 2?

1813
01:52:24,560 --> 01:52:26,757
You sort the left half, just the number 1.

1814
01:52:26,757 --> 01:52:28,340
Obviously, there's no work to be done.

1815
01:52:28,340 --> 01:52:30,620
Done, sorting the left half.

1816
01:52:30,620 --> 01:52:33,080
6, done, sorting the right half.

1817
01:52:33,080 --> 01:52:34,280
Now, what do I do?

1818
01:52:34,280 --> 01:52:40,610
I merge the left half here with the right half here.

1819
01:52:40,610 --> 01:52:42,240
And that one's pretty straightforward.

1820
01:52:42,240 --> 01:52:43,050
Now, what do I do?

1821
01:52:43,050 --> 01:52:43,910
I've just merged.

1822
01:52:43,910 --> 01:52:45,048
So now I sort it.

1823
01:52:45,048 --> 01:52:47,090
I've just sorted the left half of the right half.

1824
01:52:47,090 --> 01:52:49,550
So now I sort the right half of the right half.

1825
01:52:49,550 --> 01:52:51,590
So I consider the 0, done.

1826
01:52:51,590 --> 01:52:53,270
I consider the 3, done.

1827
01:52:53,270 --> 01:52:55,040
I now merge these two together.

1828
01:52:55,040 --> 01:52:56,640
0, of course, comes first.

1829
01:52:56,640 --> 01:52:58,100
Then comes the 3.

1830
01:52:58,100 --> 01:53:00,680
And now I'm at the point of the story where

1831
01:53:00,680 --> 01:53:04,910
I've sorted the left half of the right half and the right half of the right half.

1832
01:53:04,910 --> 01:53:07,535
So step 3 is merge.

1833
01:53:07,535 --> 01:53:09,410
And I'll do it again like we did with Carter.

1834
01:53:09,410 --> 01:53:12,320
All right, 1 and 0, obviously the 0 comes first.

1835
01:53:12,320 --> 01:53:14,390
Now, compare the 1 and the 3.

1836
01:53:14,390 --> 01:53:16,130
Obviously, the 1 comes first.

1837
01:53:16,130 --> 01:53:18,590
Compare the 6 and the 3, obviously the 3.

1838
01:53:18,590 --> 01:53:20,300
And then lastly, the 6.

1839
01:53:20,300 --> 01:53:21,890
So now, where are we?

1840
01:53:21,890 --> 01:53:26,840
We've taken the left half of the whole thing and sorted it.

1841
01:53:26,840 --> 01:53:29,990
We then took the right half of the whole thing and sorted it.

1842
01:53:29,990 --> 01:53:33,560
So now we're at, lastly, step 3 for the last time.

1843
01:53:33,560 --> 01:53:35,120
What do we do?

1844
01:53:35,120 --> 01:53:35,780
Merge.

1845
01:53:35,780 --> 01:53:40,220
And so just to be consistent, let me push these down, and let's compare.

1846
01:53:40,220 --> 01:53:45,230
Left hand or right hand, noticing that they only make forward progress, none of this back and forth comparisons.

1847
01:53:45,230 --> 01:53:47,270
2 and 0, of course, the 0.

1848
01:53:47,270 --> 01:53:48,860
So we'll put that in place.

1849
01:53:48,860 --> 01:53:51,140
2 and 1, of course, the 1.

1850
01:53:51,140 --> 01:53:52,880
So we put that in place.

1851
01:53:52,880 --> 01:53:56,930
2 and 3, we merge in, of course, the 2 in this case.

1852
01:53:56,930 --> 01:54:00,770
4 and 3, we now merge in the 3 in this case.

1853
01:54:00,770 --> 01:54:05,630
4 and 6, we now merge, of course, the 4 in place.

1854
01:54:05,630 --> 01:54:07,760
And now, we compare 5 and 6.

1855
01:54:07,760 --> 01:54:08,615
We keep the 5.

1856
01:54:12,590 --> 01:54:15,226
Bug.

1857
01:54:15,226 --> 01:54:17,295
OK, well pretend that the 5 is on.

1858
01:54:20,040 --> 01:54:21,450
Oh, this is why.

1859
01:54:21,450 --> 01:54:24,240
All right, so now we compare the 7 and the 6.

1860
01:54:24,240 --> 01:54:26,430
6th is gone.

1861
01:54:26,430 --> 01:54:29,520
And lastly, 7 is the last one in place.

1862
01:54:29,520 --> 01:54:36,210
And even though I grant that of all the algorithms, this is probably the hardest one to stay on top of, especially when I'm doing it as a voice over.

1863
01:54:36,210 --> 01:54:41,010
Realize that what we've just done is only those three steps, recursively.

1864
01:54:41,010 --> 01:54:42,510
We started with a list of size 8.

1865
01:54:42,510 --> 01:54:43,650
We sorted the left half.

1866
01:54:43,650 --> 01:54:44,790
We sorted the right half.

1867
01:54:44,790 --> 01:54:46,450
And then we merge the two together.

1868
01:54:46,450 --> 01:54:54,970
But if you go down each of those rabbit holes, so to speak, sorting the left half involves sorting the left half of the left half and the right half of the left half, and so forth.

1869
01:54:54,970 --> 01:55:02,520
But this germ of an idea of really dividing and conquering the problem, not such that you're having the problem and only dealing with one half.

1870
01:55:02,520 --> 01:55:07,780
Clearly, we're sorting one half and the other half and merging them together, ultimately.

1871
01:55:07,780 --> 01:55:10,810
It does still lead us to the same solution.

1872
01:55:10,810 --> 01:55:20,310
And if we visualize the remnants of this now, if I depict this as follows, where on the screen here, you see where the numbers originally started in the top row from left to right.

1873
01:55:20,310 --> 01:55:23,470
Essentially, even though this is in a different order,

1874
01:55:23,470 --> 01:55:28,708
I divided that list of size 8, ultimately, into eight lists of size 1.

1875
01:55:28,708 --> 01:55:31,000
And that's where the base case kicked in and just said,

1876
01:55:31,000 --> 01:55:32,580
OK, we're done sorting that.

1877
01:55:32,580 --> 01:55:41,580
And after that, logically, I then merged two lists of size 1 into many lists of size 2 and those lists of size 2 into lists of size 4.

1878
01:55:41,580 --> 01:55:47,250
And then finally, the list of size 4 into one big list sorted of size 8.

1879
01:55:47,250 --> 01:55:55,620
And so I put forth this picture with the little line indicators here, because how many times did I divide, divide, divide in half?

1880
01:55:55,620 --> 01:55:57,360
Or really double, double, double.

1881
01:55:57,360 --> 01:56:00,600
So exponent is the opposite-- spoiler.

1882
01:56:00,600 --> 01:56:02,610
How many times did I divide?

1883
01:56:02,610 --> 01:56:04,320
So three, concretely.

1884
01:56:04,320 --> 01:56:12,300
But if there's eight elements total, and there's n more generally, it really is a matter of dividing and conquering log n times.

1885
01:56:12,300 --> 01:56:15,360
You start this, and you can divide one, two, three times, log n times.

1886
01:56:15,360 --> 01:56:21,060
Or conversely, you can start here and exponentially double, double, double three times, which is log n.

1887
01:56:21,060 --> 01:56:31,380
But on every row, every shelf, literally, I made a fuss about pointing my hands only from the left to the right, constantly advancing them, such that every time I did those merges,

1888
01:56:31,380 --> 01:56:34,500
I touched every element once and only once.

1889
01:56:34,500 --> 01:56:37,470
There was none of this back and forth, back and forth on stage.

1890
01:56:37,470 --> 01:56:51,057
So if I'm doing something log n times, or if I'm doing, rather, n things log n times, what would be our big O formula, perhaps? n things log n times?

1891
01:56:51,057 --> 01:56:52,140
STUDENT: Oh, it's n log n.

1892
01:56:52,140 --> 01:56:53,490
DAVID MALAN: Yeah, so n log n.

1893
01:56:53,490 --> 01:56:58,560
The order of n log n is, indeed, how we would describe the running time of merge sort.

1894
01:56:58,560 --> 01:57:10,650
And so of all of the sorts thus far, we've seen that merge sort here, actually, is n log n, which is strictly better than n squared, which is where both selection sort and bubble sort landed.

1895
01:57:10,650 --> 01:57:14,015
But it's also slower than linear search, for instance.

1896
01:57:14,015 --> 01:57:15,390
But you would rather expect that.

1897
01:57:15,390 --> 01:57:21,670
If you have to do a lot of work up front sorting some elements versus just searching them, you're going to have to put in more effort.

1898
01:57:21,670 --> 01:57:30,327
And so the question of whether or not you should just search something blindly with linear search and not bother sorting it, really boils down to, can you afford to spend this amount of time?

1899
01:57:30,327 --> 01:57:35,170
And if you're the Googles of the world, odds are you don't want to be searching their database linearly every time.

1900
01:57:35,170 --> 01:57:35,670
Why?

1901
01:57:35,670 --> 01:57:43,560
Because you can sort it once and then benefit millions, billions of people, subsequently using something like binary search or, frankly in practice,

1902
01:57:43,560 --> 01:57:46,443
something even fancier and faster than binary search.

1903
01:57:46,443 --> 01:57:48,360
But there's always going to be this trade off.

1904
01:57:48,360 --> 01:57:52,140
You can achieve binary search only if the elements are sorted.

1905
01:57:52,140 --> 01:57:53,940
How much does it cost you to sort them?

1906
01:57:53,940 --> 01:57:56,940
Well, maybe n squared, if you used some of the earlier algorithms.

1907
01:57:56,940 --> 01:58:00,850
But it turns out, n log in is pretty fast as well.

1908
01:58:00,850 --> 01:58:06,180
So at the end of the day, these running times involve trade offs.

1909
01:58:06,180 --> 01:58:12,090
And indeed, in merge sort 2, I should note that the lower bound on merge sort is also going to be omega of n log n.

1910
01:58:12,090 --> 01:58:18,030
As such, we can describe it in terms of our theta notation, saying that merge sort is, indeed, in theta of n log n.

1911
01:58:18,030 --> 01:58:24,030
So generally speaking, probably better to use something like merge sort or some other algorithm that's n log n.

1912
01:58:24,030 --> 01:58:28,200
In practice, most programmers are not implementing these sorting algorithms themselves.

1913
01:58:28,200 --> 01:58:34,200
Odds are, they're using a library off the shelf that themselves have made the decision as to which of these algorithms to do.

1914
01:58:34,200 --> 01:58:42,750
But generally speaking, and we're seeing now this for the first time, if you want to improve time, like use less time, write faster code, you've got to pay a price.

1915
01:58:42,750 --> 01:58:49,080
And that might be your human time, just takes you more time to code up something more sophisticated, more difficult to implement.

1916
01:58:49,080 --> 01:58:51,840
Or you need to spend something like space.

1917
01:58:51,840 --> 01:58:55,740
And as these shelves suggest, that too is one of the key details of merge sort.

1918
01:58:55,740 --> 01:58:58,500
You can't just have the elements swapping in place.

1919
01:58:58,500 --> 01:59:03,960
You need at least an auxiliary array, so that when you do the merging, you have a place to put them.

1920
01:59:03,960 --> 01:59:05,988
And this is excessive, this amount of memory.

1921
01:59:05,988 --> 01:59:09,030
I could have just gone back and forth between top shelf and bottom shelf.

1922
01:59:09,030 --> 01:59:11,113
But it's a little more interesting to go top down.

1923
01:59:11,113 --> 01:59:12,870
But you do need more space.

1924
01:59:12,870 --> 01:59:15,605
Back in the day, decades ago, space was really expensive.

1925
01:59:15,605 --> 01:59:16,480
And so you know what?

1926
01:59:16,480 --> 01:59:23,230
It might have been better to not use merge sort, use bubble sort or selection sort even, or some other algorithm altogether.

1927
01:59:23,230 --> 01:59:25,300
Nowadays, space is relatively cheap.

1928
01:59:25,300 --> 01:59:27,160
And so these are more acceptable trade offs.

1929
01:59:27,160 --> 01:59:29,650
But it totally depends on the application.

1930
01:59:29,650 --> 01:59:34,450
The very last thing we thought we'd do is show you an actual comparison of some of these sorting algorithms.

1931
01:59:34,450 --> 01:59:35,800
It's about 60 seconds long.

1932
01:59:35,800 --> 01:59:46,570
And it will compare for you, selection sort, bubble sort, and merge sort in parallel simultaneously with some fun sorting music, showing you ultimately what it really

1933
01:59:46,570 --> 01:59:52,750
means to be an O of n squared, or better yet, big O of n log n.

1934
01:59:52,750 --> 01:59:54,850
Selection on the top.

1935
01:59:54,850 --> 01:59:58,050
Bubble on the bottom.

1936
01:59:58,050 --> 01:59:59,400
Merge in the middle.

1937
01:59:59,400 --> 02:00:01,885
[MUSIC PLAYING]

1938
02:00:53,660 --> 02:00:55,700
All right, that's it for CS50.

1939
02:00:55,700 --> 02:00:57,910
We'll see you next time.

