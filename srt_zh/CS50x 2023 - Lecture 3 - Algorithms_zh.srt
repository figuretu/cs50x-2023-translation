3
00:01:12,660 --> 00:01:15,420
戴维-马兰：好的，这是 CS50。

4
00:01:15,420 --> 00:01:21,400
现在已经是第 3 周了，我们将回顾一下第 0 周的情况。

5
00:01:21,400 --> 00:01:24,930
回顾第 0 周，从某种意义上说，一切都非常直观。

6
00:01:24,930 --> 00:01:28,000
我们谈论的不仅仅是信息的表示，还有算法。

7
00:01:28,000 --> 00:01:30,450
我们还讨论了一遍又一遍撕电话簿的事。

8
00:01:30,450 --> 00:01:32,860
这让我们找到了更好的解决办法。

9
00:01:32,860 --> 00:01:41,650
但今天，我们将尝试开始将其中的一些想法正规化，并捕捉其中的一些相同想法，但还不是用伪代码，而是用实际代码。

10
00:01:41,650 --> 00:01:48,372
但我们也会考虑这些算法的效率，比如我们的算法究竟有多好，设计得有多完善。

11
00:01:48,372 --> 00:01:56,460
如果你还记得，当我们做电话簿的例子时，我首先让算法一次搜索一页，然后是第二次，一次搜索两页，然后是第三次、

12
00:01:56,460 --> 00:02:01,900
我们开始把它撕成两半，记得我们一挥手，对它进行了如下分析。

13
00:02:01,900 --> 00:02:11,430
我们建议，如果这里的 x 轴是问题的大小，如电话簿的页数，y 轴是解决问题所需的时间，以秒、分钟为单位、

14
00:02:11,430 --> 00:02:19,620
不管你的计量单位是什么，请记住，第一种算法是这样的直线：如果你的电话簿有 n 页，它的斜率可能是 n------------。

15
00:02:19,620 --> 00:02:23,280
页数和眼泪之间是一一对应的关系。

16
00:02:23,280 --> 00:02:33,570
当然，一次翻两页的速度是原来的两倍，但形状还是一样，这里的黄线表示，是的，超过 2 页，如果要翻两页，可能还要加 1 页，就像我们讨论过的那样。

17
00:02:33,570 --> 00:02:38,370
但从根本上说，每次一到两页的算法还是一样的。

18
00:02:38,370 --> 00:02:45,660
但第三种算法，请回想一下，就是这个绿色的算法，我们根据它的快慢称之为对数算法。

19
00:02:45,660 --> 00:02:53,280
事实上，这种算法的含义是，我们甚至可以把电话簿的大小增加一倍，而且没什么大不了的--多撕一页、

20
00:02:53,280 --> 00:02:55,990
而我们的电话簿又被翻了 1000 页。

21
00:02:55,990 --> 00:03:01,530
因此，今天我们将重温其中的一些想法，将其形式化，并最终将其中的一些想法转化为代码。

22
00:03:01,530 --> 00:03:07,600
而现在这一切之所以成为可能，是因为我们对电脑内部的实际情况有了较低层次的了解。

23
00:03:07,600 --> 00:03:10,170
当然，这就是电脑的 RAM 或内存。

24
00:03:10,170 --> 00:03:15,420
回想一下，如果我们开始将其抽象化，那么电脑内存实际上就是一个由字节组成的网格。

25
00:03:15,420 --> 00:03:17,730
事实上，我们不必再看硬件了。

26
00:03:17,730 --> 00:03:27,460
我们看到的是这样一个字节网格，其中每个字节都可以用来存储一个 char、一个 int、一个 long，甚至整个字符串。

27
00:03:27,460 --> 00:03:34,830
不过，让我们把重点放在其中的一个子集上，因为上周我们强调了数组、在数组中存储东西。

28
00:03:34,830 --> 00:03:44,770
这样，我们就可以开始存储整个字符串、字符序列，甚至整数数组（如果我们想要多个整数数组，而不仅仅是多个变量）。

29
00:03:44,770 --> 00:03:53,850
但问题是，如果你查看计算机内存中的数组内部--例如，假设这里存储的是这些整数--我们人类很容易就能瞥见以下内容

30
00:03:53,850 --> 00:03:55,698
并立即找到数字 50。

31
00:03:55,698 --> 00:03:59,700
从你所在的位置可以鸟瞰屏幕上的一切。

32
00:03:59,700 --> 00:04:02,500
因此，如何得出 50 这个数字是显而易见的。

33
00:04:02,500 --> 00:04:06,720
但在计算机世界里，这当然是硬件的问题。

34
00:04:06,720 --> 00:04:10,440
而现在的计算机一次只能做一件事。

35
00:04:10,440 --> 00:04:14,820
他们不可能把一切都看在眼里，然后马上找到一个类似 50 的数字。

36
00:04:14,820 --> 00:04:22,500
因此，一个恰当的比喻也许是把计算机内部的内存阵列看作是一连串紧闭的门。

37
00:04:22,500 --> 00:04:30,730
如果计算机要查找数组中的某个值，就必须用数字方式逐个打开这些门。

38
00:04:30,730 --> 00:04:32,410
代码如何做到这一点？

39
00:04:32,410 --> 00:04:39,900
当然，上周我们介绍了索引或指数，按照惯例，我们将数组的第一个元素称为位置 0、

40
00:04:39,900 --> 00:04:45,150
第二个位置 1，第三个位置 2，以此类推--即所谓的 0 索引。

41
00:04:45,150 --> 00:04:51,510
这样，我们就可以将内存中的概念世界与实际代码连接起来，因为现在我们有了这个方括号

42
00:04:51,510 --> 00:04:55,710
如果我们愿意，可以通过这个句法去寻找一些东西。

43
00:04:55,710 --> 00:05:07,170
事实证明，如果我现在把这些颜色涂成红色而不是黄色，我们就会发现，这里其实有一个很好的物理隐喻，就像计算机的内存阵列一样

44
00:05:07,170 --> 00:05:10,390
例如，如果您要存储这样的七个数字。

45
00:05:10,390 --> 00:05:13,710
因此，今天我们首先来看看一种特殊的算法。

46
00:05:13,710 --> 00:05:14,910
那是用来搜索的。

47
00:05:14,910 --> 00:05:16,270
到处都在搜索。

48
00:05:16,270 --> 00:05:21,090
我们每个人每天都可能多次访问 google.com 或类似网站。

49
00:05:21,090 --> 00:05:25,110
而像谷歌这样的公司最擅长的就是快速回复。

50
00:05:25,110 --> 00:05:26,700
他们是怎么做到的？

51
00:05:26,700 --> 00:05:29,882
它们是如何在计算机内存中存储信息的？

52
00:05:29,882 --> 00:05:31,590
好吧，让我们想想这到底是什么。

53
00:05:31,590 --> 00:05:34,500
这其实和第 0 周时的问题一样。

54
00:05:34,500 --> 00:05:38,253
不过，就目前而言，解决问题的方法可能就是这 7 个储物柜。

55
00:05:38,253 --> 00:05:40,920
这就是问题的输入，里面是一个数字。

56
00:05:40,920 --> 00:05:51,250
也许为了简单起见，我们现在只需要一个 "是/否"、"真/假 "的答案，也就是一个 bool，表示数组中是否有类似 50 这样的数字。

57
00:05:51,250 --> 00:05:52,680
它不像谷歌那样花哨。

58
00:05:52,680 --> 00:05:55,500
这不只是告诉你，是的，我们有搜索结果。

59
00:05:55,500 --> 00:05:57,300
实际上，它能提供搜索结果。

60
00:05:57,300 --> 00:06:06,090
不过，现在我们还是简单点，只要在输入数组时输出是或否、真或假，我们就能找到要找的数字。

61
00:06:06,090 --> 00:06:12,385
但事实证明，在我们不断回到的这个黑盒子里，存在着各种可能的算法。

62
00:06:12,385 --> 00:06:15,860
我们在第 0 周用电话簿从概念上讨论了这个问题。

63
00:06:15,860 --> 00:06:22,648
但今天，让我们通过你们中的一些人可能从小玩过的一种游戏，即大富翁，来更具体地思考这个问题。

64
00:06:22,648 --> 00:06:26,800
原来，在这些门后面，还藏着一些面值的垄断货币。

65
00:06:26,800 --> 00:06:28,690
但为此，我们现在有两名志愿者。

66
00:06:28,690 --> 00:06:30,483
如果您想向世界问好？

67
00:06:30,483 --> 00:06:31,525
嗨，我是杰克逊

68
00:06:35,440 --> 00:06:37,220
你好，我叫斯蒂芬妮。

69
00:06:37,220 --> 00:06:40,570
你们想说说自己的情况吗？ 年纪、房子、宿舍？

70
00:06:40,570 --> 00:06:43,030
我是住在马修斯的一年级学生。

71
00:06:43,030 --> 00:06:43,780
很好。

72
00:06:43,780 --> 00:06:45,580
翟克森：我在加拿大读一年级。

73
00:06:45,580 --> 00:06:46,330
很好。

74
00:06:46,330 --> 00:06:48,670
欢迎两位志愿者。

75
00:06:48,670 --> 00:06:50,710
那我们为什么不这样做呢？

76
00:06:50,710 --> 00:06:54,460
你们中的一位愿意自愿让另一位先走吗？

77
00:06:54,460 --> 00:06:55,510
我去吧

78
00:06:55,510 --> 00:06:56,560
大卫-马兰：好的。

79
00:06:56,560 --> 00:06:58,300
好了，斯蒂芬妮先来。

80
00:06:58,300 --> 00:07:02,560
在其中一扇门后面 我们藏了50美元的垄断奖金

81
00:07:02,560 --> 00:07:04,180
因此，我们希望你们能找到这 50 个。

82
00:07:04,180 --> 00:07:06,490
关于储物柜，我们就不多说了。

83
00:07:06,490 --> 00:07:08,900
但我们希望你执行某种算法。

84
00:07:08,900 --> 00:07:11,020
事实上，我会给你一些相关的伪代码。

85
00:07:11,020 --> 00:07:12,770
我给你起个名字。

86
00:07:12,770 --> 00:07:13,900
这就是所谓的线性搜索。

87
00:07:13,900 --> 00:07:17,980
顾名思义，你最终会走成一条直线。

88
00:07:17,980 --> 00:07:19,220
但你打算怎么做呢？

89
00:07:19,220 --> 00:07:23,170
好吧，让我来提议一下，你的第一步将是像循环一样思考。

90
00:07:23,170 --> 00:07:27,280
对于从左到右的每扇门，我们希望您在每次迭代时做什么？

91
00:07:27,280 --> 00:07:33,070
好吧，如果 50 就在那扇门后面，那么我们想让你返回 true。

92
00:07:33,070 --> 00:07:35,860
如果你愿意，还可以骄傲地为大家举起这 50 块钱。

93
00:07:35,860 --> 00:07:42,640
否则，如果你绕了一圈还没找到数字 50，你就只能失望地举起双手了。

94
00:07:42,640 --> 00:07:45,190
错--你没有找到数字 50。

95
00:07:45,190 --> 00:07:50,293
因此，为了明确起见，第一步要从左到右逐个检查每扇门。

96
00:07:50,293 --> 00:07:51,460
您想如何开始？

98
00:07:56,495 --> 00:07:57,840
哦，然后 - 是的。

99
00:07:57,840 --> 00:07:58,340
好了

101
00:08:00,365 --> 00:08:04,040
如果你想至少告诉 - 好，好演技在这里。

102
00:08:04,040 --> 00:08:06,140
你发现了什么？

103
00:08:06,140 --> 00:08:07,970
不是50，是20。

104
00:08:07,970 --> 00:08:08,900
哦，好的。

105
00:08:08,900 --> 00:08:10,280
所以第一步是失败的。

106
00:08:10,280 --> 00:08:11,870
下面我们进入第二步。

107
00:08:11,870 --> 00:08:14,453
在这个循环中，你下一步要做什么？

108
00:08:14,453 --> 00:08:16,370
我要搬到隔壁去了

109
00:08:16,370 --> 00:08:17,037
大卫-马兰：好的。

110
00:08:20,790 --> 00:08:22,100
差不多了

111
00:08:22,100 --> 00:08:23,100
好吧，差不多。

113
00:08:23,790 --> 00:08:25,110
换成 500。

114
00:08:25,110 --> 00:08:26,280
下一个储物柜？

115
00:08:26,280 --> 00:08:30,200
我宁可要那个

117
00:08:33,840 --> 00:08:36,558
大卫-马兰：好吧，我们不告诉观众？

118
00:08:36,558 --> 00:08:38,260
是10分

119
00:08:38,260 --> 00:08:39,789
大卫-马兰：好的，继续。

120
00:08:39,789 --> 00:08:40,974
现在是第三步。

121
00:08:45,470 --> 00:08:46,310
天啊

122
00:08:49,850 --> 00:08:51,260
五，好的。

123
00:08:51,260 --> 00:08:52,670
还要检查几个储物柜

124
00:08:57,296 --> 00:08:58,790
有点难过 伙计们

125
00:09:02,527 --> 00:09:04,360
好的，倒数第二步。

126
00:09:07,710 --> 00:09:09,070
是1。

127
00:09:09,070 --> 00:09:10,022
有点接近。

128
00:09:10,022 --> 00:09:10,980
好的。

129
00:09:10,980 --> 00:09:12,780
最后，最后一步。

130
00:09:12,780 --> 00:09:15,780
很明显，你可能是被人陷害的。

131
00:09:15,780 --> 00:09:17,340
我们走吧

132
00:09:17,340 --> 00:09:19,920
大卫-马兰：好吧，那么数字 50。

133
00:09:23,500 --> 00:09:25,870
斯蒂芬妮，请允许我问你一个问题。

134
00:09:25,870 --> 00:09:28,890
在屏幕上，这就是你刚刚执行的伪代码。

135
00:09:28,890 --> 00:09:34,770
不过，假设我做了很多人在遇到 "如果 "时都会做的事。

136
00:09:34,770 --> 00:09:36,730
您通常还有一个分支。

137
00:09:36,730 --> 00:09:38,760
假如我现在这样做了。

138
00:09:38,760 --> 00:09:41,680
我把它标成红色，以明确这是错误的。

139
00:09:41,680 --> 00:09:47,040
但是，您觉得这段代码使用 if 和 else 会有什么不好呢？

140
00:09:47,040 --> 00:09:48,360
有什么直觉吗？

141
00:09:55,620 --> 00:10:00,210
那你就会在找到那 50 块钱之前取消密码。

142
00:10:00,210 --> 00:10:01,020
是的，没错。

143
00:10:01,020 --> 00:10:02,070
我是说 你会永远伤心的

144
00:10:02,070 --> 00:10:02,460
确实如此。

145
00:10:02,460 --> 00:10:05,127
当斯蒂芬妮打开第一个储物柜时，她会发现有 20 个。

146
00:10:05,127 --> 00:10:06,630
20 当然不是 50。

147
00:10:06,630 --> 00:10:07,838
她会判定是假的。

148
00:10:07,838 --> 00:10:10,547
当然，她还没有检查过其他所有的储物柜。

149
00:10:10,547 --> 00:10:18,810
因此，这似乎是一个关键的细节，在这个伪代码的实现中，我们实际上是通过--就像我们所做的那样--只返回 false，而不返回 else、

150
00:10:18,810 --> 00:10:25,245
但只是在循环的末尾，这样我们只有在没有返回 true 之前才会到达该行。

151
00:10:25,245 --> 00:10:26,620
好吧，让我们开始吧。

152
00:10:26,620 --> 00:10:27,360
让我接过你手中的麦克风。

153
00:10:27,360 --> 00:10:28,930
你想坐在杰克逊旁边吗？

154
00:10:28,930 --> 00:10:31,180
杰克逊，等一下，我们会请你上来。

155
00:10:31,180 --> 00:10:34,170
卡特 如果你不介意的话 帮我们整理一下储物柜

156
00:10:34,170 --> 00:10:38,010
但与此同时，请允许我指出，我们现在可以如何将同样的想法转化为代码。

157
00:10:38,010 --> 00:10:44,910
这个伪代码相当高级，相当面向英语--但实际上，从上周开始，我们已经有了语法，通过它，斯蒂芬妮

158
00:10:44,910 --> 00:10:51,250
很快，杰克逊就可以使用括号符号将这个储物柜、这组储物柜视为一个数组。

159
00:10:51,250 --> 00:10:54,480
因此，我们现在可以在伪代码中更接近实际代码了。

160
00:10:54,480 --> 00:11:03,720
举例来说，计算机科学家会把像这样相当高级的英语伪代码翻译成更接近 C 语言或其他语言的东西

161
00:11:03,720 --> 00:11:06,600
支持数组的程序会更隐蔽一些，就像这样。

162
00:11:06,600 --> 00:11:09,060
但在接下来的日子里，你们会看到更多这样的句法。

163
00:11:09,060 --> 00:11:13,260
对于从 0 到 n 减 1 的 i -- 这仍然是伪代码。

164
00:11:13,260 --> 00:11:17,730
但这是我们所熟知的 for 循环的英语表达方式。

165
00:11:17,730 --> 00:11:26,503
为了便于讨论，我假设 doors 是我的变量名，也就是这个由七扇门组成的数组。

166
00:11:26,503 --> 00:11:30,370
但其余的逻辑、其余的伪代码其实都是一样的。

167
00:11:30,370 --> 00:11:40,170
因此你会发现，当你开始向别人表达想法和算法时，程序员和计算机科学家一般都会在这个层面上进行操作，而不是在这里、

168
00:11:40,170 --> 00:11:47,380
你现在有了一个新词汇，实际上是一种新的语法，你可以写得更具体一些，而不至于陷入编写实际 C 代码的困境、

169
00:11:47,380 --> 00:11:51,810
但至少现在做的事情更接近于像这样操作一个数组。

170
00:11:51,810 --> 00:11:55,140
杰克逊，你想站起来吗？

173
00:11:57,360 --> 00:11:59,010
这里也支持杰克逊。

175
00:12:00,780 --> 00:12:04,470
现在，我允许你做一个斯蒂芬妮没有的假设。

176
00:12:04,470 --> 00:12:10,050
很明显，斯蒂芬妮在使用线性搜索（我们现在称之为 "线性搜索"）从左到右进行搜索时，确实做到了最好。

177
00:12:10,050 --> 00:12:12,180
但它们的顺序很随意，不是吗？

178
00:12:12,180 --> 00:12:15,030
那边是 20，那边是 1，然后是 50。

179
00:12:15,030 --> 00:12:19,110
因此，我们故意把事情弄得一团糟，没有为她把数字分类。

180
00:12:19,110 --> 00:12:24,510
但卡特好心上来帮你一把，杰克逊，提前把数字分类。

181
00:12:24,510 --> 00:12:32,250
这次，我们希望你们能像第 0 周一样，反复做一些事情，但这次我们称之为二进制搜索。

182
00:12:32,250 --> 00:12:35,580
在概念上，这与第 0 周的算法完全相同。

183
00:12:35,580 --> 00:12:40,450
但是，如果我们把它转换到这个数组的上下文中，我们现在就可以这样说了。

184
00:12:40,450 --> 00:12:48,570
杰克逊的第一步可能是问一个问题 -- 如果 50 就在中间那扇门后面，那么他应该已经通过心算找出了中间那扇门的位置、

185
00:12:48,570 --> 00:12:50,610
那么他就会返回 true。

186
00:12:50,610 --> 00:12:53,070
希望我们运气好，50 块钱就能到手。

187
00:12:53,070 --> 00:12:58,290
当然，至少还有另外两种可能，是什么呢？

188
00:12:58,290 --> 00:13:01,290
50 是指这些门吗？

189
00:13:01,290 --> 00:13:03,930
是的，向左或向右，交替进行。

190
00:13:03,930 --> 00:13:07,722
因此，如果 50 小于中门，那就可以推测、

191
00:13:07,722 --> 00:13:09,180
杰克逊想往左走

192
00:13:09,180 --> 00:13:17,910
否则，如果 50 大于中门，他就会想往右走，就像我上周用电话簿做的那样，从左到右分而治之。

193
00:13:17,910 --> 00:13:20,020
但实际上还有第四种情况。

194
00:13:20,020 --> 00:13:21,540
我们先把它放在黑板上。

195
00:13:21,540 --> 00:13:25,530
杰克逊应该考虑的其他情况是什么？

197
00:13:26,170 --> 00:13:28,590
哦，不在那儿。

198
00:13:28,590 --> 00:13:39,080
所以，让我回去修改一下我的伪代码，就说杰克逊，如果我们不给你任何门，或者最终，在他分裂和征服的过程中，如果他没有门了、

199
00:13:39,080 --> 00:13:42,380
我们必须处理这种情况，以便定义行为。

200
00:13:42,380 --> 00:13:48,650
好吧，既然如此，杰克逊，你是否想继续前进，找到我们的50号，并口头告诉我们你正在做什么和发现什么？

201
00:13:48,650 --> 00:13:52,860
好吧，看来这扇门是中间那扇。

202
00:13:52,860 --> 00:13:55,290
所以我要打开它。

203
00:13:55,290 --> 00:13:57,030
但这是 20，不是 50。

204
00:13:57,030 --> 00:13:59,622
啊

205
00:13:59,622 --> 00:14:01,080
你现在在想什么？

206
00:14:01,080 --> 00:14:06,490
因为50比20高，我想看右边。

207
00:14:06,490 --> 00:14:07,440
很好。

208
00:14:07,440 --> 00:14:10,270
寻找新的中门，就在这里。

209
00:14:10,270 --> 00:14:11,700
很好。

210
00:14:11,700 --> 00:14:13,740
很糟糕

211
00:14:13,740 --> 00:14:16,560
但 50 比 100 少。

212
00:14:16,560 --> 00:14:20,520
现在我们向左看，也就是这里。

214
00:14:21,240 --> 00:14:21,990
很好。

215
00:14:21,990 --> 00:14:25,680
这次也做得很好。

216
00:14:25,680 --> 00:14:29,680
首先，感谢我们的志愿者。

217
00:14:29,680 --> 00:14:36,743
事实上，既然您是大富翁的粉丝，我们也知道，我们有剑桥版的大富翁，里面有您最喜欢的哈佛游戏。

218
00:14:36,743 --> 00:14:37,410
不可能

219
00:14:37,410 --> 00:14:38,460
给你。

220
00:14:38,460 --> 00:14:38,970
谢谢

221
00:14:38,970 --> 00:14:40,095
非常感谢。

222
00:14:40,095 --> 00:14:42,570
戴维-马兰：感谢我们的志愿者为我们找到了 50.

223
00:14:42,570 --> 00:14:46,940
所以，这比我们预想的更受欢迎。

224
00:14:46,940 --> 00:14:52,060
在这里，我们可以再把它翻译成更接近代码的内容。

225
00:14:52,060 --> 00:14:59,380
同样，还是伪代码--但现在，这里可能是杰克逊刚才所做工作的另一种表述，只是使用了数组的术语、

226
00:14:59,380 --> 00:15:04,640
在这种情况下，你可以把指令说得更精确一些，但还是要让别人把这些指令最终翻译成代码。

227
00:15:04,640 --> 00:15:06,640
但在这里，我们一开始就遇到了同样的问题。

228
00:15:06,640 --> 00:15:08,650
如果没有门，则返回 false。

229
00:15:08,650 --> 00:15:19,480
如果 50 在括号中间--所以我在这里假设，因为这是伪代码--我已经在某个地方进行了心算或实际计算，以找出中间的指数是多少。

230
00:15:19,480 --> 00:15:27,310
例如，如果一个数组中有 7 扇门，那么位置就是 0、1、2、3、4、5、6。

231
00:15:27,310 --> 00:15:33,520
于是，我就用门的总数 7 除以 2 来找出中间值。

232
00:15:33,520 --> 00:15:34,430
这是3又1/2。

233
00:15:34,430 --> 00:15:35,680
我们必须处理四舍五入的问题。

234
00:15:35,680 --> 00:15:39,910
但可以说，找到中间指数有一个明确的公式。

235
00:15:39,910 --> 00:15:43,280
将储物柜总数除以 2，然后四舍五入。

236
00:15:43,280 --> 00:15:48,790
所以，杰克逊大概是通过数数或者在脑子里想了想，才找到了 3 号门。

237
00:15:48,790 --> 00:15:52,210
不是第 3 扇门，也不是第 4 扇门，而是 3 号门支架。

238
00:15:52,210 --> 00:15:56,200
也就是说，如果 50 在门后括号中间，则返回 true。

239
00:15:56,200 --> 00:15:57,200
事实并非如此。

240
00:15:57,200 --> 00:15:58,960
他发现了一张 20 美元的钞票。

241
00:15:58,960 --> 00:16:10,660
否则，如果 50 小于门括号中间的数字，那么继续--现在变得有趣了--搜索门 0 到门中间减 1。

242
00:16:10,660 --> 00:16:12,730
所以，现在的情况越来越复杂了。

243
00:16:12,730 --> 00:16:24,340
但如果中间是 3，也就是这里的这个，我们现在要让杰克逊搜索的是，如果 50 是 -- 如果这个数字更小，我们要从 0 号括号开始，一直搜索到这个括号。

244
00:16:24,340 --> 00:16:28,297
我们故意减去 1，因为再看同一个储物柜又有什么意义呢？

245
00:16:28,297 --> 00:16:31,270
我们不妨从 0 到中间减 1。

246
00:16:31,270 --> 00:16:37,120
否则，如果 50 大于门括号的中间值，那我们该怎么办？

247
00:16:37,120 --> 00:16:43,295
于是，杰克逊凭直觉寻找中间加 1 的门，穿过 n 减 1 的门。

248
00:16:43,295 --> 00:16:46,420
老实说，在这里说优点和缺点有点烦人。

249
00:16:46,420 --> 00:16:47,780
但想想这意味着什么吧。

250
00:16:47,780 --> 00:16:49,090
这是中门。

251
00:16:49,090 --> 00:16:56,150
然后，杰克逊又开始搜查中间加 1 号门，因为再搜查这扇门已经没有意义了。

252
00:16:56,150 --> 00:17:05,352
然后，在任何大小为 n 的数组中，最后一个元素总是 n 减 1。

253
00:17:05,352 --> 00:17:06,310
它不会是 n。

254
00:17:06,310 --> 00:17:10,839
它将是 n 减 1，因为我们总是从 0 开始计数数组。

255
00:17:10,839 --> 00:17:16,430
在这里，我们将这个完全相同的想法翻译成了更接近 C 语言的伪代码。

256
00:17:16,430 --> 00:17:18,490
在这里，我们又回到了第 0 周。

257
00:17:18,490 --> 00:17:23,420
在第 0 周，我们可以很直观地想象如何分割和征服这样一个问题。

258
00:17:23,420 --> 00:17:29,920
但是，如果你现在回想一下你的 iPhone、Android 手机或类似设备，当你在进行自动完成和搜索列表时、

259
00:17:29,920 --> 00:17:34,840
如果你没有很多朋友、家人或同事的电话，你知道吗？

260
00:17:34,840 --> 00:17:40,720
线性搜索，只检查要搜索的人的每一个名字，可能完全没问题。

261
00:17:40,720 --> 00:17:47,770
但是，你的手机很可能比这更聪明，尤其是当你的联系人数年来增加到几十、几百、几千人的时候。

262
00:17:47,770 --> 00:17:49,540
有什么比线性搜索更好？

263
00:17:49,540 --> 00:17:51,340
嗯，也许是二进制搜索。

264
00:17:51,340 --> 00:17:55,180
但是，但是，但是 - 有一个假设，一个要求，这是什么？

265
00:17:55,180 --> 00:18:04,830
为什么杰克逊最终只用了三步就找到了 50，而不是像斯蒂芬妮那样用了整整七步？

266
00:18:04,830 --> 00:18:06,570
因为数组已排序。

267
00:18:06,570 --> 00:18:09,990
所以，这只是一个预告，我们今天晚些时候还要继续讨论。

268
00:18:09,990 --> 00:18:12,780
那么，像卡特这样的人需要付出多少努力呢？

269
00:18:12,780 --> 00:18:17,040
你的手机要花费多少精力才能提前将这些名字和号码分类？

270
00:18:17,040 --> 00:18:19,650
因为也许这实际上不值得花那么多时间。

271
00:18:19,650 --> 00:18:24,210
现在，像谷歌这样的公司可能会以某种方式对网页数据库进行分类。

272
00:18:24,210 --> 00:18:32,280
你可以想象一下，当你在 google.com 上输入猫或其他东西时，如果他们对整个数据集进行线性搜索，速度会有多慢。

273
00:18:32,280 --> 00:18:35,430
理想的情况是，他们做的事情比这更聪明一些。

274
00:18:35,430 --> 00:18:38,820
因此，我们现在要把这种分析正式化。

275
00:18:38,820 --> 00:18:42,180
它不会太数学化，但仍然会很直观。

276
00:18:42,180 --> 00:18:50,550
但我们会向你介绍一些行话，一些大多数程序员或计算机科学家在分析自己的算法时可能会用到的术语。

277
00:18:50,550 --> 00:18:53,670
现在，让我们把这种分析正式化。

278
00:18:53,670 --> 00:18:56,910
因此，现在我认为二进制搜索比线性搜索更好。

279
00:18:56,910 --> 00:18:59,100
但究竟好了多少，为什么？

280
00:18:59,100 --> 00:19:01,120
那么，这一切又回到了这样一张图上。

281
00:19:01,120 --> 00:19:04,830
回想一下，我们在第 0 周就是这样分析电话簿的。

282
00:19:04,830 --> 00:19:13,740
回想一下，我们确实有这些公式，描述这三种算法运行时间的粗略公式--一次一页，一次两页，然后是

283
00:19:13,740 --> 00:19:15,720
一次又一次地把它撕成两半。

284
00:19:15,720 --> 00:19:26,700
准确地说，如果你统计一下我接触的页数或撕掉的页数，可以说第一种算法在最坏的情况下可能总共用了 n 页。

285
00:19:26,700 --> 00:19:31,260
因为我当时正在搜索约翰-哈佛（John Harvard），而字母表中的约翰-哈佛（John Harvard）还有点早。

286
00:19:31,260 --> 00:19:34,340
但如果我在搜索一个姓 Z、

287
00:19:34,340 --> 00:19:38,430
我不得不一直读下去，最糟糕的情况是读完所有 N 页。

288
00:19:38,430 --> 00:19:41,940
第二种算法就没那么糟糕了，这就是我们用 n 除以 2 的原因。

289
00:19:41,940 --> 00:19:43,920
即使是这样，也有点像是在撒一个弥天大谎。

290
00:19:43,920 --> 00:19:48,270
可能是 n 除以 2 再加上 1，以防我需要加倍计算。

291
00:19:48,270 --> 00:19:52,030
不过，我这样做也是为了更概括地抓住这些事情的本质。

292
00:19:52,030 --> 00:19:54,363
然后，我们就真正进入了像原木基地这样的杂草丛生的地方

293
00:19:54,363 --> 00:19:56,940
2 活动的第三个也是最后一个算法。

294
00:19:56,940 --> 00:20:04,200
当时，我们认为，任何时候，如果要把某个东西对半分、对半分、对半分，都有可能涉及某种对数。

295
00:20:04,200 --> 00:20:05,340
我们今天就能看到这一点。

296
00:20:05,340 --> 00:20:09,010
但今天，我们将真正开始使用计算机科学术语。

297
00:20:09,010 --> 00:20:13,590
如果你愿意，我们将把这种不精确正式化。

298
00:20:13,590 --> 00:20:20,820
一般来说，我们不会关心某种算法到底要走多少步，因为这不会有什么启发、

299
00:20:20,820 --> 00:20:24,630
尤其是当你明天的电脑速度比今天更快的时候。

300
00:20:24,630 --> 00:20:27,510
过于精确地比较数字并不公平。

301
00:20:27,510 --> 00:20:33,930
我们真的希望，只要挥挥手，就能大致了解算法的速度有多快或多慢。

302
00:20:33,930 --> 00:20:36,000
因此，这里的标注是经过深思熟虑的。

303
00:20:36,000 --> 00:20:40,620
这简直就是一个大写的 O，通常是斜体，被称为大 O。

304
00:20:40,620 --> 00:20:43,920
因此，第一种算法是 n 的大 O。

305
00:20:43,920 --> 00:20:47,760
第二种算法是 n 除以 2 的大 O。

306
00:20:47,760 --> 00:20:51,480
第三种算法的运算量为 n 的对数基 2 的大 O。

307
00:20:51,480 --> 00:20:54,690
但即便如此，细节也是多余的。

308
00:20:54,690 --> 00:21:01,230
在使用大 O 符号时，你真的不需要关心小阶项，我们会看到。

309
00:21:01,230 --> 00:21:04,500
我们不会关心除以 2 的问题，因为你知道吗？

310
00:21:04,500 --> 00:21:07,720
这些算法的形状几乎相同。

311
00:21:07,720 --> 00:21:11,340
实际上，算法本身在本质上是一样的。

312
00:21:11,340 --> 00:21:13,620
我不再一次只做一页，而是要做两页。

313
00:21:13,620 --> 00:21:22,085
但是，如果你向我抛出数百万页、数十亿页的数据，随着 n 越来越大，向无穷大的方向发展，这些算法的性能就会越来越差。

314
00:21:22,085 --> 00:21:23,585
对数也是如此。

315
00:21:23,585 --> 00:21:33,040
即使你有点生疏，事实证明，无论你用对数基 2、对数基 3 还是对数基 10 来计算，只要用其中一个乘以另一个，就能得到相同的公式。

316
00:21:33,040 --> 00:21:39,270
因此，这只能说，计算机科学家一般会说，前两种算法都是 n 步的数量级。

317
00:21:39,270 --> 00:21:42,690
第三种算法的步骤数为 log n。

318
00:21:42,690 --> 00:21:46,350
除此之外，我们并不关心我们的确切含义。

319
00:21:46,350 --> 00:21:49,770
而这个大 O 符号，我们会看到--实际上，让我放大一下。

320
00:21:49,770 --> 00:21:58,320
如果你能想象一下，突然把 X 轴变得更长--这样屏幕上就能同时显示更多的页面--那就确实会出现这些曲线的形状了

321
00:21:58,320 --> 00:22:07,470
因为在你的脑海中想象一下，当你放大、放大、再放大、再放大，当 n 在 x 轴上变大很多很多时，红线和黄线

322
00:22:07,470 --> 00:22:11,400
在 n 足够大的情况下，基本上都是一样的。

323
00:22:11,400 --> 00:22:14,378
但绿线永远不会是原来的样子。

324
00:22:14,378 --> 00:22:16,420
这将是一个根本不同的形状。

325
00:22:16,420 --> 00:22:23,200
因此，这就是大 O 的直觉，它能让人感觉到这样的绩效率。

326
00:22:23,200 --> 00:22:32,490
这里也许是计算机科学家（当然是在入门情况下）在分析算法时可能会用到的常用公式的小抄。

327
00:22:32,490 --> 00:22:39,040
让我们先考虑一下我们的前两种算法--线性搜索和二进制搜索--属于哪一类。

328
00:22:39,040 --> 00:22:44,318
因此，我将它们从最慢到最快排序，所以顺序是 n 的平方。

329
00:22:44,318 --> 00:22:48,392
我们还没有真正见过这种情况，但它往往很慢，因为它是二次方的。

330
00:22:48,392 --> 00:22:49,350
你在做 n 次 n。

331
00:22:49,350 --> 00:22:51,090
这些步骤加起来可不少。

332
00:22:51,090 --> 00:22:53,190
今天会更好，是 n log n。

333
00:22:53,190 --> 00:22:54,630
更好的将是 n。

334
00:22:54,630 --> 00:22:56,190
比这更好的是 log n。

335
00:22:56,190 --> 00:23:08,200
最好是所谓的 1 的数量级，比如 1 步或 2 步，甚至 1000 步，但无论 n 有多大，都是固定的、有限的步数，永远不会改变。

336
00:23:08,200 --> 00:23:13,570
因此，考虑到这个图表，为了清楚起见，线性搜索 -- 让我们考虑最坏的情况。

337
00:23:13,570 --> 00:23:23,500
在最坏的情况下，假设不是七扇门，而是 n 扇门，像斯蒂芬妮这样的人需要走多少步才能找到解决问题的办法？

339
00:23:25,160 --> 00:23:26,540
所以是 n 的数量级。

340
00:23:26,540 --> 00:23:28,280
在这种情况下，正好是 n。

341
00:23:28,280 --> 00:23:33,530
但你知道吗，也许可以说是 2n，因为它花了斯蒂芬妮几步。

342
00:23:33,530 --> 00:23:34,460
她不得不抬起门闩。

343
00:23:34,460 --> 00:23:35,360
她不得不打开门。

344
00:23:35,360 --> 00:23:36,318
也许是三个步骤。

345
00:23:36,318 --> 00:23:37,530
她必须拿出钱来。

346
00:23:37,530 --> 00:23:39,170
所以现在是 3n，2n。

347
00:23:39,170 --> 00:23:41,990
但我们并不关心这种精确度。

348
00:23:41,990 --> 00:23:45,660
我们其实只关心运算的基本次数。

349
00:23:45,660 --> 00:23:47,540
所以我们说是的，数量级为 n。

350
00:23:47,540 --> 00:23:51,320
因此，这可能是线性搜索的上限，我们称之为 "上限"。

351
00:23:51,320 --> 00:23:53,030
那么二进制搜索呢？

352
00:23:53,030 --> 00:24:02,910
如果有 n 扇门，杰克逊或我使用二进制搜索需要多少步？

353
00:24:02,910 --> 00:24:04,860
在这种情况下，简直就是三个人。

354
00:24:04,860 --> 00:24:07,200
但这不是一个公式。

355
00:24:07,200 --> 00:24:09,690
是的，所以是 log n 的数量级。

356
00:24:09,690 --> 00:24:14,250
事实上，如果有七扇门，那么，只要稍微四舍五入一下，就差不多有八扇门了。

357
00:24:14,250 --> 00:24:18,480
事实上，如果以 8 为对数基数 2，实际上就是 3。

358
00:24:18,480 --> 00:24:19,813
因此，计算结果是正确的。

359
00:24:19,813 --> 00:24:22,272
如果你对对数感到不适应，也没什么大不了的。

360
00:24:22,272 --> 00:24:23,670
凭直觉想一想就知道了。

361
00:24:23,670 --> 00:24:27,010
以 2 为底的对数就是重复除以某物。

362
00:24:27,010 --> 00:24:38,610
因此，在这张图上，当我们考虑大 O 时，说白了，它允许你描述算法运行时间的顺序--比如它的大小--但它也更具体地描述了、

363
00:24:38,610 --> 00:24:40,090
一个上限。

364
00:24:40,090 --> 00:24:49,270
因此，举例来说，在最坏的情况下，这些都能很好地衡量线性搜索和二进制搜索的好坏。

366
00:24:49,770 --> 00:24:56,320
好吧，假设你正在搜索一本 1000 页的电话簿，而这个人的名字是 Z 开头的。

368
00:24:56,820 --> 00:25:01,080
因为你可能要花费 N 个步骤才能找到它。

369
00:25:01,080 --> 00:25:05,250
但实际情况未必如此。

370
00:25:05,250 --> 00:25:16,180
如果我用大 O 作为上限，那么如果有相应的下限就更好了，尤其是如果你不仅要考虑最坏的情况，还要考虑最好的情况。

371
00:25:16,180 --> 00:25:18,040
那么，我们在这里可以使用什么呢？

372
00:25:18,040 --> 00:25:20,200
这是一个大写的希腊文欧米茄符号。

373
00:25:20,200 --> 00:25:28,710
因此，Ω 通常是计算机科学家用来描述算法下限的符号，通常在最佳情况下使用，但也不一定。

374
00:25:28,710 --> 00:25:32,490
那么，下限是指算法可能需要多少步？

375
00:25:32,490 --> 00:25:33,990
这里也是同样的公式。

376
00:25:33,990 --> 00:25:36,270
随着时间的推移，我们将填补这些空白。

377
00:25:36,270 --> 00:25:41,370
有些算法可能总是需要最少 n 个平方步，或者与 n 步的数量级相当。

378
00:25:41,370 --> 00:25:45,660
有些可能只需要 n log n，或 n，或 log n，或 1。

379
00:25:45,660 --> 00:25:52,980
因此，像线性搜索这样的东西 -- 当斯蒂芬妮开始使用线性搜索时，她这次在舞台上并不走运。

380
00:25:52,980 --> 00:25:57,720
但如果她打开的第一扇门是 50 扇呢？

381
00:25:57,720 --> 00:26:08,290
那么，在这种所谓的最佳情况下，您可以如何利用这个可能答案列表来描述线性搜索的下限？

383
00:26:09,530 --> 00:26:11,060
是的，所以Ω为1。

384
00:26:11,060 --> 00:26:18,990
因此，在最好的情况下，线性搜索需要多少步才能找到某样东西，下限可能只是一步。

386
00:26:19,490 --> 00:26:28,460
因为如果斯蒂芬妮运气好的话，我们事先把这些储物柜的数字按照其他顺序排列好，她可能会打开第一个储物柜，然后就可以了、

387
00:26:28,460 --> 00:26:34,610
数字 50 可能就在那里，因此可以说，线性搜索的下限确实可能是 1 的欧米茄。

388
00:26:34,610 --> 00:26:35,990
杰克逊现在怎么样？

389
00:26:35,990 --> 00:26:37,440
他使用了二进制搜索。

390
00:26:37,440 --> 00:26:40,940
于是，他一头扎进了问题的中心。

391
00:26:40,940 --> 00:26:45,020
但使用这种逻辑进行二进制搜索的下限是多少呢？

393
00:26:45,980 --> 00:26:47,460
是的，所以还是 1 的欧米茄值。

395
00:26:47,960 --> 00:26:49,580
因为也许他只是运气好。

396
00:26:49,580 --> 00:26:53,300
事实上，在储物柜的正中间可能就是 50 号。

398
00:26:54,060 --> 00:27:00,050
因此，在杰克逊的实际实践中，大 O 的讨论会更有针对性。

399
00:27:00,050 --> 00:27:08,670
但是，大 O 和欧米茄，上限和下限，只是让计算机科学家纠结于在最坏的情况下可能发生什么，在最好的情况下可能发生什么？

400
00:27:08,670 --> 00:27:12,267
您甚至可以获得更精确的结果，比如平均案例或类似的结果。

401
00:27:12,267 --> 00:27:21,380
事实上，这就是工程师们在公司或大学的白板上设计算法，并试图论证为什么他们的算法比别人的更好时可能会做的事情。

402
00:27:21,380 --> 00:27:24,080
通过这类分析，我们还可以了解到其他国家的情况。

403
00:27:24,080 --> 00:27:35,880
你也看到了，如果某种算法的上界和下界恰好相同，那么实际上也可以使用大写的希腊字母θ。

404
00:27:35,880 --> 00:27:38,210
这是今天最后一个希腊符号。

405
00:27:38,210 --> 00:27:43,130
但希腊文的 θ 表示上限和下限的重合。

406
00:27:43,130 --> 00:27:44,702
也就是说，它们是一体的。

407
00:27:44,702 --> 00:27:49,220
前一秒我们讨论线性搜索时的情况并非如此，二进制搜索也并非如此。

408
00:27:49,220 --> 00:27:56,970
但如果发现上限和下限相同，也可以使用相同的公式。

409
00:27:56,970 --> 00:28:09,080
因此，举例来说，如果我按字面意思数这个房间里的每个人--一、二、三、四、五、六等等--你实际上可以说，以这种方式数数，是在 n 的θ中

410
00:28:09,080 --> 00:28:13,468
因为在最好的情况下，观众会给我N分。

411
00:28:13,468 --> 00:28:15,260
最坏的情况是，我得花上 N 年时间。

412
00:28:15,260 --> 00:28:18,380
如果要计算房间里的每个人，我总是要走 N 步。

413
00:28:18,380 --> 00:28:20,930
除非你跳过别人，否则你不可能做得更好。

414
00:28:20,930 --> 00:28:26,150
因此，这将是一个例子，说明袖口中的θ反而是有意义的。

415
00:28:26,150 --> 00:28:38,730
现在是否有任何关于大 O、Ω 或 Theta 的问题，它们现在只是工具包中更正式的工具，用于讨论我们的算法设计？

416
00:28:38,730 --> 00:28:42,050
有问题吗？

418
00:28:42,860 --> 00:28:44,720
没有。

419
00:28:44,720 --> 00:28:45,560
哦，这是 - 是吗？

421
00:28:46,840 --> 00:28:48,250
好了，我们没事了。

422
00:28:48,250 --> 00:28:52,000
因此，让我们把它转换成一些实际的代码吧。

423
00:28:52,000 --> 00:28:53,900
让我来看看 VS 代码。

424
00:28:53,900 --> 00:29:00,280
现在，让我们看看能否将这些想法转化为实际代码，但先不要使用太多新语法。

425
00:29:00,280 --> 00:29:03,320
我们仍将像上周一样，在阵列的世界里运行。

426
00:29:03,320 --> 00:29:09,280
因此，让我继续在终端中执行代码空间 search.c，创建一个名为 search.c 的程序。

427
00:29:09,280 --> 00:29:14,740
然后在这里，让我们继续并包含我们常用的 cs50.h，这样我就能得到一些输入了。

428
00:29:14,740 --> 00:29:18,370
包含标准 io.h，以便打印输出。

429
00:29:18,370 --> 00:29:23,140
我们要做的是 int main void，上周我们已经开始厘清它的含义。

430
00:29:23,140 --> 00:29:26,650
今天再次失效只是意味着没有命令行参数。

431
00:29:26,650 --> 00:29:28,580
让我来做这件事。

432
00:29:28,580 --> 00:29:34,840
为了便于讨论，让我声明一个静态数组，就像一个永远不会改变的数组。

433
00:29:34,840 --> 00:29:41,290
语法是使用方括号符号给我一个名为数字的数组。

434
00:29:41,290 --> 00:29:50,060
我将立即把它初始化为 20、500、10、5、100、1 和 50，让人想起之前的那些面额。

435
00:29:50,060 --> 00:29:54,080
因此，这是一种略微新颖的语法，也许我们还没有见过。

436
00:29:54,080 --> 00:30:00,820
这里的大括号不同于 for 循环、while 循环和函数，只是告诉编译器请给我

437
00:30:00,820 --> 00:30:05,380
一个数组，大小与此数组相同，从左到右包含这些数字。

438
00:30:05,380 --> 00:30:10,220
我也可以用上周的句法，这样说。

439
00:30:10,220 --> 00:30:13,090
让我们看看，1、2、3、4、5、6、7 种面额。

440
00:30:13,090 --> 00:30:15,250
我也可以这样做。

441
00:30:15,250 --> 00:30:21,910
然后我可以说数字括号 0 等于

442
00:30:21,910 --> 00:30:25,570
20，数字括号 1 等于 500。

443
00:30:25,570 --> 00:30:27,572
我还可以这样做五次。

444
00:30:27,572 --> 00:30:28,780
这有点乏味。

445
00:30:28,780 --> 00:30:32,530
如果事先知道数字，就不必告诉编译器有多少个。

446
00:30:32,530 --> 00:30:37,420
你可以让它计算出你的数字将是 10、500、10、5、

447
00:30:37,420 --> 00:30:39,430
100、1 和 50。

448
00:30:39,430 --> 00:30:42,550
这就是静态定义数组的方法。

449
00:30:42,550 --> 00:30:45,380
好吧，现在就让我继续向用户询问一个数字。

450
00:30:45,380 --> 00:30:50,020
我们将使用 get_int 调用 n，并提示他们输入一个数字--所以这并不新鲜。

451
00:30:50,020 --> 00:30:53,680
现在，让我继续实施线性搜索。

452
00:30:53,680 --> 00:30:57,520
我们之前的伪代码使用了一些类似数组的符号。

453
00:30:57,520 --> 00:30:59,620
那么，就让我从类似的方面说起吧。

454
00:30:59,620 --> 00:31:04,270
对于 int i -- 按照惯例，几乎总是从 i 开始计数。

455
00:31:04,270 --> 00:31:06,490
因此，这或许是一个很好的起点。

456
00:31:06,490 --> 00:31:09,790
只要 i 小于 7，我就会这么做。

457
00:31:09,790 --> 00:31:15,560
硬编码 7 并不是最好的设计，但这只是为了演示，因为我知道我在里面输入了多少数字。

458
00:31:15,560 --> 00:31:16,992
然后我要去i++。

459
00:31:16,992 --> 00:31:21,550
现在我有了一个循环的雏形，它可以让我遍历整个数组。

460
00:31:21,550 --> 00:31:22,760
我想问一下

461
00:31:22,760 --> 00:31:36,190
如果位置 i 上的当前数字等于 n，也就是人类输入的数字，那么我们就来做一些简单的操作，比如 printf、quote unquote、found、backslash n。

462
00:31:36,190 --> 00:31:40,240
然后，根据我们上周的讨论，说明这是成功的、

463
00:31:40,240 --> 00:31:42,610
如果我找到了，我会归还 0。

464
00:31:42,610 --> 00:31:48,640
如果找不到，我就在下面默认为 "未找到，反斜杠 n"。

465
00:31:48,640 --> 00:31:52,610
只是为了惯例--哎呀，只是为了好的措施，按照惯例、

466
00:31:52,610 --> 00:31:55,630
我会返回 1 或 0 以外的任何值。

467
00:31:55,630 --> 00:31:57,130
0 表示成功。

468
00:31:57,130 --> 00:32:02,690
而任何其他整数往往意味着某种误差，与我要找的数字无关。

469
00:32:02,690 --> 00:32:06,670
因此，我们再来回顾一下，这里唯一的新内容就是语法。

470
00:32:06,670 --> 00:32:09,980
我们正在创建一个包含七个数字的数组，就是这些数字。

471
00:32:09,980 --> 00:32:16,090
之后，我们在这里着重强调了线性搜索的实现。

472
00:32:16,090 --> 00:32:22,540
我敢说，这就是斯蒂芬妮在黑板上所做工作的 C 语言版本，只不过现在的数组叫数字，而不是门。

473
00:32:22,540 --> 00:32:25,460
但我认为，情况都差不多。

474
00:32:25,460 --> 00:32:30,380
让我打开终端窗口，运行 make search。

475
00:32:30,380 --> 00:32:32,518
似乎可以编译，./search。

476
00:32:32,518 --> 00:32:34,310
让我们继续搜索一个数字。

477
00:32:34,310 --> 00:32:36,230
我们从之前的 50 开始。

478
00:32:36,230 --> 00:32:37,340
找到了

479
00:32:37,340 --> 00:32:39,770
让我们再次运行 ./search。

480
00:32:39,770 --> 00:32:42,500
一开始大概搜索 20 个吧。

481
00:32:42,500 --> 00:32:43,670
这个也找到了。

482
00:32:43,670 --> 00:32:50,720
让我们再搜索一次，比如 1000，这不在教派之列。

483
00:32:50,720 --> 00:32:52,980
而那个人，确实没有找到。

484
00:32:52,980 --> 00:32:59,300
因此，我们将第 0 周的想法在第 3 周正式化，并将其转化为代码。

485
00:32:59,300 --> 00:33:05,500
对线性搜索的实现有疑问？

486
00:33:05,500 --> 00:33:07,570
线性搜索。

488
00:33:08,680 --> 00:33:11,810
哦，今天到目前为止都很成功。

489
00:33:11,810 --> 00:33:19,270
所以，让我们看看能不能让这个问题变得更有趣一些，看看我们能不能绊倒一个在 C 语言中会很重要的细节。

490
00:33:19,270 --> 00:33:23,330
与其用数字说话，不如让我这样做。

491
00:33:23,330 --> 00:33:25,030
我们还是以大富翁为主题吧。

492
00:33:25,030 --> 00:33:27,730
然后我就钻进了兔子洞，阅读了维基百科上关于大富翁的文章。

493
00:33:27,730 --> 00:33:33,740
而大富翁游戏中的原始棋子或代币 -- 原来我们可以用字符串来表示。

494
00:33:33,740 --> 00:33:39,170
因此，我要创建一个名为 strings 的数组，复数，大小随我在这里定义的大小而定。

495
00:33:39,170 --> 00:33:54,700
当年最早的大富翁棋子是一艘可以玩的战舰、一只靴子、一门大炮、一个铁器、一个顶针和一顶高帽，其中一些你现在可能还能从游戏中找到。

496
00:33:54,700 --> 00:33:57,890
原来这些年来他们一直在换这些东西--没想到--。

497
00:33:57,890 --> 00:34:00,170
现在，这里是一个字符串数组。

498
00:34:00,170 --> 00:34:03,940
让我继续提示用户，现在不用再输入整数了。

499
00:34:03,940 --> 00:34:07,970
我现在想搜索其中一个字符串，仍然使用线性搜索。

500
00:34:07,970 --> 00:34:13,840
因此，让我创建一个字符串 s，设置它等于 get_string，然后提示用户搜索一个字符串。

501
00:34:13,840 --> 00:34:19,540
然后，我想我这里的代码几乎是一样的，除了一个细节。

502
00:34:19,540 --> 00:34:21,850
现在我有一个名为 strings 的数组。

503
00:34:21,850 --> 00:34:24,040
现在我有一个名为 s 的变量。

504
00:34:24,040 --> 00:34:31,030
但事实证明，由于我们下周将详细探讨的原因，这行代码是行不通的。

505
00:34:31,030 --> 00:34:36,880
事实证明，原因与我们上周讨论的 "字符串到底是什么 "有关。

506
00:34:36,880 --> 00:34:39,355
什么是字符串？

507
00:34:39,355 --> 00:34:41,000
字符串是一个数组。

508
00:34:41,000 --> 00:34:51,949
但事实证明，并不能因为你使用了等价等式，等价等式就会慷慨地为你比较数组中的所有字符。

509
00:34:51,949 --> 00:34:54,650
事实证明，它不会比较每一个字母。

510
00:34:54,650 --> 00:35:03,058
幸好，在我们上周介绍的字符串库中，有一个解决这个问题的方法。

511
00:35:03,058 --> 00:35:05,850
问题的原因，我们下周再详细探讨。

512
00:35:05,850 --> 00:35:15,680
但现在，你只需知道，当你想用 C 语言比较字符串时--尤其是如果你在学习这门课时了解一些 Java、Python 或其他语言的话--你不能使用等式 equals。

513
00:35:15,680 --> 00:35:18,500
在 Scratch 中可以，在 C 语言中却不行。

514
00:35:18,500 --> 00:35:21,620
因此，我在这里要做的实际上是这样的。

515
00:35:21,620 --> 00:35:36,050
我想问一个问题，当输入当前字符串和用户输入时，名为 str compare 或 strcomp 的函数的返回值是否等于 0？

516
00:35:36,050 --> 00:35:44,500
因此，如果你阅读一下这个名为 str compare 的函数的文档，就会发现它需要两个字符串作为输入，第一个字符串和第二个字符串。

517
00:35:44,500 --> 00:35:51,910
然后--几十年前有人写了一段代码，可能是用 for 循环或 while 循环来比较每个字符串中的每个字符。

518
00:35:51,910 --> 00:35:56,290
结果发现，如果它们实际上相等，则返回 0。

519
00:35:56,290 --> 00:36:02,440
原来，在其他情况下，它也会返回正数或负数。

520
00:36:02,440 --> 00:36:10,810
有没有直觉告诉我们，为什么使用一个函数来检查两个字符串是否相等会很有用？

521
00:36:10,810 --> 00:36:14,830
如果它们不相等，那么在比较两个字符串时，还有什么值得注意的？

522
00:36:18,474 --> 00:36:19,391
如果某些值是

523
00:36:19,391 --> 00:36:23,347
学生：[听不清]

524
00:36:23,347 --> 00:36:24,430
好吧，有可能。

525
00:36:24,430 --> 00:36:26,950
也许你想知道它们有多相似。

526
00:36:26,950 --> 00:36:28,810
这本身就是一种算法。

527
00:36:28,810 --> 00:36:31,410
但是，str 比较比这更简单一些。

528
00:36:31,410 --> 00:36:33,040
学生：[听不清]

529
00:36:35,850 --> 00:36:41,950
DAVID MALAN：没错，如果你想按字母顺序排列整个字符串列表，就像你的手机可能会按字母顺序排列通讯录或地址簿一样。

530
00:36:41,950 --> 00:36:53,800
事实证明，str compare 实际上会返回一个正数、一个负数或一个 0，这取决于它是按字母顺序排列在前还是在后，或者实际上是相等的。

531
00:36:53,800 --> 00:36:55,130
因此，这可能是一件有用的事情。

532
00:36:55,130 --> 00:36:58,880
这只是一个预告，下周我们将看到更低层次的解释。

533
00:36:58,880 --> 00:37:01,750
现在，让我掰掰手指头，看看我说的对不对。

534
00:37:01,750 --> 00:37:05,410
让我继续搜索。

535
00:37:05,410 --> 00:37:08,590
编译成功了，尽管速度很慢。

536
00:37:08,590 --> 00:37:11,920
点斜线搜索，搜索顶针之类的东西。

537
00:37:11,920 --> 00:37:14,048
我们看到，这确实是真的。

538
00:37:14,048 --> 00:37:19,060
否则，我们就去找一些我知道不存在的东西，比如赛车，我长大后赛车就在那里。

539
00:37:19,060 --> 00:37:23,227
但是啊，分段故障，核心转储。

540
00:37:23,227 --> 00:37:25,810
实际上，你们中的一些人以前也曾犯过这样的错误。

541
00:37:25,810 --> 00:37:27,220
有谁愿意承认看到了这一幕？

542
00:37:27,220 --> 00:37:32,170
所以，是的，这不是我们讨论过的话题，说实话，也不是我刚才想说的。

543
00:37:32,170 --> 00:37:34,450
不过，这也是下周的事了。

544
00:37:34,450 --> 00:37:39,920
我的程序为什么会崩溃？

545
00:37:39,920 --> 00:37:41,900
我并没有真正改变逻辑。

546
00:37:41,900 --> 00:37:43,550
它仍然是线性搜索。

547
00:37:43,550 --> 00:37:46,280
让我把终端隐藏起来，这样你就能一次性看到所有代码。

548
00:37:46,280 --> 00:37:49,850
我做的唯一一件事就是把整数换成字符串。

549
00:37:49,850 --> 00:37:52,310
在这里，我改用 str 比较。

550
00:37:52,310 --> 00:37:54,205
但分段故障发生了。

551
00:37:54,205 --> 00:37:57,080
而预告的内容是，这与计算机的内存有某种联系。

553
00:37:57,996 --> 00:38:00,690
学生：[听不清]

554
00:38:01,470 --> 00:38:03,670
戴维-马兰：是的，这一点很微妙，但很准确。

555
00:38:03,670 --> 00:38:12,810
因此，这个数组中一共有 1、2、3、4、5、6 个元素，而我们之前有 7 个垄断面额的数字。

556
00:38:12,810 --> 00:38:13,888
就在这里，看到了吗？

557
00:38:13,888 --> 00:38:15,930
这就是一个典型的例子，它反过来咬了我一口。

558
00:38:15,930 --> 00:38:26,610
事实上，我对这个值进行了硬编码，而不是将它作为一个常量分离出来，或者在更高的位置进行声明，这让我很不爽，因为现在我正在遍历一个大小为 6 的数组。

559
00:38:26,610 --> 00:38:32,250
但很明显，我走得太远了，因为我要迭代七次，而不是六次。

560
00:38:32,250 --> 00:38:35,580
因此，我仿佛看到了这边的记忆。

561
00:38:35,580 --> 00:38:37,530
事实上，下周我们将重点讨论记忆。

562
00:38:37,530 --> 00:38:38,860
这就是一件坏事。

563
00:38:38,860 --> 00:38:47,280
因此，即使不看你们上周的代码，如果你们中有人出现过分段故障，也很有可能是你触碰了不该触碰的内存。

564
00:38:47,280 --> 00:38:49,290
你可能循环了太多次。

565
00:38:49,290 --> 00:38:52,770
你可能使用了负数来进入数组。

566
00:38:52,770 --> 00:38:55,220
总的来说，你触及了不该触及的记忆。

567
00:38:55,220 --> 00:38:57,720
你触及了一段不该触及的记忆。

568
00:38:57,720 --> 00:39:00,060
不过，至少对我来说，解决方法很简单。

569
00:39:00,060 --> 00:39:01,300
别这么做

570
00:39:01,300 --> 00:39:03,210
所以，让我继续重新编译。

571
00:39:03,210 --> 00:39:06,870
进行点斜线搜索。

572
00:39:06,870 --> 00:39:10,320
我再搜索一下赛车，回车。

573
00:39:10,320 --> 00:39:11,850
现在它不会崩溃了。

574
00:39:11,850 --> 00:39:13,630
但它确实告诉我找不到。

575
00:39:13,630 --> 00:39:17,040
如此微妙，但你自己可能已经被绊倒了。

576
00:39:17,040 --> 00:39:23,190
那么，请就我刚才有意无意的行为提出问题。

577
00:39:23,190 --> 00:39:24,423
是啊，在前面。

578
00:39:24,423 --> 00:39:31,275
学生：有一点是，如果你不返回 0，而是返回 1，程序仍然可以运行。

579
00:39:31,275 --> 00:39:33,220
那么，这样做的目的是什么？

580
00:39:33,220 --> 00:39:34,720
大卫-马兰：这真是一个好问题。

581
00:39:34,720 --> 00:39:38,920
因此，即使我不返回 0 或返回 1，程序仍然可以运行。

582
00:39:38,920 --> 00:39:43,930
事实上，让我先把终端窗口隐藏起来。

583
00:39:43,930 --> 00:39:48,040
让我们在这里摆脱回程。

584
00:39:48,040 --> 00:39:50,810
然而，请看这里发生了什么。

585
00:39:50,810 --> 00:39:53,710
让我继续重新编译，进行搜索。

586
00:39:53,710 --> 00:39:55,610
让我在代码中向上滚动。

587
00:39:55,610 --> 00:39:57,560
让我继续进行点斜线搜索。

588
00:39:57,560 --> 00:40:02,800
让我继续搜索列表中的第一件事--战舰，这样我就知道应该能找到它。

589
00:40:02,800 --> 00:40:04,690
我按了回车键。

590
00:40:04,690 --> 00:40:05,858
嗯，有意思。

591
00:40:05,858 --> 00:40:07,150
所以它说 "未找到"。

592
00:40:07,150 --> 00:40:11,496
但是，从逻辑上讲，在这种情况下，你明白为什么吗？

593
00:40:11,496 --> 00:40:12,980
学生：循环还在运行吗？

594
00:40:12,980 --> 00:40:13,910
大卫-马兰：没错。

595
00:40:13,910 --> 00:40:15,302
因此，循环仍在运行。

596
00:40:15,302 --> 00:40:17,010
因此，有几种解决方案可以解决这个问题。

597
00:40:17,010 --> 00:40:21,080
例如，我可以用某种方法跳出这里的代码。

598
00:40:21,080 --> 00:40:24,200
但这仍会导致执行第 18 行。

599
00:40:24,200 --> 00:40:26,600
这样我就可以直接回到这里了。

600
00:40:26,600 --> 00:40:29,390
严格来说，我并不需要在底部返回 1。

601
00:40:29,390 --> 00:40:39,300
但我上周说过，当你的程序越来越复杂时，至少要像现实世界中的程序员一样，在出错时给出错误代码，这往往会有所帮助。

602
00:40:39,300 --> 00:40:44,090
因此，在 main 中返回 0 是表示代码完成的最简单方法。

603
00:40:44,090 --> 00:40:46,340
我已经准备好成功退出了，就这样。

604
00:40:46,340 --> 00:40:50,280
但在这里，我绝对还是可以返回 0，因为这不是什么大问题。

605
00:40:50,280 --> 00:40:55,200
这并不是一个真正的错误，不值得用某种弹出窗口来提醒用户出了问题。

606
00:40:55,200 --> 00:41:00,330
但返回值 1 只是一种较低级的信号，表示 "嗯，它并没有找到我要找的东西"。

607
00:41:00,330 --> 00:41:03,510
还记得上周的内容吗？

608
00:41:03,510 --> 00:41:08,060
如果我重新编译，现在我已经还原了这些更改，所以请进行搜索。

609
00:41:08,060 --> 00:41:19,790
如果我进行点斜线搜索，搜索战舰，确实找到了，那么我就可以执行这个神奇的命令，回声美元符号问号，你不会经常执行这个命令。

610
00:41:19,790 --> 00:41:22,790
但它向你展示了返回的主要内容。

611
00:41:22,790 --> 00:41:27,770
如果我再次运行搜索，搜索赛车，但没有找到、

612
00:41:27,770 --> 00:41:32,150
我看到了未找到，但我也可以再次运行这条命令，并看到，哦，它返回了 1。

613
00:41:32,150 --> 00:41:40,100
因此，如果把时间快进到几个月或几年后，当你在一家公司或大型项目中实际编写代码时，你可能会希望实现软件自动化。

614
00:41:40,100 --> 00:41:43,100
你可能不希望人类一定要手动运行它。

615
00:41:43,100 --> 00:41:48,360
您可能希望通过夜间程序或类似程序自动执行代码。

616
00:41:48,360 --> 00:41:55,910
利用这些退出代码，程序能否确定其他代码成功或失败。

617
00:41:55,910 --> 00:42:01,850
以这种方式进行线性搜索的其他问题。

619
00:42:02,350 --> 00:42:11,590
好吧，让我们将这两个想法融入到另一个程序中，从而将其转化为 C 语言的另一个特性。

620
00:42:11,590 --> 00:42:16,605
因此，我将通过代码空间 phonebook dot C 创建一个 C 语言电话簿。

621
00:42:16,605 --> 00:42:23,030
让我们把这些想法结合起来，实现在电话簿中搜索真实姓名并返回号码的概念。

622
00:42:23,030 --> 00:42:30,860
因此，我将继续快速包含一些相同的内容，如 cs50.h，以便我们获取输入。

623
00:42:30,860 --> 00:42:39,010
我还会预先包含 string.h，以备不时之需。 int main void，今天不需要命令行参数。

624
00:42:39,010 --> 00:42:42,650
现在，让我给自己的电话簿起个名字吧。

625
00:42:42,650 --> 00:42:45,040
因此，字符串名称等于

626
00:42:45,040 --> 00:42:50,840
然后在大括号里，卡特将是电话簿上的一个人，而大卫，也就是我，将是另一个人。

627
00:42:50,840 --> 00:42:53,465
所以我们长话短说，免得打出太多名字。

628
00:42:53,465 --> 00:42:55,840
但到目前为止，这是一本有两个人的电话簿。

629
00:42:55,840 --> 00:42:59,628
假设现在我们还想存储卡特的电话号码。

630
00:42:59,628 --> 00:43:01,420
所以，它不只是说找到或没找到。

631
00:43:01,420 --> 00:43:05,320
它就像一本正规的电话簿一样查找我们的电话号码。

632
00:43:05,320 --> 00:43:09,440
目前确实没有办法做到这一点。

633
00:43:09,440 --> 00:43:16,510
我可以做点小动作，比如在卡特后面加个号码，比如 617-495-1000。

634
00:43:16,510 --> 00:43:22,460
我也许可以在我身后做一些类似 949-468-2750 的事情。

635
00:43:22,460 --> 00:43:25,300
但现在你却在做 "苹果和橘子 "的事情。

636
00:43:25,300 --> 00:43:26,470
现在，它不是字符串了。

637
00:43:26,470 --> 00:43:28,420
是字符串 int，字符串 int。

638
00:43:28,420 --> 00:43:31,240
好吧，也许我可以把这些字符串都做出来。

639
00:43:31,240 --> 00:43:34,600
但现在，这只是在概念上把苹果和橘子混为一谈。

640
00:43:34,600 --> 00:43:36,425
没错，这是一个由四个字符串组成的数组。

641
00:43:36,425 --> 00:43:43,100
但现在你可以通过荣誉系统知道 第一个字符串是名字 第二个字符串是数字 第三个字符串是 你可以做到的

642
00:43:43,100 --> 00:43:45,110
但可以说，这有点像 "黑客"。

643
00:43:45,110 --> 00:43:47,300
那么，还有什么比这更干净的呢？

644
00:43:47,300 --> 00:43:55,480
与其把电话号码和姓名合并到同一个数组中，我们还能做些什么更好的事情呢？

645
00:43:55,480 --> 00:43:56,440
说大声点

646
00:43:58,960 --> 00:44:01,197
二维阵列，可能是我们可以做到的。

647
00:44:01,197 --> 00:44:07,823
我现在要把它说得更简单一些，因为我们还没有使用过这些文件的名称，尽管我们上周已经看到，从技术上讲，argv 就是这样的文件。

648
00:44:07,823 --> 00:44:10,240
如果我想存储姓名和数字，还能做什么？

650
00:44:11,147 --> 00:44:12,220
学生：[听不清]

651
00:44:12,220 --> 00:44:13,690
大卫-马兰：是的，我同意这个建议。

652
00:44:13,690 --> 00:44:14,607
这就简单多了。

653
00:44:14,607 --> 00:44:18,970
与其把事情复杂化，还不如让我来做串联。

654
00:44:18,970 --> 00:44:21,730
好吧，我可以做 int 数字。

655
00:44:21,730 --> 00:44:22,690
但你知道吗？

656
00:44:22,690 --> 00:44:29,200
为了支持破折号、括号或国家代码等标点符号，我打算这样做。

657
00:44:29,200 --> 00:44:40,390
我将使用字符串数字，这样就可以按照美国的惯例，将卡特的号码表示为引号加 1，即 617-495-1000，并加上连字符。

658
00:44:40,390 --> 00:44:47,930
然后，我将继续使用 +1-949-468-2750 分号。

659
00:44:47,930 --> 00:44:53,860
现在，让我们像第 0 周那样，让用户搜索电话簿。

660
00:44:53,860 --> 00:44:55,960
字符串名称等于获取字符串。

661
00:44:55,960 --> 00:44:59,990
让我们询问用户的姓名，大概是 David、Carter 或其他人。

662
00:44:59,990 --> 00:45:01,850
现在，让我们重新实现线性搜索。

663
00:45:01,850 --> 00:45:05,920
因此，4，int i 得到 0，i 小于 2。

664
00:45:05,920 --> 00:45:07,510
照我说的做，而不是照我做的做。

665
00:45:07,510 --> 00:45:13,220
我认为我们应该小心这种硬编码，但现在我们还是保持简单。

666
00:45:13,220 --> 00:45:17,150
然后在这个 for 循环中，我认为我们已经具备了解决这个问题的所有要素。

667
00:45:17,150 --> 00:45:28,810
因此，如果字符串比较所有名称的返回值与人类键入的名称进行比较，如果所有返回值都等于

668
00:45:28,810 --> 00:45:36,770
等于 0，即这两个字符串中的所有字符都相等，那么我想我们就可以像上次一样说 "找到了"。

669
00:45:36,770 --> 00:45:37,520
但你知道吗？

670
00:45:37,520 --> 00:45:40,130
我们来打印卡特或我的电话号码吧。

671
00:45:40,130 --> 00:45:44,770
所以找到了百分数 s，我们将数字填入括号 i。

672
00:45:44,770 --> 00:45:47,800
然后，为了保持一致，我会在这里返回 0。

673
00:45:47,800 --> 00:45:53,600
为了清楚起见，我在下面会说 printf 未找到之类的话。

674
00:45:53,600 --> 00:45:56,240
然后，我也会返回 1。

675
00:45:56,240 --> 00:45:58,120
下面是所有的代码。

676
00:45:58,120 --> 00:46:01,610
和以前几乎一样，只不过现在有用了。

677
00:46:01,610 --> 00:46:03,460
我不只是说找到或没找到。

678
00:46:03,460 --> 00:46:07,180
我在大富翁游戏中找到了一个数字，或者我在大富翁游戏中找到了一个棋子。

679
00:46:07,180 --> 00:46:09,880
我正在一个数组中查找其中一个字符串。

680
00:46:09,880 --> 00:46:12,730
然后我从另一个数组中打印出答案。

681
00:46:12,730 --> 00:46:19,480
让我继续运行编译器，制作电话簿，回车。

682
00:46:19,480 --> 00:46:21,070
好的，很有希望，没有错误。

683
00:46:21,070 --> 00:46:22,720
点斜线电话簿。

684
00:46:22,720 --> 00:46:26,350
例如，让我们搜索 "卡特回车"。

685
00:46:26,350 --> 00:46:28,060
我们找到卡特的号码了

686
00:46:28,060 --> 00:46:29,393
好吧，让我再来一遍。

687
00:46:29,393 --> 00:46:30,960
电话簿，让我们搜索大卫。

688
00:46:30,960 --> 00:46:32,960
好了 我们似乎找到了戴维的号码

689
00:46:32,960 --> 00:46:34,502
好吧，我们再来最后一次。

690
00:46:34,502 --> 00:46:35,410
电话簿，输入。

691
00:46:35,410 --> 00:46:37,360
现在我们来寻找约翰-哈佛。

692
00:46:37,360 --> 00:46:40,060
输入，未找到。

693
00:46:40,060 --> 00:46:45,520
好吧，我敢说，尽管只进行了最低限度的测试，但这段代码是正确的。

694
00:46:45,520 --> 00:46:48,190
现在有人愿意对设计进行点评吗？

695
00:46:48,190 --> 00:46:51,910
这种方法是否让你觉得不妥？

696
00:46:55,120 --> 00:47:01,510
而且，要一如既往地思考，如果计划变得更长、更复杂，类似这样的决定会如何展开。

698
00:47:02,448 --> 00:47:04,400
学生：如果 i 小于 2。

699
00:47:04,400 --> 00:47:10,080
大卫-马兰：好的，如果 i 小于 2，那么从技术上讲，如果我改变了电话簿中的人数、

700
00:47:10,080 --> 00:47:11,330
我必须更新 i。

701
00:47:11,330 --> 00:47:13,290
我们已经看到，我给自己找了不少麻烦。

702
00:47:13,290 --> 00:47:14,165
这就是糟糕的设计。

704
00:47:15,005 --> 00:47:20,710
学生：假设你在电话簿中添加了某人的名字，但却没有相应的号码。

705
00:47:20,710 --> 00:47:24,730
所以，当你去调取他们的号码时，就会[听不清]别人的号码。

706
00:47:24,730 --> 00:47:25,480
是的

707
00:47:25,480 --> 00:47:28,180
所以，我又一次相信自己不会搞砸。

708
00:47:28,180 --> 00:47:36,640
如果我把约翰或其他人添加到第一个数组中，却忘了把他们的号码添加到第二个数组中，最终事情就会发生偏移和不一致。

709
00:47:36,640 --> 00:47:39,010
这时，代码就会出现错误。

710
00:47:39,010 --> 00:47:43,420
因此，可以说这是一个为我未来的失败埋下伏笔的糟糕设计。

711
00:47:43,420 --> 00:47:44,860
还有其他想法吗？

713
00:47:45,460 --> 00:47:52,848
学生：所以如果你要调换数字的顺序，但不调换主要的[听不清]

714
00:47:52,848 --> 00:47:54,140
是的，非常好。

715
00:47:54,140 --> 00:47:55,550
我们假设顺序相同。

716
00:47:55,550 --> 00:47:59,452
从左到右依次是名字，从左到右依次是数字。

717
00:47:59,452 --> 00:48:01,160
但这只是一种荣誉制度。

718
00:48:01,160 --> 00:48:07,047
比如，代码中没有任何东西可以阻止我以任何理由颠倒顺序，或者对名字进行排序。

719
00:48:07,047 --> 00:48:10,130
比如，他们现在被分类了，也许这是故意的，但也许不是。

720
00:48:10,130 --> 00:48:12,920
因此，这里的荣誉制度也是不可取的。

721
00:48:12,920 --> 00:48:19,490
我可以在这里写个注释来提醒自己，注意，一定要以同样的方式更新数组。

722
00:48:19,490 --> 00:48:26,090
但是，总归会有事情发生的，尤其是当我们有了不是两个，而是三个，而是 30、300 个名字和号码的时候。

723
00:48:26,090 --> 00:48:29,670
如果能将所有相关数据保存在一起就更好了。

724
00:48:29,670 --> 00:48:37,970
因此，事实上，我们今天要介绍的 C 语言的一个新功能就是允许我们实现自己的数据结构。

725
00:48:37,970 --> 00:48:45,930
你可以将数组视为一种非常轻量级的数据结构，因为它允许你将相关数据背靠背地集中在一起。

726
00:48:45,930 --> 00:48:48,170
这就是字符串的实现方式。

727
00:48:48,170 --> 00:48:51,560
它们是一种通过数组有效实现的数据结构。

728
00:48:51,560 --> 00:48:59,870
但事实证明，使用 C 语言和其他语言，你可以发明自己的数据类型，无论是一维、二维甚至更多。

729
00:48:59,870 --> 00:49:07,200
那么在 C 语言中，您是否可以专门创建具有自己名称的类型呢？

730
00:49:07,200 --> 00:49:16,380
因此，举例来说，如果 C 语言不仅有 char、int、floats 和 long 等，还有其他，那该多好。

731
00:49:16,380 --> 00:49:19,970
如果 C 语言自带一种名为 person 的数据类型，岂不更好？

732
00:49:19,970 --> 00:49:22,790
理想情况下，一个人应该有名字和号码。

733
00:49:22,790 --> 00:49:24,860
现在看来，这有点天真和不切实际。

734
00:49:24,860 --> 00:49:28,460
比如，他们为什么要把一个人定义为只有这两个字段。

735
00:49:28,460 --> 00:49:30,950
当然，人们对 "人 "的定义可能存在分歧。

736
00:49:30,950 --> 00:49:32,300
所以，他们把它留给了我们。

737
00:49:32,300 --> 00:49:36,810
C 语言的作者为我们提供了所有这些基元，如 ints、浮点数和字符串等等。

738
00:49:36,810 --> 00:49:48,150
但现在我们要做的是以一种更有趣的方式使用这些变量，这样我们就可以在一个名为 people 的数组中创建一个人物变量数组。

739
00:49:48,150 --> 00:49:49,740
那么，我们该怎么做呢？

740
00:49:49,740 --> 00:49:58,010
好吧，现在我们先规定，世界上的人都会有一个名字和一个号码，至于一个人还应该有什么，我们可以争论一整天。

741
00:49:58,010 --> 00:49:58,677
这很好。

742
00:49:58,677 --> 00:50:01,790
你最终可以发明自己的人。

743
00:50:01,790 --> 00:50:06,500
目前，我只用两个变量来定义一个人的姓名和号码。

744
00:50:06,500 --> 00:50:14,660
但是，如果能将这两种数据类型封装起来，即合并成一种新的、改进的数据类型--"人"，岂不更好？

745
00:50:14,660 --> 00:50:17,360
其语法是这样的

746
00:50:17,360 --> 00:50:18,800
所以说起来有点拗口。

747
00:50:18,800 --> 00:50:21,960
不过，你或许可以推断出这其中的一些作用。

748
00:50:21,960 --> 00:50:24,500
原来 C 语言有一个关键字叫 typedef。

749
00:50:24,500 --> 00:50:28,310
顾名思义，它允许你定义自己的类型。

750
00:50:28,310 --> 00:50:31,550
结构表明这是一个结构。

751
00:50:31,550 --> 00:50:36,710
这就像一个结构，里面有多个你要定义的值。

752
00:50:36,710 --> 00:50:42,270
然后在大括号外的最下方，是你要创建的类型的名称。

753
00:50:42,270 --> 00:50:46,790
因此，在这种特殊情况下，你不能随意使用 typedef 或 struct。

754
00:50:46,790 --> 00:50:48,665
但你可以给它起任何你想要的名字。

755
00:50:48,665 --> 00:50:52,590
你也可以在结构中加入任何你想要的东西。

756
00:50:52,590 --> 00:51:05,760
只要在代码底部执行分号，此后的每一行都可以访问一个人的数据类型，无论是单个变量还是整个数组。

757
00:51:05,760 --> 00:51:10,260
因此，如果我想在此基础上再进一步，就让我继续这样做吧。

758
00:51:10,260 --> 00:51:12,230
让我回到我的 C 代码。

759
00:51:12,230 --> 00:51:17,610
我想先改动几处。

760
00:51:17,610 --> 00:51:19,110
让我们开始吧。

761
00:51:19,110 --> 00:51:23,240
首先，我要去掉这两个硬编码数组。

762
00:51:23,240 --> 00:51:30,180
让我继续前进，在文件顶端发明这个类型，即 typedef struct。

763
00:51:30,180 --> 00:51:34,470
其中将包含一个字符串名称和一个字符串编号。

764
00:51:34,470 --> 00:51:36,780
然后，结构的名称将是人。

765
00:51:36,780 --> 00:51:44,530
最好的做法是在文件的最顶端定义它，这样我的任何函数都可以使用它，尽管在本例中我只使用了 main。

766
00:51:44,530 --> 00:51:47,100
现在，如果我愿意，我可以这样做。

767
00:51:47,100 --> 00:51:50,370
人 P1 和人 P2。

768
00:51:50,370 --> 00:51:53,040
但我们从上周就知道，这已经是糟糕的设计了。

769
00:51:53,040 --> 00:52:00,044
如果要使用同一类型变量的多个实例，我们应该用什么来代替？

770
00:52:00,044 --> 00:52:01,046
学生：[听不清]

771
00:52:01,046 --> 00:52:01,796
还有

772
00:52:01,796 --> 00:52:02,470
学生：一个数组。

773
00:52:02,470 --> 00:52:03,637
戴维-马兰：是的，一个阵列。

774
00:52:03,637 --> 00:52:05,230
所以，我就不多说了。

775
00:52:05,230 --> 00:52:06,700
让我这样做吧。

776
00:52:06,700 --> 00:52:09,727
Person 将是数组的类型。

777
00:52:09,727 --> 00:52:10,810
但我要叫它 --

778
00:52:10,810 --> 00:52:11,980
我可以称之为 "人"。

779
00:52:11,980 --> 00:52:13,720
但在英语中，我们通常说 "人"。

780
00:52:13,720 --> 00:52:15,190
所以我要打电话给阵列人员。

781
00:52:15,190 --> 00:52:20,920
我希望在这个数组中存在两个人，当然我也可以随意更改这个数字。

782
00:52:20,920 --> 00:52:27,190
现在，你如何把名字放在一个人的里面，然后再把数字放在同一个人的里面？

783
00:52:27,190 --> 00:52:28,990
嗯，今天的语法有点新。

784
00:52:28,990 --> 00:52:30,520
我就直说了。

785
00:52:30,520 --> 00:52:34,420
人字段 0 只提供了数组中的第一个人。

786
00:52:34,420 --> 00:52:35,570
这并不新鲜。

787
00:52:35,570 --> 00:52:40,840
但如果你想进入记忆中的那个人的内心世界，就需要使用点。

788
00:52:40,840 --> 00:52:44,870
然后只需指定其中的属性名称即可。

789
00:52:44,870 --> 00:52:47,410
所以，如果我想把第一个人的名字设置为卡特、

790
00:52:47,410 --> 00:52:49,480
我只是使用所谓的点符号。

791
00:52:49,480 --> 00:52:52,780
然后，如果我想用点记法设置卡特的数字、

792
00:52:52,780 --> 00:52:56,680
我会这样做，+1-617-495-1000。

793
00:52:56,680 --> 00:52:58,880
然后，如果我想为自己做同样的事、

794
00:52:58,880 --> 00:53:03,730
我现在会做的人括弧 1 点名等于引号大卫。

795
00:53:03,730 --> 00:53:08,440
然后人们括号里的 1 仍然是点号等于引号，而不是引号

796
00:53:08,440 --> 00:53:13,030
+1-949-468-2750.

797
00:53:13,030 --> 00:53:18,610
现在，在我的文件底部，我认为我的逻辑可以基本保持不变。

798
00:53:18,610 --> 00:53:24,370
我仍然可以在这一行提示用户输入他们想要查询的人的姓名。

799
00:53:24,370 --> 00:53:26,620
现在，尽管我承认这不是最好的设计、

800
00:53:26,620 --> 00:53:28,495
我这样做只是为了演示、

801
00:53:28,495 --> 00:53:31,360
我把这两个留在这里，因为我知道我有两个人。

802
00:53:31,360 --> 00:53:34,100
但在这里，这种情况必须改变。

803
00:53:34,100 --> 00:53:37,000
我不想再比较括号 I 的名字了。

804
00:53:37,000 --> 00:53:42,190
我想在这里输入什么作为 str 比较的第一个参数？

805
00:53:42,190 --> 00:53:43,900
我想在这里做什么？

807
00:53:44,960 --> 00:53:46,800
学生

808
00:53:46,800 --> 00:53:49,140
马兰：是的，所以是点名的人。

809
00:53:49,140 --> 00:53:54,480
因此，我想在第 i 个位置进入人物数组，因为这正是我的循环要做的事情。

810
00:53:54,480 --> 00:53:55,890
它一次又一次地更新 i。

811
00:53:55,890 --> 00:53:58,087
然后再看名字，这样就很好。

812
00:53:58,087 --> 00:53:59,670
我想现在我也需要改变一下。

813
00:53:59,670 --> 00:54:01,890
如果找到了这个人，我想打印什么？

814
00:54:01,890 --> 00:54:02,445
别人？

815
00:54:05,070 --> 00:54:08,850
如果我找到了这个人的名字，我想在这里打印什么？

817
00:54:09,360 --> 00:54:10,890
学生：[听不清]

818
00:54:10,890 --> 00:54:12,390
说大声点。

819
00:54:12,390 --> 00:54:13,795
学生：人i点号。

820
00:54:13,795 --> 00:54:14,670
好极了

821
00:54:14,670 --> 00:54:20,310
因此，如果我确实想给这个人打印相应的数字，那么人的括号里就会有 i 点编号。

822
00:54:20,310 --> 00:54:22,930
然后，我想我的其他代码可以保持不变。

823
00:54:22,930 --> 00:54:27,150
因此，让我继续重新运行 make phone book，重新编译这个版本。

824
00:54:27,150 --> 00:54:28,170
到目前为止还不错。

825
00:54:28,170 --> 00:54:29,400
点斜线电话簿。

826
00:54:29,400 --> 00:54:31,598
让我们输入卡特的名字，找到了。

827
00:54:31,598 --> 00:54:33,390
好吧，我们再运行一次。

828
00:54:33,390 --> 00:54:35,273
大卫的名字，找到了。

829
00:54:35,273 --> 00:54:36,940
让我们再运行一次。

830
00:54:36,940 --> 00:54:40,260
例如，输入约翰-哈佛，在这种情况下找不到。

831
00:54:40,260 --> 00:54:43,710
因此，从根本上说，代码并没有什么不同。

832
00:54:43,710 --> 00:54:46,090
线性搜索仍在以同样的方式进行。

833
00:54:46,090 --> 00:54:48,690
我承认，这看起来有点丑。

834
00:54:48,690 --> 00:54:52,350
我们把一个两行代码的解决方案变成了五行代码。

835
00:54:52,350 --> 00:55:03,892
但是，如果我们快进一两周，开始将信息保存到文件中，我们就会向你介绍 csv 文件（逗号分隔值）或电子表格文件等文件，它们是

836
00:55:03,892 --> 00:55:06,600
您肯定曾经在 Mac 或 PC 上打开过这些文件。

837
00:55:06,600 --> 00:55:11,790
我们很快就能学会在文件中存储姓名和数字等信息的技术。

838
00:55:11,790 --> 00:55:19,080
到那时，我们就不会再像黑客那样硬编码数字 2，也不会再在程序中手动输入我和卡特的名字和号码了。

839
00:55:19,080 --> 00:55:21,750
我们将从文件中动态读取信息。

840
00:55:21,750 --> 00:55:25,180
几周后，我们将从数据库中动态读取数据。

841
00:55:25,180 --> 00:55:32,190
但目前，这只是从语法上讲，我们如何创建一个大小为 2 的数组，每个数组包含一个人。

842
00:55:32,190 --> 00:55:41,610
我们可以更新第一个人的姓名和编号，更新第二个人的姓名和编号，然后搜索这些姓名并打印出相应的编号。

843
00:55:41,610 --> 00:55:44,220
从这个意义上说，这是一个更好的设计。

845
00:55:44,730 --> 00:55:53,400
因为我的人数据类型现在概括了作为一个人的所有含义，至少在这个狭隘的世界里是这样。

846
00:55:53,400 --> 00:55:57,580
例如，如果我想在 "人 "的概念中添加一些内容、

847
00:55:57,580 --> 00:56:03,743
明天，我就可以在我的类型定义中为每个人添加一个地址，然后开始读取。

848
00:56:03,743 --> 00:56:05,160
现在不是荣誉制度了。

849
00:56:05,160 --> 00:56:12,210
它不是一个姓名数组、一个数字数组、一个地址数组，以及你可能想象到的与人有关的其他一切。

850
00:56:12,210 --> 00:56:17,223
这一切都是封装的，是同一类型中的一个术语。

851
00:56:17,223 --> 00:56:21,660
如果你们中有人以前编过程序，就会想起一种叫做面向对象编程的东西。

852
00:56:21,660 --> 00:56:23,190
但我们还没到那一步。

853
00:56:23,190 --> 00:56:24,690
C 并非如此。

854
00:56:24,690 --> 00:56:35,037
关于 struct 的使用或这种新语法的问题，点运算符是最重要的部分。

855
00:56:35,037 --> 00:56:35,620
有问题吗？

857
00:56:36,522 --> 00:56:39,414
学生：[听不清]

858
00:56:42,800 --> 00:56:44,420
戴维-马兰：在第几行？

859
00:56:44,420 --> 00:56:46,063
学生： 16.

860
00:56:46,063 --> 00:56:46,730
大卫-马兰：16？

861
00:56:46,730 --> 00:56:51,230
是的，从语法上讲，我们上周引入了方括号。

862
00:56:51,230 --> 00:56:55,310
因此，"0 号括弧 "的意思就是去找数组中的第一个人。

863
00:56:55,310 --> 00:56:58,400
就好像斯蒂芬妮真的打开了这扇门。

864
00:56:58,400 --> 00:56:59,990
这是 0 号门。

865
00:56:59,990 --> 00:57:02,330
不过，这当然是人的括号 0 代替的。

866
00:57:02,330 --> 00:57:04,580
如今，"点 "已成为一种新的语法。

867
00:57:04,580 --> 00:57:13,297
这意味着进入记忆中的那个人，查看他们的名字，将其设置为卡特，并对数字做同样的设置。

868
00:57:13,297 --> 00:57:13,880
就这样吧。

869
00:57:13,880 --> 00:57:18,410
这就好比，打开储物柜门，进入柜内，检查或设置名称和编号。

871
00:57:19,040 --> 00:57:29,280
学生：[听不清]你能为每个[听不清]设置默认值吗？

872
00:57:29,280 --> 00:57:30,840
DAVID MALAN：属性没问题。

873
00:57:30,840 --> 00:57:31,530
问得好。

874
00:57:31,530 --> 00:57:34,050
在结构体中，能否设置默认值？

875
00:57:34,050 --> 00:57:35,100
简而言之，没有。

876
00:57:35,100 --> 00:57:42,580
与 Python 和 Java 等更现代的语言相比，C 语言的功能性就显得不足了。

877
00:57:42,580 --> 00:57:47,140
因此，当我们在几周后过渡到 Python 时，我们将看到如何开始解决这样的问题。

878
00:57:47,140 --> 00:57:51,450
但现在，您需要将名称和编号初始化为某个值。

880
00:57:52,832 --> 00:57:55,540
学生：[听不清]

881
00:58:04,123 --> 00:58:05,540
大卫-马兰：问得好。

882
00:58:05,540 --> 00:58:08,470
我们该如何调整或批评我的设计？

883
00:58:08,470 --> 00:58:13,780
这是为数不多的我会虚伪地说 "照我说的做，而不是照我做的做 "的情况之一。

884
00:58:13,780 --> 00:58:17,710
我用了这样很难看的一行，只是为了介绍一下语法。

885
00:58:17,710 --> 00:58:26,230
但我今天在教学上的主张是，最终，当我们开始在文件或数据库中存储名称、数字或其他东西时，你就不会再有这种冗余了。

886
00:58:26,230 --> 00:58:34,630
你将用一行或两行代码从文件或数据库中读取信息，然后用这些数据填充整个数组。

887
00:58:34,630 --> 00:58:39,400
目前，我只是手动操作，以便让我们只关注新语法，但仅此而已。

888
00:58:39,400 --> 00:58:42,640
所以，请原谅今天的糟糕设计。

889
00:58:42,640 --> 00:58:45,740
还有其他问题吗？

890
00:58:45,740 --> 00:58:47,595
好了，已经说了很多了。

891
00:58:47,595 --> 00:58:50,470
不如我们先去吃点心，休息 10 分钟。

892
00:58:50,470 --> 00:58:53,020
我们在大厅里准备了一些美味的巧克力蛋糕。

893
00:58:53,020 --> 00:58:55,900
好了，我们回来了。

894
00:58:55,900 --> 00:59:02,350
到目前为止，如果你的数据是排序的，这显然是件好事，因为你可以使用二进制搜索。

895
00:59:02,350 --> 00:59:05,540
你对数据的了解更多一些。

896
00:59:05,540 --> 00:59:10,420
但事实证明，分类本身也是一个需要解决的问题。

897
00:59:10,420 --> 00:59:20,237
你可能会想，好吧，如果排序会很快，我们绝对应该在开始搜索之前进行排序，因为这会加快我们所有的搜索速度。

898
00:59:20,237 --> 00:59:28,090
但是，如果排序速度很慢，就会引出这样一个问题：如果我们只搜索一次或两次数据，我们还需要费心排序数据吗？

899
00:59:28,090 --> 00:59:30,550
因此，这可能是一种权衡。

900
00:59:30,550 --> 00:59:33,250
因此，让我们思考一下数据分类的真正含义。

901
00:59:33,250 --> 00:59:35,950
在我们的案例中，只需简单地使用数字即可。

902
00:59:35,950 --> 00:59:40,880
但是，对于世界上的谷歌来说，它可能是实际的网页或人或类似的东西。

903
00:59:40,880 --> 00:59:46,090
这就是我们排序和解决任何问题的典型图片。

904
00:59:46,090 --> 00:59:48,190
左侧为输入，右侧为输出。

905
00:59:48,190 --> 00:59:54,340
排序问题的输入将是一组未排序的值。

906
00:59:54,340 --> 00:59:57,940
理想情况下，输出将是排序后的同一组值。

907
00:59:57,940 --> 01:00:04,786
具体来讲，假设我们要对 7、2、5、4、1、6、0 这一串数字进行排序、

909
01:00:05,860 --> 01:00:07,810
所以是从 0 到 7 的所有数字。

910
01:00:07,810 --> 01:00:09,757
但不知何故，它们被随意地混杂在一起。

911
01:00:09,757 --> 01:00:11,590
这就是问题的症结所在。

912
01:00:11,590 --> 01:00:17,990
现在的目标是对这些数据进行排序，这样你就能得到 0、1、2、3、4、5、6、7，而不是 0、1、2、3、4、5、6、7。

913
01:00:17,990 --> 01:00:23,900
事实证明，我们可以用很多不同的方法对这些数字进行排序。

914
01:00:23,900 --> 01:00:32,410
事实上，为了补充我们之前的搜索示例，如果你愿意出现在互联网上，我们是否可以快速让八位志愿者上来？

915
01:00:32,410 --> 01:00:39,100
如果你想做 1、2、3、4、5、6、7、8，怎么样？

916
01:00:39,100 --> 01:00:40,255
好了，下来吧

918
01:00:47,970 --> 01:00:50,560
过来，我给你们每人一个号码。

919
01:00:50,560 --> 01:00:58,390
如果你们想按照黑板上的数字顺序排列，请按顺序排列。

920
01:00:58,390 --> 01:01:04,460
所以，请抬头看看头顶，按照同样的顺序从左到右排列。

921
01:01:04,460 --> 01:01:06,210
让我们有你的第一个 - 完美。

922
01:01:06,210 --> 01:01:10,420
如果你想过来，和这个排成一线如何？

923
01:01:10,420 --> 01:01:13,990
好了，还有几个数字。

925
01:01:14,980 --> 01:01:19,810
2号、6号，完美。

926
01:01:19,810 --> 01:01:21,625
数字刚刚好

928
01:01:22,858 --> 01:01:24,400
好了，第三项。

930
01:01:24,968 --> 01:01:26,260
所以，让我们快速检查一下。

931
01:01:26,260 --> 01:01:30,867
我们有 7、2、5、4、1、6、0、3，目前非常好。

932
01:01:30,867 --> 01:01:34,510
你想往这边挪一点，腾出更多空间吗？

933
01:01:34,510 --> 01:01:38,090
好了，现在让我们来看看台上都有谁。

934
01:01:38,090 --> 01:01:40,780
你们想和观众打个招呼吗？

935
01:01:40,780 --> 01:01:42,070
你好，我叫莱恩。

936
01:01:42,070 --> 01:01:45,597
我是佩妮帕克的一年级学生。

937
01:01:45,597 --> 01:01:46,930
你好，我叫伊瑟尔嗨，我叫伊瑟尔

938
01:01:46,930 --> 01:01:49,177
我是施特劳斯学院的一年级学生。

939
01:01:49,177 --> 01:01:50,260
嗨，我叫露西。

940
01:01:50,260 --> 01:01:52,400
我是来自格林诺夫的一年级学生。

941
01:01:52,400 --> 01:01:53,650
你好，我叫夏伊洛。

942
01:01:53,650 --> 01:01:55,927
我是维格斯沃斯的一年级学生。

943
01:01:55,927 --> 01:01:57,010
你好，我叫杰克。

944
01:01:57,010 --> 01:01:59,877
我是施特劳斯学院的一年级学生。

945
01:01:59,877 --> 01:02:01,210
你好，我叫凯瑟琳。

946
01:02:01,210 --> 01:02:02,787
我是施特劳斯学院的一年级学生。

947
01:02:02,787 --> 01:02:04,120
嗨，我叫迈克尔嗨，我的名字是迈克尔。

948
01:02:04,120 --> 01:02:06,063
我是佩妮派克的一年级学生。

949
01:02:06,063 --> 01:02:07,480
你好，我叫穆罕默德。

950
01:02:07,480 --> 01:02:09,047
我是马修斯大学的一年级学生。

951
01:02:09,047 --> 01:02:10,630
嗨，很好，欢迎加入。

953
01:02:11,240 --> 01:02:21,160
因此，现在让我们考虑一下，如何在这里对我们的志愿者进行分类，我们的目标是把他们按照从大到小的顺序排列，这样就可以了、

954
01:02:21,160 --> 01:02:24,160
那么，我们可以使用比线性搜索更智能的方法。

955
01:02:24,160 --> 01:02:27,878
实际上，我们可以使用二进制搜索，假设它们已经排序。

956
01:02:27,878 --> 01:02:32,600
因此，我建议我们首先考虑一种算法，它实际上有一个名字，叫做选择排序。

957
01:02:32,600 --> 01:02:43,610
而 "选择排序 "就是让我，或者说是你，作为程序员，一次又一次地选择最小的元素，然后把它们放到合适的位置。

958
01:02:43,610 --> 01:02:47,115
让我从这里开始，从数字 7 开始。

959
01:02:47,115 --> 01:02:49,240
目前，7 是我找到的最小数字。

960
01:02:49,240 --> 01:02:52,610
所以，我要用一个心理变量来记下这一点。

961
01:02:52,610 --> 01:02:53,710
我要继续前进了。

962
01:02:53,710 --> 01:03:01,555
2 号显然更小，所以我只是要更新我的心理提醒，2 号现在是最小的，实际上暂时忘记了 7 号。

963
01:03:01,555 --> 01:03:02,440
5，而不是更小。

964
01:03:02,440 --> 01:03:03,370
4，而不是更小。

965
01:03:03,370 --> 01:03:04,170
1，较小。

966
01:03:04,170 --> 01:03:05,920
我要在心里记下这一点。

967
01:03:05,920 --> 01:03:07,030
6，而不是更小。

968
01:03:07,030 --> 01:03:08,200
0，甚至更小。

969
01:03:08,200 --> 01:03:11,140
我会记下来的，其他的都忘了。

970
01:03:11,140 --> 01:03:13,180
而现在，3 号也不小了。

971
01:03:13,180 --> 01:03:14,290
你叫什么名字来着？

972
01:03:14,290 --> 01:03:14,630
迈克尔迈克尔

973
01:03:14,630 --> 01:03:16,240
迈克尔是0号。

974
01:03:16,240 --> 01:03:18,310
当然，他属于那里。

975
01:03:18,310 --> 01:03:20,740
但不幸的是 -- 你 --

976
01:03:20,740 --> 01:03:21,550
莱恩

977
01:03:21,550 --> 01:03:23,360
瑞安挡住了去路

978
01:03:23,360 --> 01:03:24,580
那我们该怎么办？

979
01:03:24,580 --> 01:03:27,570
我们应该如何开始对这份清单进行排序？

980
01:03:27,570 --> 01:03:30,510
0 号应该放在哪里？

982
01:03:31,012 --> 01:03:32,220
你想说大声点吗？

983
01:03:32,220 --> 01:03:34,545
学生：我想我会交换的。

984
01:03:34,545 --> 01:03:36,670
是啊，那我们就继续交换吧。

985
01:03:36,670 --> 01:03:39,190
所以，如果你想继续 0，就继续 7 的位置。

986
01:03:39,190 --> 01:03:41,170
我们需要为 7 号腾出空间。

987
01:03:41,170 --> 01:03:45,530
如果每个人都礼貌地站到一边，那就有点作弊了。

989
01:03:46,030 --> 01:03:54,190
因为如果我们把所有的志愿者都想象成一个数组，那么要让数组中的每个元素都向左移动以腾出空间，这将是一个非常大的工作量。

990
01:03:54,190 --> 01:03:57,340
所以我们就简单点，不管是谁，只要把他赶走就行了。

991
01:03:57,340 --> 01:04:00,880
现在，也许我们运气好，7 号实际上离目的地更近了。

992
01:04:00,880 --> 01:04:03,250
也许我们运气不好，它走得更远。

993
01:04:03,250 --> 01:04:05,260
但我们至少解决了一个问题。

994
01:04:05,260 --> 01:04:10,280
如果一开始我们有 n 个问题，那么现在我们有 n 减 1，因为数字 0 确实在正确的位置上。

995
01:04:10,280 --> 01:04:15,130
所以，如果我继续演下去，就让我继续说 2，目前是最小的。

996
01:04:15,130 --> 01:04:18,040
5，否，4，否，1 目前最小。

997
01:04:18,040 --> 01:04:19,000
我会记下来的。

998
01:04:19,000 --> 01:04:22,690
6、7、3，现在让我暂停一下。

999
01:04:22,690 --> 01:04:26,000
1 显然是现在最小的元素。

1000
01:04:26,000 --> 01:04:27,760
那么，我需要继续前进吗？

1001
01:04:27,760 --> 01:04:30,550
事实证明，至少我已经定义了选择排序、

1002
01:04:30,550 --> 01:04:36,550
我确实需要继续下去，因为我只声称我在脑海中用一个变量来记忆当时最小的元素。

1003
01:04:36,550 --> 01:04:39,970
我不像我们人类那么聪明，不记得了，等等、

1004
01:04:39,970 --> 01:04:41,590
1 现在肯定是最小的。

1005
01:04:41,590 --> 01:04:43,190
我没有那段完整的回忆。

1006
01:04:43,190 --> 01:04:45,590
所以，我只是在记录现在最小的。

1007
01:04:45,590 --> 01:04:46,910
那么第一位，你叫什么名字？

1008
01:04:46,910 --> 01:04:47,410
杰克

1009
01:04:47,410 --> 01:04:49,300
杰克，杰克该去哪儿？

1010
01:04:49,300 --> 01:04:50,380
可能在那里。

1011
01:04:50,380 --> 01:04:51,670
你叫什么名字？

1012
01:04:51,670 --> 01:04:51,880
伊策尔伊瑟尔

1013
01:04:51,880 --> 01:04:57,430
好了，杰克和伊瑟尔，如果你们想交换位置的话，我们现在已经解决了N个问题中的两个。

1014
01:04:57,430 --> 01:04:58,990
现在我们要做得更快一点。

1015
01:04:58,990 --> 01:05:03,880
如果你们每个人都想在我找到合适人选后开始交换，那么最小的 5 人、

1016
01:05:03,880 --> 01:05:06,340
4 更小，2 更小。

1017
01:05:06,340 --> 01:05:07,750
必须继续检查。

1018
01:05:07,750 --> 01:05:09,572
好吧，2 号比较小。

1019
01:05:09,572 --> 01:05:11,780
好了，现在我要回到开头。

1020
01:05:11,780 --> 01:05:13,090
好吧，4 是小数。

1023
01:05:14,740 --> 01:05:16,120
7 -- 哦，3个很小。

1024
01:05:16,120 --> 01:05:17,770
你想去哪里？

1026
01:05:18,670 --> 01:05:19,810
我要回到这里。

1027
01:05:19,810 --> 01:05:21,060
我还会耍小聪明。

1028
01:05:21,060 --> 01:05:24,950
我没有必要一直写到最后，因为我知道这些人已经分好类了。

1029
01:05:24,950 --> 01:05:26,630
因此，我至少可以稍微优化一下。

1030
01:05:26,630 --> 01:05:27,970
所以，现在 5 是小数目。

1031
01:05:27,970 --> 01:05:28,720
6 是小数。

1032
01:05:28,720 --> 01:05:30,160
7 是 4，4 更小。

1033
01:05:30,160 --> 01:05:33,080
如果你想去那里。

1034
01:05:33,080 --> 01:05:34,810
现在，事情变得有趣了。

1035
01:05:34,810 --> 01:05:39,340
我可以不看这些人，因为他们显然已经解决问题了。

1036
01:05:39,340 --> 01:05:42,970
但现在 5 号是小号，6 号不是，7 号也不是。

1037
01:05:42,970 --> 01:05:45,010
好了，5号，你可以留在原地。

1038
01:05:45,010 --> 01:05:49,420
现在，房间里的人显然会质疑我为什么还要浪费时间。

1039
01:05:49,420 --> 01:05:52,090
但是，按照我目前的定义，选择排序、

1040
01:05:52,090 --> 01:05:55,840
我现在还得检查 6 是最小的，而不是 7。

1041
01:05:55,840 --> 01:05:58,520
现在是我的最后一步，好了，它们都就位了。

1042
01:05:58,520 --> 01:06:05,060
因此，在这里也存在着这样一种对立，即我们都从鸟瞰的角度来看待整个问题，显然每个人都需要去哪里。

1043
01:06:05,060 --> 01:06:09,137
但是，使用数组实现这一功能的计算机必须更加有条不紊。

1044
01:06:09,137 --> 01:06:10,720
实际上，我们在这里节省了一个步骤。

1045
01:06:10,720 --> 01:06:13,780
如果我们真的这样做了，这些数字就都看不到了。

1046
01:06:13,780 --> 01:06:16,840
我们的八名志愿者都会在一扇上锁的门内。

1047
01:06:16,840 --> 01:06:19,220
只有这样，我们才能一个一个地看到它们。

1048
01:06:19,220 --> 01:06:21,670
但我们现在只关注分类方面。

1049
01:06:21,670 --> 01:06:29,620
所以，在我们做其他演示之前，请允许我提议，我刚才用伪代码做的事情其实是这样的。

1050
01:06:29,620 --> 01:06:38,110
对于从 0 到 n 减 1 的 i，记住 0 总是数组的左端，n 减 1 总是数组的右端。

1051
01:06:38,110 --> 01:06:45,730
对于从 0 到 n 减 1 的 i，我找到了数字括号 i 和数字括号 n 减 1 之间的最小数字。

1052
01:06:45,730 --> 01:06:48,610
这就是这种优化的极客表达方式。

1053
01:06:48,610 --> 01:06:51,490
无论在哪里，我总是从数字括号 i 开始。

1054
01:06:51,490 --> 01:06:53,200
然后是右边的一切。

1055
01:06:53,200 --> 01:06:56,890
这也是让我忽略已经排序的志愿者的原因。

1056
01:06:56,890 --> 01:07:05,470
不过，如果我的最后一行说用数字 i 交换最小的数字，我想这就实现了我们人类通过身体走到另一个地方的做法。

1057
01:07:05,470 --> 01:07:09,220
好了，这就是我们所说的选择排序。

1058
01:07:09,220 --> 01:07:13,360
让我们使用第二种方法，我把这种算法称为冒泡排序。

1059
01:07:13,360 --> 01:07:16,090
但要做到这一点，我们需要你们全部重置到原来的位置。

1060
01:07:16,090 --> 01:07:19,750
如果你想回到这个位置，我们在黑板上有一张小抄。

1061
01:07:19,750 --> 01:07:26,780
让我采取一种根本不同的方法，因为我不太喜欢现在的选择排序，因为这有点像来回走动。

1062
01:07:26,780 --> 01:07:30,620
而 "走了很多路 "则意味着要走很多很多步。

1063
01:07:30,620 --> 01:07:32,090
那我该怎么做呢？

1064
01:07:32,090 --> 01:07:36,730
嗯，气泡排序会让我更直观地关注一些小问题。

1065
01:07:36,730 --> 01:07:38,605
让我们看看这是否能让我去别的地方。

1066
01:07:38,605 --> 01:07:43,670
因此，如果我只看这份名单，而不看其他人，7 和 2，这显然是个问题。

1068
01:07:44,170 --> 01:07:45,500
因为你失常了。

1069
01:07:45,500 --> 01:07:47,810
所以，我们还是先解决一个小问题吧。

1070
01:07:47,810 --> 01:07:49,570
那么 7 和 2，你们为什么不交换呢？

1071
01:07:49,570 --> 01:07:54,160
我知道 2 号现在的情况比 7 号好，因为她肯定比 7 号小。

1072
01:07:54,160 --> 01:07:55,540
所以，我想我现在可以继续前进了。

1073
01:07:55,540 --> 01:07:57,350
7 和 5，问题。

1074
01:07:57,350 --> 01:07:58,390
那我们就来解决这个问题。

1075
01:07:58,390 --> 01:07:59,830
7 和 4，问题。

1076
01:07:59,830 --> 01:08:02,380
让我们来解决这个问题，7 和 1，让我们来解决这个问题。

1077
01:08:02,380 --> 01:08:03,970
7 和 6，让我们来解决这个问题。

1078
01:08:03,970 --> 01:08:05,080
7 和 0，解决这个问题。

1079
01:08:05,080 --> 01:08:06,550
7 和 3，解决这个问题。

1081
01:08:07,330 --> 01:08:09,130
分类了，对吗？

1082
01:08:09,130 --> 01:08:11,780
或者说，如果你只看一眼这些数字，显然不是这样。

1083
01:08:11,780 --> 01:08:14,530
但从根本上说，我们已经解决了这个问题。

1084
01:08:14,530 --> 01:08:17,020
7 的位置确实没错。

1085
01:08:17,020 --> 01:08:21,170
因此，我们最多还有 n 减 1 个其他问题需要解决。

1086
01:08:21,170 --> 01:08:23,660
那么我该怎么做呢？

1087
01:08:23,660 --> 01:08:25,700
我想我可以重复同样的逻辑。

1088
01:08:25,700 --> 01:08:26,770
让我到这边来。

1089
01:08:26,770 --> 01:08:28,210
2 和 5，很好。

1090
01:08:28,210 --> 01:08:29,800
第 5 和第 4 号

1091
01:08:29,800 --> 01:08:31,330
5 和 1，No.

1092
01:08:31,330 --> 01:08:32,590
5 和 6，是的。

1093
01:08:32,590 --> 01:08:34,660
6 and 0, no.

1094
01:08:34,660 --> 01:08:36,760
6 和 3，No.

1095
01:08:36,760 --> 01:08:39,191
现在我们已经解决了两个问题。

1096
01:08:39,191 --> 01:08:42,707
泡泡排序的好处是，至少从这个角度看，它既漂亮又简单。

1097
01:08:42,707 --> 01:08:43,540
这里环境优美，又是当地人的乐园。

1098
01:08:43,540 --> 01:08:46,510
而你只是不断地逐步解决越来越多的问题。

1099
01:08:46,510 --> 01:08:48,010
所以，让我们再来一次。

1100
01:08:48,010 --> 01:08:50,080
我会做的，我们可以做得更快。

1101
01:08:50,080 --> 01:08:51,760
我们知道，2 号和 4 号都不错。

1102
01:08:51,760 --> 01:08:59,200
4 和 1、4 和 5、5 和 0、5 和 3、5 和 6、6 和 7，很好。

1103
01:08:59,200 --> 01:09:01,390
所以我们回去，2 和 1。

1104
01:09:01,390 --> 01:09:03,340
啊，现在又一个问题解决了。

1105
01:09:03,340 --> 01:09:09,939
2和4、4和0、4和3、4和5、5和6、6和7。

1106
01:09:09,939 --> 01:09:14,895
因此，请注意 2，正如它的名字一样，最大的元素已经冒了出来。

1107
01:09:14,895 --> 01:09:18,340
就在我们解决一些遗留问题的时候，这似乎正在发生。

1108
01:09:18,340 --> 01:09:19,120
就快完成了。

1109
01:09:19,120 --> 01:09:27,550
1 和 2、2 和 0、2 和 3、3 和 4、4 和 5、5 和 6、6 和 7，快完成了。

1110
01:09:27,550 --> 01:09:29,830
显然，对我们人类来说，它看起来已经完成了。

1111
01:09:29,830 --> 01:09:32,529
作为计算机，我如何确定？

1112
01:09:32,529 --> 01:09:36,370
有什么最万无一失的办法能让我现在就走？

1113
01:09:36,370 --> 01:09:38,080
这是一个错误。

1114
01:09:38,080 --> 01:09:43,390
好，1 和 0、1 和 2、2 和 3、3 和 4、4 和 5、5 和 6、6 和 7。

1115
01:09:43,390 --> 01:09:47,899
好了，现在舞台上的其他人显然已经分好类了。

1116
01:09:47,899 --> 01:09:50,290
我怎样才能尽可能多地确认代码？

1117
01:09:50,290 --> 01:09:52,670
你只是瞥了一眼，就用意念去做了。

1118
01:09:52,670 --> 01:09:56,080
计算机、代码如何确定列表已经排序？

1120
01:09:57,000 --> 01:09:58,500
学生：[听不清]再来一次。

1121
01:09:58,500 --> 01:10:00,000
戴维-马兰：我们再来一次。

1122
01:10:00,000 --> 01:10:03,512
你看，得出了什么结论？

1123
01:10:03,512 --> 01:10:05,490
学生：什么都不用换。

1124
01:10:05,490 --> 01:10:08,860
是啊，我们再来一次吧，虽然有点浪费。

1125
01:10:08,860 --> 01:10:19,133
但是，从逻辑上讲，如果我一遍又一遍地比较整个列表中的配对，而这一次我没有做任何工作，那么现在停下来显然在逻辑上是安全的，因为否则，我就会

1126
01:10:19,133 --> 01:10:22,933
如果没有人真正行动起来，我就会浪费时间反复做同样的事情。

1127
01:10:22,933 --> 01:10:25,350
所以，恐怕我们没有为你们所有人准备大富翁游戏。

1128
01:10:25,350 --> 01:10:26,767
但我们确实有八个压力球。

1129
01:10:26,767 --> 01:10:30,090
掌声送给我们的志愿者。

1130
01:10:30,090 --> 01:10:33,910
如果你想把你的数字放在架子上。

1131
01:10:33,910 --> 01:10:36,720
所以，如果我们考虑一下 -- 谢谢。

1132
01:10:36,720 --> 01:10:39,340
非常感谢。

1137
01:10:44,730 --> 01:10:48,870
那么，如果我们现在考虑这两种算法，哪一种更好呢？

1138
01:10:48,870 --> 01:10:55,950
第一种选择排序方式比第二种冒泡排序方式好还是不好，有什么直观感受吗？

1139
01:10:55,950 --> 01:10:58,020
有什么想法？

1141
01:10:58,860 --> 01:11:03,620
泡泡排序的更好，因为它的工作[听不清]。

1142
01:11:03,620 --> 01:11:08,930
戴维-马兰：所以说，泡沫似乎更省事，尤其是我当时专注于那些局部问题。

1143
01:11:08,930 --> 01:11:11,460
其他直觉？

1144
01:11:11,460 --> 01:11:14,580
选择排序与冒泡排序

1145
01:11:14,580 --> 01:11:19,420
好吧，让我提议，我们试着将其量化，这样我们就能以某种方式对其进行实际分析了。

1146
01:11:19,420 --> 01:11:22,590
而且，这也不是我们为大量算法不断进行的练习。

1147
01:11:22,590 --> 01:11:24,940
但这些算法都很有代表性。

1148
01:11:24,940 --> 01:11:28,960
因此，我们可以对这些东西的性能或设计进行思考。

1149
01:11:28,960 --> 01:11:34,350
下面是我的选择排序伪代码，正如它的名字一样、

1150
01:11:34,350 --> 01:11:38,500
我只是反复选择下一个最小的元素。

1151
01:11:38,500 --> 01:11:41,890
那么，我们该如何对这样的事情进行分析呢？

1152
01:11:41,890 --> 01:11:48,030
好吧，我们可以用纸笔来做，然后数一数代码中逻辑上似乎隐含的步骤数。

1153
01:11:48,030 --> 01:11:52,890
我们简直可以数出我从左到右一次又一次走了多少步。

1154
01:11:52,890 --> 01:11:55,830
我们也可以只计算比较的次数

1155
01:11:55,830 --> 01:11:58,302
我和每个相关人员都在一起工作。

1156
01:11:58,302 --> 01:12:00,510
在选择排序时，我做得有点快。

1157
01:12:00,510 --> 01:12:04,950
但每当我看着一个人做出决定时，我是否要记住那个数字是最小的？

1158
01:12:04,950 --> 01:12:11,700
那个数字，我是在用等号或小于号或大于号比较两个值，至少如果我们在代码中这样做的话是这样。

1159
01:12:11,700 --> 01:12:13,110
因此，这往往是常态。

1160
01:12:13,110 --> 01:12:23,490
在分析类似算法时，我们需要计算比较次数，因为它是一种全局衡量单位，我们可以用它来比较不同的算法。

1161
01:12:23,490 --> 01:12:35,220
因此，我们也要想一想，在一般情况下，当我们有超过 8 个志愿者、超过 7 扇门时，我们可以将我们的数组一般化，因为这是括号 0 中的第一个元素。

1162
01:12:35,220 --> 01:12:37,770
其末尾总是 n 减 1。

1163
01:12:37,770 --> 01:12:47,200
因此，数组或门（在本例中为志愿者）的数字索引总是从 0 到 n 减 1（如果总共有 n 个）。

1164
01:12:47,200 --> 01:12:50,940
那么，我们该如何分析选择排序的代码呢？

1165
01:12:50,940 --> 01:12:56,370
那么，我花了多少步才找到第一个最小元素？

1166
01:12:56,370 --> 01:13:06,100
或者更准确地说，当我从左到右寻找我们的第一个最小的人时，我需要进行多少次比较，最后结果是 0？

1167
01:13:06,100 --> 01:13:09,310
我从左到右走了多少次？

1168
01:13:09,310 --> 01:13:15,850
如果台上有八个人，我一共做了多少次比较？

1169
01:13:15,850 --> 01:13:18,280
比如说，如果有八个人，我就把这些人比下去。

1170
01:13:18,280 --> 01:13:22,210
然后这个人，这个人，是的。

1171
01:13:22,210 --> 01:13:23,412
是的，一共七个，对吗？

1172
01:13:23,412 --> 01:13:29,960
因为如果台上有八个人，你一共只能进行七次比较，否则你就会把一个数字和它自己进行比较。

1173
01:13:29,960 --> 01:13:38,560
因此，在一般情况下，如果要对 n 个数字进行排序，首先找到最小的元素需要进行 n 减 1 的比较。

1174
01:13:38,560 --> 01:13:41,275
也许从左到右共有 n 个台阶。

1175
01:13:41,275 --> 01:13:46,030
但比较的次数，我认为只是一个有用的度量单位，是 n 减 1。

1176
01:13:46,030 --> 01:13:48,490
找到下一个最小的人怎么样？

1177
01:13:48,490 --> 01:13:53,200
我花了多少步才找到下一个最小的数字，最后是数字 1？

1179
01:13:56,855 --> 01:13:58,340
学生： n 减 2。

1180
01:13:58,340 --> 01:13:59,600
戴维-马兰：是的，所以是 n 减 2。

1182
01:13:59,870 --> 01:14:01,610
因为我已经解决了一个问题。

1183
01:14:01,610 --> 01:14:03,210
有人已经在正确的位置上了。

1184
01:14:03,210 --> 01:14:05,490
如果一而再、再而三地计算，那就太傻了。

1185
01:14:05,490 --> 01:14:09,200
这样，我就可以把下一次的比较次数减少到 n 减 2。

1186
01:14:09,200 --> 01:14:12,350
第三次求最小的第三个数是 n 减 3。

1187
01:14:12,350 --> 01:14:19,620
然后，点点，点点，点点，大概这个故事，这个公式，就在最后只有一对人，也就是最后的人，可以比较的时候结束了。

1188
01:14:19,620 --> 01:14:28,220
所以，如果你觉得这有点像高中数学、高中物理或类似题目的复现，那么请允许我说明一下，如果你真的做完了这道数学题

1189
01:14:28,220 --> 01:14:33,392
并加以推广，就等于 n 乘以 n 减 1 再除以 2。

1190
01:14:33,392 --> 01:14:35,100
如果你已经生疏了，也没什么大不了的。

1191
01:14:35,100 --> 01:14:42,302
你只要记住，任何时候，只要你把这种系列加起来，一些东西加上一些稍小的东西，再加上一些稍小的东西，其中每一个

1192
01:14:42,302 --> 01:14:46,520
n 乘以 n 再减去 1 得到 2。

1193
01:14:46,520 --> 01:14:51,680
当然，如果我们把它乘出来，实际上就是 n 的平方减去 n，再除以 2。

1194
01:14:51,680 --> 01:14:56,540
如果我们继续相乘，那就是 n 的平方除以 2 再减去 n 超过 2。

1195
01:14:56,540 --> 01:15:03,140
现在，我们有了一种词汇，可以用来讨论这种算法的效率和设计。

1196
01:15:03,140 --> 01:15:09,560
但老实说，我并不太在意这种精确度，比如 n 的平方除以 2 再减去 n 除以 2。

1197
01:15:09,560 --> 01:15:20,190
当 n 越来越大时，哪一个符号、哪一个术语将真正占据主导地位，成为步骤总价值的最大影响因素？

1199
01:15:20,690 --> 01:15:21,890
是广场，对吗？

1200
01:15:21,890 --> 01:15:23,382
绝对不是 n 除以 2。

1201
01:15:23,382 --> 01:15:24,590
这样可以节省一些时间。

1202
01:15:24,590 --> 01:15:27,800
但 n 的平方，随着 n 的增大，会变得非常大。

1203
01:15:27,800 --> 01:15:29,990
如果 n 是 100，那么 n 的平方更大。

1204
01:15:29,990 --> 01:15:32,570
如果 n 是一百万，那么 n 的平方确实更大。

1205
01:15:32,570 --> 01:15:43,130
所以，最后，当我们真的只是在讨论挥手分析和上限时，如果你愿意，让我们只说选择排序，就像这里分析的那样、

1206
01:15:43,130 --> 01:15:45,860
是 n 平方步的数量级。

1207
01:15:45,860 --> 01:15:47,690
这并不是精确的 n 平方步。

1208
01:15:47,690 --> 01:15:58,570
但你知道吗？n 的平方除以 2，直觉上可能是 n 的一半，但随着 n 越来越大，n 的平方才是真正重要的。

1209
01:15:58,570 --> 01:16:02,445
这时，你就会开始思考并试图解决世界上的谷歌问题。

1210
01:16:02,445 --> 01:16:07,490
当 n 变大时，你就必须变得更聪明，而不仅仅是天真地实现任何算法。

1211
01:16:07,490 --> 01:16:12,480
那么，这种算法属于哪一类呢？

1212
01:16:12,480 --> 01:16:19,610
事实证明，无论排序与否，在最坏的情况下，n 的平方是 n 步的平方。

1213
01:16:19,610 --> 01:16:28,670
但事实证明，如果我们考虑同样的代码，假设最好的情况是我们的八位志愿者上台，那么下限就会降低。

1214
01:16:28,670 --> 01:16:32,240
因为他们已经自己排序了，所以从 0 到 7。

1215
01:16:32,240 --> 01:16:34,490
假设他们正好在那个州。

1216
01:16:34,490 --> 01:16:42,670
遴选商店需要多少步骤才能对已经排序的志愿者名单进行排序？

1217
01:16:42,670 --> 01:16:43,420
有什么直觉吗？

1219
01:16:44,318 --> 01:16:47,186
学生：还会[听不清]吗？

1220
01:16:47,186 --> 01:16:49,717
它还会是 n --

1221
01:16:49,717 --> 01:16:51,180
学生：仍然是 7 [听不清]。

1222
01:16:51,180 --> 01:16:55,710
戴维-马兰：因此，对于第一次穿越，人类的第一次穿越仍将是 7 次。

1223
01:16:55,710 --> 01:16:58,530
因为，尽管我声称 "0 "在这里、

1224
01:16:58,530 --> 01:17:03,990
我不知道 "0 "是最小的，直到我一路走过去做了七次比较。

1225
01:17:03,990 --> 01:17:08,220
好吧，好吧，第一次一般用了 7 步或更多 n 减 1 步。

1226
01:17:08,220 --> 01:17:14,370
如果我寻找下一个最小的元素，而故事中的人类已经从 0 到 7 排序了呢？

1227
01:17:14,370 --> 01:17:17,580
是的，1 号在这里，我先看到他们。

1228
01:17:17,580 --> 01:17:22,530
但我不知道他们是最小的，直到我和其他人比较后才知道他们是最小的。

1229
01:17:22,530 --> 01:17:24,238
我们会说，哦，那太愚蠢了。

1230
01:17:24,238 --> 01:17:26,550
那时，我手里已经有了最小的那个人。

1231
01:17:26,550 --> 01:17:31,650
因此，这个伪代码，这个选择排序的实现，就是这样固定下来的。

1232
01:17:31,650 --> 01:17:35,490
没有什么特例说，如果已经排序，就提前退出。

1233
01:17:35,490 --> 01:17:37,860
总是需要 N 个平方的步骤。

1234
01:17:37,860 --> 01:17:50,790
因此，在这种情况下，如果我们借用之前使用欧米茄符号的行话，为了清楚起见，选择排序也将以 n 平方的欧米茄形式出现、

1235
01:17:50,790 --> 01:17:59,040
因为即使在最好的情况下，即列表已经排序，你也会浪费大量时间去验证或发现同样多的信息、

1236
01:17:59,040 --> 01:18:01,750
尽管我们人类当然能立刻看到它。

1237
01:18:01,750 --> 01:18:08,425
因此，在最坏的情况下，选择排序似乎需要 n 个平方步骤，而在最好的情况下，选择排序也需要 n 个平方步骤。

1238
01:18:08,425 --> 01:18:09,300
你知道吗？

1239
01:18:09,300 --> 01:18:11,280
对此，我们可以使用我们的 Theta 术语。

1240
01:18:11,280 --> 01:18:19,652
这里有一种算法，就像前面的计数法一样，无论数组是否从一开始就排序，它总是需要 n 平方步。

1241
01:18:19,652 --> 01:18:21,360
好吧，希望我们能做得更好。

1242
01:18:21,360 --> 01:18:25,618
之前有人提出，气泡排序感觉使用的步骤更少了。

1243
01:18:25,618 --> 01:18:26,910
好吧，让我们接下来考虑这个问题。

1244
01:18:26,910 --> 01:18:30,630
对于气泡排序，我声称我们有这样的伪代码。

1245
01:18:30,630 --> 01:18:33,780
因此，让我们先关注代码的内部。

1246
01:18:33,780 --> 01:18:36,120
在这下面，我在做什么？

1247
01:18:36,120 --> 01:18:39,960
对于从 0 到 n 减 2 的 i。

1248
01:18:39,960 --> 01:18:40,740
这就奇怪了。

1249
01:18:40,740 --> 01:18:42,360
我们以前从未见过 n 负 2。

1250
01:18:42,360 --> 01:18:44,040
但我还是问了这个问题。

1251
01:18:44,040 --> 01:18:50,160
如果第 i 个括号中的数字和第 i 个括号中的数字加 1 的顺序不对，则对调它们。

1252
01:18:50,160 --> 01:18:53,610
所以，当我在这里指着我们的前两名志愿者时，他们就是我们的志愿者。

1253
01:18:53,610 --> 01:18:57,090
我看到它们的顺序不对，所以就把它们对调了。

1254
01:18:57,090 --> 01:19:09,670
但是，我为什么要一次又一次地这样做，直到 n 减 2，而不是 n 减 1，因为到目前为止，我们一直使用 n 减 1 作为最右边的边界？

1255
01:19:09,670 --> 01:19:14,170
有没有直觉告诉我为什么要从 0 到 n 减 2 这样做？

1257
01:19:14,700 --> 01:19:18,540
学生：[听不清]数字，你不能去掉第几个数字。

1258
01:19:18,540 --> 01:19:21,005
没有良性角色可以与你交换。

1259
01:19:21,005 --> 01:19:21,880
大卫-马兰：没错。

1260
01:19:21,880 --> 01:19:31,550
因为我在这里查看的是这个伪代码中的第 i 个人和第 i 个加 1 个人，所以我最好确保不会超出数组的边界。

1261
01:19:31,550 --> 01:19:33,010
如果你想到我的左手

1262
01:19:33,010 --> 01:19:41,350
当我背对着你，指着第一个位置上的人时，我的右手就会指着旁边的人。

1263
01:19:41,350 --> 01:19:44,740
在这些人中，你要一直用左手迭代。

1264
01:19:44,740 --> 01:19:47,620
但你不希望你的左手指向最后一个人。

1265
01:19:47,620 --> 01:19:50,000
你希望它指向倒数第二个人。

1266
01:19:50,000 --> 01:19:54,220
但我们知道，最后一个人总是 n 减 1。

1267
01:19:54,220 --> 01:19:57,820
因此，从数学角度看，倒数第二个人的位置是 n 减 2。

1268
01:19:57,820 --> 01:19:58,780
因此，这是一个微妙之处。

1269
01:19:58,780 --> 01:20:00,880
但这是一个等待发生的故障。

1270
01:20:00,880 --> 01:20:08,170
如果用 n 减 1 来实现冒泡排序，我的右手就会超出数组的边界，所以很糟糕。

1271
01:20:08,170 --> 01:20:10,490
好吧，为什么我说了N遍？

1272
01:20:10,490 --> 01:20:13,070
我们与人类的合作非常有机。

1273
01:20:13,070 --> 01:20:19,840
但每次都有人 -- 我每次通过阵列 -- 都会有人冒泡爬到最后。

1274
01:20:19,840 --> 01:20:22,870
7 号，然后是 6 号，然后是 5 号。

1275
01:20:22,870 --> 01:20:26,600
因此，如果每次通过志愿者数组时、

1276
01:20:26,600 --> 01:20:36,940
我至少在解决一个问题，看起来冒泡排序总共运行 n 次就能解决所有 n 个问题，因为第一次运行至少会有一个数字到位。

1277
01:20:36,940 --> 01:20:38,470
第二次通过，第二个数字到位。

1278
01:20:38,470 --> 01:20:39,970
你可能会很幸运，它会做得更多。

1279
01:20:39,970 --> 01:20:41,740
但在最坏的情况下，这感觉已经足够了。

1280
01:20:41,740 --> 01:20:46,240


1281
01:20:46,240 --> 01:20:49,780
好吧，技术上 -- 好吧，现在我们要进入杂草了。

1282
01:20:49,780 --> 01:20:58,900
从技术上讲，你可以用减 1 的方式来重复它，因为如果你解决了所有 n 减 1 的其他问题，只剩下 1 个问题，那么从逻辑上讲，这个人就到了他们应该到的地方。

1283
01:20:58,900 --> 01:21:02,540
如果你已经把其他东西都整理好了，只剩下 1，那么它就已经冒泡了。

1284
01:21:02,540 --> 01:21:03,980
那么，我们该如何分析呢？

1285
01:21:03,980 --> 01:21:06,670
那么，在泡沫排序中，我们可以这样做。

1286
01:21:06,670 --> 01:21:11,015
我基本上是在做 n 减 1 的事情 n 减 1 次。

1287
01:21:11,015 --> 01:21:14,980
现在，让我回到伪代码上，因为这个不太明显。

1288
01:21:14,980 --> 01:21:21,110
在这里，您实际上可以从您的循环中以数学方式推断出您走了多少步。

1289
01:21:21,110 --> 01:21:24,585
因此，第一行的字面意思是：重复下面的 n 减 1 次。

1290
01:21:24,585 --> 01:21:28,240
因此，这将非常直接地转化为我们的数学公式。

1291
01:21:28,240 --> 01:21:30,190
做 n 次减 1 次。

1292
01:21:30,190 --> 01:21:35,840
因为我使用的是 for 循环术语，所以这个循环的框架有点不同。

1293
01:21:35,840 --> 01:21:43,258
但是，如果从 0 到 n 减 2 的迭代，则总共迭代了 n 减 1 次。

1294
01:21:43,258 --> 01:21:45,550
再说一遍，算术题有点烦人。

1295
01:21:45,550 --> 01:21:48,470
但这只是意味着做下面的 n 减 1 次。

1296
01:21:48,470 --> 01:21:51,670
所以要做 n 次减 1 的事情 n 次减 1 次。

1297
01:21:51,670 --> 01:21:54,440
现在我们可以计算如下。

1298
01:21:54,440 --> 01:21:57,940
我们有一个 n 减 1 乘以 n 减 1 的公式。

1299
01:21:57,940 --> 01:22:03,100
我们在这里用我们的 FOIL 小方法，n 的平方减 1 乘以 n，减 1 乘以 n，再加 1。

1300
01:22:03,100 --> 01:22:06,550
n 平方减 2n 加 1。

1301
01:22:06,550 --> 01:22:10,900
但此时，当 n 变得非常大时，我们真正关心的是哪个项呢？

1302
01:22:10,900 --> 01:22:13,390
这相当于什么？

1303
01:22:13,390 --> 01:22:14,870
是的，n 平方。

1304
01:22:14,870 --> 01:22:16,780
所以，至少从渐近的角度来看是这样。

1305
01:22:16,780 --> 01:22:20,830
渐进的意思是，当 n 接近无穷大时，会变得非常大。

1306
01:22:20,830 --> 01:22:25,430
原来，选择排序和冒泡排序的上限基本相同。

1307
01:22:25,430 --> 01:22:29,680
现在，如果我们真的吹毛求疵，比较比较的总数，它们可能会略有不同。

1308
01:22:29,680 --> 01:22:36,350
但当 n 越大时，说实话，你几乎不会注意到这两种算法之间的差别。

1309
01:22:36,350 --> 01:22:39,550
但下限呢？

1310
01:22:39,550 --> 01:22:45,470
如果冒泡排序的上限也是 n 的大 O，那么这里的下限呢？

1311
01:22:45,470 --> 01:22:50,170
那么，根据这个伪代码，冒泡排序的下限会是多少呢？

1312
01:22:50,170 --> 01:22:53,890
即使在最好的情况下，所有志愿者都已分类。

1313
01:22:53,890 --> 01:22:56,830
有什么直觉吗？

1314
01:22:56,830 --> 01:22:57,670
在这段伪代码中

1315
01:22:57,670 --> 01:22:58,538
是的，在中间。

1316
01:22:58,538 --> 01:22:59,830
学生：对不起，我有个简单的问题。

1317
01:22:59,830 --> 01:23:05,955
冒泡排序的结构不就是不需要比较已经冒泡的数字吗？

1318
01:23:05,955 --> 01:23:07,080
大卫-马兰：问得好。

1319
01:23:07,080 --> 01:23:12,860
气泡排序的设计不就是为了让你不需要比较已经冒泡的数字吗？

1320
01:23:12,860 --> 01:23:17,000
这就是中间隐含发生的事情。

1321
01:23:17,000 --> 01:23:19,220
我总是从左到右。

1322
01:23:19,220 --> 01:23:27,140
但请记住，即使我在最后搞砸了，最后两个人的顺序出了问题，我也总是需要从头开始，因为大数字是

1323
01:23:27,140 --> 01:23:29,691
小部分人往这边走。

1324
01:23:29,691 --> 01:23:32,892
学生：[听不清]

1325
01:23:32,892 --> 01:23:34,100
大卫-马兰：原来如此。

1326
01:23:34,100 --> 01:23:37,460
有一些小的优化，我在这里就不多说了。

1327
01:23:37,460 --> 01:23:40,700
我想说的是，最终的结果仍然是 n 的平方。

1328
01:23:40,700 --> 01:23:43,910
但这样做肯定会缩短实际运行时间。

1329
01:23:43,910 --> 01:23:46,340
但如果列表已经排序了呢？

1330
01:23:46,340 --> 01:23:51,020
目前，我们的伪代码不允许在列表已经排序的情况下提前退出。

1331
01:23:51,020 --> 01:23:58,850
因此，除非像我之前口头说的那样，修改我们的伪代码，否则我们将盲目地做 n 减 1 的事情和减 1 的次数、

1332
01:23:58,850 --> 01:23:59,960
我提出了这个建议。

1333
01:23:59,960 --> 01:24:08,990
在这个外循环中，如果你对所有志愿者进行了一次传递，而你的心理计数器没有进行任何交换，你就必须用某种变量来进行跟踪、

1334
01:24:08,990 --> 01:24:10,518
那你还是别说了。

1335
01:24:10,518 --> 01:24:17,550
因为如果你做了一整遍，却没有进行任何交换，为什么还要浪费时间再做一遍，期待有不同的表现呢？

1336
01:24:17,550 --> 01:24:26,640
因此，如果数据已经排序或大部分已经排序，为了帮助可视化这些数据，现在气泡排序就很有优势。

1338
01:24:27,140 --> 01:24:29,510
因为它确实有这个短路细节。

1339
01:24:29,510 --> 01:24:36,263
至少，如果我们这样做，如何才能更清晰地将这些事情可视化呢？

1340
01:24:36,263 --> 01:24:37,680
好吧，让我来做这件事。

1341
01:24:37,680 --> 01:24:46,850
让我在这里调出这些算法的可视化效果，这要感谢第三方工具，它可以帮助我们将这些排序算法可视化如下。

1342
01:24:46,850 --> 01:24:48,740
小横杠代表小数字。

1343
01:24:48,740 --> 01:24:50,480
大条形代表大数字。

1344
01:24:50,480 --> 01:24:56,843
因此，现在的想法是，当我点击这里的按钮时，所有的小条形图都会这样显示，所有的大条形图都会这样显示。

1345
01:24:56,843 --> 01:24:58,010
就像我们的志愿者一样。

1346
01:24:58,010 --> 01:25:02,370
不过，这不是点亮的数字，而是代表其大小的条形图。

1347
01:25:02,370 --> 01:25:07,190
那么，我们就从选择排序开始吧。

1348
01:25:07,190 --> 01:25:14,820
你会看到粉红色的当前数字被高亮显示，然后被拉到左边。

1349
01:25:14,820 --> 01:25:16,220
这就是选择排序。

1350
01:25:16,220 --> 01:25:20,420
同样，它会选择下一个最小的元素。

1351
01:25:20,420 --> 01:25:27,450
但在这里，你可以更明显地看到，就像我的脚一样，我们也在迈着大步。

1352
01:25:27,450 --> 01:25:32,430
那么，这种算法是否在一次又一次地接触这些元素呢？

1353
01:25:32,430 --> 01:25:34,970
这就是 "n 平方 "真正存在的原因。

1354
01:25:34,970 --> 01:25:37,322
这里肯定有一些固有的冗余。

1355
01:25:37,322 --> 01:25:40,280
比如，为什么我们要反复查看那些该死的元素？

1356
01:25:40,280 --> 01:25:43,070
从我们的伪代码来看，我们确实需要这样做。

1357
01:25:43,070 --> 01:25:48,782
但是，正是这种多余的比较解释了为什么 n 平方确实是这种情况。

1358
01:25:48,782 --> 01:25:49,490
现在已经完成了。

1359
01:25:49,490 --> 01:25:50,977
这里是小酒吧，那里是大酒吧。

1360
01:25:50,977 --> 01:25:54,650
我不得不在那里不停地说话来消磨时间，因为速度相对较慢。

1361
01:25:54,650 --> 01:25:58,640
好吧，让我重新随机排列，这样我们就能以不同的顺序开始了。

1362
01:25:58,640 --> 01:26:00,380
现在让我点击气泡排序。

1363
01:26:00,380 --> 01:26:03,240
你会看到类似的想法，但算法不同。

1364
01:26:03,240 --> 01:26:09,995
因此，现在粉红色的两个条形图是正在比较和修正的两个条形图，如果它们的顺序不对的话。

1365
01:26:09,995 --> 01:26:14,420
你已经可以看到，最大的条形图正在往上冒泡。

1366
01:26:14,420 --> 01:26:22,740
但现在，你也能看到这种冗余，就像我们不停地在列表中反复扫视，就像我不停地来回走动。

1367
01:26:22,740 --> 01:26:23,795
这就是 n 的平方。

1368
01:26:23,795 --> 01:26:24,920
这样的酒吧并不多。

1370
01:26:25,420 --> 01:26:27,830
10个、20个，我猜大概有40个吧。

1371
01:26:27,830 --> 01:26:31,560
光是排序 40 个数字就已经很慢了。

1372
01:26:31,560 --> 01:26:34,310
而且我觉得，如果我继续说下去，会变得很乏味。

1373
01:26:34,310 --> 01:26:37,590
因此，我们姑且认为这也相对较慢。

1374
01:26:37,590 --> 01:26:43,310
如果我运气好，列表几乎已经排序完毕，那么冒泡排序就会非常快。

1375
01:26:43,310 --> 01:26:46,040
但这确实是一个随机排列，所以我们并不走运。

1376
01:26:46,040 --> 01:26:50,010
因此，最坏的情况可能就是这样。

1377
01:26:50,010 --> 01:26:55,980
所以我觉得，如果我不让你看到结尾，就像憋着喷嚏一样，会让人觉得很反常。

1378
01:26:55,980 --> 01:26:57,890
那么，我们开始吧。

1379
01:26:57,890 --> 01:27:00,110
没什么有趣的事情要发生了。

1380
01:27:00,110 --> 01:27:02,330
快好了

1382
01:27:03,080 --> 01:27:05,890
好的，谢谢。

1385
01:27:09,110 --> 01:27:12,500
所以速度还是有点慢。

1386
01:27:12,500 --> 01:27:15,800
不过，我们如何才能从根本上做得更好一些呢？

1387
01:27:15,800 --> 01:27:19,070
因此，如果我们引入另一种技术，就可以做到这一点。

1388
01:27:19,070 --> 01:27:22,130
这与其说是代码的作用，不如说是概念的作用。

1389
01:27:22,130 --> 01:27:27,500
你可能在现实世界中见过这种情况，但也许并不那么明显。

1390
01:27:27,500 --> 01:27:34,970
原来，在编程中，递归指的是函数调用自身的能力。

1391
01:27:34,970 --> 01:27:43,850
在数学世界里，如果你有一个函数 f，如果 f 同时出现在一个公式的左边和右边，那么在数学世界里这也是一个递归函数。

1392
01:27:43,850 --> 01:27:53,660
只要 f 是以自身为单位定义的，或者在我们的例子中以计算为单位定义的--在程序设计中，只要函数调用自身，该函数就被称为递归函数。

1393
01:27:53,660 --> 01:27:57,373
这其实是我们在课堂上已经看到过的，尽管我们没有说得那么多。

1394
01:27:57,373 --> 01:28:07,760
因此，举个例子，看一下之前的这个伪代码，这是通过二进制搜索进行搜索的伪代码，其中有一大堆门。

1395
01:28:07,760 --> 01:28:12,600
如果没有门，则返回 false，这是我们添加的附加条件。

1396
01:28:12,600 --> 01:28:20,780
但如果中门后面的数字返回 true，有趣的是，如果数字小于中门，则搜索左半边。

1397
01:28:20,780 --> 01:28:24,020
否则，如果数字大于中门，则搜索右半部分。

1398
01:28:24,020 --> 01:28:27,800
前面的伪代码本身就是递归的。

1400
01:28:28,340 --> 01:28:30,590
因为这是一种搜索算法。

1401
01:28:30,590 --> 01:28:32,650
但算法告诉了我们什么？

1402
01:28:32,650 --> 01:28:37,280
嗯，在这一行和这一行，它告诉我们要搜索别的东西。

1403
01:28:37,280 --> 01:28:47,650
因此，尽管代码中没有明确定义它的名称，但如果这是一个搜索算法，而搜索算法又使用了搜索算法，那么这个伪代码就是递归的。

1404
01:28:47,650 --> 01:28:53,410
现在，如果函数一次又一次地调用自己，很快就会给你带来麻烦。

1405
01:28:53,410 --> 01:29:01,840
但是，从直觉上讲，为什么这些代码、这些伪代码调用自己没有问题呢？

1406
01:29:01,840 --> 01:29:03,460
为什么算法还会停止？

1408
01:29:03,970 --> 01:29:07,525
学生：它有一个出口条件，就像如果没有门了，[听不清]......

1409
01:29:07,525 --> 01:29:08,400
大卫-马兰：没错。

1410
01:29:08,400 --> 01:29:10,860
它有一些退出条件，比如没有门了。

1411
01:29:10,860 --> 01:29:17,120
更重要的是，任何时候搜索左半部分，都是在搜索问题的缩小版。

1412
01:29:17,120 --> 01:29:22,330
任何时候搜索右半部分，都是在搜索问题的缩小版，实际上只有一半大小。

1413
01:29:22,330 --> 01:29:24,270
这就是为什么在电话簿中，很明显

1414
01:29:24,270 --> 01:29:29,560
我不能把电话簿无限次地撕成两半，因为每撕一次，它就会变小一次。

1415
01:29:29,560 --> 01:29:33,580
因此，如果你愿意，递归就是这种召唤自己的能力。

1416
01:29:33,580 --> 01:29:42,010
但重要的是，你要在越来越小的问题上做这件事，这样最终，你就没有更多的问题要解决，也没有更多的数据，更没有更多的门了。

1417
01:29:42,010 --> 01:29:46,210
因此，这两行就是递归元素。

1418
01:29:46,210 --> 01:29:49,690
但如果回到第 0 周，我们本可以用其他方式使用递归。

1419
01:29:49,690 --> 01:29:53,040
这就是我们在第 0 周时为电话簿编写的伪代码。

1420
01:29:53,040 --> 01:29:59,050
记得我们曾描述过，这些黄线实际上代表了一个循环，一种周而复始的循环。

1421
01:29:59,050 --> 01:30:01,080
但这里错失了一个机会。

1422
01:30:01,080 --> 01:30:05,670
如果我重新实现这段代码，会怎样呢？

1423
01:30:05,670 --> 01:30:14,610
而不是说打开左半边书的中间部分，然后回到第 3 行，就像字面意义上的循环，或者打开右半边书的中间部分，然后回到第 3 行。

1424
01:30:14,610 --> 01:30:23,730
到第 3 行引起另一个循环，我为什么不承认我现在看到的是一个搜索电话簿的算法呢？

1425
01:30:23,730 --> 01:30:30,750
如果你想搜索一个较小的电话簿，比如从 A 到 M 或从 N 到 Z，我们将使用相同的算法。

1426
01:30:30,750 --> 01:30:35,100
因此，我可以随便用这个来代替这些黄线。

1427
01:30:35,100 --> 01:30:37,282
搜索书的左半部分，搜索书的右半部分。

1428
01:30:37,282 --> 01:30:43,633
这将是隐式的，现在我可以缩短整个过程，是第 0 周电话簿伪代码的递归实现。

1429
01:30:43,633 --> 01:30:48,900
而且它是递归的，因为如果这是一种搜索算法，你说去搜索别的东西，那就没问题。

1430
01:30:48,900 --> 01:30:49,890
这是递归的。

1431
01:30:49,890 --> 01:30:55,710
但是，因为你搜索的是电话簿的一半，所以它确实会越来越小。

1432
01:30:55,710 --> 01:31:03,820
即使在现实世界或真实的虚拟世界中，你也能看到递归数据结构的身影，至少在《超级马里奥兄弟》中是这样。

1433
01:31:03,820 --> 01:31:10,860
让我摒弃一切杂念，把注意力集中在这个金字塔上，这里有一个区块，然后是两个区块，三个区块，四个区块。

1434
01:31:10,860 --> 01:31:16,590
那么，从技术上讲，这本身就是递归定义的，那么，高度的金字塔是用来做什么的呢？

1435
01:31:16,590 --> 01:31:18,420
嗯，这真的是什么？

1436
01:31:18,420 --> 01:31:25,743
你如何描述高度为 4 的金字塔与高度为 -- 的金字塔？

1437
01:31:25,743 --> 01:31:28,200
学生：身高 3.

1438
01:31:28,200 --> 01:31:30,750
戴维-马兰：3层高，外加一层。

1439
01:31:30,750 --> 01:31:32,370
那么，高度为 3 的金字塔是什么呢？

1440
01:31:32,370 --> 01:31:36,250
严格来说，这是一个高度为 2 加 1 层的金字塔。

1441
01:31:36,250 --> 01:31:40,630
因此，即使是物理结构也可以是递归的，只要你能用它本身来定义它们。

1442
01:31:40,630 --> 01:31:46,090
现在，你不得不说，如果金字塔的高度是 1，就只有一个积木块。

1443
01:31:46,090 --> 01:31:50,440
你不能永远说它是以负 1 或负 2 的高度定义的，那样你就永远停不下来了。

1444
01:31:50,440 --> 01:31:52,752
因此，你必须有一种特殊的情况。

1445
01:31:52,752 --> 01:31:55,710
不过，让我们继续把这样的东西翻译成代码吧。

1446
01:31:55,710 --> 01:32:03,090
让我回到 VS 代码这里，让我实现一个名为迭代的程序，它指的是循环迭代。

1447
01:32:03,090 --> 01:32:05,620
让我来实现这样一个非常简单的金字塔。

1448
01:32:05,620 --> 01:32:08,370
因此，让我继续把 CS50 库包括进来。

1449
01:32:08,370 --> 01:32:14,918
我将加入标准的 io.h int main void，今天没有命令行参数。

1450
01:32:14,918 --> 01:32:16,210
让我们开始吧。

1451
01:32:16,210 --> 01:32:21,150
让我们声明一个名为 height 的变量，向人类询问这座金字塔的高度。

1452
01:32:21,150 --> 01:32:25,300
然后，让我们继续绘制这个高度的金字塔。

1453
01:32:25,300 --> 01:32:27,580
当然，现在抽奖还不存在。

1454
01:32:27,580 --> 01:32:30,090
所以我需要发明绘制函数。

1455
01:32:30,090 --> 01:32:33,180
让我继续定义一个没有返回值的函数。

1456
01:32:33,180 --> 01:32:34,722
只是会有副作用。

1457
01:32:34,722 --> 01:32:37,230
它只是在屏幕上打印砖块，称为绘制。

1458
01:32:37,230 --> 01:32:40,240
它的输入是一个整数 n。

1459
01:32:40,240 --> 01:32:41,950
我该如何实施呢？

1460
01:32:41,950 --> 01:32:46,530
同样，我想打印一个区块，然后是两个、三个、四个。

1461
01:32:46,530 --> 01:32:49,680
这非常简单，至少在你熟悉了循环之后是这样。

1462
01:32:49,680 --> 01:32:51,370
让我回到代码这里。

1463
01:32:51,370 --> 01:32:58,260
我先说 4，int i，得到 0，i 小于 n，i 加上 plus。

1464
01:32:58,260 --> 01:33:01,170
这将逐行迭代。

1465
01:33:01,170 --> 01:33:06,060
在每一行上，我要打印出一块砖，然后是两块、三块、四块。

1466
01:33:06,060 --> 01:33:08,815
但我是从 0 到 1 再到 2 再到 3 的迭代。

1467
01:33:08,815 --> 01:33:09,690
所以，我觉得这没问题。

1468
01:33:09,690 --> 01:33:19,380
我可以这样说：4 int j 得到 0。j，让我们聪明点，小于 i。

1469
01:33:19,380 --> 01:33:22,560
现在，让我继续前进，进入这个循环、

1470
01:33:22,560 --> 01:33:27,130
我想我只需要打印出一个哈希符号就可以了。

1471
01:33:27,130 --> 01:33:30,270
但在这个循环之外，情况与上周类似、

1472
01:33:30,270 --> 01:33:32,920
我要单独打印我的新生产线。

1473
01:33:32,920 --> 01:33:34,470
所以一开始有点不明显。

1474
01:33:34,470 --> 01:33:38,790
但这个外循环是逐行迭代的，也可以说是逐行迭代。

1475
01:33:38,790 --> 01:33:46,890
然后内循环确保当 i 等于 0 时，让我们看看。

1476
01:33:46,890 --> 01:33:48,960
哦，不，有一个错误。

1477
01:33:48,960 --> 01:33:52,170
我需要确保它的 j 小于 i 加 1。

1478
01:33:52,170 --> 01:33:55,500
因此，当我的第一行输出中 i 为 0 时、

1479
01:33:55,500 --> 01:33:57,600
我要打印出一块砖。

1480
01:33:57,600 --> 01:34:02,350
当 i 为 1 时，我会打印出两块砖，以此类推。

1481
01:34:02,350 --> 01:34:05,460
所以，让我继续运行迭代。

1482
01:34:05,460 --> 01:34:09,090
好了，现在似乎可以编译了。

1483
01:34:09,090 --> 01:34:10,770
哦

1484
01:34:10,770 --> 01:34:12,900
函数 draw 的隐式声明。

1485
01:34:12,900 --> 01:34:16,100
所以我又犯了第一周的错误。

1488
01:34:17,570 --> 01:34:18,450
学生：[听不清]

1489
01:34:18,450 --> 01:34:19,200
是的

1490
01:34:19,200 --> 01:34:20,320
原型不见了。

1491
01:34:20,320 --> 01:34:21,300
我没有在上面宣布。

1492
01:34:21,300 --> 01:34:23,550
这是很容易解决的问题，也是唯一一次，真的

1493
01:34:23,550 --> 01:34:25,530
确定，需要复制粘贴。

1494
01:34:25,530 --> 01:34:29,050
让我把函数声明复制到这里，并加上分号。

1495
01:34:29,050 --> 01:34:32,370
因此，铛现在知道绘制将存在。

1496
01:34:32,370 --> 01:34:33,240
进行迭代。

1497
01:34:33,240 --> 01:34:33,930
现在好用了。

1498
01:34:33,930 --> 01:34:36,090
谢谢。

1499
01:34:36,090 --> 01:34:37,830
我们将输入类似 4 的内容。

1500
01:34:37,830 --> 01:34:43,340
这就是我们的金字塔，高度分别为 1、2、3、4，看起来与这个非常相似，尽管使用的是哈希值。

1501
01:34:43,340 --> 01:34:49,110
两周前的第一周，也许是上周，我们就是这样实现的，但只是使用数组。

1502
01:34:49,110 --> 01:34:53,640
但我建议，我们可以用递归的方式来代替。

1503
01:34:53,640 --> 01:34:55,480
请允许我结束这一版本的代码。

1504
01:34:55,480 --> 01:35:01,800
让我回到 VS 代码，打开 recursion.c，演示一下递归。

1505
01:35:01,800 --> 01:35:04,420
我第一次就会故意做错。

1506
01:35:04,420 --> 01:35:06,630
因此，让我加入 cs50.h。

1507
01:35:06,630 --> 01:35:08,850
让我加入标准 io.h。

1508
01:35:08,850 --> 01:35:12,000
让我来做 int main void。

1509
01:35:12,000 --> 01:35:17,910
让我盲目地画一个高度为 1 的金字塔。

1510
01:35:17,910 --> 01:35:21,910
但现在在我的绘制函数中，让我以一种稍有不同的方式重新实现它。

1511
01:35:21,910 --> 01:35:24,840
因此，这次我的绘制函数仍将取一个数字 n。

1512
01:35:24,840 --> 01:35:26,860
但这就是它要打印的哈希值。

1513
01:35:26,860 --> 01:35:34,050
所以我们来做 4，int i 得到 0，i 小于 n，i++。

1514
01:35:34,050 --> 01:35:38,440
然后在这里打印出一个散列标记。

1515
01:35:38,440 --> 01:35:44,290


1516
01:35:44,290 --> 01:35:49,770
当然，现在只能绘制单行。

1517
01:35:49,770 --> 01:35:54,750
它会打印出一个哈希值、两个哈希值或三个哈希值，但只能打印在一行上。

1518
01:35:54,750 --> 01:35:58,560
现在，让我以一种好奇的口吻说，好吧。

1519
01:35:58,560 --> 01:36:04,860
好吧，如果这画出的是高度为 1 的金字塔，那么我们就用自己来画一个高度为 n 加 1 的金字塔吧。

1520
01:36:04,860 --> 01:36:08,370
因此，我第一次调用 draw 时，它会打印出一个哈希值。

1521
01:36:08,370 --> 01:36:13,770
然后，当我第二次调用 draw 时，它会打印出两个哈希值，然后是三个，最后是四个。

1522
01:36:13,770 --> 01:36:18,000
因此，我们要从上到下铺设这些砖块。

1523
01:36:18,000 --> 01:36:20,670
进行递归。

1524
01:36:20,670 --> 01:36:22,420
哎呀，我又搞砸了。

1525
01:36:22,420 --> 01:36:24,630
因此，让我们在这里复制原型。

1526
01:36:24,630 --> 01:36:27,260
把这个放在这里，分号。

1527
01:36:27,260 --> 01:36:28,600
让我们再来一次。

1528
01:36:28,600 --> 01:36:30,010
进行递归。

1529
01:36:30,010 --> 01:36:32,410
好的，很好，点斜线递归。

1530
01:36:32,410 --> 01:36:37,310
现在让我增大终端窗口的大小，以便你能看到更多的输出。

1531
01:36:37,310 --> 01:36:39,490
这就是

1532
01:36:39,490 --> 01:36:41,480
好吧，不好，但还是谢谢你。

1533
01:36:41,480 --> 01:36:43,525
这样，我们就有了一个无限高的金字塔。

1534
01:36:43,525 --> 01:36:47,020
它在屏幕上飞来飞去，所以看起来有点乱。

1535
01:36:47,020 --> 01:36:51,670
但我打印出了一个高度为 1 的金字塔，然后是 2，然后是 3，然后是 4。

1536
01:36:51,670 --> 01:36:59,353
不幸的是，我缺乏任何一种快速条件，任何一种说 "等一下，太高了就完全停下来 "的条件。

1537
01:36:59,353 --> 01:37:00,520
因此，这是一个无限循环。

1538
01:37:00,520 --> 01:37:01,570
但这不是一个循环。

1539
01:37:01,570 --> 01:37:03,250
这是一个递归调用。

1540
01:37:03,250 --> 01:37:05,780
实际上，一般来说，这样做是非常不好的。

1541
01:37:05,780 --> 01:37:14,050
我们将在下周看到，如果你调用一个函数的次数过多，实际上会触发另一个分段故障，因为你使用了太多的内存。

1542
01:37:14,050 --> 01:37:16,300
但现在，我还没有触发这个功能。

1543
01:37:16,300 --> 01:37:17,927
控制 C 是您取消操作的朋友。

1544
01:37:17,927 --> 01:37:22,750
顺便说一句，如果你在家里玩，或者稍后再玩这个代码，实际上我在这里作弊了。

1545
01:37:22,750 --> 01:37:29,350
我们有一个特殊的 clang 配置功能，可以防止你调用这样的函数而产生问题。

1546
01:37:29,350 --> 01:37:31,598
为了演示，我把它推翻了。

1547
01:37:31,598 --> 01:37:34,640
但在家里，你很可能无法自己编译这些代码。

1548
01:37:34,640 --> 01:37:39,050
不过，让我来做一个适当版本的递归代码，如下所示。

1549
01:37:39,050 --> 01:37:41,870
让我回到代码中。

1550
01:37:41,870 --> 01:37:46,540
让我继续前进，不要盲目地开始画一层、两层、三层砖块。

1551
01:37:46,540 --> 01:37:53,350
让我像之前一样，使用 get int 函数提示人类他们想要的金字塔高度。

1552
01:37:53,350 --> 01:37:55,670
现在，请允许我再次提醒大家注意身高。

1553
01:37:55,670 --> 01:37:58,330
所以，现在我又回到了类似循环的版本。

1554
01:37:58,330 --> 01:38:04,120
不过，现在不再使用循环了，可以说递归变得相当优雅。

1555
01:38:04,120 --> 01:38:10,690
让我继续执行绘制函数并编写代码如下。

1556
01:38:10,690 --> 01:38:18,520
根据你的定义，如果高度为 4 的金字塔实际上就是高度为 3 的金字塔再加一排，那我们就按字面意思来理解吧。

1557
01:38:18,520 --> 01:38:19,990
让我回到我的代码。

1558
01:38:19,990 --> 01:38:29,380
如果你想画一个高度为 4 的金字塔，那就先画一个高度为 3 的金字塔，或者更笼统地说，n 减 1。

1559
01:38:29,380 --> 01:38:30,640
但第二步是什么呢？

1560
01:38:30,640 --> 01:38:34,510
那么，一旦你画出了高度为 3 的金字塔，就再多画一行。

1561
01:38:34,510 --> 01:38:37,190
因此，我至少要自己解决这部分问题。

1562
01:38:37,190 --> 01:38:41,530
因此，让我对 int i 进行计算，得到 0，i 小于 n i++。

1563
01:38:41,530 --> 01:38:46,010
让我，这个函数的程序员，打印出我的哈希值。

1564
01:38:46,010 --> 01:38:50,350
然后在最下面打印出一行新的内容，这样光标就会移动到下一行。

1565
01:38:50,350 --> 01:38:58,570
但我敢说，现在这已经很优雅了，因为绘制是递归的，因为我实际上是从英语翻译成 C 代码、

1566
01:38:58,570 --> 01:39:02,050
高度为 4 的金字塔实际上只是高度为 3 的金字塔。

1567
01:39:02,050 --> 01:39:03,640
所以我先做这个。

1568
01:39:03,640 --> 01:39:06,560
我有点相信这会成功。

1569
01:39:06,560 --> 01:39:09,800
然后我只需再铺一层砖，一共四层。

1570
01:39:09,800 --> 01:39:15,520
因此，如果 n 为 4，这只是一个简单的 for 循环，就像第 1 周那样，会打印出额外的一层。

1571
01:39:15,520 --> 01:39:18,610
当然，这最终会成为问题。

1573
01:39:20,030 --> 01:39:22,670
这个项目还没有完成。

1574
01:39:22,670 --> 01:39:27,644
在这个模型中，绘制会自己调用多少次？

1575
01:39:27,644 --> 01:39:28,640
学生：是无限的。

1576
01:39:28,640 --> 01:39:30,098
无数次。

1578
01:39:30,814 --> 01:39:34,170
学生：因为没有退出功能。

1579
01:39:34,170 --> 01:39:36,450
戴维-马兰：是的，不存在退出。

1580
01:39:36,450 --> 01:39:41,050
比如，如果你已经印得够多了，那就不印了，那么，我们该如何捕捉呢？

1581
01:39:41,050 --> 01:39:43,320
我想我们都不希望这件事变得消极。

1582
01:39:43,320 --> 01:39:46,570
画一个负高度的金字塔是毫无意义的。

1583
01:39:46,570 --> 01:39:53,650
所以我认为，作为程序员，我们可以从一个简单的案例、一个简单的答案、一个所谓的基础案例中摘取下来。

1584
01:39:53,650 --> 01:39:54,900
我只是要做到这一点。

1585
01:39:54,900 --> 01:40:02,830
在我的绘制函数的顶端，我只想说，如果 n 小于或等于 0，就可以了。

1586
01:40:02,830 --> 01:40:04,530
去吧，直接回来。

1587
01:40:04,530 --> 01:40:06,030
没什么可做的了。

1588
01:40:06,030 --> 01:40:13,290
这个简单的条件在技术上被称为 "基本情况"，它将确保代码不会永远运行下去。

1590
01:40:13,860 --> 01:40:17,730
那么，假设调用 draw 时的参数是 4。

1591
01:40:17,730 --> 01:40:20,580
当然，4 不小于 0，所以我们不返回。

1592
01:40:20,580 --> 01:40:22,590
但我们确实画出了一个高度为 3 的金字塔。

1593
01:40:22,590 --> 01:40:24,870
这就是事情变得有点棘手的地方。

1594
01:40:24,870 --> 01:40:28,320
在叫出平局之前，您不会转到第 20 行。

1595
01:40:28,320 --> 01:40:34,230
因此，在调用参数为 3 的 draw 时，就好像再次从这个函数的顶层开始执行一样。

1596
01:40:34,230 --> 01:40:35,520
3 不小于 0。

1597
01:40:35,520 --> 01:40:36,330
那你该怎么办？

1598
01:40:36,330 --> 01:40:38,490
你抽到 2。

1599
01:40:38,490 --> 01:40:39,540
如何绘制 2？

1600
01:40:39,540 --> 01:40:41,950
那么，2 不小于 0，所以你不能返回。

1601
01:40:41,950 --> 01:40:43,050
所以你抽到了 1。

1602
01:40:43,050 --> 01:40:44,370
在这里一定要小心。

1604
01:40:45,240 --> 01:40:47,340
现在，我们回到开头。

1605
01:40:47,340 --> 01:40:48,090
如何画 1？

1606
01:40:48,090 --> 01:40:50,430
那么，1 不小于 0，所以你不能返回。

1607
01:40:50,430 --> 01:40:53,400
您绘制的高度为 0。

1608
01:40:53,400 --> 01:40:54,510
高度 0 如何绘制？

1609
01:40:54,510 --> 01:40:55,110
等一下

1610
01:40:55,110 --> 01:40:57,660
0 小于或等于 0。

1611
01:40:57,660 --> 01:40:58,980
你回来了

1612
01:40:58,980 --> 01:41:02,100
因此，这就像是一个心理堆栈，一个待办事项清单。

1613
01:41:02,100 --> 01:41:12,840
你不断推迟、执行这些较低的代码行，因为你不断重启、重启、重启绘制函数，直到最后，其中一个函数调用说没有事情可做、

1615
01:41:13,530 --> 01:41:16,530
现在，整个事情开始变得扑朔迷离。

1616
01:41:16,530 --> 01:41:18,330
然后你再回到你离开的地方。

1617
01:41:18,330 --> 01:41:20,300
这也许是最好的方案。

1618
01:41:20,300 --> 01:41:21,300
我们不会在课堂上做。

1619
01:41:21,300 --> 01:41:31,480
不过，如果你想自己用 debug50 来对每一行进行步进、步进、步进，那么从逻辑上讲，你就会明白到底发生了什么。

1620
01:41:31,480 --> 01:41:37,740
让我进入终端，执行 make recursion，这就是代码的正确版本，点斜线递归。

1621
01:41:37,740 --> 01:41:39,240
让我们输入 4 的高度。

1622
01:41:39,240 --> 01:41:47,910
瞧，现在我们有了同样的金字塔，虽然我们使用迭代来打印附加层，但本身并没有使用迭代。

1623
01:41:47,910 --> 01:41:55,120
我们现在使用 draw 递归来打印在它之前的所有小金字塔。

1624
01:41:55,120 --> 01:41:57,370
学生：只能在 void 函数中使用递归吗？

1626
01:41:58,123 --> 01:41:58,790
DAVID MALAN: No.

1627
01:41:58,790 --> 01:42:01,070
问题是，只能在 void 函数中使用递归吗？

1628
01:42:01,070 --> 01:42:01,920
不，一点也不。

1629
01:42:01,920 --> 01:42:11,360
事实上，通常情况下，返回值是一个整数或其他值，这样你就可以用这个实际值做一些有建设性的事情。

1630
01:42:11,360 --> 01:42:13,190
其他相关问题。

1631
01:42:13,190 --> 01:42:15,290
学生：第 21 行什么时候执行？

1632
01:42:15,290 --> 01:42:16,790
说大声点。

1633
01:42:16,790 --> 01:42:18,770
学生：第 21 行什么时候执行？

1634
01:42:18,770 --> 01:42:20,850
第 21 行何时执行？

1635
01:42:20,850 --> 01:42:26,600
所以，如果你继续 -- 让我再向下滚动一点，这样你就能看到代码的顶部。

1636
01:42:26,600 --> 01:42:35,310
因此，一旦第 19 行执行完毕，第 21 行就会被执行。

1637
01:42:35,310 --> 01:42:40,790
现在，在我讲述的故事中，我们不停地呼叫抽奖，一次又一次。

1638
01:42:40,790 --> 01:42:48,510
但是，只要其中一个 n 等于 0 的函数调用立即返回，我们就不会反复绘制了。

1639
01:42:48,510 --> 01:42:59,303
所以，现在如果你把这个过程看作是反向的，那么你就可以继续到第 21 行，然后再到第 21 行，然后再到第 21 行，这样的逻辑就解开了。

1640
01:42:59,303 --> 01:43:03,530
下周，我们将实际描绘计算机内存中的实际情况。

1641
01:43:03,530 --> 01:43:07,950
但就目前而言，这与电话簿的伪代码非常相似。

1642
01:43:07,950 --> 01:43:09,680
你只是在一次又一次地寻找。

1643
01:43:09,680 --> 01:43:14,408
但你要等到最后才能得到最终结果。

1644
01:43:14,408 --> 01:43:18,830
当然，我今天一直不约而同地提到的谷歌现在也有很多程序员。

1645
01:43:18,830 --> 01:43:20,600
这里有一个有趣的练习。

1646
01:43:20,600 --> 01:43:23,432
让我回到浏览器上。

1647
01:43:23,432 --> 01:43:27,980
我要继续搜索递归，因为我想学习一些关于递归的知识。

1648
01:43:27,980 --> 01:43:30,230
这是一个网络流行语或笑话。

1649
01:43:30,230 --> 01:43:35,360
如果我放大这里，谷歌的工程师们就会觉得很有趣。

1651
01:43:37,902 --> 01:43:38,798
学生：啊。

1652
01:43:38,798 --> 01:43:40,540
啊，这就对了。

1654
01:43:41,740 --> 01:43:43,030
是的，这就是递归。

1655
01:43:43,030 --> 01:43:48,490
现在，你会遇到很多关于递归的流行语，比如，如果你曾把摄像机对准电视机，那就是

1656
01:43:48,490 --> 01:43:52,660
在展示摄像机的过程中，你会一次又一次地看到自己或影像，这就是真正的递归。

1657
01:43:52,660 --> 01:43:56,320
而在这种情况下，只有在遇到单个像素的基本情况时才会停止。

1658
01:43:56,320 --> 01:44:01,880
不过，说到递归和谷歌，这在某些圈子里是个非常有趣的笑话。

1659
01:44:01,880 --> 01:44:08,050
那么，我们如何才能真正使用谷歌，或者说，我们如何才能真正建设性地使用递归呢？

1660
01:44:08,050 --> 01:44:16,870
好吧，让我提议，我们实际上引入了第三种也是最后一种排序算法，希望它能比迄今为止的两种排序算法做得更好。

1661
01:44:16,870 --> 01:44:19,480
我们已经完成了选择排序和气泡排序。

1662
01:44:19,480 --> 01:44:24,220
至少在列表已经排序的最佳情况下，我们更喜欢气泡排序。

1663
01:44:24,220 --> 01:44:30,490
泡泡排序至少更聪明，它实际上会提前结束，根据我们的欧米茄符号，给我们一个更好的下限。

1664
01:44:30,490 --> 01:44:36,250
但事实证明，递归并不一定是递归的特征，而是我们现在可以利用的东西。

1665
01:44:36,250 --> 01:44:47,560
事实证明，利用递归，我们可以采用一种根本不同的方法来对一大堆数字进行排序，这样我们就可以减少比较次数，并在理想情况下加快速度

1666
01:44:47,560 --> 01:44:49,010
我们的最终结果。

1667
01:44:49,010 --> 01:44:54,010
下面是我们将要看到的合并排序的伪代码。

1668
01:44:54,010 --> 01:44:56,230
而且真的如此简洁。

1669
01:44:56,230 --> 01:44:58,330
对左半部分数字进行排序。

1670
01:44:58,330 --> 01:45:00,550
对右半部分数字进行分类。

1671
01:45:00,550 --> 01:45:02,950
合并已排序的两半。

1672
01:45:02,950 --> 01:45:10,960
这几乎是无稽之谈，因为如果有人问你一种排序算法，你的回答是，好吧，左半排序，右半排序。

1673
01:45:10,960 --> 01:45:14,230
这太难了，因为我要求的是一种排序算法。

1674
01:45:14,230 --> 01:45:16,897
你只是让我把左半边和右半边分类。

1675
01:45:16,897 --> 01:45:21,760
但最后一句话隐含的意思是，合并是这类功能中相当强大的一种。

1676
01:45:21,760 --> 01:45:23,908
现在，我们确实需要在顶层再设一个基础案例。

1677
01:45:23,908 --> 01:45:24,700
所以，请允许我补充一句。

1678
01:45:24,700 --> 01:45:29,807
如果我们发现自己有一个大小为 1 的列表、数组，那么，这个数组显然是排序过的。

1679
01:45:29,807 --> 01:45:32,390
如果其中只有一个元素，就没有工作可做。

1680
01:45:32,390 --> 01:45:33,890
因此，这将是我们的基本情况。

1681
01:45:33,890 --> 01:45:40,900
但现在，我们只需用这四、六行伪代码，就能对一些元素进行实际排序。

1682
01:45:40,900 --> 01:45:43,652
不过，让我们先关注其中的一个子集。

1683
01:45:43,652 --> 01:45:46,360
让我们先来思考一下合并排序的两半意味着什么。

1684
01:45:46,360 --> 01:45:50,170
因此，卡特很高兴能来这里做志愿者，帮助我们重设这些数字。

1685
01:45:50,170 --> 01:45:56,020
假设在我们将要讲述的故事中间，有两个排序的半部分。

1686
01:45:56,020 --> 01:46:01,630
我已经对这些数字的左半部分进行了排序，事实上，2、4、5、7 是从小到大排序的。

1687
01:46:01,630 --> 01:46:06,100
右半部分似乎已经排序，0、1、3、6，已经排序。

1688
01:46:06,100 --> 01:46:10,630
因此，在我的伪代码中，我们已经完成了左半部分和右半部分的排序。

1689
01:46:10,630 --> 01:46:12,160
但我们马上就会知道是怎么回事。

1690
01:46:12,160 --> 01:46:14,980
那么，我该如何合并这两半呢？

1691
01:46:14,980 --> 01:46:18,490
因为它们已经排好序了，而你想按顺序合并它们、

1692
01:46:18,490 --> 01:46:20,110
我想我们可以向下翻转。

1693
01:46:20,110 --> 01:46:25,030
我们可以隐藏每个子列表中除第一个数字之外的所有数字。

1694
01:46:25,030 --> 01:46:28,125
在这里，我们有一个以 2 开头的半球。

1695
01:46:28,125 --> 01:46:32,060
我并不关心其他数字是多少，因为它们显然大于 2。

1696
01:46:32,060 --> 01:46:35,043
我只能关注 "2"，"0 "也是，"0 "也是。

1697
01:46:35,043 --> 01:46:39,293
我们知道 "0 "是最小的，所以就忽略卡特好心翻下的数字吧。

1698
01:46:39,293 --> 01:46:44,360
那么，如何将这两个列表合并成一个新的已排序的大列表呢？

1699
01:46:44,360 --> 01:46:50,470
好吧，我把左边的两个和右边的 0 进行比较，很明显，哪个先到，哪个就是 0。

1700
01:46:50,470 --> 01:46:51,963
所以，让我把这个放在这里。

1701
01:46:51,963 --> 01:46:54,130
卡特，如果你想给我们下一个元素。

1702
01:46:54,130 --> 01:46:55,960
现在我有两个分类的半成品。

1703
01:46:55,960 --> 01:46:57,650
但我已经拔掉了一个。

1704
01:46:57,650 --> 01:47:00,010
因此，现在我将两者与 "1 "进行比较。

1705
01:47:00,010 --> 01:47:01,580
1 显然是下一个。

1706
01:47:01,580 --> 01:47:04,843
因此，我要把 "1 "取出来，放在这里。

1707
01:47:04,843 --> 01:47:06,760
现在我再把这两半进行比较。

1708
01:47:06,760 --> 01:47:08,830
2 和 3，我应该先合并哪个？

1709
01:47:08,830 --> 01:47:10,660
很明显，接下来是 2。

1710
01:47:10,660 --> 01:47:15,220
现在请注意，每次我这样做时，我的双手理论上都在向前迈进。

1711
01:47:15,220 --> 01:47:20,290
我不会像处理选择排序或气泡排序时那样来回折腾。

1712
01:47:20,290 --> 01:47:24,310
我的手指不断向前推进，这将是一个关键细节。

1713
01:47:24,310 --> 01:47:27,340
所以我比较了 4 和 3，显然是 3。

1714
01:47:27,340 --> 01:47:32,560
我比较了 4 和 6，显然是 4。

1715
01:47:32,560 --> 01:47:36,520
我比较了 5 号和 6 号，显然是 5 号。

1716
01:47:36,520 --> 01:47:40,810
然后我比较了 7 和 6，当然是 6。

1717
01:47:40,810 --> 01:47:43,000
最后，我们只剩下一个要素了。

1718
01:47:43,000 --> 01:47:48,160
虽然我的动作有点笨拙，但严格来说，我的手只是在向右移动。

1719
01:47:48,160 --> 01:47:51,130
我从来没有循环往复地做过一件事。

1720
01:47:51,130 --> 01:47:54,430
这或许就是直觉，也是 7 的足够空间。

1721
01:47:54,430 --> 01:47:58,210
那么，这就是如何合并两个排序的半成品。

1722
01:47:58,210 --> 01:48:00,610
我们从左半边排序，右半边排序开始。

1723
01:48:00,610 --> 01:48:02,860
合并就像你作为人类所做的那样。

1724
01:48:02,860 --> 01:48:08,620
卡特只是把数字向下翻转，所以我们的重点只是放在每个数字中最小的元素上。

1725
01:48:08,620 --> 01:48:17,120
在我们继续讨论以这种方式合并意味着什么之前，还有什么问题吗？

1726
01:48:17,120 --> 01:48:18,777
现在，这里有一份原创名单。

1727
01:48:18,777 --> 01:48:22,480
我们特意把它放在最前面，因为有一个合并类的细节很关键。

1728
01:48:22,480 --> 01:48:25,490
从技术上讲，合并排序会占用更多空间。

1729
01:48:25,490 --> 01:48:32,110
因此，以前我们只是不停地移动我们的人类，交换人员，确保他们最终留在原来的位置上。

1730
01:48:32,110 --> 01:48:36,700
使用合并排序时，假设这里是我们的原始内存数组。

1731
01:48:36,700 --> 01:48:38,970
我至少还需要一个内存阵列。

1732
01:48:38,970 --> 01:48:41,160
我要作弊，我要使用更多内存。

1733
01:48:41,160 --> 01:48:45,540
但从技术上讲，我实际上可以在一个阵列和一个辅助阵列之间来回切换。

1734
01:48:45,540 --> 01:48:48,370
但这会占用我更多的空间。

1735
01:48:48,370 --> 01:48:53,130
那么，如何在这段代码中实施合并排序呢？

1736
01:48:53,130 --> 01:48:54,930
那么，让我们考虑一下这个问题。

1737
01:48:54,930 --> 01:48:57,060
这是一个 8 号尺寸的阵列。

1738
01:48:57,060 --> 01:48:59,590
如果只有一个号码退出，显然不适用。

1739
01:48:59,590 --> 01:49:01,230
所以，让我们把注意力集中在多汁的部分吧。

1740
01:49:01,230 --> 01:49:02,880
将左半边的数字排序。

1741
01:49:02,880 --> 01:49:05,130
好吧，如何对左半边的数字进行排序？

1742
01:49:05,130 --> 01:49:09,240
为了清楚起见，我要把它们推过来，也就是左半边。

1743
01:49:09,240 --> 01:49:11,850
现在是一个大小为 4 的子列表。

1744
01:49:11,850 --> 01:49:14,860
如何对左半部分进行排序？

1745
01:49:14,860 --> 01:49:17,380
那么，我有排序算法吗？

1746
01:49:17,380 --> 01:49:18,430
是啊，我该怎么办？

1747
01:49:18,430 --> 01:49:19,492
这里有一份 4 号尺码的清单。

1748
01:49:19,492 --> 01:49:20,200
如何分类？

1749
01:49:20,200 --> 01:49:22,000
第一步是什么？

1750
01:49:22,000 --> 01:49:23,330
将左半边分类。

1751
01:49:23,330 --> 01:49:28,060
因此，我现在在脑海中概念性地将这个子列表取为 4 号。

1752
01:49:28,060 --> 01:49:32,740
我首先对左半部分进行排序，现在重点对 7 和 2 进行排序。

1753
01:49:32,740 --> 01:49:34,330
好了，这是一份 2 号尺寸的清单。

1754
01:49:34,330 --> 01:49:37,060
如何对大小为 2 的列表进行排序？

1755
01:49:37,060 --> 01:49:38,740
学生：[听不清]

1756
01:49:38,740 --> 01:49:40,170
什么？

1757
01:49:40,170 --> 01:49:42,360
我想，我们只需按指示行事。

1758
01:49:42,360 --> 01:49:43,650
将左半边分类。

1759
01:49:43,650 --> 01:49:45,630
好了，下面是尺寸 1 的清单。

1760
01:49:45,630 --> 01:49:48,417
如何对大小为 1 的列表进行排序？

1761
01:49:48,417 --> 01:49:49,803
学生：[听不清]

1762
01:49:49,803 --> 01:49:50,720
我不玩了

1764
01:49:51,360 --> 01:49:52,740
所以我就不去管它了。

1765
01:49:52,740 --> 01:49:54,740
故事的下一步是什么？

1766
01:49:54,740 --> 01:49:58,160
我刚刚整理了左半边的左半边。

1767
01:49:58,160 --> 01:49:59,580
下一步是什么？

1768
01:49:59,580 --> 01:50:06,260
我把右半部分的左半部分的左半部分排序，然后就完成了，因为这只是一个大小为 1 的列表。

1769
01:50:06,260 --> 01:50:09,280
之后呢？

1771
01:50:09,972 --> 01:50:16,187
因此，这就变得有点匪夷所思了，因为你必须记住，我们在哪里暂停故事，在哪里重复做事情。

1772
01:50:16,187 --> 01:50:20,890
但如果我刚对左半边进行了排序，又对右半边进行了排序，现在我就把它们合并在一起。

1773
01:50:20,890 --> 01:50:25,040
这是一份超短名单，所以我们不需要卡特像以前那样帮忙。

1774
01:50:25,040 --> 01:50:27,640
但我认为，我在这里取的第一个数字是 2。

1775
01:50:27,640 --> 01:50:31,660
然后我选的第二个数字是 7，因为这是唯一的选择。

1776
01:50:31,660 --> 01:50:40,270
但现在好了，注意，左半边的左半边确实排序了，因为我对它的左半边和右半边进行了微不足道的排序。

1777
01:50:40,270 --> 01:50:42,760
但合并才是真正的神奇之处。

1778
01:50:42,760 --> 01:50:51,300
好了，再来一遍，如果你现在在脑海中倒带，如果我刚刚把左半边的左半边排序了，接下来会发生什么？

1779
01:50:51,300 --> 01:50:55,000
将右半部分与左半部分排序。

1780
01:50:55,000 --> 01:50:56,980
所以，你又一次回到了过去。

1781
01:50:56,980 --> 01:50:58,290
那么我该怎么做呢？

1782
01:50:58,290 --> 01:50:59,520
我有一份 2 号的清单。

1783
01:50:59,520 --> 01:51:01,920
我把左半边分类，只有 5 个，完成。

1784
01:51:01,920 --> 01:51:04,200
右半部分排序，4，完成。

1785
01:51:04,200 --> 01:51:11,380
现在有趣的部分来了，我把左半边和右半边的右半边合并在一起。

1786
01:51:11,380 --> 01:51:12,450
那我该怎么办？

1787
01:51:12,450 --> 01:51:14,280
4 来到这里。

1788
01:51:14,280 --> 01:51:16,260
5 到这里来。

1789
01:51:16,260 --> 01:51:19,860
现在，请注意我有什么。

1790
01:51:19,860 --> 01:51:21,600
左半部分已分类。

1791
01:51:21,600 --> 01:51:23,130
右半部分已分类。

1792
01:51:23,130 --> 01:51:26,610
如果时光倒流，我的下一步在哪里，3？

1793
01:51:26,610 --> 01:51:27,742
合并两半。

1794
01:51:27,742 --> 01:51:29,700
这就是卡特之前帮我做的事。

1795
01:51:29,700 --> 01:51:32,665
让我们只关注最小的元素，以减少干扰。

1796
01:51:32,665 --> 01:51:34,020
我比较了 2 和 4。

1797
01:51:34,020 --> 01:51:36,520
2 是第一位的，所以我们显然应该把它放在这里。

1798
01:51:36,520 --> 01:51:41,280
现在，我比较一下这份清单的新开头和旧开头。

1799
01:51:41,280 --> 01:51:43,050
4 显然是下一个。

1800
01:51:43,050 --> 01:51:45,940
现在，我将 7 和 5 进行比较。

1801
01:51:45,940 --> 01:51:47,430
5 显然是下一个。

1802
01:51:47,430 --> 01:51:49,240
最后，我只剩下一个数字了。

1803
01:51:49,240 --> 01:51:50,970
现在我只剩 7 个了。

1804
01:51:50,970 --> 01:51:58,260
因此，即使你已经记不清这里的一些细微差别，但如果你退一步想，我们这里还有原来的右半部分没有被动过。

1805
01:51:58,260 --> 01:52:08,940
但是，原始输入的左半部分现在确实已经排序，排序的方式是左半、右半、左半、右半，但中间进行了合并。

1806
01:52:08,940 --> 01:52:13,590
好了，如果我们刚刚整理了左半部分，那么我们倒带回到开头。

1807
01:52:13,590 --> 01:52:15,590
我现在该怎么办？

1808
01:52:15,590 --> 01:52:17,120
好了，把右半部分排序。

1809
01:52:17,120 --> 01:52:18,410
所以要把右半部分排序。

1810
01:52:18,410 --> 01:52:20,180
如何对大小为 4 的列表进行排序？

1811
01:52:20,180 --> 01:52:22,550
好吧，我先把左半边、1 和 6 分类。

1812
01:52:22,550 --> 01:52:24,560
如何对大小为 2 的列表进行排序？

1813
01:52:24,560 --> 01:52:26,757
你把左半边排序，只排数字 1。

1814
01:52:26,757 --> 01:52:28,340
显然，没有工作可做。

1815
01:52:28,340 --> 01:52:30,620
完成，对左半边进行分类。

1816
01:52:30,620 --> 01:52:33,080
6、完成，整理右半部分。

1817
01:52:33,080 --> 01:52:34,280
现在，我该怎么办？

1818
01:52:34,280 --> 01:52:40,610
我把左半边和右半边合并在一起。

1819
01:52:40,610 --> 01:52:42,240
这个问题很简单。

1820
01:52:42,240 --> 01:52:43,050
现在，我该怎么办？

1821
01:52:43,050 --> 01:52:43,910
我刚刚合并了。

1822
01:52:43,910 --> 01:52:45,048
所以现在我把它分类。

1823
01:52:45,048 --> 01:52:47,090
我刚把左半边和右半边分类。

1824
01:52:47,090 --> 01:52:49,550
现在我把右半边的右半边排序。

1825
01:52:49,550 --> 01:52:51,590
因此，我认为 0 已完成。

1826
01:52:51,590 --> 01:52:53,270
我认为这 3 项已经完成。

1827
01:52:53,270 --> 01:52:55,040
现在，我将这两者合并在一起。

1828
01:52:55,040 --> 01:52:56,640
当然，0 是第一位的。

1829
01:52:56,640 --> 01:52:58,100
然后是 3。

1830
01:52:58,100 --> 01:53:00,680
现在，我的故事到了这样的地步

1831
01:53:00,680 --> 01:53:04,910
我把右半部分的左半部分和右半部分的右半部分进行了分类。

1832
01:53:04,910 --> 01:53:07,535
因此，第三步就是合并。

1833
01:53:07,535 --> 01:53:09,410
我会像对待卡特那样再做一次。

1834
01:53:09,410 --> 01:53:12,320
好吧，1 和 0，显然 0 在前。

1835
01:53:12,320 --> 01:53:14,390
现在，比较一下 1 和 3。

1836
01:53:14,390 --> 01:53:16,130
显然，"1 "是第一位的。

1837
01:53:16,130 --> 01:53:18,590
比较 6 和 3，显然是 3。

1838
01:53:18,590 --> 01:53:20,300
最后是 6。

1839
01:53:20,300 --> 01:53:21,890
现在，我们在哪里？

1840
01:53:21,890 --> 01:53:26,840
我们已经把整个事情的左半部分整理好了。

1841
01:53:26,840 --> 01:53:29,990
然后，我们把整件事情的右半部分进行了分类。

1842
01:53:29,990 --> 01:53:33,560
现在，我们最后一次来到第三步。

1843
01:53:33,560 --> 01:53:35,120
我们该怎么办？

1845
01:53:35,780 --> 01:53:40,220
为了保持一致，让我把这些推倒，然后进行比较。

1846
01:53:40,220 --> 01:53:45,230
左手或右手，注意它们只是向前推进，而不是来回比较。

1847
01:53:45,230 --> 01:53:47,270
2 和 0，当然是 0。

1848
01:53:47,270 --> 01:53:48,860
因此，我们将把它落实到位。

1849
01:53:48,860 --> 01:53:51,140
2 和 1，当然是 1。

1850
01:53:51,140 --> 01:53:52,880
因此，我们将其落实到位。

1851
01:53:52,880 --> 01:53:56,930
2 和 3，我们合并进来，当然，这里是 2。

1852
01:53:56,930 --> 01:54:00,770
在这种情况下，我们现在将 4 和 3 合并为 3。

1853
01:54:00,770 --> 01:54:05,630
4 和 6，我们现在当然要把 4 合并。

1854
01:54:05,630 --> 01:54:07,760
现在，我们比较一下 5 号和 6 号。

1855
01:54:07,760 --> 01:54:08,615
我们保留 5.

1857
01:54:15,226 --> 01:54:17,295
好吧，那就假装 5 号电池已经启动。

1858
01:54:20,040 --> 01:54:21,450
哦，这就是原因。

1859
01:54:21,450 --> 01:54:24,240
好了，现在我们来比较一下 7 和 6。

1860
01:54:24,240 --> 01:54:26,430
第 6 个已不复存在。

1861
01:54:26,430 --> 01:54:29,520
最后，7 是最后一个到位。

1862
01:54:29,520 --> 01:54:36,210
尽管我承认，在所有算法中，这可能是最难掌握的一种，尤其是当我做配音时。

1863
01:54:36,210 --> 01:54:41,010
要知道，我们刚才所做的只是这三个递归步骤。

1864
01:54:41,010 --> 01:54:42,510
我们先列了一份 8 号的清单。

1865
01:54:42,510 --> 01:54:43,650
我们整理了左半边。

1866
01:54:43,650 --> 01:54:44,790
我们整理了右半边。

1867
01:54:44,790 --> 01:54:46,450
然后，我们将两者合并在一起。

1868
01:54:46,450 --> 01:54:54,970
但是，如果你沿着每一个兔子洞走下去，可以说左半边的分类涉及到左半边的左半边和右半边的右半边，以此类推。

1869
01:54:54,970 --> 01:55:02,520
但这种想法的萌芽是真正的分而治之，而不是有了问题却只处理一半。

1870
01:55:02,520 --> 01:55:07,780
很明显，我们正在对一半和另一半进行分类，最终将它们合并在一起。

1871
01:55:07,780 --> 01:55:10,810
它仍然会引导我们找到相同的解决方案。

1872
01:55:10,810 --> 01:55:20,310
如果我们现在将残余的数字可视化，我可以这样描述：在屏幕上，你可以看到最上面一排从左到右的数字。

1873
01:55:20,310 --> 01:55:23,470
从本质上讲，尽管顺序不同、

1874
01:55:23,470 --> 01:55:28,708
最终，我把这份 8 号清单分成了 8 份 1 号清单。

1875
01:55:28,708 --> 01:55:31,000
这就是基础案例的作用所在、

1876
01:55:31,000 --> 01:55:32,580
好了，我们整理完了。

1877
01:55:32,580 --> 01:55:41,580
之后，从逻辑上讲，我将两个大小为 1 的列表合并成许多大小为 2 的列表，再将这些大小为 2 的列表合并成大小为 4 的列表。

1878
01:55:41,580 --> 01:55:47,250
最后，将 4 号列表排序为 8 号。

1879
01:55:47,250 --> 01:55:55,620
于是，我提出了这幅画，画上有小的线条指示器，因为我分了多少次，分了多少次，分了多少次？

1880
01:55:55,620 --> 01:55:57,360
或者真的是双倍、双倍、双倍。

1881
01:55:57,360 --> 01:56:00,600
所以指数是相反的--破坏者。

1882
01:56:00,600 --> 01:56:02,610
我分了多少次？

1883
01:56:02,610 --> 01:56:04,320
具体来说，有三个。

1884
01:56:04,320 --> 01:56:12,300
但如果一共有 8 个元素，而一般情况下又有 n 个元素，那就真的是对数 n 次的分与合的问题了。

1885
01:56:12,300 --> 01:56:15,360
从这里开始，你可以除以 1、2、3 倍，再除以 log n 倍。

1886
01:56:15,360 --> 01:56:21,060
或者反过来说，你可以从这里开始，指数式地翻倍、翻倍、再翻倍三次，也就是 log n。

1887
01:56:21,060 --> 01:56:31,380
但是，在每一排、每一个架子上，我都小题大做，双手只能从左边指向右边，不断地向前推进，以至于每次做这些合并动作时都是如此、

1888
01:56:31,380 --> 01:56:34,500
每个元素我都只碰过一次。

1889
01:56:34,500 --> 01:56:37,470
舞台上没有这样的来来回回、反反复复。

1890
01:56:37,470 --> 01:56:51,057
那么，如果我正在做一件事情的对数 n 次方，或者说，如果我正在做 n 件事情的对数 n 次方，我们的大 O 公式会是什么呢？ n 件事情的对数 n 次方？

1891
01:56:51,057 --> 01:56:52,140
学生：哦，是 n log n。

1892
01:56:52,140 --> 01:56:53,490
对，所以是 n log n。

1893
01:56:53,490 --> 01:56:58,560
事实上，n log n 的阶数就是我们对合并排序运行时间的描述。

1894
01:56:58,560 --> 01:57:10,650
因此，在迄今为止的所有排序中，我们看到这里的合并排序实际上是 n log n，严格来说比 n 平方要好，这也是选择排序和冒泡排序的优势所在。

1895
01:57:10,650 --> 01:57:14,015
但它也比线性搜索等慢。

1896
01:57:14,015 --> 01:57:15,390
但你更希望如此。

1897
01:57:15,390 --> 01:57:21,670
如果你必须在前期做大量工作来分类某些元素，而不是仅仅搜索它们，你就必须付出更多努力。

1898
01:57:21,670 --> 01:57:30,327
因此，是否应该盲目地使用线性搜索来搜索，而不是费力地进行分类，这个问题其实可以归结为：你能花得起这么多时间吗？

1899
01:57:30,327 --> 01:57:35,170
如果你是全球最大的谷歌公司，你很可能不希望每次都以线性方式搜索他们的数据库。

1901
01:57:35,670 --> 01:57:43,560
因为你可以对其进行一次排序，然后使用类似二进制搜索的方法，或者坦率地说，在实践中使用类似二进制搜索的方法，让数百万、数十亿人受益、

1902
01:57:43,560 --> 01:57:46,443
比二进制搜索更先进、更快速的东西。

1903
01:57:46,443 --> 01:57:48,360
但是，这其中总会有这样那样的权衡。

1904
01:57:48,360 --> 01:57:52,140
只有对元素进行排序，才能实现二进制搜索。

1905
01:57:52,140 --> 01:57:53,940
分类的费用是多少？

1906
01:57:53,940 --> 01:57:56,940
如果使用早期的算法，可能是 n 的平方。

1907
01:57:56,940 --> 01:58:00,850
但事实证明，登录速度也相当快。

1908
01:58:00,850 --> 01:58:06,180
因此，归根结底，这些运行时间是需要权衡的。

1909
01:58:06,180 --> 01:58:12,090
事实上，在合并排序 2 中，我应该注意到合并排序的下限也将是 n log n 的欧米茄。

1910
01:58:12,090 --> 01:58:18,030
因此，我们可以用我们的 θ 符号来描述它，即合并排序确实是在 n log n 的 θ 范围内。

1911
01:58:18,030 --> 01:58:24,030
所以一般来说，最好使用合并排序或其他 n log n 的算法。

1912
01:58:24,030 --> 01:58:28,200
实际上，大多数程序员都不会自己实现这些排序算法。

1913
01:58:28,200 --> 01:58:34,200
很有可能，他们正在使用一个现成的库，而这个库本身已经决定了采用其中的哪种算法。

1914
01:58:34,200 --> 01:58:42,750
但一般来说，我们现在也是第一次看到，如果你想缩短时间，比如用更少的时间，写更快的代码，你就必须付出代价。

1915
01:58:42,750 --> 01:58:49,080
这可能需要你花费更多时间来编写更复杂、更难实现的代码。

1916
01:58:49,080 --> 01:58:51,840
或者你需要花费空间之类的东西。

1917
01:58:51,840 --> 01:58:55,740
正如这些书架所示，这也是合并分类的关键细节之一。

1918
01:58:55,740 --> 01:58:58,500
你不能让元素就地交换。

1919
01:58:58,500 --> 01:59:03,960
你至少需要一个辅助数组，以便在合并时有地方放置它们。

1920
01:59:03,960 --> 01:59:05,988
这样的内存量实在是太大了。

1921
01:59:05,988 --> 01:59:09,030
我本可以在顶层和底层之间来回穿梭。

1922
01:59:09,030 --> 01:59:11,113
但从上往下看更有趣一些。

1923
01:59:11,113 --> 01:59:12,870
但你确实需要更大的空间。

1924
01:59:12,870 --> 01:59:15,605
几十年前，太空真的很昂贵。

1925
01:59:15,605 --> 01:59:16,480
你知道吗？

1926
01:59:16,480 --> 01:59:23,230
如果不使用合并排序，甚至使用冒泡排序或选择排序，或其他算法，可能会更好。

1927
01:59:23,230 --> 01:59:25,300
如今，空间相对便宜。

1928
01:59:25,300 --> 01:59:27,160
因此，这些都是比较容易接受的折衷办法。

1929
01:59:27,160 --> 01:59:29,650
但这完全取决于应用。

1930
01:59:29,650 --> 01:59:34,450
最后，我们想向大家展示一些排序算法的实际比较。

1931
01:59:34,450 --> 01:59:35,800
时长约 60 秒。

1932
01:59:35,800 --> 01:59:46,570
它还会同时为你比较选择排序、气泡排序和合并排序，并伴有一些有趣的排序音乐，最终向你展示它到底是什么。

1933
01:59:46,570 --> 01:59:52,750
意味着是 n 平方的 O，或者更好的是 n log n 的大 O。

1934
01:59:52,750 --> 01:59:54,850
在顶部进行选择。

1935
01:59:54,850 --> 01:59:58,050
底部有气泡

1936
01:59:58,050 --> 01:59:59,400
在中间合并。

1938
02:00:53,660 --> 02:00:55,700
好了，CS50 到此为止。

1939
02:00:55,700 --> 02:00:57,910
我们下次再见。

