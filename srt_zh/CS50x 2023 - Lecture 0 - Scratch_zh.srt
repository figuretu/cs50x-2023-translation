1
00:01:13,310 --> 00:01:15,260
戴维-J-马兰：好的。

2
00:01:15,260 --> 00:01:22,940
这里是 CS50，哈佛大学计算机科学和编程艺术的入门课程。

3
00:01:22,940 --> 00:01:27,660
我叫大卫-马兰（David Malan），实际上，早在 1996 年，我就亲自上过这门课。

4
00:01:27,660 --> 00:01:29,382
当时我上大二。

5
00:01:29,382 --> 00:01:40,200
实际上，我的专业是政府学，因为在一年前，作为一年级学生，我进入哈佛时认为自己喜欢历史和宪法，以及高中时的类似课程。

6
00:01:40,200 --> 00:01:44,180
因此，当我来到这里时，我更倾向于熟悉的事物。

7
00:01:44,180 --> 00:01:50,300
我想，如果我在高中时喜欢并擅长那门学科，那么我在这里就应该是这样的人。

8
00:01:50,300 --> 00:01:57,680
但直到大二，我才鼓起勇气踏进 CS50 教室，即便如此，也只是出于好奇。

9
00:01:57,680 --> 00:02:03,170
就像我刚进校园时，根本没打算学习计算机科学，甚至连 CS50 都没选。

10
00:02:03,170 --> 00:02:07,400
但人们对此议论纷纷，纷纷提防。

11
00:02:07,400 --> 00:02:12,560
而且，这也许只是为初学者准备的，我最终也不知道计算机科学到底是什么。

12
00:02:12,560 --> 00:02:15,800
但对我来说，灯泡熄灭了。

13
00:02:15,800 --> 00:02:24,830
我发现，与我在高中看到的情况相反，我看到我的朋友们在计算机实验室里低头编程，反社会地做着他们正在做的事情、

14
00:02:24,830 --> 00:02:29,280
一旦我上了这个特殊的班级，到了这个特殊的地方，就真的不是那么回事了。

15
00:02:29,280 --> 00:02:34,852
它更多地是关于解决问题，以及学习如何用代码和不同的语言表达自己。

16
00:02:34,852 --> 00:02:37,310
这样，你才能真正解决自己感兴趣的问题。

17
00:02:37,310 --> 00:02:47,280
即使你无意成为一名计算机科学家或工程师，只是希望能够在艺术、人文和社会科学领域解决问题、分析数据、做有趣的事情、

18
00:02:47,280 --> 00:02:49,710
物理科学，或任何其他领域。

19
00:02:49,710 --> 00:02:56,090
事实上，这条特殊的道路将我引向了计算机科学，但 CS50 更普遍的希望是，你能

20
00:02:56,090 --> 00:03:02,370
只要找到自己的方法，将未来几个月学到的原则应用到自己感兴趣的领域就可以了。

21
00:03:02,370 --> 00:03:07,500
尽管如此，这对我来说绝对是一项艰巨的工作，而且并非没有挫折。

22
00:03:07,500 --> 00:03:15,630
但是，没有什么比用脑袋撞墙，花上几个小时甚至几天，试图修复代码中的一个错误更美妙的了。

23
00:03:15,630 --> 00:03:23,600
然后，我的天啊，当你终于解决了某个一直压在你心头的难题时，那种成就感、自豪感、疲惫感一涌而上。

24
00:03:23,600 --> 00:03:26,570
这让我感到无比欣慰，同时也增强了我的能力。

25
00:03:26,570 --> 00:03:31,200
因为与很多领域不同，计算机科学是由人类自己建立起来的。

26
00:03:31,200 --> 00:03:35,460
因此，如果人类建造了这个，那么你，另一个人类，肯定也能理解它。

27
00:03:35,460 --> 00:03:42,440
因此，尽管一路上会有一些干扰，但如果你以前从未做过编程，你就会看到一些看起来令人难以置信的东西。

28
00:03:42,440 --> 00:03:46,402
随着时间的推移和实践的积累，一切都会变得更有意义。

29
00:03:46,402 --> 00:03:49,950
随着时间的推移和实践的积累，你会在这一领域越做越好。

30
00:03:49,950 --> 00:03:55,530
事实上，编程成功的关键在于给自己留出足够的时间。

31
00:03:55,530 --> 00:04:00,950
因此，至少值得庆幸的是，我很快就养成了在一周内尽早开始工作的习惯，比如在编写实际代码时。

32
00:04:00,950 --> 00:04:03,200
为什么？因为你会碰壁。

33
00:04:03,200 --> 00:04:04,460
你不会看到什么虫子。

34
00:04:04,460 --> 00:04:06,470
有些东西不会让你眼前一亮，没关系。

35
00:04:06,470 --> 00:04:11,030
这时，你就可以收工了，休息一下，干点别的，然后再回来干。

36
00:04:11,030 --> 00:04:16,310
这也是我保持编程乐趣的原因，即使在多年以后，无论是教学还是实际应用，都是如此。

37
00:04:16,310 --> 00:04:22,170
但是，在这条路上，有一段麻省理工学院黑客的历史，昔日的麻省理工学院看起来有点像这样。

38
00:04:22,170 --> 00:04:25,280
麻省理工学院的学生们在做这个黑客的时候，还发出了一点感叹。

39
00:04:25,280 --> 00:04:33,890
墙上写着：从麻省理工学院接受教育就像从消防水龙头里喝水一样，而他们确实把消防水龙头连接到了本应只是一个饮水机的地方。

40
00:04:33,890 --> 00:04:39,560
有时候，不光是计算机科学本身，就是一个陌生的领域，也会有这种感觉。

41
00:04:39,560 --> 00:04:42,740
如果你不是来自 STEM，不是来自 CS，那也没关系。

42
00:04:42,740 --> 00:04:49,430
但是，很多东西最终都会被你吸收，并在学期结束时在你的掌握之中。

43
00:04:49,430 --> 00:04:57,440
因此，请记住，这就是我们的初衷，但你会对自己在三个月左右的时间里所创造的成果感到惊讶。

44
00:04:57,440 --> 00:05:03,140
事实上，你们当中有三分之二的人从未上过 CS 课程，这与你们可能认为的情况恰恰相反。

45
00:05:03,140 --> 00:05:07,550
所以，绝对不是说左边或右边的人肯定比你懂得多。

46
00:05:07,550 --> 00:05:09,462
事实上，情况恰恰相反。

47
00:05:09,462 --> 00:05:17,450
在接下来的几周里，当你编写自己的代码、解决自己的问题时，你就会发现，在这门课程中，最终重要的并不是你与你的同学们的排名

48
00:05:17,450 --> 00:05:20,783
而是相对于你开始时的自己而言，你的终点在哪里。

49
00:05:20,783 --> 00:05:27,380
不管你有没有编程，只要能从这样的课程中有所收获，这就是真正的 "三角洲"。

50
00:05:27,380 --> 00:05:34,520
如果这确实需要时间，如果你确实感受到了挫折，但你同时也最终感受到了成就感，那只能说明这一切都很有效。

51
00:05:34,520 --> 00:05:39,712
事实上，希望最终能因此而更有价值、更令人欣慰。

52
00:05:39,712 --> 00:05:41,670
那么，未来几周我们该做些什么呢？

53
00:05:41,670 --> 00:05:43,550
现在是第零周。

54
00:05:43,550 --> 00:05:47,480
我们很快就会明白，为什么计算机和计算机科学家要从 0 开始计数。

55
00:05:47,480 --> 00:05:54,860
但第 0 周，我们将探索计算思维，像计算机一样思考，并开始清理你的思维过程。

56
00:05:54,860 --> 00:05:59,360
让你思考，更有条理地解决问题，并最终将其转化为代码。

57
00:05:59,360 --> 00:06:04,520
有些人可能认识这个环境，又名 Scratch，巧合的是，它也来自麻省理工学院。

58
00:06:04,520 --> 00:06:06,350
你可能在小学时用过。

59
00:06:06,350 --> 00:06:11,760
我们将在今天和本周末的课程第一次家庭作业或问题集中使用它。

60
00:06:11,760 --> 00:06:18,990
但这并不是为了让你像过去那样玩游戏，而是为了探索计算机科学和编程的理念。

61
00:06:18,990 --> 00:06:22,650
我们以后每周都会使用和重复使用。

62
00:06:22,650 --> 00:06:26,800
此后，我们将在下周过渡到第一周，可以这么说。

63
00:06:26,800 --> 00:06:31,979
在此，我们将向您介绍一种更传统的语言，一种低级语言，一种叫做 C 语言的更古老的语言。

64
00:06:31,979 --> 00:06:39,030
在 C 语言中，你需要使用键盘，而不是鼠标，但你要编写的代码很快就会像这样。

65
00:06:39,030 --> 00:06:42,120
如果你以前编过程序，大概就能明白这要做什么。

66
00:06:42,120 --> 00:06:47,560
如果你以前从未学过编程（大多数人都是这种情况），这也会很快变得有意义。

67
00:06:47,560 --> 00:06:51,120
但这是大多数程序员编写的最经典的程序

68
00:06:51,120 --> 00:06:59,430
事实上，这句话以及它上下的所有语法很快就会变得更有意义。

69
00:06:59,430 --> 00:07:02,250
可以说，您将学会如何使用行业标准工具。

70
00:07:02,250 --> 00:07:04,980
图中所示的是 Visual Studio 代码，简称 VS 代码。

71
00:07:04,980 --> 00:07:10,678
您最初将使用基于云的版本，因此您不必担心任何技术问题或类似的头痛问题。

72
00:07:10,678 --> 00:07:18,840
这只是一开始的工作，但我们最终会利用它来探索计算机科学中的想法，以及你可以应用的原理。

73
00:07:18,840 --> 00:07:27,210
我们将从电脑的引擎盖下看一看内存或 RAM（随机存取存储器），所有数据最终都将存储在这里。

74
00:07:27,210 --> 00:07:31,470
此后，我们还将看看程序错误。错误就是程序中的错误。

75
00:07:31,470 --> 00:07:41,040
这是昔日真实电脑中的一个真实错误，但我们会教你如何调试程序、发现自己的错误、发现别人的错误，并改进代码。

76
00:07:41,040 --> 00:07:47,340
然后，我们将过渡到算法，即解决一些问题的分步指导，我们今天也会涉及到这一点。

77
00:07:47,340 --> 00:07:51,120
如果你想象一下，这其实是一个很有代表性的问题。

78
00:07:51,120 --> 00:07:55,510
您很可能没有遇到过类似的情况，但这是有代表性的排序方式。

79
00:07:55,510 --> 00:08:00,810
如果把这些小条中的每一条都看作是一个小数，那么大条中的每一条就是一个大数、

80
00:08:00,810 --> 00:08:08,478
你可能会想，作为一个人，你怎么能把所有这些条形图分类，比如把所有的短条形图放在这里，把所有的大条形图放在那里？

81
00:08:08,478 --> 00:08:16,533
好吧，如果你像我一样，你可能会用眼睛看一下，如果你可以用身体互动，你可能会先抓取最小的元素，把它们放在左边。

82
00:08:16,533 --> 00:08:20,880
也许可以抓住最大的元素，把它们放在右边。但你的算法是什么？

83
00:08:20,880 --> 00:08:24,930
比如，你如何教一个比你年轻、从未做过这种事的人如何做？

84
00:08:24,930 --> 00:08:28,740
你如何强迫你的 Mac、PC 或手机做这样的事情？

85
00:08:28,740 --> 00:08:32,572
你不能只是挥挥手，然后说，哦，想办法吧。把东西搬来搬去。

86
00:08:32,572 --> 00:08:36,815
你必须更有条理地表达自己。因此，即使是这样的想法，我们也要将其转化为代码。

87
00:08:36,815 --> 00:08:42,780
而这正是谷歌和世界上其他公司在不断做的事情，因为它们要对世界上的信息进行分类和整理。

88
00:08:42,780 --> 00:08:45,490
如果有帮助的话，我们可以用比喻来说明。

89
00:08:45,490 --> 00:08:48,990
我们把电脑内存比作一个邮政地址。

90
00:08:48,990 --> 00:08:57,560
就像世界上的每个邮箱都有某种形式的邮政地址，街道、城市、州、国家等等，而事实证明，你的 Mac、PC 和手机也是这样工作的。

91
00:08:57,560 --> 00:09:02,730
你有一大堆内存，就像之前的图片一样，但你可以把它看作是一个个独立的邮箱。

92
00:09:02,730 --> 00:09:08,725
你可以在这些邮箱中放置任何你想要的东西，你也可以进入邮箱获取其中的信息。

93
00:09:08,725 --> 00:09:12,490
所以说到底，这就是电脑处理信息的全部工作。

94
00:09:12,490 --> 00:09:18,870
它只是在整理信息，而不是将信息整理到邮箱中，比如你可能知道的 "字节"。

95
00:09:18,870 --> 00:09:22,560
我们来谈谈现在也会出现的问题。

96
00:09:22,560 --> 00:09:32,520
事实上，你们中的大多数人都熟悉 Mac、PC 甚至手机有时会自发重启、死机、出现恼人的旋转沙滩球或沙漏图标的情况。

97
00:09:32,520 --> 00:09:33,790
这到底是怎么回事？

98
00:09:33,790 --> 00:09:40,110
这些只是苹果、谷歌、微软等公司的人类程序中的漏洞，他们搞砸了，写出了漏洞百出的代码。

99
00:09:40,110 --> 00:09:44,290
而你的电脑在遇到这些错误时，不知道该怎么办。

100
00:09:44,290 --> 00:09:50,110
因此，可以说十有八九会出现死机或冻结之类的情况，但这种情况会更有意义。

101
00:09:50,110 --> 00:09:55,350
因此，即使是现实世界也会有意义，图中是我们最终会在学期中接触到的一些低级术语。

102
00:09:55,350 --> 00:10:02,440
但一般来说，当事情像这个箭头一样朝这个方向发展，而事情又像这个箭头一样朝这个方向发展时，结局就不会太好。

103
00:10:02,440 --> 00:10:05,250
这往往就是电脑崩溃时发生的情况。

104
00:10:05,250 --> 00:10:11,470
有人在上面使用记忆，但也有人在下面使用记忆，这样就不是真正意义上的左手和右手了。

105
00:10:11,470 --> 00:10:17,010
因此，这只是我们会遇到的一些问题的高度概括，但我们最终会把重点放在数据上。

106
00:10:17,010 --> 00:10:20,530
因此，这里展示的是一种相当技术性的东西，叫做哈希表。

107
00:10:20,530 --> 00:10:25,110
它是一个我们即将称之为数组的东西和一个我们称之为链接列表的东西的混合体。

108
00:10:25,110 --> 00:10:34,440
这些都是花哨的术语，用来描述如何比将单个值放入邮箱更灵活地组织信息。

109
00:10:34,440 --> 00:10:40,510
比如，你如何构建结构，比如可以说是实际的数据结构，二维结构？

110
00:10:40,510 --> 00:10:48,040
因此，你们在这里看到的是哈利-波特宇宙中的一些名字，有些人可能已经认出来了，但它们是按字母顺序排列的。

111
00:10:48,040 --> 00:10:58,440
请注意，任何时候都有多个名字以 H 开头的人，比如赫敏、哈利和海格，如果左边的每个方格都是同一个邮箱，那么他们就不可能都装进邮箱。

112
00:10:58,440 --> 00:11:02,490
因此，你必须将它们串联起来。你将在代码中学习如何做到这一点。

113
00:11:02,490 --> 00:11:07,440
这样，即使你获得的数据比你预期的要多，如果你的业务正在蓬勃发展，而且你是一些基于网络的企业、

114
00:11:07,440 --> 00:11:12,790
您是如何在软件中不断添加信息，从而真正跟上它的步伐的？

115
00:11:12,790 --> 00:11:16,480
但这也是代码很快就会出现的情况，最快下周就会出现、

116
00:11:16,480 --> 00:11:25,190
但几周后，我们将过渡到一种更现代、更高级的语言，可以说是 Python。

117
00:11:25,190 --> 00:11:33,520
事实上，在我的时代和现在，这门课程非常有意地首先向你介绍 C 语言，有趣的是，很多人并不倾向于每天都用 C 语言编程。

118
00:11:33,520 --> 00:11:40,540
我一般在 9 月、10 月、11 月和 12 月教授 CS50 时使用 C 语言。尽管如此，它还是无处不在。

119
00:11:40,540 --> 00:11:52,360
事实上，即使是今天你可能熟悉的其他语言，如 Python 和 Java，以及其他语言，你也能在引擎盖下看到同样的原始语言，因为它实在是太快了。

120
00:11:52,360 --> 00:11:59,180
在接下来的几周里，你将了解到，它真的能让你接触和理解这里的概念。

121
00:11:59,180 --> 00:12:05,180
这样，在 CS50 之后，当你编写代码时，你就可以从一个非常高的层面来思考实际发生了什么。

122
00:12:05,180 --> 00:12:11,170
因此，事实上，再过几周，在 C 语言中看起来是这样的，在 Python 中就会变成这样。

123
00:12:11,170 --> 00:12:16,521
您将更好地了解引擎盖下发生的事情，而且很有可能在这堂课之后，您会去学习一门语言。

124
00:12:16,521 --> 00:12:22,750
与 C 语言相比，Python 的使用频率更高，但你会从这种自下而上的理解中受益匪浅。

125
00:12:22,750 --> 00:12:28,630
此后，在学期结束前，我们将向您介绍一些其他想法，比如您该把大量数据放在哪里？

126
00:12:28,630 --> 00:12:32,690
数据库不是电子表格，而是真正的数据库。

127
00:12:32,690 --> 00:12:37,300
我们使用的也是这种数据结构，你可以在内存中以有趣的方式布局。

128
00:12:37,300 --> 00:12:42,010
之后，我们将过渡到一个你我每天都在使用的非常熟悉的环境--网络。

129
00:12:42,010 --> 00:12:49,690
如今，网络已成为我们在笔记本电脑、台式机甚至移动设备上随处使用的用户界面。

130
00:12:49,690 --> 00:12:52,360
这里展示的是一种名为 HTML 的语言。

131
00:12:52,360 --> 00:12:53,693
它不是一种编程语言。

132
00:12:53,693 --> 00:12:57,550
这是一种标记语言，有些人过去可能制作过主页或作品集。

133
00:12:57,550 --> 00:13:08,930
但你会明白这里发生了什么，而且更重要的是，你会明白计算机是如何看到同样的代码，并在内存中建立起层次分明的家族树状结构的。

134
00:13:08,930 --> 00:13:16,150
然后，你就可以用代码操作这棵树，在屏幕上添加越来越多的信息、聊天信息等任何你喜欢的内容。

135
00:13:16,150 --> 00:13:27,140
最后，我们将通过介绍所谓的框架和库，将所有这一切联系在一起，这些第三方代码能让你更轻松地解决感兴趣的问题。

136
00:13:27,140 --> 00:13:33,820
尤其是这里，这是我自己在 1997 年制作的第一个网络应用程序。

137
00:13:33,820 --> 00:13:41,380
我参加了一年级的校内体育项目，但不是作为运动员，而是作为程序员，自学如何构建网络应用程序。

138
00:13:41,380 --> 00:13:44,410
当时我只知道 C，也许还知道一点别的。

139
00:13:44,410 --> 00:13:53,290
但至少对哈佛大学来说，这成了一年级校内体育项目的第一个网站，而且它不仅仅是一个带有链接和图片等的静态网站。

140
00:13:53,290 --> 00:13:55,570
它是互动的。你可以报名参加体育运动。

141
00:13:55,570 --> 00:14:01,340
我们可以准确地输入谁进入了锦标赛或类似的比赛，它实际上可以自动跟踪这些数据。

142
00:14:01,340 --> 00:14:07,687
因此，在短短三个月这样的课程之后，你也会从简单地写这周和下周的 Hello, World

143
00:14:07,687 --> 00:14:13,822
如果您愿意，也可以在网络、手机或其他平台上构建类似的功能。

144
00:14:13,822 --> 00:14:17,030
但在学期结束前，我们会让你离开课程的基础设施。

145
00:14:17,030 --> 00:14:19,570
沿途不会使用任何玩具环境。

146
00:14:19,570 --> 00:14:29,980
最终，我们将赋予你在 CS50 之后编写代码的能力，尤其是如果这是你唯一的一门 CS 课程，你可以在自己的 Mac 或 PC 上使用相同的软件，但不是基于云的版本。

147
00:14:29,980 --> 00:14:37,010
但所有这些软件本身都是免费的，在课程结束后，您还可以继续使用。

148
00:14:37,010 --> 00:14:46,210
但一路走来，大家可能都知道，班级里有这样一个传统，尤其是在健康时期，有很多活动能让大家真正聚在一起、

149
00:14:46,210 --> 00:14:52,120
不仅是合作和学术上的，而且还包括解决问题和一般的相互交流。

150
00:14:52,120 --> 00:15:00,460
首先是 "CS50 拼图日"，这不是拼图游戏，而是不需要任何计算机科学或编程经验的逻辑谜题。

151
00:15:00,460 --> 00:15:07,270
但这只是一个机会，可以和一些朋友一起静静地做一包谜题，获得奖品等。

152
00:15:07,270 --> 00:15:15,910
在本学期晚些时候，一旦你完成了期末项目，也就是课程的巅峰之作，我们不给你写作业，而是你自己想出一些东西来构建。

153
00:15:15,910 --> 00:15:23,260
我们一般会在晚上 7:00 左右聚在一起，如果你愿意，可以在早上 7:00 左右结束。

154
00:15:23,260 --> 00:15:33,340
这是一个晚上，一个与同学合作完成自己的毕业设计的 12 个小时的机会，地点就在校园的一个大空间里，如果你和我们一样醒着的话，结束时间是凌晨 5:00。

155
00:15:33,340 --> 00:15:38,710
我们可以跳上 CS50 穿梭巴士，6:00 左右去路上的 IHOP 吃煎饼。

156
00:15:38,710 --> 00:15:43,396
当然--当然，这时候是早上六、七点钟

157
00:15:43,396 --> 00:15:52,300
这是一个学期末的庆祝活动，也是一个展览，展示了你们在未来几个月里所取得的成就。

158
00:15:52,300 --> 00:15:56,200
事实上，图中是您在健康时代的一些前辈。

159
00:15:56,200 --> 00:16:03,729
在 CS50 展览会上，您可以携带笔记本电脑或手机，与全校学生、教职员工一起亲自参加展览。

160
00:16:03,729 --> 00:16:10,150
在这几周的时间里，你将展示自己的创作成果和所学到的知识，并通过视频让人们欣喜地看到。

161
00:16:10,150 --> 00:16:14,880
最终，这也是一个分享和激励他人的机会。

162
00:16:14,880 --> 00:16:20,820
最终，你们都将带着自己的 "我参加了 CS50 "T恤衫回家。

163
00:16:20,820 --> 00:16:23,820
以上就是本课程的概况、

164
00:16:23,820 --> 00:16:32,780
我建议，我们也开始看看计算机科学本身是什么，以及在接下来的几周里，我们要在这个较低的层次上做些什么。

165
00:16:32,780 --> 00:16:34,130
那么，什么是计算机科学？

166
00:16:34,630 --> 00:16:40,310
如果你和我一样，或者是像我高中同学一样的新朋友，你可能会认为这意味着编程。

167
00:16:40,310 --> 00:16:48,110
对很多人来说，这绝对是重要的一部分，因为有了代码，你就可以写作，可以表达想法，解决实际问题，尤其是涉及数据的问题。

168
00:16:48,110 --> 00:16:52,100
但计算机科学本身其实就是一门研究信息的学科。

169
00:16:52,100 --> 00:16:55,170
你如何表现它，又如何实际处理它？

170
00:16:55,170 --> 00:17:04,604
从这个意义上说，计算思维就是将计算机科学的思想，像这样的课程，应用到你感兴趣的问题中去。

171
00:17:04,604 --> 00:17:09,089
同样，艺术、人文、科学、社会科学，无论你感兴趣的领域是什么。

172
00:17:09,089 --> 00:17:16,770
那么，如果说计算机科学的核心是信息，并以此来解决问题，那么，解决问题究竟意味着什么呢？

173
00:17:16,770 --> 00:17:21,950
让我们看看，我们是否能提出一个模式，让所有的经验教训最终都能融入其中。

174
00:17:21,950 --> 00:17:29,070
我认为这就是解决问题。你已经有了一些输入，这就像是你想要解决的问题。目标就是解决问题。

175
00:17:29,070 --> 00:17:36,233
因此，这就是所谓的输出，然后在这里的某个地方，也就是众所周知的黑盒子里，有某种能完成工作的秘方。

176
00:17:36,233 --> 00:17:42,440
在接下来的几个月里，我们必须决定，我们该如何表示这些输入和输出，以及我们该如何编码？

177
00:17:42,440 --> 00:17:47,310
我们怎样才能写出解决我们感兴趣的问题的方案？

178
00:17:47,310 --> 00:17:51,560
因此，说到信息的表现形式，我们有很多方法可以做到这一点。

179
00:17:51,560 --> 00:17:59,340
举例来说，如果当前的问题很简单，就是在开学第一天上课时进行考勤，那么，我们该如何去做呢？

180
00:17:59,340 --> 00:18:03,420
实际上，我们可以使用一种叫做 "一元 "的系统。那是什么呢？

181
00:18:03,420 --> 00:18:08,300
嗯，那是 1、2、3、4、5，也许还有 6、7、8、9、10 的花哨说法。

182
00:18:08,300 --> 00:18:13,298
我还能用我的手指--双关语--数出每个人的人数。

183
00:18:13,298 --> 00:18:16,340
最后，你还需要脚趾什么的，如果你非要数到这么高的话。

184
00:18:16,340 --> 00:18:24,830
但是，一元数是一个非常简单的系统，它使用一个符号（这里指的是人的手指）来解决一些问题，比如计算房间里的人数。

185
00:18:24,830 --> 00:18:27,950
让我们把这个问题稍微技术化一点，数学化一点。

186
00:18:27,950 --> 00:18:36,920
这就是所谓的基数-1，你所操作的基数中只有一位数，就像人的手指一样，如果你需要数得更高，可能还有多个这样的手指。

187
00:18:36,920 --> 00:18:47,180
当然，你们中的大多数人（如果不是所有人的话）一般都隐约知道计算机使用的不是一元数组，甚至你和我可能也不经常使用一元数组。

188
00:18:47,180 --> 00:18:50,430
他们用什么语言或字母来代替。

189
00:18:50,930 --> 00:18:55,980
所以二进制，所以二进制确实是计算机以某种方式使用的系统。

190
00:18:55,980 --> 00:19:01,760
因此，在这种情况下，"bi "意味着 "2"，所以计算机有两位数可以使用。

191
00:19:01,760 --> 00:19:07,490
事实上，如果你听说过技术术语比特（bit），它就像是字节（byte）的缩小版--很快会有更多的介绍。

192
00:19:07,490 --> 00:19:15,965
二进制位是 "比特 "一词的由来，因为如果去掉一些字母，二进制位只剩下 B-I-T，这就是比特。

193
00:19:15,965 --> 00:19:17,990
比特就是 0 和 1。

194
00:19:17,990 --> 00:19:23,030
这比你自己手指上的数字还多两个，当然，也比你我的数字少。

195
00:19:23,030 --> 00:19:25,820
作为人类，你我通常使用十进制。

196
00:19:25,820 --> 00:19:29,390
Dec 表示 10，因为你我一般使用 0 到 9。

197
00:19:29,390 --> 00:19:32,930
因此，一方面--又是一个双关语--你有了单韵母。

198
00:19:32,930 --> 00:19:37,760
计算机使用二进制。我们人类通常用十进制思考和交谈。

199
00:19:37,760 --> 00:19:44,090
但归根结底，这些东西从根本上说都是一样的，也就是说，我们都可以很容易地接触到它们。

200
00:19:44,090 --> 00:19:47,610
即使你不是电脑达人，我敢说你也即将成为电脑达人。

201
00:19:47,610 --> 00:19:53,570
那么什么是比特呢？那么，一个比特就是一个 0 或一个 1，也就是所谓的二进制位。

202
00:19:53,570 --> 00:19:56,090
但电脑怎么只能用二进制说话呢？

203
00:19:56,090 --> 00:19:59,360
他们如何仅用二进制解决问题、表示信息？

204
00:19:59,360 --> 00:20:05,300
好吧，说到底，如果他们想表示 0 和 1，我们就需要通过某种物理方式来实现。

205
00:20:05,300 --> 00:20:11,310
我敢说，也许最简单的方法就是把比特、0 或 1 想象成灯泡。

206
00:20:11,310 --> 00:20:20,030
按照人类的习惯，我们假设你是一台电脑，无论是笔记本电脑、台式机、手机，还是其他类似设备，你想表示的数字是 0

207
00:20:20,030 --> 00:20:22,770
你知道吗，你只要把电灯开关关上就行了。

208
00:20:22,770 --> 00:20:24,290
你把灯泡关掉。

209
00:20:24,290 --> 00:20:30,990
相比之下，如果你是那台电脑，你想表示数字 1，你就可以打开同样的开关，同样的灯泡，然后把它打开。

210
00:20:30,990 --> 00:20:35,840
因此，亮着的灯泡代表 "1"，熄灭的灯泡代表 "0"。

211
00:20:35,840 --> 00:20:37,928
为什么这与计算机有关？

212
00:20:37,928 --> 00:20:41,340
说到底，你我都是在晚上给笔记本电脑或手机充电。

213
00:20:41,340 --> 00:20:46,020
因此，无论你使用的是电池还是电源线，都会有一些物理资源得到补充。

214
00:20:46,020 --> 00:20:51,433
如今，电脑内部有成千上万个小开关。

215
00:20:51,433 --> 00:20:55,430
你可以把它们比喻成灯泡，但实际上它们并不发光。

216
00:20:55,430 --> 00:21:01,430
但是，还有一些很小很小的开关，这些开关，如果你听说过这个词，就是所谓的晶体管。

217
00:21:01,430 --> 00:21:08,390
因此，就像计算机拥有数百万个晶体管一样，这些晶体管可以打开表示 1，也可以关闭表示 0。

218
00:21:08,390 --> 00:21:15,110
从这个非常简单的机制中，电存在或不存在，一个 1 或一个 0。

219
00:21:15,110 --> 00:21:23,160
显然，计算机可以从 0 数到 1，但事实证明，如果多用一点电，还可以数得更高。

220
00:21:23,160 --> 00:21:24,420
那么，我该怎么做呢？

221
00:21:24,420 --> 00:21:28,500
好吧，让我来提议，我在台上拿一个我们自己的灯泡。

222
00:21:28,500 --> 00:21:29,210
这个关了。

223
00:21:29,210 --> 00:21:35,850
因此，举例来说，如果把它微型化，装在 Mac、PC 或手机里，这就是一个晶体管，事实上，这是底部的小开关。

224
00:21:35,850 --> 00:21:40,910
如果你的电脑想表示 0，它就会把开关关掉，灯也不会亮。

225
00:21:40,910 --> 00:21:45,193
如果你想表示 1，那么现在，我已经数到了 1，因为开关现在打开了。

226
00:21:45,193 --> 00:21:46,610
我抓住了一点电。

227
00:21:46,610 --> 00:21:50,598
我把它放在电脑里，所以现在我看到这是一个 1。

228
00:21:50,598 --> 00:21:53,390
好吧，但不幸的是，只有一个开关，一个灯泡、

229
00:21:53,390 --> 00:21:56,630
我只能从 0 数到 1。

230
00:21:56,630 --> 00:21:59,475
你可能会直觉地想，我怎么才能算得更高呢？

231
00:22:00,350 --> 00:22:01,070
大卫-J-马兰：再说一遍。

232
00:22:01,070 --> 00:22:01,430
听众：更多灯泡

233
00:22:01,430 --> 00:22:02,900
是啊，所以要多装灯泡。

234
00:22:02,900 --> 00:22:03,650
那就让我来吧。

235
00:22:03,650 --> 00:22:08,270
让我先拿点东西把它们放上去，这样我就可以一次用几个了。

236
00:22:08,270 --> 00:22:14,150
让我在此提议，与其只有一个灯泡，不如让我给自己一共装上三个灯泡。

237
00:22:14,150 --> 00:22:20,540
因此，所有的晶体管最初都是关闭的，如果你把它想象成微缩形式，在你的脑海中，这就像一台有三个晶体管的计算机。

238
00:22:20,540 --> 00:22:24,860
三个开关现在代表你我都知道的数字 0。

239
00:22:24,860 --> 00:22:27,150
为什么？他们都不在状态。

240
00:22:27,150 --> 00:22:30,450
那么，计算机如何表示数字 1 呢？

241
00:22:30,450 --> 00:22:33,230
嗯，它打开了其中一个灯泡。

242
00:22:33,230 --> 00:22:35,600
电脑又是如何表示数字 2 的？

243
00:22:35,600 --> 00:22:39,900
好吧，你可能会想，如果可以的话，你只需打开第二个灯泡。

244
00:22:39,900 --> 00:22:42,290
如果你想，计算机如何表示 3？

245
00:22:42,290 --> 00:22:44,250
你只需打开第三个灯泡。

246
00:22:44,250 --> 00:22:51,020
因此，有了三个比特，计算机似乎就能从 0 开始数到 1、2、3。

247
00:22:51,020 --> 00:22:53,480
但事实证明，如果我稍微聪明一点的话、

248
00:22:53,480 --> 00:22:55,760
其实我数的比这还多。

249
00:22:55,760 --> 00:22:59,060
为什么？我只是在考虑灯泡在这里的组合。

250
00:22:59,060 --> 00:23:00,435
如果我这样做呢？

251
00:23:00,435 --> 00:23:08,840
但如果我现在提出，这将是计算机表示 1 的方式呢？

252
00:23:08,840 --> 00:23:12,680
不过，这将是计算机表示 2 的方式。

253
00:23:12,680 --> 00:23:14,360
请注意，我没有打开同样的两个。

254
00:23:14,360 --> 00:23:16,430
我正在打开中间那个。

255
00:23:16,430 --> 00:23:19,820
我现在声称，这将是计算机表示 3 的方式。

256
00:23:19,820 --> 00:23:28,550
这将会是 -- 马上就会是 -- 电脑是如何表示我们所知道的 4 这个数字的，但我仍然只用了三个灯泡。

257
00:23:28,550 --> 00:23:32,600
这将是计算机表示为 5 的数字。

258
00:23:32,600 --> 00:23:42,380
这将是电脑如何表示数字 6 的过程，最后，事实证明，如果你聪明的话，用三个灯泡就能把数字数到 7。

259
00:23:42,380 --> 00:23:46,220
现在，即使你不知道我打开了什么以及为什么打开、

260
00:23:46,220 --> 00:23:50,470
我声称有八种不同的模式，从全部关闭到全部打开。

261
00:23:50,470 --> 00:23:52,220
但请注意，我开始对它们进行烫发处理。

262
00:23:52,220 --> 00:23:55,220
我考虑了哪些是打开的，哪些是关闭的。

263
00:23:55,220 --> 00:23:59,600
为什么这些数字代表我们所熟知的 0 到 7 呢？

264
00:23:59,600 --> 00:24:02,503
好吧，让我继续，也许我们可以这样做。

265
00:24:02,503 --> 00:24:09,650
让我们根据灯泡所在的位置，为每一个灯泡赋予一些特殊的意义，而不是仅仅考虑灯泡的存在。

266
00:24:09,650 --> 00:24:15,350
也许我们可以找三名志愿者，三名志愿者？

267
00:24:15,350 --> 00:24:17,480
好的你是自愿的

268
00:24:17,480 --> 00:24:18,210
好的上来吧

269
00:24:18,210 --> 00:24:19,610
如果你想去那边的舞台。

270
00:24:19,610 --> 00:24:22,350
你也上来吧你也上来吧 也到这边来

271
00:24:22,350 --> 00:24:24,530
因此，两端都有一些楼梯。

272
00:24:24,530 --> 00:24:27,440
也许我们应该为本学期的第一批志愿者鼓掌。

273
00:24:34,050 --> 00:24:38,633
好的所以你想成为我们的1号，如果你想继续前进，大致站在这里。

274
00:24:38,633 --> 00:24:40,175
你想成为第二名吗？

275
00:24:40,175 --> 00:24:41,330
是的Yeah.

276
00:24:41,330 --> 00:24:46,090
请到右边来，你是4号。

277
00:24:46,090 --> 00:24:53,120
如果你们愿意，可以到这边来，让我们给你们一点时间，向同学们简单介绍一下自己。

278
00:24:53,120 --> 00:24:53,662
你好

279
00:24:54,350 --> 00:24:56,120
我是高年级学生。

280
00:24:56,120 --> 00:24:57,440
很高兴见到你。

281
00:24:57,440 --> 00:24:59,840
听众：我叫[? Rayhanna, ?]，是一年级学生。

282
00:24:59,840 --> 00:25:00,978
欢迎。

283
00:25:00,978 --> 00:25:03,850
我叫约瑟夫，是一年级学生。

284
00:25:03,850 --> 00:25:04,850
欢迎。

285
00:25:04,850 --> 00:25:07,940
好的很高兴你们三位都来了。谢谢你们

286
00:25:10,940 --> 00:25:16,480
现在我提议，请你们三位代表数字 0。

287
00:25:16,480 --> 00:25:21,790
我现在宣布，如果你们每个人现在都代表一个开关，那么你们现在就有了更高级的灯泡。

288
00:25:21,790 --> 00:25:27,340
一个是 1，一个是 2，一个是 4，但事实上，你们每个人的塑料设备底部都有一个开关。

289
00:25:27,340 --> 00:25:30,520
我声称这三位志愿者代表的是数字 0。

290
00:25:30,520 --> 00:25:34,240
现在让我来问问大家，你们如何表示数字 1？

291
00:25:34,240 --> 00:25:36,240
你们应该如何合作？

292
00:25:36,240 --> 00:25:43,087
好的。所以，我们会有开、关、关，我想这和我的三个灯泡也是一样的，如果你想去关掉你的灯泡的话。

293
00:25:43,087 --> 00:25:46,910
你们三个如何表示数字 2？

294
00:25:46,910 --> 00:25:50,420
好了，现在从右到左，关、开、关。

295
00:25:50,420 --> 00:25:54,020
你们三个如何表示数字 3？

296
00:25:54,020 --> 00:25:57,043
啊，这就是为什么我的两个灯泡最后都亮了。

297
00:25:57,043 --> 00:25:58,835
你们三个如何表示数字 4？

298
00:26:02,620 --> 00:26:10,357
完美。5号、6号和7号？

299
00:26:10,357 --> 00:26:11,690
好吧，再给我们一个。

300
00:26:11,690 --> 00:26:14,184
你如何代表 8？

301
00:26:14,184 --> 00:26:15,000
我们不能We can't.

302
00:26:15,000 --> 00:26:16,190
好吧，你不能。

303
00:26:16,190 --> 00:26:20,250
那就再来一名志愿者，一名志愿者，怎么样？

304
00:26:20,250 --> 00:26:21,470
好的上来吧

305
00:26:25,350 --> 00:26:26,617
好吧 你叫什么名字 All right.你叫什么名字？

306
00:26:26,617 --> 00:26:27,950
我叫穆因我叫穆因

307
00:26:27,950 --> 00:26:28,610
戴维-J-马兰：如果你想说的话。

308
00:26:28,610 --> 00:26:29,390
我叫穆因我叫穆因

309
00:26:29,390 --> 00:26:40,150
好吧，[和穆因，]你们将是第 8 号，如果现在你们都-- 实际上，让我们来做个假设，你们将如何集体表示第 8 号，是 4 比特还是交换机？

310
00:26:40,150 --> 00:26:42,340
好，8，最后，给我 15。

311
00:26:46,380 --> 00:26:49,835
每个人都在脑子里笨拙地做算术题，哦，用单项式。

312
00:26:53,440 --> 00:26:55,150
是每个人

313
00:26:56,290 --> 00:26:57,670
掌声欢迎。

314
00:26:58,180 --> 00:27:00,610
谢谢大家。

315
00:27:00,610 --> 00:27:07,107
如果您想在这里留下您的号码，我们为您准备了一个 CS50 压力球，但还是要感谢您的志愿服务。

316
00:27:07,107 --> 00:27:09,440
你可以把这些数字关掉，放在这里。

317
00:27:09,440 --> 00:27:11,500
谢谢你。

318
00:27:11,500 --> 00:27:19,160
那么，我们该如何--如何从那里去创造这些模式呢？

319
00:27:19,160 --> 00:27:28,720
尽管我们最初仍有三个比特和三个开关，后来又有四个比特和四个开关，但最终，我们还是

320
00:27:28,720 --> 00:27:32,860
从根本上说，它使用了同样的方法来实际表示信息。

321
00:27:32,860 --> 00:27:38,150
我为什么要故意让志愿者们这样排队？

322
00:27:38,150 --> 00:27:44,140
我想让它们使用 2 进制，也就是二进制，但二进制也有一定的规则。

323
00:27:44,140 --> 00:27:53,021
即使你对二进制并不熟悉，只知道它的存在并与计算机有某种联系，但它实际上与你我每天使用的系统基本相同

324
00:27:53,021 --> 00:27:55,520
称为基数 10，又称十进制。

325
00:27:55,520 --> 00:28:00,370
因此，让我们把时间倒回小学，考虑一下十进制是如何工作的。

326
00:28:00,370 --> 00:28:03,820
你会发现，即使你不是电脑达人，其实你也是。

327
00:28:03,820 --> 00:28:06,410
你只需稍微调整一下你的心智模式。

328
00:28:06,410 --> 00:28:11,510
所以，这里的数字你可能会认为是 123，但这是为什么呢？

329
00:28:11,510 --> 00:28:13,240
其实也不是 123。

330
00:28:13,240 --> 00:28:23,967
这只是屏幕上三个符号的图案，1、2、3，你的大脑正在迅速赋予它们数学意义，123，但这是为什么呢？

331
00:28:23,967 --> 00:28:32,800
好吧，如果你和我一样，可能在以前就学过，当你有一个三位数时，比如，最右边的数字是 1 的位数，中间的数字是 10 的位数、

332
00:28:32,800 --> 00:28:35,870
最左边的数字是 100，这有什么关系？

333
00:28:35,870 --> 00:28:40,271
好吧，如果你快速做一些心算，就像你我如今即时做的那样

334
00:28:40,271 --> 00:28:50,500
这意味着 100 乘以 1 再乘以 10 乘以 2 再乘以 1 乘以 3，当然，100 乘以 20 再乘以 3 就得到了你我都知道的 123。

335
00:28:50,500 --> 00:28:56,900
但除此之外，我们如何才能在十进制系统中只用两位数而不是多达 9 位数呢？

336
00:28:56,900 --> 00:28:58,150
好吧，我们来归纳一下。

337
00:28:58,150 --> 00:29:05,920
在十进制系统中，你我都知道，如果我们这里的哈希值代表三位数，没错，就是 1 位、10 位、100 位、

338
00:29:05,920 --> 00:29:09,860
如果我们不断地进行 1,000 次、10,000 次等，但为什么会这样呢？

339
00:29:09,860 --> 00:29:12,580
好了，基础术语现在更贴切了。

340
00:29:12,580 --> 00:29:17,420
从技术上讲，就是 10 到第 0 列，10 到 1，10 到 2。

341
00:29:17,420 --> 00:29:20,650
因此，这些都是 10 的幂，其中 10 是基数。

342
00:29:20,650 --> 00:29:27,520
计算机只是把事情简化了一点，因为计算机最终只能使用电力，无论开机还是关机。

343
00:29:27,520 --> 00:29:32,780
他们无法使用 10 种不同类型的电力，只有 2 种，即开即关。

344
00:29:32,780 --> 00:29:34,640
他们只是使用了不同的底座。

345
00:29:34,640 --> 00:29:37,900
而最右边的数字就是所谓的 2 到 0。

346
00:29:37,900 --> 00:29:39,850
那么中间的数字就是 2 到 1。

347
00:29:39,850 --> 00:29:41,830
最左边是 2 到 2，又名

348
00:29:41,830 --> 00:29:51,920
1 的位置、2 的位置、4 的位置，继续下去就是 8，再继续下去就是 16、32、64、128，等等，但基本思路是一样的。

349
00:29:51,920 --> 00:29:56,770
那么，为什么你我都知道的数字 "0 "会被电脑这样表示呢？

350
00:29:56,770 --> 00:30:02,750
那么，从右到左，从左到右，就是 0。

351
00:30:02,750 --> 00:30:08,320
为什么呢？因为 4 乘以 0 再加上 2 乘以 0 再加上 1 乘以 0 当然就是 0。

352
00:30:08,320 --> 00:30:12,400
这就是为什么 001 代表 1。

353
00:30:12,400 --> 00:30:20,320
这就是为什么 010 代表 2、3、4、5、6 和 7。

354
00:30:20,320 --> 00:30:23,500
为什么我们需要第 4 位来表示 8 呢？

355
00:30:23,500 --> 00:30:29,740
可以说，我们需要用我们熟悉的人类术语来表达 "1"。

356
00:30:29,740 --> 00:30:34,630
但为此我们需要第 4 位，即另一个晶体管，它现在代表数字 8。

357
00:30:34,630 --> 00:30:39,070
这就是为什么我们以 "开 "结束 -- 从左到右 -- "关"、"关"、"关"。

358
00:30:39,070 --> 00:30:45,310
所以我一直在说 "开 "和 "关"，或者灯泡 "开 "或 "关"，但实际上，我的意思只是 "1 "或 "0"。

359
00:30:45,310 --> 00:30:52,860
因此，计算机和我们人类认为的数字事物只是 0 和 1，但从机械角度来看，你可以把它看作是这些灯泡。

360
00:30:52,860 --> 00:30:56,300
现在，一个比特用处不大。即使是 3 位、4 位，也没多大用。

361
00:30:56,300 --> 00:31:01,240
你可以数到 7 或 15，但一般来说，字节是更有用的计量单位。

362
00:31:01,240 --> 00:31:04,190
有谁知道一个字节有多少位？

363
00:31:04,190 --> 00:31:08,557
是的一个字节有 8 个比特。你可以把它看成一个八位组。

364
00:31:08,557 --> 00:31:14,200
在某些情况下，会有一些细微差别，但把一个字节看作是 8 位，这只是一个更有用的衡量标准。

365
00:31:14,200 --> 00:31:15,890
那么，这意味着什么呢？

366
00:31:15,890 --> 00:31:22,990
因此，如果你下载过音乐文件、照片或视频，这些都是以字节为单位的。

367
00:31:22,990 --> 00:31:32,290
可能不是小数字节，可能是千字节的千字节、百万字节的兆字节、亿字节的千兆字节，尤其是视频。

368
00:31:32,290 --> 00:31:39,670
这意味着你的计算机硬盘上有很多 8 位的模式，一些 0 和 1 的组合。

369
00:31:39,670 --> 00:31:46,330
在这里，计算机通常用 8 位字节来表示数字 0。

370
00:31:46,330 --> 00:31:58,247
如果同一台计算机使用全部 8 个比特（即全部字节）将其变为 1 -- 任何数学思维敏捷或见过这种情况的人都知道，一台计算机用 8 个比特或 1 能数多高？

371
00:31:59,080 --> 00:32:00,902
是的，255。为什么是255？

372
00:32:00,902 --> 00:32:03,610
好吧，我们不打算把这变成一成不变的数学练习。

373
00:32:03,610 --> 00:32:08,230
事实上，过了今天，我们就不会再考虑或谈论这么低级的比特了。

374
00:32:08,230 --> 00:32:19,520
但这是 1 的位置，2，4，8，16，32，64，128，如果我从左往右算，确实是 255。

375
00:32:19,520 --> 00:32:24,160
它忽略了我们如何表示负数，但也许改天会有更多关于负数的内容。

376
00:32:24,160 --> 00:32:28,810
当然，计算机能做的远不止数字、数学和这些低层次的东西。

377
00:32:28,810 --> 00:32:32,150
我们发送短信、撰写文件和电子邮件等等。

378
00:32:32,150 --> 00:32:36,220
那么，计算机该如何表示字母 A 呢？

379
00:32:36,220 --> 00:32:46,210
我认为，归根结底，你的 Mac、PC 和手机只是拥有大量的晶体管和开关，可以以 8 或字节为单位使用。

380
00:32:46,210 --> 00:32:58,440
不过，如果它已经使用这些 0 和 1 的模式来表示从 0 开始的数字，那么你认为该如何表示字母表中的字母呢？

381
00:32:59,730 --> 00:33:01,800
因此，我们可以给每个字母分配一个数字。

382
00:33:01,920 --> 00:33:08,760
让我来猜想一下，为了简单起见，我们把 A 称为 0，B 称为 1，C 称为 2。

383
00:33:08,760 --> 00:33:13,500
好了，我现在该如何表示 0、1 或 2 呢？

384
00:33:13,500 --> 00:33:19,050
好吧，如果现在我们不得不偷用一些数字来表示字母，那我们可能会给自己带来麻烦。

385
00:33:19,050 --> 00:33:21,870
我们必须选择一条车道，但也有解决办法，我们会看到的。

386
00:33:21,870 --> 00:33:25,710
事实证明，世界并不像 A 为 0 那么简单。

387
00:33:25,710 --> 00:33:32,640
一个典型的例子是，各地的电脑和电话都用数字 65（十进制数字 65）来表示。

388
00:33:32,640 --> 00:33:41,220
使用 8 个比特，如果我们将某些 0 变为 1，那么让我来规定一下，你可以使用 8 个比特，通过打开某些比特来表示字母 A

389
00:33:41,220 --> 00:33:46,000
但我们将尽量不过多地关注二进制层面。

390
00:33:46,000 --> 00:33:54,060
因此，如果 A 是 65，那么 B 将是 66，C 将是 67，以此类推，我们会得到什么呢？

391
00:33:54,060 --> 00:33:59,130
原来，有一整套系统可以将数字映射到字母。

392
00:33:59,130 --> 00:34:05,130
正如我刚才口头提到的，这里是 0 和 1 的模式，你可以通过它来表示 65。

393
00:34:05,130 --> 00:34:13,770
这里只需快速检查一下，我们不会经常做 1 位的数学运算，这很简单，2、4、8、16、32、64 位都可以。

394
00:34:13,770 --> 00:34:17,969
所以 64 加 1 等于 65。

395
00:34:17,969 --> 00:34:21,540
那么，一旦我做到了这一点，我怎样才能获得所有其他的信息呢？

396
00:34:21,540 --> 00:34:25,020
原来，几年前一群美国人想出了这个办法

397
00:34:25,020 --> 00:34:28,889
ASCII，美国信息交换标准码。

398
00:34:28,889 --> 00:34:30,344
现在，这是什么意思？

399
00:34:30,344 --> 00:34:37,620
嗯，这只是一个缩写，描述的是你真正提出的，数字和字母之间的映射，不像 0、1、2 那么简单。

400
00:34:37,620 --> 00:34:45,610
大写字母从 65、66、67 开始，但这里是目前使用的大多数字母，至少在这一系统中是这样。

401
00:34:45,610 --> 00:34:52,800
这是网上的一个大图表，你会在图表中间看到，这里是我的65分，A，这里是我的66分、

402
00:34:52,800 --> 00:34:58,750
B、C，让我们看看，72 是 H，73 是 I，以此类推。

403
00:34:58,750 --> 00:35:03,160
因此，至少在英语中，所有这些数字和字母之间都有一个映射关系。

404
00:35:03,160 --> 00:35:07,080
如果我们把注意力集中在这里，这些就是大写字母的开头。

405
00:35:07,080 --> 00:35:15,630
那么假设今天、明天，你收到了某人发来的短信，而你是个电脑高手、

406
00:35:15,630 --> 00:35:19,110
你要想办法查看发送的是什么 0 和 1 的模式。

407
00:35:19,110 --> 00:35:23,147
在这种情况下，它是无线的，而不是有线的，但它仍然是一些 0 和 1 的模式。

408
00:35:23,147 --> 00:35:27,900
而你的手机正在打开和关闭自己的一些开关，以表示朋友发来的信息。

409
00:35:27,900 --> 00:35:35,430
假设您收到的三个图案是这三个字节，从左到右，拼成一个三个字母的单词。

410
00:35:35,430 --> 00:35:40,060
好吧，如果我们算出 1 的位置、2 的位置等等 -- 我就不告诉你了。

411
00:35:40,060 --> 00:35:49,410
假设您收到的短信并不是字面上的 72、73、33，而是 8 加 8 加 8，24 比特的模式

412
00:35:49,410 --> 00:35:54,510
如果用数学运算，则表示十进制数 72、73、33。

413
00:35:54,510 --> 00:35:58,980
有谁还记得你可能从绿色和白色图表中收到了什么信息？

414
00:35:59,970 --> 00:36:00,930
你好

415
00:36:00,930 --> 00:36:02,010
你好。

416
00:36:02,010 --> 00:36:08,370
是的，"嗨 "是信息，但 72、73 给了我们 H 和 I。

417
00:36:08,370 --> 00:36:10,560
猜到 33 吗？

418
00:36:10,560 --> 00:36:12,100
是啊，在这里。

419
00:36:12,600 --> 00:36:13,770
所以这是一个感叹号。

420
00:36:13,770 --> 00:36:14,650
你怎么知道？

421
00:36:14,650 --> 00:36:17,025
好吧，你确实需要一些小抄，又名......

422
00:36:17,025 --> 00:36:18,010
这里是 ASCII 编码。

423
00:36:18,010 --> 00:36:24,490
如果我们再看看其他地方--让我突出显示图表的左边--你就会发现，在小数点后 33 位的旁边确实有一个感叹号。

424
00:36:24,490 --> 00:36:31,396
所以，在过去，一群人在一个房间里决定，嘿，当我们开始制造 PC，后来又制造 Mac 和手机时

425
00:36:31,396 --> 00:36:38,110
在这种情况下，我们只需就英文字母的这种表现形式达成一致。

426
00:36:38,110 --> 00:36:39,810
我们只需就这一映射达成一致。

427
00:36:39,810 --> 00:36:42,910
但有点奇怪的是，请注意这一点。

428
00:36:42,910 --> 00:36:54,660
事实证明，一旦你把自己逼到这个角落，开始用 65 表示 A，66 表示 B，那么，你该如何表示 65 这个数字和 66 这个数字呢？

429
00:36:54,660 --> 00:36:57,690
如果你想做数学题或使用 Excel 或类似的东西？

430
00:36:57,690 --> 00:37:01,380
有谁能找到解决办法吗？

431
00:37:01,380 --> 00:37:06,070
如何用 ASCII 码表示数字 1？

432
00:37:06,070 --> 00:37:07,528
是啊，在中间？

433
00:37:09,065 --> 00:37:09,940
是的。

434
00:37:09,940 --> 00:37:15,080
这可能有点 "萌"，但你可以用其他数字来表示数字。

435
00:37:15,080 --> 00:37:23,230
因此，如果你想把你我都知道的数字表示为 1，比如你在键盘上输入 1，结果计算机会把它存储为十进制数字 49。

436
00:37:23,230 --> 00:37:27,070
如果您在键盘上敲击 2，计算机本身并没有存储 2。

437
00:37:27,070 --> 00:37:29,230
它存储的是十进制数 50。

438
00:37:29,230 --> 00:37:33,940
现在，值得庆幸的是，悖论到此为止。

439
00:37:33,940 --> 00:37:36,340
我们现在只需将数字与数字进行映射。

440
00:37:36,340 --> 00:37:43,720
但实际上，归根结底--下周我们开始用另一种语言 C 编写代码时，你就会学到这一点--归根结底，这只是取决于上下文。

441
00:37:43,720 --> 00:37:49,720
在你的 Mac、PC 和手机里，有所有这些比特的排列组合，所有这些 0 和 1 的模式。

442
00:37:49,720 --> 00:37:55,252
一般来说，当你打开收到的短信时，里面都是 0 和 1。

443
00:37:55,252 --> 00:38:04,862
但很明显，如果是文字信息，文字信息的全部意义就在于发送文字，因此这些 0 和 1 的模式，默认情况下通常会被解释为字母表中的字母。

444
00:38:04,862 --> 00:38:06,070
因此，你不会看到 0 和 1。

445
00:38:06,070 --> 00:38:07,320
您不会看到小数点后的数字。

446
00:38:07,320 --> 00:38:10,090
您将看到您朋友想要的英文信息。

447
00:38:10,090 --> 00:38:19,660
相比之下，如果你打开 Excel 等软件，同样的 0 和 1 的模式可能确实是 72、73、33。

448
00:38:19,660 --> 00:38:23,530
您可能会在电子表格中看到写有这三个数字的单元格。

449
00:38:24,040 --> 00:38:28,210
因为电子表格在很多情况下都是关于数字、数字运算和数学的。

450
00:38:28,210 --> 00:38:36,820
相比之下，如果打开 Photoshop，尝试查看同样的 0 和 1 图案，就不会是 72、73、33 了。

451
00:38:36,820 --> 00:38:38,530
它不会是 0 和 1。

452
00:38:38,530 --> 00:38:39,670
它不会是喜。

453
00:38:39,670 --> 00:38:42,100
它将是彩虹中的某种颜色。

454
00:38:42,100 --> 00:38:46,810
原来，你也要用这些 0 和 1 的图案来表示颜色。

455
00:38:46,810 --> 00:38:56,560
事实上，只要你我同意，就像人类一直以来同意的那样，这些模式将会是什么，我们所有的系统，我们如今的许多系统确实都是可互操作的。

456
00:38:56,560 --> 00:39:01,330
但我在这里很有偏见，事实上，A 和 ASCII 非常以美国为中心。

457
00:39:01,330 --> 00:39:03,940
你在这张图表中看不到什么？

458
00:39:03,940 --> 00:39:11,620
如果你说的是英语以外的其他语言，那么你很可能看不到你熟悉和喜爱的、每天都需要用来输入或发送信息的字符。

459
00:39:11,620 --> 00:39:17,170
这里不支持大量字符集，包括重音字符和大量亚洲字母。

460
00:39:17,170 --> 00:39:20,420
你有很多符号，甚至在这个屏幕上都放不下。

461
00:39:20,420 --> 00:39:24,010
因此，人类很早就把自己逼入了绝境、

462
00:39:24,010 --> 00:39:24,970
美国人做到了。

463
00:39:24,970 --> 00:39:33,880
但在典型的键盘上，即美国英语键盘上，有 A、B、C、大写和小写字母，但也有重音字符。

464
00:39:33,880 --> 00:39:41,090
如今，不知道是否有必要这样做，但现在键盘上还有其他字符，比如这些。

465
00:39:41,090 --> 00:39:45,730
这些都是这一问题的技术解决方案的有趣化身。

466
00:39:45,730 --> 00:39:52,480
如果我暂时声称 ASCII 码历史上用 7 位来表示字母--让我们把它四舍五入为一个字节--那么

467
00:39:52,480 --> 00:40:00,520
用 8 位来表示字母，ASCII 可以表示多达 255 个字符，实际上是 256 个字符。

468
00:40:01,550 --> 00:40:04,840
如果都是 0，那就是 0，最高的数字是

469
00:40:04,840 --> 00:40:07,070
我刚才说的是 255。

470
00:40:07,070 --> 00:40:09,160
因此，总共有 256 种可能性。

471
00:40:09,160 --> 00:40:10,360
这可不是几个字母。

472
00:40:10,360 --> 00:40:13,730
这对英语还行，但对很多人类语言就不行了。

473
00:40:13,730 --> 00:40:25,360
那么，如果要表示重音字符、亚洲字符、表情符号，甚至像这些如今只是键盘上的按键的字符，直观的解决方案可能是什么呢？

474
00:40:25,360 --> 00:40:28,610
如果一个字节太少，直观的解决方案是什么？

475
00:40:29,110 --> 00:40:30,320
听众：再加一位数

476
00:40:30,320 --> 00:40:30,710
是的。

477
00:40:30,710 --> 00:40:31,610
所以再加一位数。

478
00:40:31,610 --> 00:40:37,640
就像我们让第 4 个志愿者上来给我们出第 4 个价一样，让我们把硬件扔到问题上，多用几个位子。

479
00:40:37,640 --> 00:40:41,925
因此，也许可以用 2 个字节代替 1 个字节，或者干脆用 3 或 4 个字节。

480
00:40:41,925 --> 00:40:49,047
尽管它变得有点昂贵--我们正在从 8 位变为 16 位，再变为 24 位或 32 位--但这就是如今计算机的工作方式。

481
00:40:49,047 --> 00:40:54,710
值得庆幸的是，我们的电脑和手机内存如此之大，我们当然可以腾出一些内存来表现这些东西。

482
00:40:54,710 --> 00:40:58,400
解决 ASCII 码的办法就是我们所说的统一码。

483
00:40:58,400 --> 00:41:06,380
因此，Unicode 也只是数字到字母的映射，但使用的语言多种多样。

484
00:41:06,380 --> 00:41:16,610
事实上，Unicode 协会是由一群来自不同公司、不同国家和不同文化背景的人组成的、

485
00:41:16,610 --> 00:41:23,070
在这种情况下，作为一个组织，就是要以数字方式捕捉人类语言的所有形式。

486
00:41:23,070 --> 00:41:32,600
此外，还要确保使用鲜为人知的语言的人类，尤其是较小的人口群体，能够通过这些 0 和 1 的映射，以数字方式得到表达和保存。

487
00:41:32,600 --> 00:41:42,830
但事实证明，如果开始使用 32 位（多达 32 位）来表示键盘上的字符，那么就有 40 亿种 0 和 1 的可能排列组合。

488
00:41:42,830 --> 00:41:45,538
这远远超出了我们对大多数人类语言的需求。

489
00:41:45,538 --> 00:41:49,850
因此，还有一点空间可以容纳一些更好玩的东西，比如那些表情符号。

490
00:41:49,850 --> 00:41:55,040
举个例子，假设你收到一条短信，短信内容是 0 和 1 的组合。

491
00:41:55,040 --> 00:42:03,080
或者，如果我们计算一下，假设你收到一条短信，如果按十进制计算，就是 4,036,991,106 条。

492
00:42:03,080 --> 00:42:07,110
有人知道你在看什么表情符号吗？

493
00:42:07,110 --> 00:42:11,033
如果你这样做就太奇怪了，但这是什么？

494
00:42:11,033 --> 00:42:16,990
事实证明，截至去年，这个表情符号是最受欢迎的表情符号、

495
00:42:16,990 --> 00:42:18,970
喜极而泣的脸庞

496
00:42:18,970 --> 00:42:24,070
这就是统一码联盟中的一群人所决定的表示模式。

497
00:42:24,070 --> 00:42:31,810
但你会发现，你们中的许多人可能有 iPhone，有些人可能也有安卓设备，有时，这些设备实际上看起来不太一样。

498
00:42:31,810 --> 00:42:36,850
这恰好是 iOS 上的 "喜极而泣 "当前版本。

499
00:42:36,850 --> 00:42:42,550
在安卓系统上，它往往看起来更像这样一些，而这里就有点奇怪了。

500
00:42:42,550 --> 00:42:46,840
尽管你我看到的这些东西看起来像图像，但它们并不是图像。

501
00:42:46,840 --> 00:42:50,470
它们是字符，至少是我们现在在 Unicode 中定义的字符。

502
00:42:50,470 --> 00:42:59,325
如今，iOS、Android、Windows、Facebook 以及其他公司和应用程序的字体都不尽相同。

503
00:42:59,325 --> 00:43:09,250
因此，就像英文字体和其他语言的字体可以给你提供有衬线或无衬线的不同字符一样，emoji 本身也是有人画的图画，但它们实际上只是一种字体。

504
00:43:09,250 --> 00:43:14,830
因此，同样是 0 和 1 的模式，在某人的手机上呈现的效果可能会略有不同。

505
00:43:14,830 --> 00:43:22,771
如果你的手机上有一个图标坏了，你收到了一个表情符号，但它就像一个正方形或其他任意的、不合理的东西。

506
00:43:22,771 --> 00:43:29,710
这可能只是意味着你还没有更新到 iOS 或 Android 的最新版本，而最新版本只会更新支持的表情符号字体。

507
00:43:29,710 --> 00:43:36,838
因为如今，Unicode 的工作人员几乎每年都会在特定字符集中添加越来越多的表情符号。

508
00:43:36,838 --> 00:43:41,710
前几天，我在兔子洞里找出了最近最流行的表情符号。

509
00:43:41,710 --> 00:43:49,390
相比之下，去年 Twitter 上最流行的表情符号是 "大声哭泣的脸"。

510
00:43:49,390 --> 00:43:55,780
我不知道这更能说明 2021 年的情况，还是 Twitter 的情况，但你肯定会看到使用这些工具的不同趋势。

511
00:43:55,780 --> 00:44:03,790
但是，即使是人类自己也不一定会提前两步思考，现在很多表情符号都是默认的黄色。

512
00:44:03,790 --> 00:44:10,690
但有很多表情符号并不是这些卡通人物，而是代表人类的各种职业或手势等。

513
00:44:10,690 --> 00:44:18,190
如今，你可能也注意到了，在你的手机、Mac 和 PC 上，你可以为某些表情符号指定不同的肤色。

514
00:44:18,190 --> 00:44:27,483
如果得到公司和 Unicode 的支持，你就可以触摸并按住某个表情符号，然后选择合适的肤色来代表自己或他人。

515
00:44:27,483 --> 00:44:29,440
然后修改显示屏。

516
00:44:29,440 --> 00:44:38,650
我们不妨想一想，苹果、谷歌和微软等公司是如何实现对不同肤色表情符号的支持的？

517
00:44:38,650 --> 00:44:41,000
你怎么能这样做？

518
00:44:41,000 --> 00:44:47,230
如果你想用五个不同肤色的表情符号来表示一些微笑的表情符号，你能想到什么？

519
00:44:47,230 --> 00:44:53,950
五种不同的图案在结构上完全相同，只是在该图像的某些地方使用了肤色。

520
00:44:53,950 --> 00:45:00,890
但如果只是复制、粘贴、粘贴、粘贴、粘贴，然后在 Photoshop 中更改颜色，效率就有点低了。

521
00:45:00,890 --> 00:45:05,020
这将使用比你可能需要的更多比特、更多信息。

522
00:45:05,020 --> 00:45:12,271
如果你现在开始像计算机科学家那样思考问题，如果一天结束时，你所拥有的只是 0 和 1，那还能怎样呢？

523
00:45:12,271 --> 00:45:14,180
你认为还能如何实现肤色？

524
00:45:14,680 --> 00:45:15,298
观众：RGB.

525
00:45:15,298 --> 00:45:16,090
大卫-J-马兰：好的。

526
00:45:16,090 --> 00:45:18,190
所以，RGB，我们稍后再谈。

527
00:45:18,190 --> 00:45:20,590
这代表红、绿、蓝。这是一种方法。

528
00:45:20,590 --> 00:45:29,720
不过，在这种情况下，我正在寻找一种替代方法，而不仅仅是用五个不同的 0 和 1 图案来表示相同的表情符号，但却代表不同的肤色。

529
00:45:29,720 --> 00:45:30,620
因此不完全是 RGB。

530
00:45:32,278 --> 00:45:33,070
大卫-J-马兰：好的。

531
00:45:33,070 --> 00:45:39,410
因此，先存储一个表情符号的副本，然后存储您想为该表情符号指定的颜色的不同变体。

532
00:45:39,910 --> 00:45:42,452
所以这实际上是一个例子 -- 你想详细说明一下吗？

533
00:45:42,452 --> 00:45:43,858
听众：你可以用一个循环。

534
00:45:43,858 --> 00:45:44,650
大卫-J-马兰：好的。

535
00:45:44,650 --> 00:45:46,900
因此，你可以使用循环来实际输出这些内容。

536
00:45:46,900 --> 00:45:47,942
稍后再详述。

537
00:45:47,942 --> 00:45:49,990
让我沿着这条路走下去。

538
00:45:49,990 --> 00:45:54,335
如果你愿意，这在某种意义上是一种更好的设计，但为什么呢？

539
00:45:54,835 --> 00:45:55,798
听众：过滤器？

540
00:45:55,798 --> 00:45:56,590
大卫-J-马兰：好的。

541
00:45:56,590 --> 00:45:58,780
所以，如果我们从 Instagram 的角度来考虑，滤镜也是如此。

542
00:45:58,780 --> 00:46:01,885
你可以改变某些东西的颜色，这也可能与此有关。

543
00:46:01,885 --> 00:46:03,967
会不会是另一种字体？会不会是另一种字体？

544
00:46:03,967 --> 00:46:05,300
大卫-J-马兰：哦，有意思。

545
00:46:05,300 --> 00:46:07,410
所以，也许只是一种完全不同的字体。

546
00:46:07,410 --> 00:46:12,800
除了对相同表情符号的肤色有不同的解释外，你有五种几乎完全相同的不同字体。

547
00:46:12,800 --> 00:46:13,550
让我来破坏。

548
00:46:13,550 --> 00:46:20,104
我认为，如果我们沿着这条特殊的道路走下去，Unicode 工作人员几年前决定这样做的方式是

549
00:46:20,104 --> 00:46:29,060
其中，您通过短信或电子邮件收到的第一个或多个字节就像表情符号的结构，即默认的黄色版本。

550
00:46:29,060 --> 00:46:37,187
但是，如果紧随其后的是这些人类标准化的、代表每种不同色调肤色的特定比特模式

551
00:46:37,187 --> 00:46:45,290
然后，手机、Mac 和 PC 就会将默认颜色（大多数情况下是黄色）更改为更适合人类的颜色。

552
00:46:45,290 --> 00:46:49,970
因此，你只需使用两倍的比特，但不会使用五倍的比特。

553
00:46:49,970 --> 00:46:50,720
那我是什么意思？

554
00:46:50,720 --> 00:46:54,890
你本身并没有五种完全不同的模式。

555
00:46:54,890 --> 00:47:07,920
对于每种可能的变体，你都有一个表情符号本身的结构表示，然后是这五种肤色的可重复使用的图案。

556
00:47:07,920 --> 00:47:16,100
遗憾的是，这对于正在开发的其他功能来说还不够全面，如今也是如此。

557
00:47:16,100 --> 00:47:24,150
表情符号旨在关注某些职业，早期也是如此，某些职业与某些性别相关，反之亦然。

558
00:47:24,150 --> 00:47:28,070
你不一定是某一性别或另一性别，从事某一职业或另一职业。

559
00:47:28,070 --> 00:47:30,230
这些组合是不可能实现的。

560
00:47:30,230 --> 00:47:37,700
但如今，正如你可能已经看到的那样，比如说，你可以看到一对热恋中的情侣，他们实际上看起来更像三个表情符号，只是有点像合二为一。

561
00:47:37,700 --> 00:47:45,390
事实上，这只需在手机上按一下键，就能将左边和右边的不同表情符号与中间的表情符号组合在一起。

562
00:47:45,390 --> 00:47:54,920
因此，现在的计算机在表示这些模式时，左边的字符用一组比特表示，右边的字符用一组比特表示、

563
00:47:54,920 --> 00:47:58,080
一组比特用于中间的任何表情符号。

564
00:47:58,080 --> 00:48:06,350
然后，你只需重复使用这些相同的图案和零碎的部分，就能组合出更复杂的表情符号。

565
00:48:06,350 --> 00:48:12,620
Unicode 人员不必为某些非常特殊的化身设计全新的表示法。

566
00:48:12,620 --> 00:48:21,390
他们可以为您要显示的其他字符创建一个人形、男形、女形，并重复使用这些相同的 0 和 1 模式。

567
00:48:21,390 --> 00:48:30,500
在这里，你可以看到人类的不完美，或者说缺乏远见，因为人类在早期建立了一个完全以美国为中心的系统，没有字符、表情符号或类似的东西，但现在也发展了。

568
00:48:30,500 --> 00:48:33,800
因此，这是当今计算领域的一个重要细节。

569
00:48:33,800 --> 00:48:39,780
它也在不断发展，而你们在接下来的日子里将要学习的语言，也同样在不断发展。

570
00:48:39,780 --> 00:48:43,942
新功能不断增加，甚至编程语言也有版本号。

571
00:48:43,942 --> 00:48:46,400
您的手机上可能有不同版本的应用程序。

572
00:48:46,400 --> 00:48:49,770
编程语言也有不同的版本。

573
00:48:49,770 --> 00:48:56,900
那么，迄今为止关于如何使用 ASCII 或 Unicode 或两者之间的任何编码来表示信息的问题是什么？

574
00:48:59,383 --> 00:49:00,800
大卫-J-马兰：哦，问得好。

575
00:49:00,800 --> 00:49:12,396
所以，概括地说，你为什么不能--嗯，让我总结一下，你为什么不能同样使用不同的模式来改变这些比特模式所代表的背景，无论是

576
00:49:12,396 --> 00:49:14,950
无论是数字、字母还是图形？

577
00:49:14,950 --> 00:49:17,920
实际上，这就是引擎盖下发生的事情。

578
00:49:17,920 --> 00:49:24,670
但从下周开始，当我们从零开始过渡到 C 语言时，你将学习类型、数据类型。

579
00:49:24,670 --> 00:49:35,642
最初的责任在于程序员，告诉程序是否应该将这种比特模式解释为数字、字母、颜色或其他东西。

580
00:49:35,642 --> 00:49:41,170
不过现在，在学期末，你会使用 Python 等语言，计算机会自动计算出结果

581
00:49:41,170 --> 00:49:45,950
通过上下文为您提供，这也让编程变得更加简单快捷。

582
00:49:45,950 --> 00:49:50,580
有关 Unicode、ASCII 或类似的其他问题？

583
00:49:50,580 --> 00:49:53,330
好吧那么，其他形式的信息呢？

584
00:49:53,330 --> 00:49:55,250
前面提到了 RGB，即红、绿、蓝。

585
00:49:55,250 --> 00:49:57,410
计算机如何处理图像？

586
00:49:57,410 --> 00:50:04,340
事实上，它通常是由一定量的红色、绿色和蓝色组合而成，但也有其他表现形式。

587
00:50:04,340 --> 00:50:08,000
如果你是平面设计师，你可能知道它们，但 RGB 还是很常见的。

588
00:50:08,000 --> 00:50:08,970
这意味着什么？

589
00:50:08,970 --> 00:50:18,395
这意味着，手机上的每一个点、电视上的每一个点、笔记本电脑或台式机上的每一个点，都有一个代表该点应显示多少红色的数字、

590
00:50:18,395 --> 00:50:24,690
一个数字代表多少绿色，一个数字代表多少蓝色，分别为红、绿、蓝。

591
00:50:24,690 --> 00:50:37,250
因此，举例来说，如果你屏幕上的一个点在短信或电子邮件中使用了这三个数字，这三个值或字节，72、73、33，那就会被解释为我声称 "高"。

592
00:50:37,250 --> 00:50:47,840
但在 Photoshop 或其他图形程序中，同样的图案会被解释为中等量的红色、中等量的绿色和少量的蓝色。

593
00:50:47,840 --> 00:50:49,250
为什么是 "中 "和 "小"？

594
00:50:49,250 --> 00:50:54,110
原来，这些都是字节，我们说的字节中最小的值是 0。

595
00:50:54,110 --> 00:50:58,100
一个字节的最大值是 255，所以我只是随便说说。

596
00:50:58,100 --> 00:51:02,660
具体来说，这就像中等、中等和少量的红色、绿色和蓝色。

597
00:51:02,660 --> 00:51:12,890
这三种颜色，就像光的波长一样，以这样的方式组合在一起，你就会在屏幕上看到这个点，一种黄色或棕色的浑浊色调。

598
00:51:12,890 --> 00:51:18,470
计算机就是这样精确存储这种颜色的，事实上，我们已经看到了这种颜色。

599
00:51:18,470 --> 00:51:23,930
一般来说，当您在屏幕上输入 "喜极而泣的脸 "时，它看起来是这样的，但通常要小得多。

600
00:51:23,930 --> 00:51:27,980
不过，让我们放大一点，或者说再放大一点。

601
00:51:27,980 --> 00:51:30,212
如果你知道这个词，你开始看到什么？

602
00:51:30,212 --> 00:51:30,920
观众：像素

603
00:51:30,920 --> 00:51:33,212
戴维-J-马兰：所以像素，它变得非常像素化。

604
00:51:33,212 --> 00:51:40,354
像素只是屏幕上的一个小点，如果把它放大，就能看到组成表情符号的所有小点。

605
00:51:40,354 --> 00:51:45,750
在 iOS 系统中，苹果公司使用的字体就是用来表示这种 0 和 0 的特殊模式的。

606
00:51:45,750 --> 00:51:53,780
屏幕上的每一个黄点都有 3 个字节。

607
00:51:53,780 --> 00:51:55,700
这个点需要多少红、绿、蓝？

608
00:51:55,700 --> 00:51:58,700
这个点需要多少红绿蓝？

609
00:51:58,700 --> 00:52:02,720
你也会注意到，当它变成褐色时，小点就会非常显眼。

610
00:52:02,720 --> 00:52:08,160
这 3 个值、3 个字节（又称 24 位）只是略有不同。

611
00:52:08,160 --> 00:52:19,850
这就是为什么你拍摄的图片或下载的 gif 会变得如此之大的原因，因为屏幕上的每一个点都代表着一个数字。

612
00:52:19,850 --> 00:52:29,630
那么，如果这就是我所说的图像的典型表示方法，即使用比特模式分配一定量的红色、绿色或蓝色，那么视频又是如何产生的呢？

613
00:52:29,630 --> 00:52:34,820
如果一天结束时，我们所拥有的只是 0 和 1，那么视频又算得了什么呢？

614
00:52:34,820 --> 00:52:36,500
视频是什么？

615
00:52:37,610 --> 00:52:39,420
让我们去这里，在后面的路。

616
00:52:39,420 --> 00:52:44,780
是的像素的数值真的会随着时间的推移而变化。你想确认还是否认这只手的举动吗？

617
00:52:45,380 --> 00:52:49,828
戴维-J-马兰：是的，或者说，一连串的图像，随着时间的推移，在屏幕上不断变化。

618
00:52:49,828 --> 00:52:59,191
因此，这两种解释都是有道理的，只是为了好玩，如果你是在这些图画书的陪伴下长大的，你可能会记得这样一个小故事：如果我们能把灯光调暗？

619
00:53:19,925 --> 00:53:31,250
因此，这是一种老式的模拟方式来实现视频，从这个意义上说，艺术家写出了数百张纸，上面的图像几乎一模一样，但他们铅笔上的墨水

620
00:53:31,250 --> 00:53:33,015
或者笔在轻微移动。

621
00:53:33,015 --> 00:53:41,220
如果将其数字化，让每一个笔画都用点来表示，那么你看到的就是一连串在屏幕上飞舞的图像。

622
00:53:41,220 --> 00:53:48,320
如果我们深入现实世界，如果你看过电影，好莱坞电影通常是 24 FPS（每秒帧数）。

623
00:53:48,320 --> 00:53:55,370
这实际上意味着你看到的是每秒 24 幅图像，而在电视或肥皂剧中，通常是每秒 30 幅图像。

624
00:53:55,370 --> 00:53:57,210
这让事情看起来更顺利一些。

625
00:53:57,210 --> 00:53:59,750
因此，如果你愿意的话，这并不是一部真正的电影。

626
00:53:59,750 --> 00:54:07,985
这是一连串的图片，而你的大脑和思维会插值到：哦，这是流畅的运动，尽管我们看到的只是非常快速的大量图片。

627
00:54:07,985 --> 00:54:15,200
现在，信息量变得非常大，我们将在本学期晚些时候讨论如何压缩信息，从而避免使用比实际需要更多的比特。

628
00:54:15,200 --> 00:54:21,590
虽然人们开发出了各种花哨的算法，但归根结底，视频可能只是一连串的图像而已。

629
00:54:21,590 --> 00:54:30,978
反过来说，如果你想表现伴奏音乐或其他东西，如果你们中有人会演奏乐器并能读懂乐谱，你如何将其数字化？

630
00:54:31,520 --> 00:54:35,330
比如，如何在计算机中表现音符？

631
00:54:35,330 --> 00:54:41,210
你和我在播放文件时都能听到它们的声音，但引擎盖下到底发生了什么？

632
00:54:41,210 --> 00:54:44,760
有音乐家、钢琴演奏家吗？

633
00:54:45,760 --> 00:54:47,150
听众：赫兹值？

634
00:54:47,150 --> 00:54:49,590
大卫-J-马兰：好的，那么赫兹值，即某种频率。

635
00:54:49,590 --> 00:54:52,528
因此，声音是一种频率，它会撞击你的耳膜。

636
00:54:52,528 --> 00:54:55,320
这就是声音低沉、高亢或介于两者之间的原因。

637
00:54:55,320 --> 00:55:00,771
因此，也许我们可以分配，就像这里的字母 A 到 G 一样，也许我们可以分配特定的频率值，这些频率值将是以某种方式测量的数字

638
00:55:00,771 --> 00:55:04,010
这些都是以赫兹为单位的数字，即每秒。

639
00:55:04,010 --> 00:55:08,780
也许我们还可以为每个音符添加一些其他数字，而不仅仅是音符或频率。

640
00:55:08,780 --> 00:55:14,900
也许，我们可以表示它的响度，比如人类按压它的力度或轻重。

641
00:55:14,900 --> 00:55:19,380
也许第三个数字，比如持续时间，比如手指在键盘上停留了多久？

642
00:55:19,380 --> 00:55:29,450
因此，你可以想象把音乐这种在现实世界中完全连续的东西量化为更离散的东西，把每个音符在一段时间内表示为一些数值序列。

643
00:55:29,450 --> 00:55:34,680
有很多不同的方式可以做到这一点，MIDI、mp3、AAC。

644
00:55:34,680 --> 00:55:45,290
你在 Mac 或 PC 上看到的几乎所有文件扩展名（如果你看到它们的话），归根结底只是表示一种不同的表示形式，在这种情况下，就像声音一样。

645
00:55:45,290 --> 00:55:53,300
因此，我只想说，有这些方法，还有更多的方法来表示输入和输出，值得庆幸的是，人类已经在很多方面实现了标准化。

646
00:55:53,300 --> 00:56:02,100
它们并不总是一致的，这就是为什么苹果数字、微软 Excel 和谷歌电子表格有不同的文件格式，以及不兼容的原因。

647
00:56:02,100 --> 00:56:07,670
但总的来说，人类已经将如何表示问题的输入和输出标准化了。

648
00:56:07,670 --> 00:56:12,590
但是，现在让我们把注意力集中在中间的这个黑盒子上，也就是这个抽象的东西。

649
00:56:12,590 --> 00:56:18,695
因此，从技术上讲，抽象是一个在计算机科学中随处可见的术语，而实际上，问题解决也是如此。

650
00:56:18,695 --> 00:56:25,310
这只是指简化某些东西，使你不必关注低层次的实现细节。

651
00:56:25,310 --> 00:56:29,880
你只需关注高层次目标或过程本身。

652
00:56:29,880 --> 00:56:36,830
因此，如果你有驾照、开过车或坐过车，那么你的车，就你而言，很可能是一个抽象概念。

653
00:56:36,830 --> 00:56:42,290
如果你和我一样，大多数人可能并不真正了解或关心发动机的工作原理和所有运动部件。

654
00:56:42,290 --> 00:56:50,510
对你来说，它只是一种从 A 点到 B 点的方式。它是一种抽象概念，但有人（希望是机械师）确实知道这些低层次的实现细节。

655
00:56:50,510 --> 00:56:56,700
如果你每次上学或去商店都要了解汽车的工作原理，那可能会是一个相当缓慢的过程。

656
00:56:56,700 --> 00:57:04,350
我们只是想在更高的抽象层次上进行思考和操作，而在编写代码和解决问题时，我们会一直这样做。

657
00:57:04,350 --> 00:57:07,940
那么，在这个黑盒子里，在这个抽象的概念里，究竟有什么呢？

658
00:57:07,940 --> 00:57:14,180
一般来说，计算机科学家会称之为算法，即解决某个问题的分步指令。

659
00:57:14,180 --> 00:57:24,230
现在，让我们来考虑实施细节，也就是如何解决某些问题，让我们举一个老式但现代的例子。

660
00:57:24,230 --> 00:57:27,970
如果你有 iPhone，这个图标当然就是通讯录应用程序。

661
00:57:27,970 --> 00:57:36,800
如果你的电话簿里有一大堆家人、朋友或同事，你就会在这里看到一些联系人的照片，这些照片通常按名字和姓氏的字母顺序排列。

662
00:57:36,800 --> 00:57:42,950
你我都有点击 "搜索 "然后使用自动完成的习惯，如果它们还不是你的最爱的话。

663
00:57:42,950 --> 00:57:45,140
当你开始输入自动完成时会发生什么？

664
00:57:45,140 --> 00:57:48,710
嗯，如果你输入字母 H，你会看到只有，大概是这样、

665
00:57:48,710 --> 00:57:50,640
海格、哈利、赫敏等等。

666
00:57:50,640 --> 00:57:56,280
如果输入 H-A，则只显示海格和哈利，而且速度超快。

667
00:57:56,280 --> 00:57:57,720
这是怎么回事呢？

668
00:57:57,720 --> 00:58:07,490
通常情况下，你可以从顶部开始，一直到底部，搜索所有的 H 或所有的 H-A，但对于较大的数据集来说，这样做会很慢。

669
00:58:07,490 --> 00:58:10,130
对于世界上的谷歌来说，这将变得非常缓慢。

670
00:58:10,130 --> 00:58:18,300
即使在我们的手机上，当你有成百上千个联系人时，最终，即使是这种方法，这种算法一步一步来，也可能会很慢。

671
00:58:18,300 --> 00:58:24,230
那么，我们该如何在这样的电话簿中搜索某个人，比如约翰-哈佛？

672
00:58:24,230 --> 00:58:30,910
这就是它的老式化身，而如今，你可能连实际使用它的机会都没有了。

673
00:58:30,910 --> 00:58:36,950
事实上，这有点像是在撒一个弥天大谎，因为这是黄页，这意味着这是一本关于公司而不是人的书。

674
00:58:36,950 --> 00:58:40,370
但你只能找到这些，甚至连这些都很难找到。

675
00:58:40,370 --> 00:58:43,770
但这与模拟形式、物理形式是一样的。

676
00:58:43,770 --> 00:58:47,310
那么，如果我想搜索像约翰-哈佛这样的人，该怎么做呢？

677
00:58:47,310 --> 00:58:55,345
好吧，我可以从第 1 页开始，然后开始搜索第 2 页、第 3 页、第 4 页、第 5 页。

678
00:58:55,345 --> 00:58:59,345
要做到这一点有点困难，尤其是这本电话簿已经很多年没人用了。

679
00:58:59,345 --> 00:59:06,260
但是，这种算法是否正确，一页一页地翻，非常不优雅？

680
00:59:06,260 --> 00:59:06,980
这样做对吗？

681
00:59:06,980 --> 00:59:09,690
如果约翰-哈佛在这里，我能找到他吗？

682
00:59:11,030 --> 00:59:16,870
这有点愚蠢地乏味，因为如果有 1000 页的话，他可能只读了几百页，但这是正确的。

683
00:59:16,870 --> 00:59:20,120
总有一天，我会找到他，如果他在页面上，我就能打电话给他。

684
00:59:20,620 --> 00:59:24,608
因为据推测，这里的名字都是按字母顺序排列的，边上也没有小抄。

685
00:59:24,608 --> 00:59:29,150
因此，如果按姓氏字母顺序排列，我必须从左到右搜索约翰-哈佛，搜索 H。

686
00:59:29,150 --> 00:59:30,740
那么，什么会稍微好一点呢？

687
00:59:30,740 --> 00:59:32,240
那么，一次翻两页如何？

688
00:59:32,240 --> 00:59:41,150
一本有 20 年历史的电话簿很难做到这一点，因为电话簿的每一页都是长在一起的，但 2、4、6、8、10、12 页都有。

689
00:59:41,150 --> 00:59:42,605
这种算法，对吗？

690
00:59:42,605 --> 00:59:43,465
AUDIENCE：No.

691
00:59:43,465 --> 00:59:44,150
戴维-J-马兰：好吧，所以没有。

692
00:59:44,780 --> 00:59:46,280
你在跳页你在跳页

693
00:59:46,280 --> 00:59:46,610
是的。

694
00:59:46,610 --> 00:59:48,060
所以我每隔一页都会跳过。

695
00:59:48,060 --> 00:59:56,120
因此，如果我不考虑这一点，而我发现自己在 I 区或 J 区，那么我可能会意外地得出结论、

696
00:59:56,120 --> 01:00:01,130
不，我还没有找到约翰-哈佛，只是因为我跳过了他，因为它夹在两页纸中间。

697
01:00:01,130 --> 01:00:08,100
现在，我可以解决这个问题，我想，如果我点击了 I 部分，好吧，让我再往回翻一页，以防他在最后一页。

698
01:00:08,100 --> 01:00:12,277
因此，它是可以恢复的，但除去刚才的小插曲，速度几乎快了一倍。

699
01:00:12,277 --> 01:00:18,020
但我们大多数人都会这么做，而你们的手机也是这么做的，尽管是以数字方式，但它们会大致打开电话簿的中间部分。

700
01:00:18,020 --> 01:00:21,747
他们低头一看，说，哦，我大概在 M 区。

701
01:00:21,747 --> 01:00:24,080
因此，1000 页的电话簿我大概看了一半。

702
01:00:24,080 --> 01:00:26,510
但我现在对约翰-哈佛了解多少呢？

703
01:00:26,510 --> 01:00:29,820
他在哪里，在我左边还是右边？

704
01:00:30,320 --> 01:00:39,950
因此，按字母顺序，他应该在我的左边，所以在这里，我可以用比喻和实际的方式，把问题撕成两半。

705
01:00:39,950 --> 01:00:41,330
你不需要留下深刻印象。

706
01:00:41,330 --> 01:00:46,460
沿着脊柱往下走很容易，但我知道约翰-哈佛就在左边。

707
01:00:46,460 --> 01:00:53,810
但现在，我可以不必要地戏剧性地把第一页的一半扔掉，我现在知道了什么？

708
01:00:53,810 --> 01:00:55,910
我已经从 1000 页减少到 500 页左右。

709
01:00:55,910 --> 01:00:57,602
我可以重复大致相同的算法。

710
01:00:57,602 --> 01:01:00,560
所以这次，我回得有点远了。

711
01:01:00,560 --> 01:01:03,150
我现在在 E 区。

712
01:01:03,150 --> 01:01:04,040
我知道什么？

713
01:01:04,040 --> 01:01:07,490
约翰-哈佛在我左边还是右边？

714
01:01:07,490 --> 01:01:09,950
在我的右边，这样我又可以把问题分成两半。

715
01:01:09,950 --> 01:01:12,800
扔掉这一半，现在我真的要飞了。

716
01:01:12,800 --> 01:01:18,380
我正在慢慢地口述，但从 1000 页到 500 页，再到现在的 250 页。

717
01:01:18,380 --> 01:01:20,960
现在，我又可以这样做了，125。

718
01:01:20,960 --> 01:01:32,210
我再做一次，大概像 67 次一样，不断重复，直到我希望只剩下一页纸，或者在这种情况下，具有讽刺意味的是，只剩下一个机械师的广告。

719
01:01:32,210 --> 01:01:36,620
那么，这对我们的业绩有什么影响呢？

720
01:01:36,620 --> 01:01:44,340
好吧，让我们抽象一下，如果第一种算法是快速绘制在一张没有偶数的图表上。

721
01:01:44,340 --> 01:01:47,340
这是我的 X 轴，问题的大小在 X 轴上。

722
01:01:47,340 --> 01:01:49,760
因此，问题越大，就越往那边走。

723
01:01:49,760 --> 01:01:51,200
是时候解决问题了。

724
01:01:51,200 --> 01:01:55,530
在 y 轴上越往上，解决问题所需的时间就越长。

725
01:01:55,530 --> 01:01:59,850
我们如何得出运行时间，即运行第一个算法所需的时间？

726
01:01:59,850 --> 01:02:01,010
嗯，这将是一条直线。

727
01:02:01,520 --> 01:02:09,790
因为如果明年因为更多的人搬到剑桥而增加一个页面，你就可能增加一个页面的翻转，所以就多了一秒钟，多了一个时间单位。

728
01:02:09,790 --> 01:02:10,790
所以这是一条直线。

729
01:02:10,790 --> 01:02:12,207
我们将其抽象为 "n"。

730
01:02:12,207 --> 01:02:16,640
如果电话簿有 n 页，那么这条直线的斜率基本上就是 n。

731
01:02:16,640 --> 01:02:22,970
第二种算法，我一次做两页，速度快了一倍，但仍然是直线。

732
01:02:22,970 --> 01:02:25,190
事实上，让我在这里画一些虚线。

733
01:02:25,190 --> 01:02:32,990
如果电话簿有这么大，按照我的第一种算法，可能需要这么多时间单位、这么多步骤、这么多翻页。

734
01:02:32,990 --> 01:02:39,260
但使用第二种算法时，请注意黄线上的交叉点比红线上的交叉点要低得多。

735
01:02:39,260 --> 01:02:43,517
如果 n 是页数，那么 n 大于 2 就意味着这里有一半的页数。

736
01:02:43,517 --> 01:02:49,530
因此，事实上，第二种算法的速度是前者的两倍，只是少了一个小插曲，那就是我必须向后翻两页。

737
01:02:49,530 --> 01:02:53,000
不过，如果我做事情的速度仍然比别人快一倍，那也没什么大不了的。

738
01:02:53,000 --> 01:02:55,340
但是，第三种算法看起来根本不同。

739
01:02:55,340 --> 01:02:56,300
看起来是这样的

740
01:02:56,300 --> 01:03:00,320
对数，如果你还记得高中或高中以前的内容--如果你不记得，也没关系。

741
01:03:00,320 --> 01:03:03,900
只是功能和形状从根本上不同而已。

742
01:03:03,900 --> 01:03:11,720
请注意，绿线在不断上升，但上升速度要慢得多，这意味着疯狂的事情是有可能发生的。

743
01:03:11,720 --> 01:03:20,890
如果马萨诸塞州的两个小镇，比如河对岸的剑桥和阿尔斯顿明年合并，那么就电话簿而言，它们的电话簿就变大了一倍。

744
01:03:20,890 --> 01:03:24,550
对于第一种算法，我需要花两倍的时间来完成。

745
01:03:24,550 --> 01:03:29,780
第二种算法，差不多要多花 50%的步骤，一次两步。

746
01:03:29,780 --> 01:03:38,650
但第三种算法，也就是我最后的算法，一次又一次地撕裂事物，一次又一次地分割和征服，如果你愿意，一半又一半，一半又一半，我的第三种算法还要走多少步呢

747
01:03:38,650 --> 01:03:42,965
如果剑桥和阿尔斯顿合并成一个两倍大的电话簿，会怎么样？

748
01:03:42,965 --> 01:03:43,840
听众：四个步骤

749
01:03:43,840 --> 01:03:45,590
就差一步了，对吧？

750
01:03:45,590 --> 01:03:46,160
没什么大不了的。

751
01:03:46,160 --> 01:03:50,960
一旦你决定约翰-哈佛是在左边还是右边，你就会在这个问题上大做文章。

752
01:03:50,960 --> 01:03:53,470
这样，你的进步就更快了。

753
01:03:53,470 --> 01:04:04,090
因此，从本质上讲，这就是你的电脑、手机在搜索哈利、赫敏、海格或其他任何人时，在引擎盖下所做的事情，因为它快得多、

754
01:04:04,090 --> 01:04:05,590
尤其是在数据量较大的情况下。

755
01:04:05,590 --> 01:04:13,360
如果你没有那么多联系人，那么采用这种分而治之的算法，从上到下搜索或更多地搜索可能并不重要。

756
01:04:13,360 --> 01:04:18,920
但是，如果你是世界上的谷歌公司，或者你正在分析大型数据集，那么这些数据的确会很快增加。

757
01:04:18,920 --> 01:04:20,420
我们该何去何从？

758
01:04:20,420 --> 01:04:23,140
接下来，我们要介绍一种叫做伪代码的东西。

759
01:04:23,140 --> 01:04:27,673
我怎样才能将口头上的直觉转化为实际代码？

760
01:04:27,673 --> 01:04:28,840
好吧，这不会是 "划痕"。

761
01:04:28,840 --> 01:04:30,830
这还不是 C 语言或 Python 语言。

762
01:04:30,830 --> 01:04:32,840
这只是一种类似英语的语法。

763
01:04:32,840 --> 01:04:35,530
许多程序员就是这样开始解决问题的。

764
01:04:35,530 --> 01:04:38,763
他们不会开始用 C、Python 或类似的语言输入代码。

765
01:04:38,763 --> 01:04:43,210
他们用英语或其他人类语言记下自己的想法大纲。

766
01:04:43,210 --> 01:04:45,700
其实，我的第一步就是拿起电话簿。

767
01:04:45,700 --> 01:04:48,790
我的第二步是打开电话簿的中间部分。

768
01:04:48,790 --> 01:04:52,570
我的第三步有些不同--看页面，因为为什么？

769
01:04:52,570 --> 01:04:57,670
我的第四步是，如果我要找的人出现在页面上，我应该怎么做？

770
01:04:57,670 --> 01:05:00,820
在我的例子中，这种情况从未发生过，但我还是给对方打了电话。

771
01:05:00,820 --> 01:05:01,960
所以我不干了。

772
01:05:01,960 --> 01:05:08,830
否则，如果该人在书中按字母顺序排列较前，如我的 H 是约翰-哈佛，那么

773
01:05:08,830 --> 01:05:12,460
我应该在电话簿左边中间的位置搜索。

774
01:05:12,460 --> 01:05:15,800
然后我应该回到第三步。

775
01:05:15,800 --> 01:05:19,540
第三步是查看页面，从而不断重复相同的过程。

776
01:05:19,540 --> 01:05:29,050
不过，第 9 步可能是别的，如果这个人在书的后半部分，那么让我们继续翻到书的右半部分中间，然后回到第 3 行。

777
01:05:29,050 --> 01:05:37,750
除此之外，我们或许还应该考虑第四种情况，以免我的搜索过程冻结或崩溃，或者给我一个带着错误的旋转沙滩球。

778
01:05:39,580 --> 01:05:41,620
如果电话簿上没有约翰-哈佛呢？

779
01:05:41,620 --> 01:05:44,438
我希望我的算法、我的手机不会重启或冻结。

780
01:05:44,438 --> 01:05:46,480
我应该用某种一网打尽的方法来处理这个问题。

781
01:05:46,480 --> 01:05:49,420
否则，可以说，我们就退出这个项目吧。

782
01:05:49,420 --> 01:05:54,340
因此，这四种可能出现的情况都有明确定义的行为。

783
01:05:54,340 --> 01:05:56,470
现在，让我们来指出其中几个突出的术语。

784
01:05:56,470 --> 01:06:00,620
事实证明，如果我在这里用黄色高亮显示，我在这里所做的事情是有规律可循的。

785
01:06:00,620 --> 01:06:02,050
这些是我所有的英语动词。

786
01:06:02,050 --> 01:06:05,410
稍后，我们将开始把这些动词称为 "功能"。

787
01:06:05,410 --> 01:06:14,020
当你编程或写代码时，你希望程序或计算机为你做一些事情，一些动作或动词，我们将提及这些动作或动词

788
01:06:14,020 --> 01:06:16,510
就像这里所说的 "功能 "一样。

789
01:06:16,510 --> 01:06:20,950
相比之下，我只是突出了我的 "如果"、"其他如果"、"其他如果 "和 "其他"。

790
01:06:20,950 --> 01:06:29,860
这将代表我们开始称之为 "条件 "的东西，也就是俗话说的岔路口，在这里你要么走这条路，要么走那条路，要么做这件事，要么做另一件事。

791
01:06:29,860 --> 01:06:38,230
你要根据我现在强调的内容来决定做哪些事情，这些内容将被称为 "布尔表达式"。

792
01:06:38,230 --> 01:06:41,260
布尔，指一位数学家，姓布尔。

793
01:06:41,260 --> 01:06:47,980
布尔表达式只是一个问题，有 "是"/"否"、"真"/"假"、"1 "或 "0 "等答案。

794
01:06:47,980 --> 01:06:51,790
它决定着你是做这件事，还是做这件事，还是做这件事，还是做那件事。

795
01:06:51,790 --> 01:06:54,440
在这种情况下，缩进是很重要的。

796
01:06:54,440 --> 01:07:06,410
我缩进第 5 行这一事实意味着，按照程序设计的惯例，只有当第 4 行的答案是 "是 "或 "true "时，我才应该执行第 5 行，其他缩进的行也是如此。

797
01:07:06,410 --> 01:07:09,492
最后一个特点就是这里。

798
01:07:09,492 --> 01:07:11,200
事实上，早些时候就有人指出了这一点。

799
01:07:11,200 --> 01:07:15,580
现在突出显示这两行，即第 8 行和第 11 行，它们代表什么？

800
01:07:15,580 --> 01:07:24,820
如果你已经做了--是的，这些是循环，是我反复做同样事情的某种循环、

801
01:07:24,820 --> 01:07:28,240
但在伪代码中，这种算法有一个关键细节。

802
01:07:28,240 --> 01:07:34,750
虽然它告诉我回到第 3 行，但为什么这种算法最终会停止呢？

803
01:07:34,750 --> 01:07:43,010
为什么我不会因为这些循环告诉我继续回到第 3 行而永远不停地寻找约翰-哈佛呢？

804
01:07:43,580 --> 01:07:51,260
最后，他会出现在页面上，或者，就像你刚才说的，他根本不会出现，我们就没有页面了，所以我们就放弃了。

805
01:07:51,260 --> 01:07:54,050
这就是去左半边还是右半边的关键所在。

806
01:07:54,050 --> 01:07:56,430
重复做同样的事情并不重要。

807
01:07:56,430 --> 01:08:03,890
只要你不断分割问题，把它缩小、缩小、再缩小，你就不会陷入所谓的无限循环。

808
01:08:03,890 --> 01:08:06,570
最终，就没有问题可以解决了。

809
01:08:06,570 --> 01:08:11,479
因此，即使你不认为自己是计算机人才，即使你从未编写过代码

810
01:08:11,479 --> 01:08:18,080
在接下来的日子里，你会发现我们从现实生活中汲取的这些想法已经触手可及。

811
01:08:18,080 --> 01:08:25,880
在学习代码的过程中，很多时候都会遇到一些磕磕绊绊，因为你无法以熟悉的方式来看待新语法。

812
01:08:25,880 --> 01:08:30,380
但你会发现，这些想法其实比你想象的要熟悉得多。

813
01:08:30,380 --> 01:08:38,240
稍后我们将看到--稍后我们将休息片刻，喘口气--你将在 Scratch 的背景下看到这些相同的想法、

814
01:08:38,240 --> 01:08:42,743
这是一种实际的编程语言，我们可以通过拖放拼图来编写实际的代码。

815
01:08:42,743 --> 01:08:47,040
我们会看到这些想法的一些变体，即所谓的 "参数"、"返回值 "和 "变量"。

816
01:08:47,040 --> 01:08:50,660
但我们最终会以某种方式将其转换成这个。

817
01:08:50,660 --> 01:08:56,810
有人想打赌，如果把这个程序输入到 Mac、PC 或手机中，它能做什么吗？

818
01:08:56,810 --> 01:08:59,975
这里只有大量的 0 和 1。

819
01:09:01,200 --> 01:09:05,370
它确实会说 "你好，世界"，但显然令人失望。

820
01:09:05,370 --> 01:09:15,750
事实上，在所有这些 0 和 1 中，不仅有 H-E-L-L-O，还有动词，即把东西打印到屏幕上的动作。

821
01:09:15,750 --> 01:09:23,870
还有其他一些东西，让程序知道如何启动，如何停止，很多东西我们都不用担心，这些都是设计计算机或语言的人做的。

822
01:09:23,870 --> 01:09:31,319
但归根结底，你们永远不会自己写 0 和 1，尽管我们的祖先曾经以某种形式写过。

823
01:09:31,319 --> 01:09:39,189
我们将使用更高级的语言，就像这样用 C 语言，或者更好的是，一会儿就用 Scratch，就像这样。

824
01:09:39,189 --> 01:09:45,812
事实上，这也是我们今天关注并开始学习 Scratch 这种图形编程语言的原因。

825
01:09:45,812 --> 01:09:49,937
因此，我们可以用函数、条件式、循环等方法来表达自己的意思

826
01:09:49,937 --> 01:09:57,720
但这种方式没有愚蠢的括号和大括号，也没有这些视觉干扰，因此可以将其翻译成这种低级语言。

827
01:09:57,720 --> 01:09:59,027
但现在，这已经够多了。

828
01:09:59,027 --> 01:10:03,365
那绝对是消防水龙头我们先休息十分钟。请随意起身或留在这里。

829
01:10:03,365 --> 01:10:06,755
稍后我们将继续学习一些实际代码。

830
01:10:35,505 --> 01:10:36,130
- 嗨

831
01:10:37,000 --> 01:10:41,491
我们是 "天气女郎"，有消息要告诉你。

832
01:10:41,491 --> 01:10:42,485
你最好听着

833
01:10:42,485 --> 01:10:45,540
准备好了，所有寂寞的姑娘们。

834
01:10:45,540 --> 01:10:47,940
把雨伞留在家里。

835
01:10:49,217 --> 01:10:51,140
湿度正在上升。

836
01:10:51,140 --> 01:10:52,912
嗯，上升。

837
01:10:52,912 --> 01:10:54,460
气压越来越低了

838
01:10:54,460 --> 01:10:56,034
有多低？

839
01:10:56,034 --> 01:11:01,600
根据所有的消息来源 -- 什么消息来源, 现在 -- 街道才是该去的地方。

840
01:11:01,600 --> 01:11:02,880
我们最好快点。

841
01:11:02,880 --> 01:11:18,100
今晚十点半左右 历史上第一次 下起了男人雨 下起了男人雨

842
01:11:18,100 --> 01:11:21,650
下雨了，哈利路亚！

843
01:11:21,650 --> 01:11:25,780
下雨了，男人们，阿门！

844
01:11:25,780 --> 01:11:27,505
我要出去了

845
01:11:27,505 --> 01:11:33,920
我要让自己全身湿透！

846
01:11:33,920 --> 01:11:37,045
下雨了，哈利路亚！

847
01:11:37,045 --> 01:11:38,795
好吧，那么 --

848
01:11:43,720 --> 01:11:49,312
这就是我们麻省理工学院媒体实验室的朋友们推出的图形编程语言 Scratch

849
01:11:49,312 --> 01:11:58,630
事实上，你们中的一些人可能在小学或类似的学校里用过这些工具，用来玩游戏、写代码等，但你们可能并不一定想过这些原语最终是如何工作的。

850
01:11:58,630 --> 01:12:07,120
事实上，你所做的一切--如果你以前用过 Scratch--以及你今天看到的一切，都将适用于接下来的几周，因为我们将探索这些被称为 "函数 "的东西

851
01:12:07,120 --> 01:12:09,820
循环"、"条件"、"布尔表达式 "等等。

852
01:12:09,820 --> 01:12:17,860
有了 Scratch，因为它的图形和动画非常协调，你就能制作出像这样的动画、互动艺术和更一般的软件。

853
01:12:17,860 --> 01:12:23,990
不过，您需要通过拖放拼图块来实现，只有在符合逻辑的情况下，拼图块才能锁定在一起。

854
01:12:23,990 --> 01:12:33,460
在第一周的课程中，你将不必处理大括号、小括号，以及所有你可能还记得的奇怪符号，而我们只想说 "你好，世界"。

855
01:12:33,460 --> 01:12:41,860
现在，这个特殊的节目 "下雨的男人 "是由前 CS50 教学研究员安德鲁-贝里（Andrew Berry）撰写的，他现在实际上是克利夫兰的总经理。

856
01:12:41,860 --> 01:12:43,730
布朗队，美国橄榄球队。

857
01:12:43,730 --> 01:12:48,400
因此，这些只是你们班上一些前辈创建的一些项目。

858
01:12:48,400 --> 01:12:56,170
在这堂课的剩余时间里，你还会看到其他几个问题，更多的是在课程的第一个作业，即问题集 0 中。

859
01:12:56,170 --> 01:12:57,470
那么，我们如何到达那里呢？

860
01:12:57,470 --> 01:13:00,040
好吧，先简单介绍一下我们要做的事情。

861
01:13:00,040 --> 01:13:03,523
在 Scratch 中，这也许是你能编写的最简单的程序。

862
01:13:03,523 --> 01:13:09,970
即使你以前从未见过 Scratch 或任何编程语言，你可能也能猜到这只是在屏幕上以某种方式 "说 "出来的、

863
01:13:09,970 --> 01:13:10,940
"你好，世界"

864
01:13:10,940 --> 01:13:16,720
但你不必输入深奥的命令和奇怪的语法，也就是我一直提到的大括号和小括号。

865
01:13:16,720 --> 01:13:18,970
你只需拖动这块黄色拼图。

866
01:13:18,970 --> 01:13:20,530
你拖动这块紫色拼图。

867
01:13:20,530 --> 01:13:22,810
可以说，让它们磁性地锁在一起。

868
01:13:22,810 --> 01:13:24,430
点击按钮，"砰 "的一声。

869
01:13:24,430 --> 01:13:31,010
有了这些积木和其他一些积木，你还能做出安德鲁栩栩如生的东西吗？

870
01:13:31,010 --> 01:13:32,740
下面我们就来看看。

871
01:13:32,740 --> 01:13:38,500
Scratch.MIT.edu 是麻省理工学院服务器上的云编程环境。

872
01:13:38,500 --> 01:13:41,380
您还可以在自己的 Mac 或 PC 上离线下载。

873
01:13:41,380 --> 01:13:43,870
它会给你一个这样的界面。

874
01:13:43,870 --> 01:13:47,770
在屏幕左侧，你会看到一个区块调色板。

875
01:13:47,770 --> 01:13:52,540
这些拼图（又称积木）有不同的颜色，这也是对它们的分类。

876
01:13:52,540 --> 01:13:57,040
例如，图中蓝色部分就是一大堆与运动相关的图块。

877
01:13:57,040 --> 01:14:05,110
于是，安德鲁用了一大堆这样的道具，让歌手和男主角在屏幕上随着背景音乐同步移动。

878
01:14:05,110 --> 01:14:09,310
同时，这个界面的中间将是代码区。

879
01:14:09,310 --> 01:14:14,729
在这里，安德鲁和你将拖放一些拼图块和其他颜色。

880
01:14:14,729 --> 01:14:20,110
并将它们锁定在一起，让你的角色--即将被发明出来的角色--在屏幕上做一些事情。

881
01:14:20,110 --> 01:14:29,650
事实上，在右下方，你会看到一个精灵区域，精灵是一个专业术语，指视频游戏或类似编程环境中的角色。

882
01:14:29,650 --> 01:14:36,020
默认情况下，Scratch 是这个编程环境的吉祥物。

883
01:14:36,020 --> 01:14:42,490
默认情况下，这里只选择了一个精灵，因为屏幕右上方就是该精灵的舞台。

884
01:14:42,490 --> 01:14:45,310
您还可以点击并放大，使其全屏显示。

885
01:14:45,310 --> 01:14:49,120
但这就是 Scratch（默认为猫咪）将要生活的世界。

886
01:14:49,120 --> 01:14:55,854
但你可以改变斯克雷奇的服装，让它看起来像一个歌手，或者像一个从天而降的人，或者像其他任何东西。

887
01:14:55,854 --> 01:15:00,260
你可以自己创作，也可以从网上或其他地方引进一些艺术品。

888
01:15:00,260 --> 01:15:03,640
那么，Scratch 所处的世界究竟是怎样的呢？

889
01:15:03,640 --> 01:15:08,646
一般来说，我们不必太在意数字，因为我们可以提出问题

890
01:15:08,646 --> 01:15:15,520
比如交互式的，比如 "抓猫 "或其他任何角色是否触碰到了屏幕边缘，是否触碰到了其他东西？

891
01:15:15,520 --> 01:15:21,080
但 Scratch 确实存在于这个二维坐标系世界中。

892
01:15:21,080 --> 01:15:27,700
因此，当猫或任何角色处于中间位置时，就是 xy 位置 0,0。

893
01:15:27,700 --> 01:15:32,990
同时，这里是 240 像素，也就是点，一直向右。

894
01:15:32,990 --> 01:15:37,700
因此，这将是 240,0，其中 y 为 0，因为它正好位于中线上。

895
01:15:37,700 --> 01:15:39,460
因此，它既不是向上的，也不是向下的。

896
01:15:39,460 --> 01:15:43,330
当然，左边是 -240 和 0。

897
01:15:43,330 --> 01:15:48,880
在猫的上方，x 等于 0，因为它正好在垂直中线上，然后是 180。

898
01:15:48,880 --> 01:15:52,152
然后往下，你可能会猜到，这里是 0，负 180。

899
01:15:52,152 --> 01:15:55,733
一般来说，我们不必在意这些精确的像素坐标。

900
01:15:55,733 --> 01:15:59,400
不过，如果你真的想让猫向上、向下、向左或向右移动，它最终还是有帮助的。

901
01:15:59,400 --> 01:16:06,010
根据 x 轴和 y 轴来确定方向，最终也能帮助你表达自己的想法。

902
01:16:06,010 --> 01:16:08,680
那么，这些想法可能是什么呢？

903
01:16:08,680 --> 01:16:09,950
好吧，就这么办。

904
01:16:09,950 --> 01:16:18,293
我要在 Scratch.MIT.edu 上创建一个像这样的空屏幕。

905
01:16:18,293 --> 01:16:19,960
因此，这是完全相同的界面。

906
01:16:19,960 --> 01:16:24,490
但现在我在浏览器中，全屏显示，这样我就可以开始写代码了。

907
01:16:24,490 --> 01:16:27,222
让那只猫在屏幕上说点什么吧。

908
01:16:27,222 --> 01:16:28,930
现在，这需要一点练习。

909
01:16:28,930 --> 01:16:36,538
但老实说，只要浏览一下这些拼图，你就能很快了解到什么是可能的，不仅是分类的，而且是具体的。

910
01:16:36,538 --> 01:16:39,163
我会跳来跳去，因为我以前当然也这么干过。

911
01:16:39,163 --> 01:16:41,410
但我要先去参加黄色的活动。

912
01:16:41,410 --> 01:16:45,475
我要拖放第一个图块，名为 "点击绿旗"。

913
01:16:45,475 --> 01:16:48,100
我放大了那里，只是为了让它更清晰一点。

914
01:16:48,100 --> 01:16:57,070
请注意，这面绿旗的形状恰好与顶部的绿旗相呼应，旁边是红色的 "停车标志"。

915
01:16:57,070 --> 01:17:02,320
绿旗表示开始，红色停止标志表示停止，即开始或停止我们的项目。

916
01:17:02,320 --> 01:17:06,560
下周，你将在键盘上编写一个文本命令来实现完全相同的想法。

917
01:17:06,560 --> 01:17:07,790
但现在，它只是一个按钮。

918
01:17:07,790 --> 01:17:10,667
那么，当点击 "绿旗 "时，我想让 Scratch 做什么呢？

919
01:17:10,667 --> 01:17:18,790
那么，不如让 Scratch 一开始就说 "Hello, world"（你好，世界）这样的话，从历史上看，这的确是大多数程序员可能写的第一个程序。

920
01:17:18,790 --> 01:17:24,490
因此，任何与猫看起来正在做的事情有关的内容，实际上都会被放在 "看起来 "下面，这里用紫色表示。

921
01:17:24,490 --> 01:17:27,100
所以我要拖过来 说 "你好"

922
01:17:27,100 --> 01:17:30,820
你会发现这个紫色块有些奇特和与众不同。

923
01:17:30,820 --> 01:17:33,400
当然，上面用紫色写着 "说"。

924
01:17:33,400 --> 01:17:40,810
但是，这里有一个白色椭圆和一些文字，默认情况下是 "hello"，因为 MIT 刚刚决定，默认情况下，占位符将是 "hello"。

925
01:17:40,810 --> 01:17:48,790
但只要你看到这个白色椭圆，就有机会为 "说 "功能提供输入。

926
01:17:48,790 --> 01:17:50,980
在这里，我借用了之前的术语。

927
01:17:50,980 --> 01:17:54,280
同样，解决问题的关键在于投入产出。

928
01:17:54,280 --> 01:17:56,045
在这两者之间，还有一些算法。

929
01:17:56,045 --> 01:18:00,470
稍后，我们将开始频繁地把算法称为 "函数"。

930
01:18:00,970 --> 01:18:03,350
因为它是某种算法的实现。

931
01:18:03,350 --> 01:18:06,640
因此，让我用 "你好，世界 "覆盖默认设置。

932
01:18:06,640 --> 01:18:07,690
我会放大。

933
01:18:07,690 --> 01:18:15,310
现在，如果我转到屏幕右上方，点击 "绿旗"，我们就能看到我的第一个程序代码了。

934
01:18:15,310 --> 01:18:17,190
现在，这不是一个巨大的提升，对吗？

935
01:18:17,190 --> 01:18:19,690
只需拖放拼图块即可。

936
01:18:19,690 --> 01:18:21,070
但现在发生了什么呢？

937
01:18:21,070 --> 01:18:23,530
事实证明，有两件事发生了。

938
01:18:23,530 --> 01:18:26,710
当我这个人类点击绿旗时、

939
01:18:26,710 --> 01:18:29,570
我触发了，我们现在开始称之为 "事件 "的东西。

940
01:18:29,570 --> 01:18:34,580
事件通常是计算机程序中发生的图形或交互式事件。

941
01:18:34,580 --> 01:18:37,600
你我整天都在用手机触发事件。

942
01:18:37,600 --> 01:18:45,460
每当你轻点、拖动、长按或捏住手机或任何时下手机上流行的手势时，都会触发事件。

943
01:18:45,460 --> 01:18:52,880
苹果、谷歌和其他公司的员工编写的代码可以监听这些事件，并在事件发生时采取相应措施。

944
01:18:52,880 --> 01:18:54,010
我就是这么做的。

945
01:18:54,010 --> 01:19:01,150
当点击 "绿旗 "时，我希望发生一些事情，即我希望这个紫色函数、这个动词、这个动作叫做

946
01:19:01,150 --> 01:19:02,910
说，做某事。

947
01:19:02,910 --> 01:19:03,910
我想让它做什么？

948
01:19:03,910 --> 01:19:05,590
我想让它说明这个输入是什么。

949
01:19:05,590 --> 01:19:07,900
我还要介绍另一个词汇。

950
01:19:07,900 --> 01:19:11,350
没错，这里的白色椭圆就是输入，非常通用。

951
01:19:11,350 --> 01:19:16,080
但在程序员的术语中，它们被称为 "参数"，又称 "参数"。

952
01:19:16,080 --> 01:19:20,050
而这只是指对函数的输入，以某种方式修改函数的行为。

953
01:19:20,050 --> 01:19:22,253
当我点击 "停止 "时，这只是另一个事件。

954
01:19:22,253 --> 01:19:23,920
而这个功能就内置在 Scratch 中。

955
01:19:23,920 --> 01:19:28,490
Scratch 知道，当你点击绿色的 "停止标志 "时，一切都会自动停止。

956
01:19:28,490 --> 01:19:30,950
我无需编写代码来支持该功能。

957
01:19:30,950 --> 01:19:33,470
所以这一切都很好，"你好，世界"。

958
01:19:33,470 --> 01:19:39,130
但如果我不停地停止、启动、停止、启动，它就会一次又一次地做同样的事情。

959
01:19:39,130 --> 01:19:45,350
说到底，这真的没什么意思，也许有一次会让人感到欣慰，但如果能有更多的互动就更好了。

960
01:19:45,350 --> 01:19:48,140
原来，我们也可以这样做。

961
01:19:48,140 --> 01:19:50,450
但我们需要一种不同的思维模式。

962
01:19:50,450 --> 01:19:53,740
因此，在这种情况下，当我们考虑这个功能时、

963
01:19:53,740 --> 01:20:01,870
比如说，在这个输入中，"你好，世界"，这实际上非常清晰地映射到了前面的这个模型中，我提出的这个模型就是解决问题，就是计算机科学，如果你愿意的话。

964
01:20:01,870 --> 01:20:05,770
当前问题的输入将以白色显示、

965
01:20:05,770 --> 01:20:06,760
"你好，世界"

966
01:20:06,760 --> 01:20:10,300
这种算法就是 "说 "算法。

967
01:20:10,300 --> 01:20:14,330
现在，我不知道麻省理工学院是如何让它在屏幕上打印出漂亮的小语泡的。

968
01:20:14,330 --> 01:20:17,770
但他们编写了这些底层的低级实施细节。

969
01:20:17,770 --> 01:20:22,630
他们给了我和你一个紫色的功能，叫做 "说"，它可以帮你做到这一点。

970
01:20:22,630 --> 01:20:24,670
你我不必重新发明轮子。

971
01:20:24,670 --> 01:20:28,580
Say 的输出是另一个专业术语，现在称为 "副作用"。

972
01:20:28,580 --> 01:20:34,008
副作用通常是指一些可视化的现象，比如调用一个函数的副作用。

973
01:20:34,008 --> 01:20:39,800
这样做的副作用是，猫咪神奇地出现了一个语音气泡，里面写着 "你好，世界"。

974
01:20:39,800 --> 01:20:41,200
所以我们有一个输入。

975
01:20:41,200 --> 01:20:42,370
我们有一个输出。

976
01:20:42,370 --> 01:20:43,540
我们有一种算法。

977
01:20:43,540 --> 01:20:46,910
但现在我们是在编程的背景下讨论这些想法。

978
01:20:46,910 --> 01:20:49,420
因此，现在的输入是一个 "参数"。

979
01:20:49,420 --> 01:20:51,400
算法是一种 "函数"。

980
01:20:51,400 --> 01:20:55,840
在这种情况下，输出是一种 "副作用"--你会听到越来越多这样的术语。

981
01:20:55,840 --> 01:21:00,800
最终我们会明白这一点，但不用担心，如果这些术语不是很自然地出现在我们的生活中。

982
01:21:00,800 --> 01:21:03,890
那么，我还能用它做些什么呢？

983
01:21:03,890 --> 01:21:09,910
让我回到 Scratch，让它更具互动性，让猫咪更生动地说点什么。

984
01:21:09,910 --> 01:21:15,050
所以，与其说 "你好，世界"，不如让他对我或你或其他人说 "你好"。

985
01:21:15,050 --> 01:21:16,010
那就让我来吧。

986
01:21:16,010 --> 01:21:20,200
让我到下面去，说 -- 让我先把这个弄掉。

987
01:21:20,200 --> 01:21:22,090
你还会发现一个小窍门。

988
01:21:22,090 --> 01:21:28,480
只要你开始拖动一个块，如果它靠近它，它就会变成灰色，然后就会被磁力吸到一起。

989
01:21:28,480 --> 01:21:30,220
你不必做得非常精确。

990
01:21:30,220 --> 01:21:32,345
相反，如果我想去掉一块拼图、

991
01:21:32,345 --> 01:21:35,800
我可以把它拖到左边的任何位置，然后放手，这样就可以删除它了。

992
01:21:35,800 --> 01:21:39,902
或者，你也可以右键单击或按住 Control 键单击，一个小菜单也会让你删除它。

993
01:21:39,902 --> 01:21:41,110
好吧，让我来做这个。

994
01:21:41,110 --> 01:21:50,700
在 "感知 "下面，我知道有很多与 "感知 "相关的东西，因为我以前也做过这样的工作。

995
01:21:50,700 --> 01:21:55,620
它能做的事情包括提出这样的问题："我是否触碰到了鼠标指针？"就像用户的光标一样。

996
01:21:55,620 --> 01:21:59,010
"我触摸的是一种特定的颜色 你可以覆盖成任何你想要的颜色吗？"

997
01:21:59,010 --> 01:22:02,500
"鼠标指针的距离是某个特定值吗？

998
01:22:02,500 --> 01:22:12,030
但现在，我要把注意力集中在这块蓝色拼图上，这块拼图会提出一个问题，它本身是一个白色的椭圆形，我显然可以改变它，然后它就会等待回应。

999
01:22:12,030 --> 01:22:14,443
但这块拼图有点不同。

1000
01:22:14,443 --> 01:22:15,360
它有点特别。

1001
01:22:15,360 --> 01:22:16,590
它还附带赠品。

1002
01:22:16,590 --> 01:22:19,690
技术上，我们称之为 "返回值"。

1003
01:22:19,690 --> 01:22:22,590
因此，有些功能并不只是在屏幕上做一些事情。

1004
01:22:22,590 --> 01:22:27,570
可以说，他们还给你的是一种价值，你可以用它做任何你想做的事。

1005
01:22:27,570 --> 01:22:31,750
除非你对所谓的返回值进行操作，否则什么都不会立即发生。

1006
01:22:31,750 --> 01:22:35,633
让我把这东西拖过来 问 "你叫什么名字？"

1007
01:22:35,633 --> 01:22:37,050
我将使用默认问题。

1008
01:22:37,050 --> 01:22:38,675
这似乎是一个合理的起点。

1009
01:22:38,675 --> 01:22:41,970
我不会覆盖默认值。现在让我继续放大。

1010
01:22:41,970 --> 01:22:43,890
让我回到 "外观"。

1011
01:22:43,890 --> 01:22:46,320
让我去说。

1012
01:22:46,320 --> 01:22:48,850
让我来组一个我想要的英语句子。

1013
01:22:48,850 --> 01:22:53,730
所以，让我放大这里，输入 "你好"，也许是逗号、空格。

1014
01:22:53,730 --> 01:23:00,270
我可以用 "戴维"，但这显然不对，因为我是在询问一个名字，然后我就像是提前硬编码了我的名字。

1015
01:23:00,270 --> 01:23:01,228
这不是我想要的。

1016
01:23:01,228 --> 01:23:02,610
我只想说 "你好"，逗号。

1017
01:23:02,610 --> 01:23:06,180
现在，让我把镜头拉远，再抓一个 Say block。

1018
01:23:06,180 --> 01:23:07,500
让我在这里说一下。

1019
01:23:07,500 --> 01:23:09,180
好吧，我不想说 "你好，你好"

1020
01:23:09,180 --> 01:23:14,230
我不想直接输入自己的名字，因为这样又有什么意义呢？

1021
01:23:14,230 --> 01:23:15,300
但请注意这一点。

1022
01:23:15,300 --> 01:23:22,080
如果我回到传感区块，蓝色椭圆形的 "应答 "就能派上用场。

1023
01:23:22,080 --> 01:23:25,280
这就是该函数的所谓 "返回值"。

1024
01:23:25,280 --> 01:23:27,780
所以，我要继续这样做，然后拖放。

1025
01:23:27,780 --> 01:23:30,600
虽然尺寸不合适，但形状是合适的。

1026
01:23:30,600 --> 01:23:34,620
因此，Scratch 会很聪明地为您填补这块拼图。

1027
01:23:34,620 --> 01:23:35,820
让我现在放大。

1028
01:23:35,820 --> 01:23:37,607
现在让我点击绿旗。

1029
01:23:37,607 --> 01:23:40,440
你会看到 Scratch 确实在用语音气泡提示我、

1030
01:23:40,440 --> 01:23:41,232
"你叫什么名字？"

1031
01:23:41,232 --> 01:23:44,320
注意到猫下面的小文本框在问：你叫什么名字？

1032
01:23:44,320 --> 01:23:46,590
所以我要输入 D-A-V-I-D，然后按回车键。

1033
01:23:46,590 --> 01:23:48,120
或者，我可以点击蓝色复选框。

1034
01:23:50,310 --> 01:23:51,802
好吧，这有点奇怪。

1035
01:23:51,802 --> 01:23:53,760
我想让他说 "你好"，而不仅仅是我的名字。

1036
01:23:53,760 --> 01:23:55,020
让我停下来。

1037
01:23:55,020 --> 01:23:56,190
让我重新开始。

1038
01:23:56,190 --> 01:23:57,648
好吧，你好，你叫什么名字？

1039
01:23:57,648 --> 01:24:00,230
D -A -V进入

1040
01:24:00,230 --> 01:24:02,490
有点粗鲁

1041
01:24:02,490 --> 01:24:04,890
为什么会出现这个错误？

1042
01:24:04,890 --> 01:24:07,920
比如，我想说 "你好，大卫"，而不只是 "大卫"。

1043
01:24:07,920 --> 01:24:11,550
然而，它两次都没有做到这一点。

1044
01:24:13,577 --> 01:24:17,658
是的，电脑正在快速处理我的指令和行动。

1045
01:24:17,658 --> 01:24:18,950
因此，它实际上正在这样做。

1046
01:24:18,950 --> 01:24:23,220
只是，你和我，在房间里，都太迟钝了 没注意到它说 -- "你好，戴维"

1047
01:24:23,220 --> 01:24:25,470
它似乎只说了 "大卫"。

1048
01:24:25,470 --> 01:24:26,910
那么好吧，我该如何解决这个问题呢？

1049
01:24:26,910 --> 01:24:29,940
这时候，你就要开始四处打探，思考如何解决这个问题。

1050
01:24:29,940 --> 01:24:31,100
让我回到 "外观 "下面。

1051
01:24:31,100 --> 01:24:33,330
也许有更聪明的办法。

1052
01:24:33,330 --> 01:24:34,520
也许我可以

1053
01:24:34,520 --> 01:24:35,540
好吧，我可以做到这一点。

1054
01:24:35,540 --> 01:24:42,150
要不，别只说 "你好"，显然还有另一个拼图，我可以给它计时，这样也许能让事情慢一点。

1055
01:24:42,150 --> 01:24:43,110
那就让我来吧。

1056
01:24:43,110 --> 01:24:45,810
让我把这些都扔掉吧。

1057
01:24:45,810 --> 01:24:49,140
让我拖动 2 秒钟，说 "你好"。

1058
01:24:49,140 --> 01:24:51,870
让我再拖一个 说 "你好 "2 秒钟。

1059
01:24:51,870 --> 01:24:54,500
让我把第一个逗号改为 "你好 "逗号。

1060
01:24:54,500 --> 01:24:57,530
然后让我回到 "感应"。

1061
01:24:57,530 --> 01:25:01,460
让我抓住那个同样的答案，因为我刚才把它扔掉了，我就改一下。

1062
01:25:01,460 --> 01:25:02,960
我甚至不用删除 "你好"。

1063
01:25:02,960 --> 01:25:04,740
我可以这样覆盖它。

1064
01:25:04,740 --> 01:25:08,360
所以，我想现在我们应该踩踩刹车，慢慢来。

1065
01:25:08,360 --> 01:25:09,620
让我停下来。

1066
01:25:09,620 --> 01:25:10,550
让我先说。

1067
01:25:10,550 --> 01:25:12,050
D-A-V-I-D，回车

1068
01:25:12,050 --> 01:25:14,600
你好，戴维

1069
01:25:14,600 --> 01:25:18,120
好吧，现在好多了，好像开始起作用了。

1070
01:25:18,120 --> 01:25:21,255
我认为你的假设是对的，只是看起来有点愚蠢，对吗？

1071
01:25:21,255 --> 01:25:22,880
就像它在说 "你好

1072
01:25:24,170 --> 01:25:25,640
--大卫，好像我们能做得更好似的。

1073
01:25:25,640 --> 01:25:29,930
而且，你手机、Mac 或 PC 上的每款软件都比它好。

1074
01:25:29,930 --> 01:25:33,750
它通过你我都熟悉的用户界面将单词加在一起。

1075
01:25:33,750 --> 01:25:35,480
所以，让我们在这里再多钓一会儿。

1076
01:25:35,480 --> 01:25:36,950
让我扔掉这些。

1077
01:25:36,950 --> 01:25:39,860
让我回到 "外观"，说得简单一些。

1078
01:25:39,860 --> 01:25:45,720
我想让它说 "Hello"（你好），逗号为 name，其中 name 来自答案的返回值。

1079
01:25:45,720 --> 01:25:46,740
那么，我该怎么做呢？

1080
01:25:46,740 --> 01:25:49,440
好吧，让我来介绍一下行动处，这是我们以前没有接触过的。

1081
01:25:49,440 --> 01:25:50,732
这里有很多东西。

1082
01:25:50,732 --> 01:25:53,720
其中一些与数学有关，如加法、减法等。

1083
01:25:53,720 --> 01:25:56,280
您可以生成可能有用的随机数。

1084
01:25:56,280 --> 01:25:59,810
如果我继续往下看，就会看到 "苹果 "和 "香蕉"。

1085
01:25:59,810 --> 01:26:01,280
但这只是占位符文字。

1086
01:26:01,280 --> 01:26:06,170
您可以将一段文字与另一段文字连接起来，默认为 "苹果 "和 "香蕉"。

1087
01:26:06,170 --> 01:26:08,480
不过，还是改成 "你好 "和我的名字吧。

1088
01:26:08,480 --> 01:26:11,120
这个也是，尺寸不对，但形状是对的。

1089
01:26:11,120 --> 01:26:13,190
所以，让我先把它说清楚。

1090
01:26:13,190 --> 01:26:15,920
现在让我来做 "你好 "逗号。

1091
01:26:15,920 --> 01:26:20,840
现在，我想我只想抓取答案的返回值。

1092
01:26:20,840 --> 01:26:25,280
让我拖着和以前一样的椭圆形，"掐"--也就是 "覆盖"--香蕉。

1093
01:26:25,280 --> 01:26:28,430
所以，现在我正在构思一些功能。

1094
01:26:28,430 --> 01:26:33,972
一个函数 "Join "的输出将是另一个函数 "Say "的输入。

1095
01:26:33,972 --> 01:26:38,660
现在，我们来看看它们堆叠在一起或嵌套在一起会发生什么。

1096
01:26:38,660 --> 01:26:42,440
点击绿旗，D-A-V-I-D。输入。

1097
01:26:42,440 --> 01:26:43,357
"你好 戴维"

1098
01:26:43,357 --> 01:26:44,690
好吧，这也太快了

1099
01:26:44,690 --> 01:26:45,680
让我们再来一次。

1100
01:26:47,270 --> 01:26:49,545
开始，D -A -V进来

1101
01:26:50,045 --> 01:26:52,650
好吧，这不是世界上最激动人心的节目。

1102
01:26:52,650 --> 01:26:53,750
但这更正确。

1103
01:26:53,750 --> 01:26:57,062
设计得更好，只是因为这是你期望软件做的事

1104
01:26:57,062 --> 01:27:03,962
而不是某种蹩脚的用户界面，只是插入随机延迟，使其勉强工作，就像是一种变通办法，一种黑客手段，如果你愿意的话。

1105
01:27:03,962 --> 01:27:06,170
不过，用 Scratch 也能做一些很酷的事情。

1106
01:27:06,170 --> 01:27:10,940
我们就不一一赘述它所拥有的各种有趣的、适合家庭使用的功能了。

1107
01:27:10,940 --> 01:27:12,810
不过，这里有一个还挺酷的。

1108
01:27:12,810 --> 01:27:16,550
让我进入屏幕左下角的 "扩展 "按钮。

1109
01:27:16,550 --> 01:27:17,720
这个还挺酷的。

1110
01:27:17,720 --> 01:27:19,575
让我转到文本到语音。

1111
01:27:19,575 --> 01:27:22,700
你会注意到，这个软件需要互联网，因为它是基于云计算的。

1112
01:27:22,700 --> 01:27:27,715
但这只是给了我一些新的拼图碎片，属于一个新的类别、

1113
01:27:27,715 --> 01:27:28,340
文本转语音

1114
01:27:28,340 --> 01:27:30,710
而这些绿色的产品也确实如其所言。

1115
01:27:30,710 --> 01:27:31,860
那就让我来吧。

1116
01:27:31,860 --> 01:27:33,120
让我再放大一点。

1117
01:27:33,120 --> 01:27:34,543
让我保留 "加入 "区块。

1118
01:27:34,543 --> 01:27:36,710
我就暂时把它扔在这里。

1119
01:27:36,710 --> 01:27:40,070
它不会因为我没有把它拖到另一边而自动删除。

1120
01:27:40,070 --> 01:27:42,800
但我要去掉紫色的 "说 "字块。

1121
01:27:42,800 --> 01:27:47,570
我要做的是绿色的 "说话 "区块，然后让它就位。

1122
01:27:47,570 --> 01:27:50,990
然后，我要把它拖放到 "说话 "输入框上。

1123
01:27:50,990 --> 01:27:54,290
现在，也许更可爱一点，让我们试试这个。

1124
01:27:54,290 --> 01:27:56,270
绿旗，你叫什么名字？

1125
01:27:56,270 --> 01:27:57,710
D -A -V进入

1126
01:27:58,460 --> 01:28:00,578
你好，戴维

1127
01:28:00,578 --> 01:28:01,370
大卫-J-马兰：好的。

1128
01:28:02,370 --> 01:28:03,890
有点像机器人。

1129
01:28:03,890 --> 01:28:05,917
但至少现在有了合成语音。

1130
01:28:05,917 --> 01:28:13,550
现在我已经有了自己的 Siri 或 Google Assistant 或 Alexa，它可以识别任何文字，并播放出来。

1131
01:28:13,550 --> 01:28:17,480
好吧，让我们把它变成一只真正的猫，它不会用那种奇怪的人类声音说话。

1132
01:28:17,480 --> 01:28:19,610
让我先把这些东西都扔掉吧。

1133
01:28:19,610 --> 01:28:22,730
让这只猫像猫一样喵喵叫吧。

1134
01:28:22,730 --> 01:28:24,650
让我到 "声音 "区下面去。

1135
01:28:24,650 --> 01:28:33,080
现在，麻省理工学院免费为你提供了一些声音，因为它默认是围绕猫设计的。我将继续使用 "Play Sound Meow（播放喵喵的声音）"，直到完成为止。

1136
01:28:33,080 --> 01:28:36,860
现在 -- 我们之前在人群中听到了一段预告 --

1137
01:28:38,982 --> 01:28:40,440
诚然，这有点刺耳。

1138
01:28:40,440 --> 01:28:42,460
也许我们可以把音量调低一点。

1139
01:28:42,460 --> 01:28:45,710
但请注意，如果我想让猫再喵喵叫一次，我只需再点击一次。

1140
01:28:46,905 --> 01:28:48,690
好吧，还有那边，我听说 --

1141
01:28:51,320 --> 01:28:53,500
好了，现在有点可爱了吧？

1142
01:28:53,500 --> 01:28:54,960
所以，它只是喵 -

1143
01:28:54,960 --> 01:28:56,610
好的，是的，回声，回声。

1144
01:28:56,610 --> 01:28:59,767
所以现在每次我打绿旗的时候，它都会喵喵叫。

1145
01:28:59,767 --> 01:29:02,100
现在，这是伟大的， 但即使是一个孩子可能会 -

1146
01:29:02,730 --> 01:29:03,780
--比如希望它--

1147
01:29:03,840 --> 01:29:06,790
--就 "喵喵 "地叫，也许，就像一次又一次，而不必一直--

1148
01:29:07,290 --> 01:29:08,165
--按下按钮

1149
01:29:08,165 --> 01:29:09,880
那么，我们该如何做呢？

1150
01:29:09,880 --> 01:29:16,570
好吧，如果我想让它多次喵喵叫，我为什么不一次又一次地抓住它呢？

1151
01:29:16,570 --> 01:29:21,725
或者，你也可以右键单击或按住 Control 键单击一块拼图，然后从弹出的小菜单中复制它。

1152
01:29:21,725 --> 01:29:22,920
好了，三只喵喵。

1153
01:29:25,960 --> 01:29:27,730
好吧，这可不是一只快乐的猫。

1154
01:29:27,730 --> 01:29:29,200
听起来可能是饿了。

1155
01:29:29,200 --> 01:29:31,240
那么，我们能减缓这种情况吗？

1156
01:29:31,240 --> 01:29:32,380
也许吧

1157
01:29:32,380 --> 01:29:34,630
事实上，如果我四处打探，就让我去控制室吧。

1158
01:29:34,630 --> 01:29:36,850
好像有个 Wait block。

1159
01:29:36,850 --> 01:29:40,630
默认情况下等待 1 秒。请注意，Scratch 会很通情达理。

1160
01:29:40,630 --> 01:29:44,410
如果你只是在块之间悬停，它也会生长到填满该块。

1161
01:29:44,410 --> 01:29:47,095
所以，我可以把它改成 1 或 2，或者任何数秒的时间。

1162
01:29:47,095 --> 01:29:48,970
我暂时将其保留为默认值，即 1.

1163
01:29:48,970 --> 01:29:50,680
现在，我要继续做这件事。

1164
01:29:55,580 --> 01:29:58,790
好了，更可爱、更不饿、更友好了。

1165
01:29:58,790 --> 01:30:00,740
但这并不是最好的设计。

1166
01:30:00,740 --> 01:30:01,460
这是正确的。

1167
01:30:01,460 --> 01:30:02,960
让我们把它作为一个艺术术语。

1168
01:30:02,960 --> 01:30:05,720
正确的意思是代码会按照您的要求运行。

1169
01:30:05,720 --> 01:30:08,090
我想让猫慢慢地喵喵叫三声。

1170
01:30:08,090 --> 01:30:08,720
它确实做到了。

1171
01:30:08,720 --> 01:30:10,370
所以我敢打赌这是正确的。

1172
01:30:10,370 --> 01:30:12,380
但这并不是最好的设计。

1173
01:30:12,380 --> 01:30:14,810
这就是事情变得更加主观的地方，对吗？

1174
01:30:14,810 --> 01:30:20,663
比如，你可以在英语课的作文中写出准确的句子，但除此之外，完全就是一团糟。

1175
01:30:20,663 --> 01:30:24,830
比如，你在这里和那里的争论，你没有说错什么，但你说得不好。

1176
01:30:24,830 --> 01:30:28,110
在代码方面，我们可以做得更好。

1177
01:30:28,110 --> 01:30:32,340
而复制/粘贴或反复重复自己的内容往往是不好的做法。

1178
01:30:32,840 --> 01:30:37,188
假设您想将等待时间从 1 秒改为 2 秒。

1179
01:30:37,188 --> 01:30:38,480
诚然，这不是什么大不了的事。

1180
01:30:38,480 --> 01:30:40,400
好吧，我点击那里，把它改成 2。

1181
01:30:40,400 --> 01:30:41,990
我点击那里，将其改为 2。

1182
01:30:41,990 --> 01:30:43,820
但如果你喵了 5 次、10 次呢？

1183
01:30:43,820 --> 01:30:46,858
现在，我必须在 5 到 10 个不同的地方更改 "等待"。

1184
01:30:46,858 --> 01:30:47,900
这太愚蠢了

1185
01:30:47,900 --> 01:30:53,270
这会占用不必要的人力时间，而且你最终会搞砸，尤其是当你的程序越来越长的时候。

1186
01:30:53,270 --> 01:30:54,740
你会错过其中一个输入。

1187
01:30:54,740 --> 01:30:56,365
你会把号码记错的。

1188
01:30:56,365 --> 01:30:57,080
这是一个错误。

1189
01:30:57,080 --> 01:31:04,050
那么，根据你们已经看到的，或者如果你们以前编制过程序（你们中的一些人已经编制过），有什么术语可以解决这个问题？

1190
01:31:04,050 --> 01:31:06,095
如何才能设计得更好？

1191
01:31:07,230 --> 01:31:08,563
大卫-J-马兰：我在这里听到的。

1192
01:31:08,563 --> 01:31:12,110
是的，所以一个循环 -- 一个循环，某种循环说，再来一次。

1193
01:31:12,110 --> 01:31:16,430
再做一次--不一定是无限次，但一定是有限次。

1194
01:31:16,430 --> 01:31:18,740
好吧，你也许可以在屏幕上看到一个扰流板。

1195
01:31:18,740 --> 01:31:22,760
在同一个橙色控制类别下有一个重复区块。

1196
01:31:22,760 --> 01:31:24,320
默认情况下，建议使用 10。

1197
01:31:24,320 --> 01:31:25,440
但我们可以改变这种状况。

1198
01:31:25,440 --> 01:31:26,280
那就让我来吧。

1199
01:31:26,280 --> 01:31:29,930
我打算把这些复制/粘贴的大部分内容当作多余的东西扔掉。

1200
01:31:29,930 --> 01:31:33,470
我要把这个暂时拆开，以便腾出地方放别的东西。

1201
01:31:33,470 --> 01:31:37,590
我要把一个 Repeat 块拖到这里，让它就位。

1202
01:31:37,590 --> 01:31:40,340
为了统一起见，我暂时把它改成 3。

1203
01:31:40,340 --> 01:31:44,660
这就是正确的形状，尽管它太小了，但 Scratch 会为我们满足这个要求。

1204
01:31:44,660 --> 01:31:50,370
而现在--同样的输出，但可以说设计得更好。

1205
01:31:50,870 --> 01:31:55,040
因为如果我想更改喵星人的数量，只需在一个地方进行更改即可，不会出现复制/粘贴的混乱情况。

1206
01:31:55,040 --> 01:31:56,867
如果我想改变等待时间，只需去一个地方。

1207
01:31:56,867 --> 01:31:59,450
我不必在多个地方进行更改，也不会搞砸。

1208
01:31:59,450 --> 01:32:00,920
所以，让我打绿旗吧。

1209
01:32:05,890 --> 01:32:06,940
好吧 很好

1210
01:32:06,940 --> 01:32:12,970
现在，如果麻省理工学院能给我们一个喵块，让我们自动完成所有这些工作，那该有多好。

1211
01:32:12,970 --> 01:32:15,910
我敢打赌，他们给了我们低层次的实施细节。

1212
01:32:15,910 --> 01:32:18,400
他们给了我们 Play Sound Meow。

1213
01:32:18,400 --> 01:32:23,120
但是，为了让一只猫一次又一次地 "喵喵喵 "叫，我不得不设置相当多的障碍。

1214
01:32:23,120 --> 01:32:26,350
我觉得我们应该从麻省理工学院免费得到这个。

1215
01:32:26,350 --> 01:32:30,100
其实，不一定只有他们发明了积木供我们使用。

1216
01:32:30,100 --> 01:32:33,920
您可以编写自己的函数、动词或动作。

1217
01:32:33,920 --> 01:32:35,180
那么，我们如何才能做到这一点呢？

1218
01:32:35,180 --> 01:32:42,650
让我们自己制作一个名为 "喵喵 "的拼图，它使用了这些代码，但创建的方式使它可以在其他地方重复使用。

1219
01:32:42,650 --> 01:32:43,420
那就让我来吧。

1220
01:32:43,420 --> 01:32:48,310
在粉红色的区块下，我要点击 "制作区块"。

1221
01:32:48,310 --> 01:32:51,100
现在，这里有一个接口，我可以通过它给程序块命名。

1222
01:32:51,100 --> 01:32:53,410
M-E-O-W 将是这个街区的名称。

1223
01:32:53,410 --> 01:32:55,810
我将继续快速点击 "确定"。

1224
01:32:55,810 --> 01:33:06,717
这只是给了我一个非常普通的、以 "定义 "开头的粉色拼图，因为 "划痕 "要求我定义，也就是为我实现或创建这个新拼图。

1225
01:33:06,717 --> 01:33:08,050
那么，这对喵星人来说意味着什么呢？

1226
01:33:08,050 --> 01:33:14,890
我想说的是，这两个步骤的意思是，播放喵喵声，然后等待 1 秒钟。

1227
01:33:14,890 --> 01:33:18,520
但这个想法的强大之处在于，看看上面这个。

1228
01:33:18,520 --> 01:33:21,970
现在我已经制作了一个区块，它就存在于 Scratch 中。

1229
01:33:21,970 --> 01:33:23,710
麻省理工学院不需要为我创造这些。

1230
01:33:23,710 --> 01:33:27,190
我创建它是为了我自己，甚至是你，如果我们最终共享代码的话。

1231
01:33:27,190 --> 01:33:30,320
现在我可以把喵喵拉上来了。

1232
01:33:30,320 --> 01:33:35,680
喵喵的优点在于，它本身是一个功能，但同时也是一个抽象概念。

1233
01:33:35,680 --> 01:33:42,340
比如，我甚至你们再也不需要担心或在意 "喵喵 "的含义，也不需要实施 "喵喵"。

1234
01:33:42,340 --> 01:33:43,930
我可以把它拖出来。

1235
01:33:43,930 --> 01:33:45,790
我没有删除它，而是把它拖走了。

1236
01:33:45,790 --> 01:33:46,970
眼不见，心不烦。

1237
01:33:47,470 --> 01:33:51,070
因为从某种意义上说，我的代码现在设计得更好了，因为它更具可读性。

1238
01:33:51,070 --> 01:33:51,910
它在做什么？

1239
01:33:51,910 --> 01:33:55,000
点击绿旗后，重复 3 次 "喵"。

1240
01:33:55,000 --> 01:33:56,305
它说什么就是什么。

1241
01:33:56,305 --> 01:34:03,040
这样阅读起来就容易多了，思考起来也容易多了，尤其是当你在其他项目中也使用喵星人的时候。

1242
01:34:03,040 --> 01:34:05,380
现在，让我继续点击 "播放"。

1243
01:34:06,280 --> 01:34:07,200
一样的。

1244
01:34:07,700 --> 01:34:09,282
因此，从根本上说并没有什么不同。

1245
01:34:09,830 --> 01:34:15,010
但我可以让这块定制拼图，也就是我自己的功能 "喵喵 "变得更加强大。

1246
01:34:15,010 --> 01:34:18,520
让我来倒带一下，看看我的 "喵喵拼图"。

1247
01:34:18,520 --> 01:34:21,658
我将按住 Control 键或右键单击我的粉色拼图。

1248
01:34:21,658 --> 01:34:22,700
我要编辑它。

1249
01:34:22,700 --> 01:34:25,210
所以我有点后悔把喵喵设计得这么简单。

1250
01:34:25,210 --> 01:34:31,960
如果喵喵能接受一个输入，也就是一个参数，告诉喵喵要喵喵叫多少次，那该有多好。

1251
01:34:31,960 --> 01:34:34,300
然后，我就可以去掉这个循环，直接告诉

1252
01:34:34,300 --> 01:34:36,530
喵喵喵，我到底想要多少喵喵喵。

1253
01:34:36,530 --> 01:34:40,390
因此，我要点击这里的另一个按钮，字面意思是 "添加输入"。

1254
01:34:40,390 --> 01:34:42,085
这里会有占位符。

1255
01:34:42,085 --> 01:34:43,960
所以我就在这里放一个占位符。

1256
01:34:43,960 --> 01:34:47,880
我一直用 "n "表示数字，这是计算机科学家的常用术语。

1257
01:34:47,880 --> 01:34:52,030
我还要添加一些描述性文字，这样就更一目了然了。

1258
01:34:52,030 --> 01:34:54,070
我只想说 Meow n Times。

1259
01:34:54,070 --> 01:34:55,510
但只有一个椭圆形。

1260
01:34:55,510 --> 01:34:57,700
时代》只是解释性文字。

1261
01:34:57,700 --> 01:34:59,290
现在请注意发生了什么。

1262
01:34:59,290 --> 01:35:06,580
现在，我的拼图需要一个输入，也就是一个参数，这个参数会告诉函数 "喵喵 "叫若干次。

1263
01:35:06,580 --> 01:35:08,440
但这并不只是神奇地起作用。

1264
01:35:08,440 --> 01:35:11,110
我需要实现较低级别的细节。

1265
01:35:11,110 --> 01:35:12,700
让我把镜头拉远。

1266
01:35:12,700 --> 01:35:14,918
我必须提醒自己这个功能是什么。

1267
01:35:14,918 --> 01:35:18,550
所以我要把它拖到更高的位置，让它们同时出现在屏幕上。

1268
01:35:18,550 --> 01:35:22,090
我现在要把它暂时移到这里。

1269
01:35:22,090 --> 01:35:24,190
我要把这个暂时拆开。

1270
01:35:24,700 --> 01:35:33,760
因为我想做的是将循环移到函数本身，将播放和等待移到循环中。

1271
01:35:33,760 --> 01:35:35,470
但我不想要硬编码 3。

1272
01:35:35,470 --> 01:35:41,390
注意，这里的 n 是它自己的椭圆形，我可以拖动 n 的副本，让它去那里。

1273
01:35:41,390 --> 01:35:48,170
现在，我有了一个新版本的 Meow，它接受一个参数 n，这个参数告诉 Meow 要喵喵叫多少次。

1274
01:35:48,170 --> 01:35:52,750
现在，让我再一次把这件事抛到脑后，因为谁会在意我是如何实施的呢？

1275
01:35:52,750 --> 01:35:54,880
一旦实施，就等于完成了。

1276
01:35:54,880 --> 01:35:58,070
从某种意义上说，现在我的程序设计得更好了。

1277
01:35:58,570 --> 01:36:01,120
因为现在它真的是言之有物了。

1278
01:36:01,120 --> 01:36:01,840
没有循环。

1279
01:36:01,840 --> 01:36:04,360
没有重复，没有实施细节。

1280
01:36:04,360 --> 01:36:07,060
点击绿旗时，喵喵叫 3 次。

1281
01:36:07,060 --> 01:36:13,070
因此，函数的确可以让你实现算法，就像它们只是为你做一些事情的代码。

1282
01:36:13,070 --> 01:36:14,930
但它们本身也是抽象的。

1283
01:36:15,430 --> 01:36:17,660
因为一旦函数存在，它就有了名字。

1284
01:36:17,660 --> 01:36:19,580
你可以从这个角度来考虑。

1285
01:36:19,580 --> 01:36:21,610
你还可以根据它的名字来使用它。

1286
01:36:21,610 --> 01:36:27,730
你不必关心或记住功能本身是如何建立的，无论它是由你还是麻省理工学院建立的。

1287
01:36:27,730 --> 01:36:29,480
在这里，我要再次点击 "绿旗"。

1288
01:36:29,480 --> 01:36:30,313
都是一样的。

1289
01:36:35,130 --> 01:36:38,250
所以还是正确的，但设计得更好、更完美。

1290
01:36:38,250 --> 01:36:42,271
因此，无论何时何地，都可以使用 Scratch，或者很快使用 C，最终使用 Python

1291
01:36:42,271 --> 01:36:49,370
当你发现自己在做任何类似于复制/粘贴的事情，或者一次又一次地抓取相同的代码时，你可能就有机会说，等一下。

1292
01:36:49,370 --> 01:36:59,580
让我来重构一下，也就是说，把那些看起来重复的代码删掉，把它放在自己的函数中，这样你就可以给它一个描述性的名字，并使用和重复使用它。

1293
01:36:59,580 --> 01:37:06,590
对于我们现在说的这些循环或函数，还有什么问题吗？

1294
01:37:09,883 --> 01:37:12,300
我是怎么让它喵喵叫三声的？

1295
01:37:12,300 --> 01:37:15,060
所以，我最初只有一块拼图，叫做 "喵喵"。

1296
01:37:15,060 --> 01:37:16,770
我决定改进它。

1297
01:37:16,770 --> 01:37:22,070
于是，我按住 Control 键，用鼠标右键或 Control 键点击左上角的粉红色拼图。

1298
01:37:22,070 --> 01:37:23,120
然后我点击了 "编辑"。

1299
01:37:23,120 --> 01:37:28,790
这让我又回到了最初的界面，可以为拼图本身添加一些参数。

1300
01:37:28,790 --> 01:37:31,250
然后我点击左侧的 "添加输入"。

1301
01:37:31,250 --> 01:37:34,260
然后点击这里的添加标签。

1302
01:37:34,260 --> 01:37:36,960
这样，你就可以进一步定制它了。

1303
01:37:36,960 --> 01:37:38,490
好吧，我们已经做到了。

1304
01:37:38,490 --> 01:37:41,900
让我们也添加一个其他的基元，来做一些可选择的事情。

1305
01:37:41,900 --> 01:37:50,540
那么，让猫咪只在人类抚摸它时才喵喵叫，就像人类抚摸猫咪那样移动鼠标悬停在猫咪上方，怎么样？

1306
01:37:50,540 --> 01:37:55,110
好吧，让我先把 "喵喵 "声扔掉吧。

1307
01:37:55,110 --> 01:37:57,083
让我用声音来简化一下。

1308
01:37:57,083 --> 01:37:58,500
我要继续这样做。

1309
01:37:58,500 --> 01:38:08,930
我将继续使用 "如果 "控制块，因为我想实现 "如果光标碰到猫，就播放喵喵声 "的想法。

1310
01:38:08,930 --> 01:38:10,710
或者，我也可以用我的那块粉色拼图。

1311
01:38:10,710 --> 01:38:14,150
但我现在要抛开这些，只关注声音。

1312
01:38:14,150 --> 01:38:15,840
我要这么做

1313
01:38:15,840 --> 01:38:19,598
如果触摸鼠标指针 -- 所以我需要感知世界的某些东西。

1314
01:38:19,598 --> 01:38:22,500
我们在前面已经看到了这一点，所以如果触摸鼠标指针。

1315
01:38:22,500 --> 01:38:24,810
注意这个形状，太大了。

1316
01:38:24,810 --> 01:38:25,920
但它的形状是正确的。

1317
01:38:25,920 --> 01:38:29,210
因此，如果我悬停得恰到好处，它就会卡住。

1318
01:38:29,210 --> 01:38:34,850
现在这个蓝色的是我的布尔表达式，一个是/否的问题，真假。

1319
01:38:34,850 --> 01:38:36,860
"如果 "是一个条件。

1320
01:38:36,860 --> 01:38:38,100
我想做什么？

1321
01:38:38,100 --> 01:38:42,290
如果猫在触摸鼠标指针的话、

1322
01:38:42,290 --> 01:38:44,970
我想继续播放声音喵，直到完成为止。

1323
01:38:44,970 --> 01:38:46,080
那就这么办吧。

1324
01:38:46,080 --> 01:38:48,808
我要点击绿旗，咔嚓。

1325
01:38:48,808 --> 01:38:51,350
现在什么都还没发生，因为这是一个条件，对吗？

1326
01:38:51,350 --> 01:38:53,808
只有在我摸猫的时候，它才会有反应。

1327
01:38:53,808 --> 01:38:55,550
让我把光标移到猫身上。

1328
01:38:55,550 --> 01:38:59,365
等等

1329
01:38:59,365 --> 01:39:02,330
嗯--又一个错误。

1330
01:39:02,330 --> 01:39:09,020
为什么我明明说了 "如果触摸鼠标指针，就喵喵叫"，猫却不喵喵叫呢？

1331
01:39:09,020 --> 01:39:10,295
是啊，在中间 -

1332
01:39:11,893 --> 01:39:15,440
我的电脑和你一样快得要命

1333
01:39:15,440 --> 01:39:18,650
我点击 "绿旗"，它会问我是否触碰到了鼠标指针？

1334
01:39:18,650 --> 01:39:21,350
嗯，没有，因为我的光标在上面，没碰到猫。

1335
01:39:21,350 --> 01:39:22,370
太迟了

1336
01:39:22,370 --> 01:39:23,570
猫已经出来了

1337
01:39:23,570 --> 01:39:28,490
因此，我们必须用其他方法来解决这个问题。

1338
01:39:28,490 --> 01:39:29,940
如何解决这个问题？

1339
01:39:29,940 --> 01:39:31,470
我们该如何解决这种比赛？

1340
01:39:32,690 --> 01:39:38,570
大卫-J-马兰：是啊，那我们为什么不继续问这个问题，直到我最终是否真的在抚摸那只猫呢？

1341
01:39:38,570 --> 01:39:40,610
所以，让我暂时脱离这个问题。

1342
01:39:40,610 --> 01:39:42,050
让我去控制室。

1343
01:39:42,050 --> 01:39:46,140
让我到下面去 -- 与其重复一些有限的次数，不如永远这样做。

1344
01:39:46,140 --> 01:39:49,070
所以，有时循环永远有效是件好事。

1345
01:39:49,070 --> 01:39:54,720
你手机上的时钟，永远在循环，因为你希望它永远显示时间，而不是在一天结束时停止。

1346
01:39:54,720 --> 01:39:58,913
因此，有时你确实希望代码永远循环下去，就像本例中一样。

1347
01:39:58,913 --> 01:40:00,830
所以，让我把它拖放到这里。

1348
01:40:00,830 --> 01:40:02,750
让我再次点击绿旗。

1349
01:40:02,750 --> 01:40:03,900
什么都还没发生。

1350
01:40:03,900 --> 01:40:06,300
但请注意，程序仍在运行。

1351
01:40:06,300 --> 01:40:10,700
因此，如果我移动光标，移动光标，移动光标，然后 --

1352
01:40:12,880 --> 01:40:14,550
好吧，也许我们可以增加一些 "等待"。

1353
01:40:14,550 --> 01:40:17,750
但在这种情况下，猫并不想被人宠爱。

1354
01:40:17,750 --> 01:40:20,220
但这确实是有条件的。

1355
01:40:20,220 --> 01:40:24,290
因此，我们在 Scratch 中看到了有条件地做某事的化身。

1356
01:40:24,290 --> 01:40:26,790
现在，我们可以让它变得非常酷、非常快，如果你愿意的话。

1357
01:40:26,790 --> 01:40:28,440
让我停止这个版本。

1358
01:40:28,440 --> 01:40:31,270
让我来吧。

1359
01:40:31,270 --> 01:40:33,270
让我把这些都扔掉吧。

1360
01:40:33,270 --> 01:40:36,210
让我进入我的小扩展桶。

1361
01:40:36,210 --> 01:40:40,620
让我来做视频感应，因为现在大多数笔记本电脑或手机都有摄像头。

1362
01:40:40,620 --> 01:40:44,190
我确实在那里，桑德斯就在我身后。

1363
01:40:44,190 --> 01:40:45,780
让我来吧

1364
01:40:45,780 --> 01:40:48,900
当 "视频动态"-- 让我闪开。

1365
01:40:48,900 --> 01:40:51,820
当视频动态大于某个值时。

1366
01:40:51,820 --> 01:40:56,670
因此 10 是默认值。这只是一个衡量运动量大小的数字。

1367
01:40:56,670 --> 01:40:58,290
所以，数字小就等于没有运动。

1368
01:40:58,290 --> 01:40:59,920
大数字就是大动作。

1369
01:40:59,920 --> 01:41:03,120
所以我选择 50，有点随意，就 50 吧。

1370
01:41:03,120 --> 01:41:05,370
在一旁编程是不正常的。

1371
01:41:05,370 --> 01:41:08,130
但我现在要说的是

1372
01:41:08,130 --> 01:41:14,460
当 "视频动态 "为 50 时，像这样播放 "声音喵"。

1373
01:41:14,460 --> 01:41:16,170
所以，这只猫还在那个世界里。

1374
01:41:16,170 --> 01:41:18,970
我要停止程序并重新运行。

1375
01:41:18,970 --> 01:41:21,090
我们开始吧，绿旗。

1376
01:41:21,090 --> 01:41:30,640
现在来了 -- 好吧，这有点吓人， 我抚摸猫的方式，但是 -- 而且 -- [叹气]

1377
01:41:35,750 --> 01:41:36,290
好了

1378
01:41:36,290 --> 01:41:37,910
好吧，50 这个数字太大了。

1379
01:41:37,910 --> 01:41:39,500
我得快点抚摸猫咪。

1380
01:41:42,900 --> 01:41:44,940
鉴于此，如果

1381
01:41:44,940 --> 01:41:46,410
我不知道

1382
01:41:50,710 --> 01:41:55,410
好了，只要把不同的拼图拼在一起，就能让事情变得更加互动。

1383
01:41:55,410 --> 01:41:58,050
老实说，这里有很多不同的拼图。

1384
01:41:58,050 --> 01:42:00,610
我们甚至不会对其中的很多内容浅尝辄止。

1385
01:42:00,610 --> 01:42:02,940
但他们一般都是说到做到。

1386
01:42:02,940 --> 01:42:12,970
事实上，当你在屏幕上看到这些拼图时，很多编程工作，尤其是在学习一门语言的初期，都是在尝试不同的东西，不断尝试，不断失败。

1387
01:42:12,970 --> 01:42:20,000
如果效果不佳，也可以寻找其他解决方案，就像我刚才不得不做的那样。

1388
01:42:20,000 --> 01:42:24,720
好吧，让我们继续用，实际上，用你的前任做的另一个例子怎么样？

1389
01:42:24,720 --> 01:42:28,830
让我在这里提前打开一个程序，名为

1390
01:42:28,830 --> 01:42:38,895
捶打鼹鼠 我们能否请一位勇敢的志愿者上台，愿意用头捶打鼹鼠？

1391
01:42:38,895 --> 01:42:40,770
好吧，我想想，在后面怎么样？

1392
01:42:40,770 --> 01:42:42,300
你想下来吗？

1393
01:42:42,300 --> 01:42:45,327
好了，下来吧

1394
01:42:45,327 --> 01:42:47,160
当然，掌声送给我们的志愿者。

1395
01:42:52,130 --> 01:43:01,178
好了 我们到了 下来吧

1396
01:43:01,178 --> 01:43:01,970
大家好

1397
01:43:01,970 --> 01:43:02,720
你叫什么名字？

1398
01:43:02,720 --> 01:43:03,320
我是乔希

1399
01:43:03,320 --> 01:43:05,695
大卫-J-马兰：哦，实际上，对着麦克风说吧。

1400
01:43:05,695 --> 01:43:06,950
嗨，我是乔希。

1401
01:43:06,950 --> 01:43:07,670
好的，很好。

1402
01:43:07,670 --> 01:43:08,240
欢迎，乔希。

1403
01:43:08,240 --> 01:43:08,782
过来吧

1404
01:43:10,850 --> 01:43:12,892
好吧，所以同样的想法在这里 -

1405
01:43:12,892 --> 01:43:13,850
我把麦克风拿回去

1406
01:43:13,850 --> 01:43:15,230
你必须站在镜头前。

1407
01:43:15,230 --> 01:43:20,150
一会儿，你就得把头放进你过去的同学制作的盒子里。

1408
01:43:22,840 --> 01:43:24,490
我们从初级开始。

1409
01:43:24,490 --> 01:43:25,180
AUDIENCE：OK.

1410
01:43:25,180 --> 01:43:28,166
马兰: 请把你的头放在盒子里。

1411
01:43:28,166 --> 01:43:29,142
好的好的

1412
01:43:43,800 --> 01:43:45,390
很好。

1413
01:43:45,390 --> 01:43:46,155
12 秒

1414
01:43:53,790 --> 01:43:55,710
注意分数已经达到 18 分了。

1415
01:43:55,710 --> 01:43:58,410
相当不错。

1416
01:43:58,410 --> 01:44:00,990
好吧，如果可以的话，请为乔希鼓掌。

1417
01:44:06,380 --> 01:44:11,330
请注意，使用一些相当简单的基元，事情很快就变得有趣起来。

1418
01:44:11,330 --> 01:44:12,560
是如何实施的？

1419
01:44:12,560 --> 01:44:14,560
嗯，可能至少有四个精灵。

1420
01:44:14,560 --> 01:44:16,222
所以，你并不局限于一只猫。

1421
01:44:16,222 --> 01:44:18,930
你可以创建越来越多的精灵，改变它们的外观。

1422
01:44:18,930 --> 01:44:20,930
因此，在这种情况下，它们实际上看起来就像一颗颗痣。

1423
01:44:20,930 --> 01:44:23,990
其中可能包含一些条件，一些持续 30 秒的循环。

1424
01:44:23,990 --> 01:44:31,550
这就是检查乔希的头部移动是否超过了某个值，或者超过了这个值，然后递增一个叫做变量的东西。

1425
01:44:31,550 --> 01:44:32,450
我们也会看到的。

1426
01:44:32,450 --> 01:44:42,350
就像代数中的 x、y 和 z，可以像数字一样存储数值，计算机程序也可以有名为 x 或 y 或 z 的变量，或者更直观地称为 Score、

1427
01:44:42,350 --> 01:44:49,632
或另一个名为 Countdown 的变量，在代码中通常是一个单词，但在本例中是两个单词，只是存储一些值。

1428
01:44:49,632 --> 01:44:54,604
因此，这里可能有一些数学运算，程序的编写者只是在递增

1429
01:44:54,604 --> 01:45:00,570
也就是说，每次检测到 "鼹鼠 "被 "捶打"（在这里是 "移动"）时，都会加上 1 和 1。

1430
01:45:00,570 --> 01:45:07,562
我自己在麻省理工学院读研究生时，就用 Scratch 实现了我的第一个程序。

1431
01:45:07,562 --> 01:45:15,500
他在麻省理工学院交叉注册，选修了麻省理工学院媒体实验室的课程，特别是终身幼儿园小组的课程，该小组本身就是 Scratch 的创建者。

1432
01:45:15,500 --> 01:45:27,120
我多年前编写的、至今仍念念不忘的程序是一个名为《奥斯卡时间》（Oscartime）的小玩意儿，我想在这里为自己播放一段简短的片段。

1433
01:45:27,120 --> 01:45:38,060
因此，在这种情况下，当音乐开始播放时，请考虑一下这个程序是如何实现的，当然，这个程序要比我们刚才做的最早的 "Say hello "示例复杂得多。

1434
01:45:38,060 --> 01:45:40,745
现在让我点击 "绿旗"。

1435
01:45:44,950 --> 01:45:46,973
鸟人奥斯卡：（唱）哦，我爱垃圾。

1436
01:45:46,973 --> 01:45:51,970
马兰：好的，一些垃圾正在移动，大概是从顶部循环移动的。

1437
01:45:51,970 --> 01:45:56,440
如果我触摸鼠标光标，它就会跟着我。

1438
01:45:56,440 --> 01:45:59,920
如果我将鼠标悬停在垃圾桶上，它就会做出反应。

1439
01:45:59,920 --> 01:46:06,910
如果我松开手，奥斯卡就会跳出来，用当前分数创建一个变量。

1440
01:46:06,910 --> 01:46:07,900
这种情况再次发生。

1441
01:46:07,900 --> 01:46:09,983
鸟人奥斯卡：（唱）洞洞真可怕。

1442
01:46:09,983 --> 01:46:11,950
鞋带也破了。

1443
01:46:11,950 --> 01:46:16,030
这是我出生那天母亲送给我的礼物。

1444
01:46:16,030 --> 01:46:20,050
我喜欢它，因为它是垃圾。

1445
01:46:21,070 --> 01:46:24,050
一开始很容易，但是 --

1446
01:46:24,050 --> 01:46:26,410
奥斯卡：（唱）--任何肮脏或邋遢的东西--

1447
01:46:26,410 --> 01:46:30,230
所以我不需要一直在舞台上当着所有人的面演奏这个。

1448
01:46:30,230 --> 01:46:32,950
因此，我的分数现在已经达到了 6 分左右。

1449
01:46:32,950 --> 01:46:35,900
但稍后，你也会看到，事态会升级。

1450
01:46:35,900 --> 01:46:38,080
所以我显然考虑到了时间问题。

1451
01:46:38,980 --> 01:46:42,343
鸟人奥斯卡：（唱）我这里有一些报纸，13 个月前的。

1452
01:46:42,343 --> 01:46:45,010
大卫-J-马兰：所以越来越多的精灵突然出现了。

1453
01:46:45,010 --> 01:46:48,040
注意，每次它们都是从屏幕的不同部分出现的。

1454
01:46:48,040 --> 01:46:52,270
这也许也是一种幻觉 -- 在 x 和 y 之间随便选一个数字。

1455
01:46:52,270 --> 01:46:56,032
因此，您实际上可以选择一些数值范围，让游戏不断变化。

1456
01:46:56,032 --> 01:47:00,860
事实上，我要继续点击 "停止"，因为几年前我花了差不多八个多小时来制作这个。

1457
01:47:00,860 --> 01:47:04,810
我再也不能听这首歌了，反正我现在也不应该听。

1458
01:47:04,810 --> 01:47:09,670
但这首歌与正在发生的许多行动是同步的。

1459
01:47:09,670 --> 01:47:12,130
归根结底，这些都是积木。

1460
01:47:12,130 --> 01:47:15,610
但我并没有坐下来立即实施我所说的 "Oscartime"。

1461
01:47:15,610 --> 01:47:17,500
可以说，我真的是一步步走过来的。

1462
01:47:17,500 --> 01:47:24,220
然后我就想，好吧，我该如何分解我当时的愿景，最终创造出这款游戏呢？

1463
01:47:24,220 --> 01:47:26,470
我该如何先咬掉最容易的部分？

1464
01:47:26,470 --> 01:47:31,120
老实说，我做的第一件事 就是找到了这张图片 然后把它拖进了Scratch --

1465
01:47:31,120 --> 01:47:33,580
好了，搞定--比如，灯柱安装完毕。

1466
01:47:33,580 --> 01:47:34,575
它什么也做不了。

1467
01:47:34,575 --> 01:47:35,450
这不是互动的。

1468
01:47:35,450 --> 01:47:37,995
但我至少为这个节目做了铺垫。

1469
01:47:37,995 --> 01:47:39,370
那我还能做什么？

1470
01:47:39,370 --> 01:47:40,640
让我来吧

1471
01:47:40,640 --> 01:47:48,980
请允许我在另一个编辑器中打开 Oscartime 的早期版本。

1472
01:47:48,980 --> 01:47:51,220
让我进入奥斯卡时间。

1473
01:47:51,220 --> 01:47:52,510
让我全屏显示。

1474
01:47:52,510 --> 01:47:59,687
这就是--让我先把垃圾藏起来--我可以称之为我的程序的第二个版本

1475
01:47:59,687 --> 01:48:06,267
其中，在舞台的右上方，我有一个灯柱，我只是拖放了一下就开始了，但随后我又添加了一个实际的精灵。

1476
01:48:06,267 --> 01:48:09,100
如果你想让它进行交互式操作，它就必须是一个精灵。

1477
01:48:09,100 --> 01:48:10,420
灯柱 不是精灵

1478
01:48:10,420 --> 01:48:14,680
如果你愿意，这只是整个舞台本身的一个形象，一套服装，一个背景。

1479
01:48:14,680 --> 01:48:20,240
但这个东西确实是一个精灵，因为它需要对代码和事件（如拖放）做出响应。

1480
01:48:20,240 --> 01:48:23,960
那么，我早期可能会用这些代码做些什么呢？

1481
01:48:23,960 --> 01:48:32,170
好吧，也许第一个版本会是这样的，而我的第一个版本的《奥斯卡时间》可能是这样的：哦，这个。

1482
01:48:32,170 --> 01:48:35,500
不如，让我像以前一样控制程序，或者说，控制事件。

1483
01:48:35,500 --> 01:48:38,630
点击 "绿旗 "后，我想做什么？

1484
01:48:38,630 --> 01:48:43,600
好吧，我想永远这样做下去。

1485
01:48:43,600 --> 01:48:46,687
所以我希望一碰盖子，盖子就会打开。

1486
01:48:46,687 --> 01:48:49,270
因此，如果光标靠近盖子，我就想让盖子打开。

1487
01:48:49,270 --> 01:48:51,340
如果我搬走了，我希望它能关闭。

1488
01:48:51,340 --> 01:48:52,640
那我该怎么做呢？

1489
01:48:52,640 --> 01:48:59,200
我想要一个 "如果"，但我只是不想要一个问题，我真的想要两个问题，可以说是一个向左或向右的岔路口。

1490
01:48:59,200 --> 01:49:02,830
让我像很久以前一样，抓住这块拼图。

1491
01:49:02,830 --> 01:49:04,690
因此，请注意，它是为了填充而生长的。

1492
01:49:04,690 --> 01:49:06,430
我想问什么问题？

1493
01:49:06,430 --> 01:49:13,863
那么，在 "感应 "功能下，我想说，如果这个垃圾桶正在触碰鼠标指针，我该怎么办？

1494
01:49:13,863 --> 01:49:16,030
我想改变垃圾桶的样子。

1495
01:49:16,030 --> 01:49:17,740
而这部分，我在课前就做了。

1496
01:49:17,740 --> 01:49:21,040
如果你进入 "服装 "页面，所有的图形都会在这里出现。

1497
01:49:21,040 --> 01:49:31,423
你会看到我导入了一大堆不同的服装，当你快速播放这些服装时，它们就像视频一样，能有效地营造出运动的错觉和一些动画效果。

1498
01:49:31,423 --> 01:49:35,320
但实际上，屏幕上显示的只是点、点、点、点、点--不同的图像。

1499
01:49:35,320 --> 01:49:39,250
其中一些服装被称为奥斯卡 1 号、奥斯卡 2 号。

1500
01:49:39,250 --> 01:49:40,810
Oscar1 已关闭。

1501
01:49:40,810 --> 01:49:42,070
奥斯卡 2 开幕。

1502
01:49:42,070 --> 01:49:43,730
所以，我们还是先解决这些问题吧。

1503
01:49:43,730 --> 01:49:48,100
所以，如果我正在触摸鼠标指针，让我到下面--"外观 "怎么样？

1504
01:49:48,100 --> 01:49:50,680
我们以前没有用过这个，但有这么一块、

1505
01:49:50,680 --> 01:49:52,870
把服装换成别的

1506
01:49:52,870 --> 01:49:55,150
我要把这个拖放到 If 中。

1507
01:49:55,150 --> 01:49:57,070
注意它有一点缩进。

1508
01:49:57,070 --> 01:50:00,730
我要把它改成 Oscar2，而不是 Oscar8。

1509
01:50:00,730 --> 01:50:10,840
否则，如果不触碰鼠标指针--这是岔路口的另一个方向--让我们继续前进，把服装换回我描述的 Oscar1。

1510
01:50:10,840 --> 01:50:12,400
让我来运行这个程序。

1511
01:50:12,400 --> 01:50:14,900
但目前还没有什么值得关注的事情发生。

1512
01:50:14,900 --> 01:50:20,030
但请注意，如果我将光标向上、向下移动--但这是怎么做到的呢？

1513
01:50:20,030 --> 01:50:22,940
这只是在改变叠加在精灵上的服装。

1514
01:50:22,940 --> 01:50:25,998
因此，这看起来像是互动，但实际上你只是在改变美学。

1515
01:50:25,998 --> 01:50:29,135
而我们人类只是假设，哦，它正在打开。

1516
01:50:29,135 --> 01:50:30,760
不，只是换一套服装。

1517
01:50:30,760 --> 01:50:31,802
这就是区别所在。

1518
01:50:31,802 --> 01:50:34,210
高级抽象--打开垃圾桶。

1519
01:50:34,210 --> 01:50:38,500
较低层次的实施细节--换装，制造幻觉。

1520
01:50:38,500 --> 01:50:46,130
如果我想让它看起来更漂亮，我可以穿上很多其他的服装，然后 "嘣、嘣、嘣、嘣"，这样就能创造出更多的每秒帧数。

1521
01:50:46,130 --> 01:50:48,820
所以我还需要做一件事。

1522
01:50:48,820 --> 01:50:52,750
也许我不小心把垃圾桶打开了，让我在这里做一个改变。

1523
01:50:52,750 --> 01:50:54,730
让我确保第一件事

1524
01:50:54,730 --> 01:51:01,810
当点击绿旗时，我总是先关闭垃圾桶，因为否则你可能会不小心把它打开。

1525
01:51:01,810 --> 01:51:03,590
这样，我就进入了某种默认状态。

1526
01:51:03,590 --> 01:51:08,133
因此，现在它总是关闭着，直到我手动将鼠标悬停在它上面。

1527
01:51:08,133 --> 01:51:09,550
那么，接下来我会怎么做呢？

1528
01:51:09,550 --> 01:51:13,587
好吧，如果我想引入垃圾之类的东西，我需要第二个精灵。

1529
01:51:13,587 --> 01:51:15,670
在这里，我已经提前抓取了图片。

1530
01:51:15,670 --> 01:51:18,310
让我假装这一切从未发生过。

1531
01:51:18,310 --> 01:51:20,260
让我把这个拖走。

1532
01:51:20,260 --> 01:51:24,033
现在，我的代码区里没有任何东西可以用来装这个垃圾。

1533
01:51:24,033 --> 01:51:25,200
但这是第二个精灵。

1534
01:51:25,200 --> 01:51:29,190
我所做的就是点击这里的小猫加号图标，创建第二个精灵。

1535
01:51:29,190 --> 01:51:30,330
我把它命名为垃圾。

1536
01:51:30,330 --> 01:51:32,250
我为它添加了一套服装。

1537
01:51:32,250 --> 01:51:34,170
我提前做了一些美学方面的工作。

1538
01:51:34,170 --> 01:51:36,360
但我现在要做的是代码。

1539
01:51:36,360 --> 01:51:37,720
我想怎么做？

1540
01:51:37,720 --> 01:51:42,160
那么，点击 "绿旗 "后，垃圾桶就会出现、

1541
01:51:42,160 --> 01:51:45,090
我想让垃圾桶并行 --

1542
01:51:45,090 --> 01:51:48,190
我想让垃圾，让垃圾做自己的事。

1543
01:51:48,190 --> 01:51:52,500
所以，我想让它做的是，让我们来做运动，怎么样？

1544
01:51:52,500 --> 01:51:54,240
让我们来看一个具体的坐标。

1545
01:51:54,240 --> 01:51:55,750
现在，这里有很多选择。

1546
01:51:55,750 --> 01:52:01,740
还有 "转弯"、"转到随机位置"、"转到 x,y"、"滑行 "等更优雅的功能。

1547
01:52:01,740 --> 01:52:03,990
有很多不同的方法来实现运动。

1548
01:52:03,990 --> 01:52:06,310
我只是想让它先到达一个非常具体的位置。

1549
01:52:06,310 --> 01:52:09,000
所以我打算先去 x,y 处。

1550
01:52:09,000 --> 01:52:14,470
我想说的是，X，怎么样，会是--让我们不要硬编码。

1551
01:52:14,470 --> 01:52:18,120
好吧，那就从 0 开始，然后是 240。

1552
01:52:18,120 --> 01:52:23,410
所以--哎呀--还是 0,240 吧，这样这块垃圾就总是从屏幕的中上部开始。

1553
01:52:23,410 --> 01:52:26,160
如果你回想一下那个坐标系，0,0 就在中间。

1554
01:52:26,160 --> 01:52:28,230
240 在其正上方。

1555
01:52:28,230 --> 01:52:31,150
好了，现在，在我做完这些之后，我想做什么？

1556
01:52:31,150 --> 01:52:34,980
那我就用永远坠落来控制它吧。

1557
01:52:34,980 --> 01:52:36,427
现在，我该如何让垃圾移动呢？

1558
01:52:36,427 --> 01:52:38,010
我们还没有看到这块拼图。

1559
01:52:38,010 --> 01:52:42,390
但在 "运动 "中，第一件事叫做 "移动一定步数"。

1560
01:52:42,390 --> 01:52:43,380
默认为 10。

1561
01:52:43,380 --> 01:52:44,880
但我们会做得更简单。

1562
01:52:44,880 --> 01:52:48,660
让我继续前进 - 哦，对不起。

1563
01:52:48,660 --> 01:52:52,350
移动 "会将它朝任何方向移动。

1564
01:52:52,350 --> 01:52:53,753
我只想让它向下移动。

1565
01:52:53,753 --> 01:52:57,540
在这里，连我自己都搞不清楚到底有多少种不同的方法。

1566
01:52:57,540 --> 01:52:59,680
我想做的事情是这样的

1567
01:52:59,680 --> 01:53:03,670
让我只对 Y 轴做如下改动。

1568
01:53:03,670 --> 01:53:06,060
这里还有一块拼图，叫做 "变化 y"。

1569
01:53:06,060 --> 01:53:07,680
因此，y 还是垂直方向。

1570
01:53:07,680 --> 01:53:14,170
因此，让我每次向下改变一个像素，所以每次-1 一个像素。

1571
01:53:14,170 --> 01:53:15,540
所以有点慢。

1572
01:53:15,540 --> 01:53:17,010
我想现在 --

1573
01:53:17,010 --> 01:53:17,890
我想就是这样了。

1574
01:53:17,890 --> 01:53:18,990
让我按 "停止 "键。

1575
01:53:18,990 --> 01:53:21,700
请注意，我的垃圾桶仍将是互动的。

1576
01:53:21,700 --> 01:53:23,370
我没有更改或删除该代码。

1577
01:53:23,370 --> 01:53:26,850
我刚刚为我的垃圾添加了代码。

1578
01:53:26,850 --> 01:53:32,920
如果我点击 "绿旗"，请注意 -- 在我启用它之后 -- 让我重新开始。

1579
01:53:32,920 --> 01:53:34,320
我把它藏在课前。

1580
01:53:34,320 --> 01:53:35,403
但现在让我来启用它 --

1581
01:53:35,403 --> 01:53:42,750
绿旗，注意它是从中心点开始的，X 等于 0，Y 等于 240，每次下降一个像素。

1582
01:53:42,750 --> 01:53:47,530
如果这看起来有点无聊，我们可以把它改成每次 -10 像素，然后，"砰 "的一声，它就完成了。

1583
01:53:47,530 --> 01:53:49,780
这就是改变程序速度的方法。

1584
01:53:49,780 --> 01:53:51,750
但我还是想把它简化为-1。

1585
01:53:51,750 --> 01:53:54,708
老实说，如果不总是从头开始，那就更好了。

1586
01:53:54,708 --> 01:53:57,083
否则，这个游戏的互动性就不会很强。

1587
01:53:57,083 --> 01:54:00,580
我简直每次都要从同一个地方抓垃圾。

1588
01:54:00,580 --> 01:54:03,250
那我为什么不这样做呢？

1589
01:54:03,250 --> 01:54:06,550
让我在 "操作员 "下随机选取一个数字。

1590
01:54:06,550 --> 01:54:12,437
因此，让我改变硬编码--手动输入的--0，让 x 介于 0 之间

1591
01:54:12,437 --> 01:54:20,970
所以从中间一直到 - - 是什么 - - 哦，我把数字弄错了 - - 240，我的Y将是180。

1592
01:54:20,970 --> 01:54:23,560
对不起，我把 x 和 y 搞混了。

1593
01:54:23,560 --> 01:54:25,420
让我再演一遍。

1594
01:54:25,420 --> 01:54:30,978
而现在，我们的游戏更像你成长过程中甚至现在玩过的游戏，有一些随机性。

1595
01:54:30,978 --> 01:54:33,660
可以说，CPU 正在做一些更有趣的事情。

1596
01:54:33,660 --> 01:54:34,570
让我再跑一遍。

1597
01:54:34,570 --> 01:54:35,820
现在向左一点。

1598
01:54:35,820 --> 01:54:36,600
让我再跑一遍。

1599
01:54:36,600 --> 01:54:38,058
现在又往左移了一点。

1600
01:54:38,058 --> 01:54:39,630
现在又回到右边了。

1601
01:54:39,630 --> 01:54:41,640
因此，随机性只会让游戏更有趣。

1602
01:54:41,640 --> 01:54:46,172
这就是为什么当你玩任何电子游戏时，如果有不同的事情发生，很可能就是随机的。

1603
01:54:46,172 --> 01:54:48,360
它被量化为一个简单的数字。

1604
01:54:48,360 --> 01:54:52,050
现在，如果可以的话，我想我只需要在这里做最后的铺垫。

1605
01:54:52,050 --> 01:54:54,060
让我来补充一下。

1606
01:54:54,060 --> 01:54:58,380
那 "活动 "呢？ 或者说，是的，"活动"。

1607
01:54:58,380 --> 01:55:02,700
当点击 "绿旗 "时，我可以在同一个精灵中执行多项操作。

1608
01:55:02,700 --> 01:55:05,190
它们不一定都要连接到同一个设备上。

1609
01:55:05,190 --> 01:55:10,110
让我继续，永远继续做别的事情。

1610
01:55:10,110 --> 01:55:20,850
那 "每当垃圾......触碰垃圾桶......就...... "怎么样？

1611
01:55:20,850 --> 01:55:28,530
那么，"触摸 "怎么样？ 这次不是 "鼠标指针"，而是 "触摸奥斯卡本人"。

1612
01:55:28,530 --> 01:55:30,810
现在让我们看看会发生什么。

1613
01:55:30,810 --> 01:55:33,750
好了，让我们点击 "绿旗"。

1614
01:55:33,750 --> 01:55:37,560
现在，我从这里下去，然后放手。

1615
01:55:37,560 --> 01:55:41,340
好吧，我有点想把它扔进垃圾桶。

1616
01:55:41,340 --> 01:55:43,620
怎样才能把它扔进垃圾桶？

1617
01:55:43,620 --> 01:55:49,950
我们怎样才能把这个高层次的想法，扔进垃圾桶，让它看起来消失不见呢？

1618
01:55:49,950 --> 01:55:51,520
从逻辑上讲，我们能做什么呢？

1619
01:55:53,245 --> 01:55:56,037
大卫-J-马兰：好吧，那么当它碰到它的时候，让它消失。

1620
01:55:56,037 --> 01:55:56,910
这样我就可以把它藏起来。

1621
01:55:56,910 --> 01:56:04,380
或者老实说，如果游戏要持续下去，就像以前那样，让我扔下越来越多的垃圾，那就让我让它继续随机选择一个新的地点吧。

1622
01:56:04,380 --> 01:56:05,560
那就让我来吧。

1623
01:56:05,560 --> 01:56:09,073
让我继续复制这块拼图，然后复制。

1624
01:56:09,073 --> 01:56:10,740
我不想要整件事情，对不起。

1625
01:56:10,740 --> 01:56:12,400
让我把这个扔掉。

1626
01:56:12,400 --> 01:56:13,540
让我这么做吧。

1627
01:56:13,540 --> 01:56:16,720
让我回到顶部的某个随机位置。

1628
01:56:16,720 --> 01:56:17,940
现在请注意发生了什么。

1629
01:56:17,940 --> 01:56:26,318
如果我点击并拖动它--它就在这里--然后松手，它看起来就像要被扔进垃圾桶，因为它又会随意地弹回到某个位置。

1630
01:56:26,318 --> 01:56:29,610
现在，我唯一没有做的事情就是记分。

1631
01:56:29,610 --> 01:56:33,940
事实证明，如果我全屏显示，默认情况下它是不可拖动的。

1632
01:56:33,940 --> 01:56:45,960
可以说，这只是一个小插曲，否则你可能会被绊倒，让我继续，让我们看看，"感知"，原来我还需要这个垃圾桶。

1633
01:56:45,960 --> 01:56:51,540
在 Scratch 中，有一种设置精灵可拖动或不可拖动的方法。

1634
01:56:51,540 --> 01:57:00,240
我需要明确规定它是可拖动的，这样当我现在全屏显示这个东西时，它仍然是可拖动的，像我这样的人可以反复播放。

1635
01:57:00,240 --> 01:57:03,120
那么，我们最后再锦上添花一下如何？

1636
01:57:03,120 --> 01:57:06,010
为什么我们现在不记录用户得分？

1637
01:57:06,010 --> 01:57:16,590
那么，当用户真的把垃圾拖到垃圾桶时，让我在这里的 "变量 "下，提前创建一个名为 "分数 "的变量。

1638
01:57:16,590 --> 01:57:20,100
我本可以把它叫做 x、y、z 或 ABC，但这样就不太好描述了。

1639
01:57:20,100 --> 01:57:24,450
在编程过程中，你通常会给事物起一个更具描述性的英文或其他语言名称。

1640
01:57:24,450 --> 01:57:26,200
因此，我把这一次称为 "得分"。

1641
01:57:26,200 --> 01:57:28,710
那么，在我的 "记分 "中，我该如何做到这一点呢？

1642
01:57:28,710 --> 01:57:37,470
好吧，让我继续前进，在这些脚本的最顶端将游戏分数设置为 0 -- 这里的其中一个程序。

1643
01:57:37,470 --> 01:57:42,570
每当我的垃圾被碰触时

1644
01:57:42,570 --> 01:57:49,630
奥斯卡，我们不要直接跳到最上面，让我们在这里把比分改成 1。

1645
01:57:49,630 --> 01:57:52,680
现在请注意，"如果感动奥斯卡，请改变比分"，就是这个意思、

1646
01:57:52,680 --> 01:57:55,920
在分数上加 1，然后选择一个新的随机位置。

1647
01:57:55,920 --> 01:57:59,520
现在是 "绿旗" 我们慢慢来

1648
01:57:59,520 --> 01:58:00,540
开始了

1649
01:58:00,540 --> 01:58:01,590
垃圾桶打开了。

1650
01:58:02,520 --> 01:58:06,660
现在请注意，在我程序的左上角，分数现在是 2。

1651
01:58:06,660 --> 01:58:10,140
注意，如果我再做一次，分数就要变成 3 了。

1652
01:58:10,140 --> 01:58:15,910
因此，我们有了让这个项目越来越好的基石。

1653
01:58:15,910 --> 01:58:22,530
因此，不管是用 Scratch、C、Python 还是其他语言，用代码解决任何问题时，一般都会采用这种方法。

1654
01:58:22,530 --> 01:58:31,530
你要把自己的愿景或家庭作业中布置给你的愿景分解成不同的部分，先把容易的部分摘下来。

1655
01:58:31,530 --> 01:58:34,980
先把灯柱放在那里，至少会让人觉得你取得了一些进展。

1656
01:58:34,980 --> 01:58:38,457
然后摘下垃圾桶之类的东西，让它做一件小事。

1657
01:58:38,457 --> 01:58:40,540
在这里，顺序不一定要相同。

1658
01:58:40,540 --> 01:58:42,750
我可以用无数种不同的方式来做这件事。

1659
01:58:42,750 --> 01:58:52,380
但要想清楚，这些小碎片最终会像我们今天解决的几个问题一样，组合成一个更大的解决方案。

1660
01:58:52,380 --> 01:58:58,470
现在，你已经有了关于这些类型的障碍和其他障碍的心理模型，让我们回到这个问题上来。

1661
01:58:58,470 --> 01:59:06,670
刚才我们看到，当我开始说 "你好，戴维"，并把这些拼图嵌套起来时，我们就有了一个完全不同的范式。

1662
01:59:06,670 --> 01:59:15,000
我对第二个版本的 "你好，世界 "的输入是，例如，将 "你叫什么名字？"传入我的函数 Ask。

1663
01:59:15,000 --> 01:59:21,690
这给我带来的不是副作用，而是我称之为返回值的东西，在 Scratch 中默认称为 "答案"。

1664
01:59:21,690 --> 01:59:31,260
现在请注意并回想一下，当我把同样的输出变为下一个程序块的输入时，它看起来是这样的--

1665
01:59:32,100 --> 01:59:37,710
那么，这种积木和积木的嵌套、堆叠，又是如何融入同一个心理模型的呢？

1666
01:59:37,710 --> 01:59:47,190
好吧，同样的想法--我对这部分故事的输入现在不是一个输入，而是两个--两个参数--"你好 "和之前的答案。

1667
01:59:47,190 --> 01:59:50,010
在这种情况下，该功能就是那个名为 Join 的新块。

1668
01:59:50,010 --> 02:00:00,840
它的输出是 "你好，戴维"，如果我们把它做成动画，它本身就成了我的最终函数的输入，而我的最终函数仍然是 Say。

1669
02:00:00,840 --> 02:00:06,729
这只是说--没有双关语的意思--你用这些拼图所做的几乎所有事情

1670
02:00:06,729 --> 02:00:16,320
无论是在《奥斯卡时间》的背景下，还是在 "鼹鼠捶 "的背景下，甚至只是像 "你好，世界 "这样简单的一句话，最终都会融入那个相对简单的心智模型中。

1671
02:00:16,320 --> 02:00:20,220
现在，我想我们最后再看几个例子。

1672
02:00:20,220 --> 02:00:22,950
这些也是您的一些前辈制作的。

1673
02:00:22,950 --> 02:00:27,760
为此，我想我们不要一起写代码，而是读代码。

1674
02:00:27,760 --> 02:00:36,720
请允许我在这里打开另一个例子，向我们展示前人制作的程序的几个不同版本。

1675
02:00:36,720 --> 02:00:38,340
给我一点时间

1676
02:00:38,340 --> 02:00:42,960
我们将看看如何建立更强的互动性。

1677
02:00:42,960 --> 02:00:51,090
稍后，我们将看到他们称之为 "常春藤最难游戏 "的东西，重点是这些特殊的机制。

1678
02:00:51,090 --> 02:00:58,560
可以说，这就是这个程序的第 0 版，我们的目标是创建一个游戏，让你走出某种迷宫。

1679
02:00:58,560 --> 02:01:01,800
在这种情况下，你必须从这个迷宫中走出哈佛大学的校徽。

1680
02:01:01,800 --> 02:01:08,040
让我继续按下 "播放 "键，这样你就能看到这个程序的第一个构件是什么了。

1681
02:01:08,040 --> 02:01:12,990
请注意，我的手实际上是放在键盘的方向键上。

1682
02:01:12,990 --> 02:01:20,432
似乎只要上下左右移动，屏幕上的这个小峰顶就会做出相应的反应。

1683
02:01:20,432 --> 02:01:22,140
现在，让我们假设一下。

1684
02:01:22,140 --> 02:01:27,260
尽管我们以前没有做过类似的工作，但如何实现这段代码呢？

1685
02:01:27,260 --> 02:01:34,220
如何让一个精灵（无论是猫还是徽章）对键盘上的按键做出反应--你能凭直觉想到吗？

1686
02:01:36,983 --> 02:01:40,410
是的，可能有什么东西能感应到你按的是什么键。

1687
02:01:40,410 --> 02:01:44,600
如果你永远循环往复地这样做，你就只能不断地监听按键。

1688
02:01:44,600 --> 02:01:47,240
如今，每款软件都是这样运行的。

1689
02:01:47,240 --> 02:01:51,690
它一直在等待你轻触手机或在屏幕上输入内容。

1690
02:01:51,690 --> 02:01:55,400
所以，让我先来看看这个现有程序的内部情况。

1691
02:01:55,400 --> 02:01:59,730
还有更多情况，但我们将快速浏览一下实际情况。

1692
02:01:59,730 --> 02:02:04,850
那么，在左上方，请注意，我们只需转到 x 等于 0 和 y 等于 0。

1693
02:02:04,850 --> 02:02:07,850
也就是说，把哈佛大学的校徽放在舞台中央的正中间。

1694
02:02:07,850 --> 02:02:13,130
然后，我们将两个函数作为自定义函数使用，这两个函数分别是

1695
02:02:13,130 --> 02:02:15,500
聆听键盘，感受墙壁。

1696
02:02:15,500 --> 02:02:17,190
因此，它同时在做两件事。

1697
02:02:17,190 --> 02:02:23,278
它永远都在聆听键盘的声音--上、下、左、右--并感觉到墙壁的存在、

1698
02:02:23,278 --> 02:02:26,010
我不想让它继续穿过那堵黑墙。

1699
02:02:26,010 --> 02:02:29,060
如果它向右移动太远，我也不想让它撞穿那堵墙。

1700
02:02:29,060 --> 02:02:34,250
因此，它要不断做两件事：听键盘声和摸墙壁声。

1701
02:02:34,250 --> 02:02:35,870
又是如何实施的？

1702
02:02:35,870 --> 02:02:37,190
这个有点长。

1703
02:02:37,190 --> 02:02:40,080
左侧是 "听键盘"。

1704
02:02:40,080 --> 02:02:47,420
因此，这块粉色拼图 "键盘监听 "首先要检查 "是否按下向上箭头键"，即问号、

1705
02:02:47,420 --> 02:02:50,570
条件中的布尔表达式，Change y By 1。

1706
02:02:50,570 --> 02:02:52,040
这意味着，将其上移 1.

1707
02:02:52,040 --> 02:02:59,540
否则，如果按下 "向下箭头 "键，则将 y 改为-1，左箭头和右箭头的操作类似。

1708
02:02:59,540 --> 02:03:04,310
尽管在这个粉红色函数中没有循环，但在我使用它的地方却有循环。

1709
02:03:04,310 --> 02:03:06,860
因此，这个问题一直被反复询问。

1710
02:03:06,860 --> 02:03:08,420
对墙壁的感觉如何？

1711
02:03:08,420 --> 02:03:13,970
好吧，在这里的右边 -- 有点断掉了 -- 但这里有《如果触摸左墙》、

1712
02:03:13,970 --> 02:03:15,260
将 x 改为 1。

1713
02:03:15,260 --> 02:03:17,200
所以，如果你碰壁了，就为时已晚。

1714
02:03:17,200 --> 02:03:18,950
你已经在吹牛了。

1715
02:03:18,950 --> 02:03:23,000
所以我想把它向后移动一个像素，这样它就不会再碰到那面墙了。

1716
02:03:23,000 --> 02:03:28,220
同样，如果它碰到了右边的墙，我想把它后退一个像素，这样它就不再碰到那面墙了。

1717
02:03:28,220 --> 02:03:33,110
因此，它就像是在轻微地反弹，这样就不会滑过那堵墙。

1718
02:03:33,110 --> 02:03:34,340
那些墙是什么？

1719
02:03:34,340 --> 02:03:41,790
注意看下面，这只是一个简单的精灵，上面有一条黑线，我把它的方向改为垂直而不是水平。

1720
02:03:41,790 --> 02:03:45,230
这样我就可以向另外两个精灵提问了。

1721
02:03:45,230 --> 02:03:47,570
现在，这给了我互动的形式。

1722
02:03:47,570 --> 02:03:49,200
我现在还能做什么？

1723
02:03:49,200 --> 02:03:52,410
那么，如果我们让这里的互动性更强一些呢？

1724
02:03:52,410 --> 02:03:55,640
让我来看看第 1 版的第二部分。

1725
02:03:55,640 --> 02:03:58,860
让我提议一下这里会发生什么。

1726
02:03:58,860 --> 02:04:02,600
那么，我们怎样才能在其中加入一点像耶鲁大学这样的东西呢？

1727
02:04:02,600 --> 02:04:07,460
那么，根据这段代码，当我现在点击绿旗时，耶鲁会怎么做？

1728
02:04:07,460 --> 02:04:09,920
有什么直觉吗？

1729
02:04:09,920 --> 02:04:13,250
下面是我的耶鲁精灵的代码。

1730
02:04:14,570 --> 02:04:19,370
戴维-J-马兰：是的，如果我继续写更多的代码，理论上它会阻挡我的前进道路，这有点不利于我。

1731
02:04:20,030 --> 02:04:22,160
它也会转到屏幕中间。

1732
02:04:22,160 --> 02:04:23,940
它指向 90 度的方向。

1733
02:04:23,940 --> 02:04:26,520
因此，同样也有一个完整的学位体系。

1734
02:04:26,520 --> 02:04:27,710
它永远在问这个问题。

1735
02:04:27,710 --> 02:04:30,920
如果触碰左墙或 -- 注意绿色块 --

1736
02:04:30,920 --> 02:04:33,900
触碰右侧墙壁，然后转体 180 度。

1737
02:04:33,900 --> 02:04:42,860
事实上，如果你从逻辑上思考一下，这就意味着你只需将自己翻转 180 度，就能在耶鲁精灵身上这样跳来跳去。

1738
02:04:42,860 --> 02:04:46,550
因此，如果我继续放大并点击 "绿旗"、

1739
02:04:46,550 --> 02:04:48,350
我仍然可以上下移动。

1740
02:04:48,350 --> 02:04:53,490
但耶鲁大学整天就是这样，来来回回，反反复复，永无止境。

1741
02:04:53,490 --> 02:04:55,710
如果我试着穿过它，就不会有坏事发生。

1742
02:04:55,710 --> 02:04:58,010
不过，我们当然可以把这一点加进去。

1743
02:04:58,010 --> 02:05:01,760
事实上，在玩这个特殊游戏之前，让我们再补充最后一项功能。

1744
02:05:01,760 --> 02:05:08,640
让我来打开这些构件的最终版本，将麻省理工学院加入其中。

1745
02:05:08,640 --> 02:05:10,940
这里是麻省理工学院。

1746
02:05:10,940 --> 02:05:13,182
谁能解释一下这段代码的作用？

1747
02:05:13,182 --> 02:05:14,390
这就是我们正在做的。

1748
02:05:14,390 --> 02:05:15,470
这本身就是一种技能。

1749
02:05:15,470 --> 02:05:20,640
阅读别人的代码并理解它是编程中除编写之外的另一个重要部分。

1750
02:05:22,015 --> 02:05:24,960
戴维-J-马兰：是的，它在追寻哈佛校徽的轮廓。

1751
02:05:24,960 --> 02:05:30,050
这显然就是这位学生制作的服装名称，哈佛校徽的轮廓。

1752
02:05:30,050 --> 02:05:32,600
显然，它会先随机进入一个位置。

1753
02:05:32,600 --> 02:05:34,700
但它却永远指向哈佛。

1754
02:05:34,700 --> 02:05:40,830
因此，无论我把它移到哪里，向上、向下、向左还是向右，麻省理工学院都比耶鲁大学更有策略，像这样来回跳动。

1755
02:05:40,830 --> 02:05:43,440
所以，让我们继续全屏播放吧。

1756
02:05:43,440 --> 02:05:45,540
这里有一面绿旗。

1757
02:05:45,540 --> 02:05:53,210
因此，如果我向上爬，麻省理工学院就会战略性地跟随我，无论我走到哪里。

1758
02:05:53,210 --> 02:05:55,190
好吧，还是没发生什么坏事。

1759
02:05:55,190 --> 02:05:56,940
但现在它在挣扎，对吗？

1760
02:05:56,940 --> 02:05:58,190
它在上升、下降、上升、下降。

1761
02:05:58,190 --> 02:06:00,950
即使我一动不动，它还是试图跟着我。

1762
02:06:00,950 --> 02:06:02,630
因此，我们需要一些最后的点缀。

1763
02:06:02,630 --> 02:06:06,740
因此，我想，为此，我们也许需要最后一位志愿者。

1764
02:06:06,740 --> 02:06:11,990
之后，蛋糕在外面等着大家，这是 CS50 第一讲结束时的传统。

1765
02:06:11,990 --> 02:06:14,840
您愿意上来做我们的志愿者吗？

1766
02:06:24,040 --> 02:06:30,040
因此，这将是实际版本，但由您的一位前辈撰写，我将在这里全屏显示。

1767
02:06:30,040 --> 02:06:35,562
它将拼接所有这些相同的基元和更多，但增加了分数和生命的概念

1768
02:06:35,562 --> 02:06:44,650
这样实际上就有了一个目标，在这种情况下，目标就是移动哈佛徽章，不断追赶右侧的角色，让你的精灵碰到那个角色。

1769
02:06:44,650 --> 02:06:46,533
你想自我介绍一下吗？

1770
02:06:46,533 --> 02:06:47,950
听众：你好，我叫穆罕默德。

1771
02:06:47,950 --> 02:06:49,000
戴维-J-马兰：好的，太好了。

1772
02:06:49,000 --> 02:06:49,630
欢迎加入。

1773
02:06:49,630 --> 02:06:56,048
在这里，如果我们想继续亮灯，但又想增加音乐，我们还需要一些说明和最后的装饰。

1774
02:07:00,486 --> 02:07:02,150
你不能这样。

1775
02:07:02,150 --> 02:07:03,025
你不能碰这个

1776
02:07:03,025 --> 02:07:05,567
大卫-J-马兰：请注意，他用的是上下左右。

1777
02:07:05,567 --> 02:07:07,320
但现在还有更多的墙。

1778
02:07:07,320 --> 02:07:08,730
第一关非常简单。

1779
02:07:08,730 --> 02:07:13,560
但现在耶鲁大学也在其中，来回跳动。

1780
02:07:13,560 --> 02:07:15,420
同样，非常简单。

1781
02:07:15,420 --> 02:07:22,290
现在有两个耶鲁大学，位置略有不同。

1782
02:07:22,290 --> 02:07:23,730
麻省理工学院即将到来。

1783
02:07:23,730 --> 02:07:25,432
但首先，我们有三个耶鲁人。

1784
02:07:25,432 --> 02:07:26,640
MC HAMMER：（唱）就是这样。

1785
02:07:26,640 --> 02:07:28,542
这个节拍，呃，你不能碰。

1786
02:07:28,542 --> 02:07:29,625
大卫-J-马兰：很好。

1787
02:07:30,125 --> 02:07:33,100
我告诉过你，伙计，你不能碰这个。

1788
02:07:33,100 --> 02:07:36,820
是啊，当你知道你不能碰这个的时候，就是这个样子。

1789
02:07:36,820 --> 02:07:40,798
看着我的眼睛，伙计，你不能碰这个。

1790
02:07:40,798 --> 02:07:43,090
Yo, let me bust the funky lyrics.

1791
02:07:43,090 --> 02:07:45,171
新鞋新裤，你一定喜欢。

1792
02:07:45,171 --> 02:07:46,504
现在，你知道你想跳舞了。

1793
02:07:46,504 --> 02:07:48,570
所以，离开你的座位，去找一只苍蝇 --

1794
02:07:48,570 --> 02:07:49,290
你得快点走 You got to go quick.

1795
02:07:49,290 --> 02:07:51,623
锤子 MC HAMMER：（唱）趁它滚动的时候，抓住这个节拍。

1796
02:07:52,130 --> 02:07:55,490
抽一点，让他们知道发生了什么，就这样，就这样。

1797
02:07:55,490 --> 02:07:57,056
寒冷在执行任务，所以请退后。

1798
02:07:57,056 --> 02:08:02,800
让他们知道你太过分了，这个节拍，呃，他们不能碰。

1799
02:08:02,800 --> 02:08:03,627
哟，我就说嘛

1800
02:08:03,627 --> 02:08:04,502
你不能碰这个

1801
02:08:08,790 --> 02:08:09,810
哟，敲钟

1802
02:08:09,810 --> 02:08:10,975
开学了，笨蛋

1803
02:08:10,975 --> 02:08:11,850
你不能碰这个

1804
02:08:11,850 --> 02:08:13,432
给我一首歌，一种节奏。

1805
02:08:13,432 --> 02:08:15,390
让他们出汗，这就是我要给他们的。

1806
02:08:15,390 --> 02:08:20,810
现在他们知道了，你说的是锤子，你说的是一场被炒得沸沸扬扬的演出。

1807
02:08:20,810 --> 02:08:24,018
歌手们满头大汗，可以递给他们一块抹布或一盘磁带，让他们学习。

1808
02:08:24,018 --> 02:08:25,060
要怎么做

1809
02:08:25,060 --> 02:08:27,040
DAVID J. MALAN：倒数第二层。

1810
02:08:27,040 --> 02:08:28,165
合法。

1811
02:08:28,165 --> 02:08:30,065
要么努力工作，要么放弃。

1812
02:08:30,065 --> 02:08:31,410
那是因为你知道

1813
02:08:31,410 --> 02:08:32,535
最后一级。

1814
02:08:32,535 --> 02:08:35,652
你不能碰这个。

1815
02:08:35,652 --> 02:08:37,124
嘿 Hey！

1816
02:08:45,170 --> 02:08:47,570
好了，CS50 到此为止。

1817
02:08:48,410 --> 02:08:49,820
蛋糕已经上桌。

1818
02:08:49,820 --> 02:08:51,950
我们下次再见。

