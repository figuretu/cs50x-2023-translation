3
00:01:13,350 --> 00:01:16,090
戴维-J-马兰：好的，这是 CS50。

4
00:01:16,090 --> 00:01:25,060
这是第一周，我们继续编程，但使用的是另一种语言，因为记得上次，我们主要学习了一种名为 Scratch 的图形语言。

5
00:01:25,060 --> 00:01:31,750
但我们使用 Scratch，不仅是因为它好玩、易学，还因为它能让我们在这里探索很多这些概念、

6
00:01:31,750 --> 00:01:36,410
即函数、条件式、布尔表达式、循环、变量等。

7
00:01:36,410 --> 00:01:44,980
因此，在我们过渡到这门名为 C 语言的新语言时，即使今天的语法确实有点令人费解，也许一开始会有点吓人、

8
00:01:44,980 --> 00:01:52,670
如果你不太明白这些符号除了语法本身之外还有什么意义，那么你要明白，这些想法最终都是一样的。

9
00:01:52,670 --> 00:02:02,350
事实上，我们从上周的 "Hello World "程序过渡到本周的 "Hello World "程序，看起来有点像这样，当然，它现在看起来会更神秘一些。

10
00:02:02,350 --> 00:02:04,350
看起来会有点像这样。

11
00:02:04,350 --> 00:02:11,578
现在，即使你不能完全分清这些代码中的各种符号是什么意思，但事实证明，这些代码最终都会实现你所期望的功能。

12
00:02:11,578 --> 00:02:15,370
就像我们在 Scratch 中做的那样，它只会在屏幕上显示 "你好，世界"。

13
00:02:15,370 --> 00:02:19,610
因此，让我们先来应用一些术语来解释这些代币。

14
00:02:19,610 --> 00:02:24,040
因此，我们将要看到的，我们今后要写的，我们将开始调用源代码。

15
00:02:24,040 --> 00:02:27,908
人类程序员编写的代码从此被称为源代码。

16
00:02:27,908 --> 00:02:29,200
是否是 Scratch 并不重要。

17
00:02:29,200 --> 00:02:32,370
就算是 C 语言也没关系，就算是 Python 也没关系。

18
00:02:32,370 --> 00:02:37,330
源代码是你我作为人类程序员最终要编写的内容的总称。

19
00:02:37,330 --> 00:02:42,190
当然，事实证明，计算机并不理解源代码。

20
00:02:42,190 --> 00:02:47,200
计算机本身并不理解 Scratch 和拼图，也不理解我们即将看到的 C 代码。

21
00:02:47,200 --> 00:02:49,870
他们只懂这个，我们上周称之为什么？

22
00:02:49,870 --> 00:02:50,650
听众：零和一

23
00:02:50,650 --> 00:02:51,525
是的。

24
00:02:51,525 --> 00:02:53,080
所以这是二进制，0 和 1。

25
00:02:53,080 --> 00:02:56,470
但实际上，它只是用二进制表示的信息。

26
00:02:56,470 --> 00:03:04,810
事实上，现在的专业术语是 "0 "和 "1 "的模式，计算机不仅能将其理解为字母或数字，还能将其理解为 "0 "和 "1 "的模式、

27
00:03:04,810 --> 00:03:12,880
因此，为了与源代码相对照，我们将机器代码称为机器码。

28
00:03:12,880 --> 00:03:18,860
因此，你和我，人类，编写源代码，而计算机最终只能理解机器代码。

29
00:03:18,860 --> 00:03:28,600
尽管我们不会详细讨论符号的具体含义，但你会发现，在这种 0 和 1 的模式中，会出现数字。

30
00:03:28,600 --> 00:03:29,530
会有信的。

31
00:03:29,530 --> 00:03:36,430
但也会有指令，因为计算机确实擅长做事情--加法、减法、将东西移入和移出内存。

32
00:03:36,430 --> 00:03:44,740
可以说，Mac、PC 和世界上的其他计算机已经决定，作为一个社会，什么是特定的 0 和 1 的模式，什么是特定的 "0 "和 "1 "的模式。

33
00:03:44,740 --> 00:03:49,200
是指在操作时也是如此，所以不只是数据，还有指令。

34
00:03:49,200 --> 00:03:52,575
但这些模式并不是我们这堂课的重点。

35
00:03:52,575 --> 00:03:58,910
我们将把重点放在更高层次的软件方面，只是假设我们需要以某种方式输出机器代码。

36
00:03:58,910 --> 00:04:07,120
事实证明，我们要解决的这个从源代码到机器代码的问题，其实与上次的范例是一样的。

37
00:04:07,120 --> 00:04:11,230
但在这种情况下，一方面输入的将是源代码。

38
00:04:11,230 --> 00:04:15,430
这就是你我理想中的写法，这样我们就不用写 0 和 1 了。

39
00:04:15,430 --> 00:04:21,730
但我们需要以某种方式输出机器代码，因为这才是 Mac、PC 和手机真正能理解的东西。

40
00:04:21,730 --> 00:04:28,690
事实证明，生活中有一些特殊的程序，其目的正是为了完成这种转换--将你的源代码转换成你的

41
00:04:28,690 --> 00:04:32,320
我写的是我们的手机和电脑能理解的机器代码。

42
00:04:32,320 --> 00:04:36,050
这种程序被称为编译器。

43
00:04:36,050 --> 00:04:39,400
因此，今天我们将向您介绍另一款软件。

44
00:04:39,400 --> 00:04:40,810
它们有多种形式。

45
00:04:40,810 --> 00:04:48,805
我们将在这里使用一个常用的软件，它可以将 C 语言源代码转换为机器代码中的 0 和 1。

46
00:04:48,805 --> 00:04:50,680
在使用 Scratch 时，你不必这样做。

47
00:04:50,680 --> 00:04:57,280
在 Scratch 的世界里，这就像点击绿旗一样简单，因为麻省理工学院已经完成了所有繁重的工作，找出了

48
00:04:57,280 --> 00:05:00,760
如何将这些图形拼图转换为底层机器代码。

49
00:05:00,760 --> 00:05:06,550
但从今天起，当我们开始学习编程和计算机科学时，这种权力就会转移到你们身上。

50
00:05:06,550 --> 00:05:09,340
现在就看你如何完成这种转换了。

51
00:05:09,340 --> 00:05:19,973
但值得庆幸的是，有了这些编译器，你我就不必再像我们的祖先那样用机器码编程，无论是虚拟编程还是实体打卡编程、

52
00:05:19,973 --> 00:05:21,640
就像有洞的纸片。

53
00:05:21,640 --> 00:05:25,810
你和我可以专注于我们的键盘。

54
00:05:25,810 --> 00:05:29,370
但今天，这不仅仅是编写代码的问题。

55
00:05:29,370 --> 00:05:32,930
从今往后，写出好代码也将成为一个问题。

56
00:05:32,930 --> 00:05:35,180
这种东西不是一朝一夕就能学会的。

57
00:05:35,180 --> 00:05:35,870
这需要时间。

58
00:05:35,870 --> 00:05:36,620
这需要练习。

59
00:05:36,620 --> 00:05:41,050
就像写任何学科的文章都可能需要时间、练习和反复推敲。

60
00:05:41,050 --> 00:05:49,360
但在 CS50 这样的编程课上，我们一般会希望沿着这三个轴来评估代码的质量。

61
00:05:49,360 --> 00:05:51,040
首先，它是否正确？

62
00:05:51,040 --> 00:05:52,810
代码是否做了它应该做的事情？

63
00:05:52,810 --> 00:05:55,835
毕竟，如果写不出来，那当初写这本书的意义何在？

64
00:05:55,835 --> 00:05:59,350
因此，不言而喻，您希望自己编写的代码是正确的。

65
00:05:59,350 --> 00:06:00,820
但显然并非总是如此。

66
00:06:00,820 --> 00:06:07,030
同样，无论你的 Mac、PC 或手机何时崩溃，都是某个地方的某个人编写了错误的代码，也就是有错误的代码。

67
00:06:07,030 --> 00:06:10,060
但代码的正确性将是首要目标。

68
00:06:10,060 --> 00:06:13,930
但还有一个更主观的目标，那就是时间，一个设计的问题。

69
00:06:13,930 --> 00:06:24,170
上周，当我提出我们可以更好地设计从头开始的程序时，我们看到了这一点，也许我们可以使用循环，而不仅仅是重复复制和粘贴相同的程序块。

70
00:06:24,170 --> 00:06:26,080
因此，设计更加主观。

71
00:06:26,080 --> 00:06:32,882
这更像是一门学问，两个人最终可能会对哪个版本的程序设计得更好产生分歧。

72
00:06:32,882 --> 00:06:40,090
不过，我们将在未来几周内为您提供构建模块和原则，这样您就能更好地了解自己的代码是否设计合理。

73
00:06:40,090 --> 00:06:41,530
这又有什么价值呢？

74
00:06:41,530 --> 00:06:49,438
代码设计得越好，运行速度往往就越快，如果你在现实世界中与他人合作，你或同事对代码的可维护性也就越高。

75
00:06:49,438 --> 00:06:50,900
因此，好的设计是一件好事。

76
00:06:50,900 --> 00:06:54,490
它可以帮助你传达自己的想法，就像在典型的英语作文中一样。

77
00:06:54,490 --> 00:06:57,523
最后，我们将从本周开始讨论风格问题。

78
00:06:57,523 --> 00:06:59,690
这其实只是代码的美学问题。

79
00:06:59,690 --> 00:07:10,750
事实证明，计算机通常不会在意你的实际代码有多草率，而在代码的世界里，你其实并不需要把东西缩进得多么漂亮。

80
00:07:10,750 --> 00:07:13,150
在文章中不需要像这样分页。

81
00:07:13,150 --> 00:07:16,390
计算机一般不会在意，但人类会在意。

82
00:07:16,390 --> 00:07:17,817
助教是这样做的。

83
00:07:17,817 --> 00:07:21,560
第二天，当你只想了解代码的作用时，你就会在意了。

84
00:07:21,560 --> 00:07:25,520
最后，我们将重点讨论代码的风格和美感。

85
00:07:25,520 --> 00:07:27,280
那么，我们要在哪里编写代码呢？

86
00:07:27,280 --> 00:07:28,940
我们要在哪里编译代码？

87
00:07:28,940 --> 00:07:39,280
因此，在这门课上，不仅是 C 语言，还有我们将在本学期使用的其他语言，我们都将使用一款名为 Visual Studio Code（又名 VS Code）的免费文本编辑器。

88
00:07:39,280 --> 00:07:45,970
如今，它不仅在 C 语言中，而且在 C++、Python、Java 以及其他语言中都非常流行。

89
00:07:45,970 --> 00:07:49,270
它是一个文本编辑器，可以编辑文本。

90
00:07:49,270 --> 00:07:52,150
这就是代码的全部内容。

91
00:07:52,150 --> 00:07:54,907
现在，严格来说，你可以在纸上/笔上写代码。

92
00:07:54,907 --> 00:07:59,532
事实上，在高中时，如果你选修了一门课，你可能会做过一次或多次这样的课内练习。

93
00:07:59,532 --> 00:08:02,532
当然，你不能把它写在纸上，但你可以把它写出来。

94
00:08:02,532 --> 00:08:07,240
您可以使用 Microsoft Word、Notepad.exe 或 Mac 上的 Text Edit 等软件。

95
00:08:07,240 --> 00:08:15,250
但是，这些程序都不能真正为你设计出最合适的代码格式，也不能让你编译和运行代码。

96
00:08:15,250 --> 00:08:22,240
因此，VS Code 将成为一个工具，你可以通过它完成所有这些工作，甚至更多--编写代码、编译代码、运行代码。

97
00:08:22,240 --> 00:08:29,110
这样，大家就不必在课程开始时因安装这个软件和那个软件而与愚蠢的技术支持问题纠缠不清了。

98
00:08:29,110 --> 00:08:34,780
我们将在 code.cs50.io 上使用基于云的 VS Code 版本。

99
00:08:34,780 --> 00:08:36,580
这将是完全相同的工具。

100
00:08:36,580 --> 00:08:46,090
我们的目标是，在学期结束前，将你从云环境迁移到你自己的 Mac 和 PC 上，这样，即使 CS50 是你上过的唯一一门 CS 课程、

101
00:08:46,090 --> 00:08:55,760
至少在一段时间内，你可以在课程结束后继续编写代码，所使用的代码甚至不是 CS50 的专用代码，而是事实上的行业标准。

102
00:08:55,760 --> 00:08:59,020
那么，VS Code 程序在 Mac 上会是什么样子呢？

103
00:08:59,020 --> 00:09:00,990
个人电脑，还是最初的浏览器？

104
00:09:00,990 --> 00:09:02,990
看起来会有点像这样。

105
00:09:02,990 --> 00:09:05,657
屏幕上会有几个不同的区域。

106
00:09:05,657 --> 00:09:10,335
图中的代码正是我一直推荐的用 C 语言编写的最简单程序。

107
00:09:10,335 --> 00:09:12,460
屏幕上的这些不同区域是什么？

108
00:09:12,460 --> 00:09:15,440
那么，这里基本上有这四个。

109
00:09:15,440 --> 00:09:21,160
首先，上方突出显示的是一个或多个标签页，你可以在这些标签页上编写代码。

110
00:09:21,160 --> 00:09:24,940
因此，就像在 Google Docs 或 Microsoft Word 中一样，你可以打开包含文件的标签页。

111
00:09:24,940 --> 00:09:30,830
同样，在 VS Code 中，或者说在任何编程环境中，如今一般都有某种标签。

112
00:09:30,830 --> 00:09:34,480
这将是一个标签页，其中包含一个名为 hello.c 的文件。

113
00:09:34,480 --> 00:09:38,020
这将是我们马上要写的第一个文件。

114
00:09:38,020 --> 00:09:41,920
不过，下面这个界面可能很多人都不知道。

115
00:09:41,920 --> 00:09:44,170
这就是所谓的终端窗口。

116
00:09:44,170 --> 00:09:47,920
而终端窗口提供的一般称为命令行

117
00:09:47,920 --> 00:09:49,720
界面，或 CLI。

118
00:09:49,720 --> 00:09:53,680
这与图形用户界面（GUI）形成鲜明对比。

119
00:09:53,680 --> 00:09:57,760
现在，你我每天都在使用手机和电脑上的图形用户界面。

120
00:09:57,760 --> 00:10:01,420
图形用户界面是图形化的，包括菜单、按钮和图标。

121
00:10:01,420 --> 00:10:06,380
你通常使用手指、触控板、鼠标或类似的东西与之互动。

122
00:10:06,380 --> 00:10:14,620
但事实证明，许多程序员 -- 他们说大多数程序员，至少随着时间的推移，更喜欢的不是图形用户界面，而是 CLI（命令行界面）。

123
00:10:14,620 --> 00:10:20,650
在这里，你只需通过键盘就能完成所有复杂的操作。

125
00:10:21,250 --> 00:10:26,260
事实证明，只要能用键盘操作，大多数电脑都能内置更多功能。

126
00:10:26,260 --> 00:10:29,530
事实证明，我们大多数人打字的速度都比你点击的速度快。

127
00:10:29,530 --> 00:10:32,330
因此，随着时间的推移，最终会提高效率。

128
00:10:32,330 --> 00:10:40,390
因此，假以时日，你就能自如地使用这个终端窗口来完成编译代码、制作程序和运行程序等工作了。

129
00:10:40,390 --> 00:10:45,800
因此，你最初不会像我们在现实世界中那样习惯于双击图标。

130
00:10:45,800 --> 00:10:47,890
你要按照程序员的方式来做。

131
00:10:47,890 --> 00:10:51,820
但这并不排斥添加图标、点击性等。

132
00:10:51,820 --> 00:11:02,110
在 VS Code 的左侧，会有一个熟悉的 "文件管理器"（File Explorer），这是一种分层树形结构，就像在 Mac 或 PC 上一样，在这里你可以看到账户中的所有文件。

133
00:11:02,110 --> 00:11:06,140
例如，这里展示的只是 hello.c，稍后我将亲自创建它。

134
00:11:06,140 --> 00:11:12,260
左侧远处是所谓的 "活动栏"，这里有很多传统的菜单和按钮。

135
00:11:12,260 --> 00:11:16,250
因此，VS Code 本身同时提供了图形用户界面和 CLI。

136
00:11:16,250 --> 00:11:22,250
但实际上，我们要在 CLI（终端窗口）、屏幕底部区域输入大部分命令。

137
00:11:22,250 --> 00:11:28,380
一般来说，在课堂上，我会隐藏所有不感兴趣的图形内容。

138
00:11:28,380 --> 00:11:32,878
说到这里，请允许我切换到 VS Code 的实时版本。

139
00:11:32,878 --> 00:11:34,670
我确实把它藏在了 "活动栏 "里。

140
00:11:34,670 --> 00:11:36,470
我确实隐藏了文件资源管理器。

141
00:11:36,470 --> 00:11:42,840
因此，为了便于查看，我这里有一个很大的区域用于编写代码，底部则是一个很大的终端窗口。

142
00:11:42,840 --> 00:11:45,260
你会看到终端窗口中有一个美元符号。

143
00:11:45,260 --> 00:11:47,160
这并不意味着任何形式的货币。

144
00:11:47,160 --> 00:11:51,230
这只是表示类型命令的标准符号。

145
00:11:51,230 --> 00:11:55,490
因此，只有美元符号和光标的事实意味着，我最终要在这里输入命令。

146
00:11:55,490 --> 00:11:58,020
但首先，我要实际创建一些代码。

147
00:11:58,020 --> 00:12:08,870
那么，我应该如何使用 VS Code（VS 代码）编程--无论是在 Mac、PC 上，还是在基于云的环境中（您将为问题集 1 设置该环境）--编写我的第一个文件呢？

148
00:12:08,870 --> 00:12:10,610
那么，也许最简单的方法就是这样。

149
00:12:10,610 --> 00:12:15,200
只需运行命令代码，然后输入要创建的文件名即可。

150
00:12:15,200 --> 00:12:18,838
请注意，我特意用小写的 .c 结尾。

151
00:12:18,838 --> 00:12:21,380
请注意，我特意将整个文件名用小写字母标出。

152
00:12:21,380 --> 00:12:22,672
而这些只是惯例。

153
00:12:22,672 --> 00:12:24,140
你可以用大写字母 "H"。

154
00:12:24,140 --> 00:12:27,260
你可以用大写的 C，但千万别这么做。

155
00:12:27,260 --> 00:12:31,100
遵循最佳做法，使其与其他人的做法保持一致。

156
00:12:31,100 --> 00:12:35,540
当我按下回车键时，得到的只是一个空标签页，就像刚才的截图一样。

157
00:12:35,540 --> 00:12:40,100
在这个选项卡中，我可以用 C 语言编写我的第一个程序。

158
00:12:40,100 --> 00:12:45,992
遗憾的是，它不像 Scratch 那样用户界面友好，只需拖放几块拼图，"砰 "的一声，拼图就完成了。

159
00:12:45,992 --> 00:12:47,450
因此，我打算这样做是为了记忆。

160
00:12:47,450 --> 00:12:49,970
但随着时间的推移，您也会逐渐熟悉这一点。

161
00:12:49,970 --> 00:12:53,720
我将包含名为 stdio.h 的内容。

162
00:12:53,720 --> 00:12:57,230
我将输入 int main，括号内为 void。

163
00:12:57,230 --> 00:13:01,190
在新的一行中，我要插入一些我们称之为大括号的东西。

164
00:13:01,190 --> 00:13:12,800
然后输入 printf，再输入一些括号，然后在引号中输入 hello、逗号、world，然后输入反斜杠，再输入小写 n，然后输入引号，最后输入分号。

165
00:13:12,800 --> 00:13:14,280
在线路的最末端。

166
00:13:14,280 --> 00:13:19,010
因此，我所做的就是凭记忆重新创建第一个程序。

167
00:13:19,010 --> 00:13:21,710
稍后，我们将阐明其中大部分的作用。

168
00:13:21,710 --> 00:13:23,857
但现在，我们还是先实际运行一下吧。

169
00:13:23,857 --> 00:13:29,840
就像上周我第一次点击绿旗一样，让我们编译并运行这个程序。

170
00:13:29,840 --> 00:13:37,408
如果这是你的 Mac 或 PC，而且是谷歌、微软或其他公司制作的软件，那么在故事的这一部分，我们就会双击一个图标。

171
00:13:37,408 --> 00:13:38,450
但我们现在还做不到。

172
00:13:38,450 --> 00:13:39,930
这仍然是源代码。

173
00:13:39,930 --> 00:13:42,380
因此，我要在终端窗口中点击下一步。

174
00:13:42,380 --> 00:13:47,880
请注意，我在第一个美元符号下面又加了一个美元符号，这意味着它已经准备好接受第二条命令了。

175
00:13:47,880 --> 00:13:59,360
现在，要把它变成一个真正的程序，把它从源代码编译成机器代码，所使用的命令很简单，就是 make，然后输入我要编译的程序的名称。

176
00:13:59,360 --> 00:14:05,870
有一点微妙之处--我故意省略了 .c，因为我想制作的程序只想调用 hello。

177
00:14:05,870 --> 00:14:07,400
不要编写 make hello.c。

178
00:14:07,400 --> 00:14:08,780
就写 "你好 "吧。

179
00:14:08,780 --> 00:14:13,040
而这个程序 make 本质上就是我们的编译器。

180
00:14:13,040 --> 00:14:17,580
从技术上讲，它是一个能自动帮我编译程序的程序。

181
00:14:17,580 --> 00:14:20,180
但它会看到我输入了 "你好 "这个词。

182
00:14:20,180 --> 00:14:30,690
它会自动查找硬盘上名为 hello.c 的文件，并将其从 C 语言源代码转换为 0 和 1 的机器代码。

183
00:14:30,690 --> 00:14:37,170
因此，如果我没有打错字，Enter 似乎什么也没发生。

184
00:14:37,170 --> 00:14:38,210
这是一件好事。

185
00:14:38,210 --> 00:14:41,862
如果屏幕上什么都没有输出，几乎总是说明你做得很好。

186
00:14:41,862 --> 00:14:43,070
你没有犯任何错误。

187
00:14:43,070 --> 00:14:43,880
你没被骂

188
00:14:43,880 --> 00:14:45,000
没有错误信息。

189
00:14:45,000 --> 00:14:46,590
所以，这其实是件好事。

190
00:14:46,590 --> 00:14:47,942
现在如何运行该程序？

191
00:14:47,942 --> 00:14:52,110
注意，我有第三个美元符号，这意味着我准备好了第三个命令。

192
00:14:52,110 --> 00:14:55,400
现在我要继续运行 ./hello。

193
00:14:55,400 --> 00:14:58,798
这确实有点奇怪，因为你必须使用点斜线。

194
00:14:58,798 --> 00:15:07,730
但现在你只需相信，在这个基于云的环境中，在你的当前文件夹、当前目录下，你就是这样运行一个名为 hello 的程序的。

195
00:15:07,730 --> 00:15:10,430
好吧，我再次祈祷，点击回车键。

197
00:15:12,110 --> 00:15:15,950
我的第一个 C 语言程序：hello, world。

198
00:15:15,950 --> 00:15:21,292
现在，让我继续揭示我之前提出的文件资源管理器。

199
00:15:21,292 --> 00:15:23,750
我将使用键盘快捷键来显示。

200
00:15:23,750 --> 00:15:28,250
一般情况下，我把它关闭，因为我并不需要经常查看账户里有哪些文件。

201
00:15:28,250 --> 00:15:35,270
但你现在会在文件资源管理器中看到，它的功能与 Mac 或 PC 相似，但图形上略有不同，这是我的文件 hello.c。

202
00:15:35,270 --> 00:15:37,520
高亮显示是因为我打开了那个选项卡。

203
00:15:37,520 --> 00:15:40,970
但现在这里还有第二个文件，名字就叫 "你好"。

204
00:15:40,970 --> 00:15:42,690
这就是我的节目名称。

205
00:15:42,690 --> 00:15:46,100
因此，如果你使用的是 Mac 或 PC，最好双击那个东西。

206
00:15:46,100 --> 00:15:48,162
在命令行环境中无法做到这一点。

207
00:15:48,162 --> 00:15:49,370
你必须把它放下来

208
00:15:49,370 --> 00:15:50,453
但这就是我们所做的一切。

209
00:15:50,453 --> 00:15:56,240
我们创建了一个名为 hello.c 的文件，然后我的编译器据此编译出了程序。

210
00:15:56,240 --> 00:16:01,970
请允许我暂停一下，看看是否有任何问题，因为这是很多神奇的短语。

213
00:16:04,950 --> 00:16:13,950
所以，如果你现在正在跟读，正在家里玩游戏，并且收到了一些错误信息，那么今天的部分工作就是让我故意诱导一些这样的错误信息。

214
00:16:13,950 --> 00:16:19,320
现在，我只想说，如果你真的像我这样做了，那你一定是在某个地方打错了。

215
00:16:19,320 --> 00:16:23,790
请注意，它确实是标准 io -- stdio.h。

216
00:16:23,790 --> 00:16:25,890
也许你输入的是 studio.h？

217
00:16:25,890 --> 00:16:30,600
好吧，超级常见的错误，我可以骂你。

218
00:16:30,600 --> 00:16:32,280
它不是 studio.h。

219
00:16:32,280 --> 00:16:34,560
它就是 stdio.h--太常见了。

220
00:16:34,560 --> 00:16:41,730
但这恰恰代表了你本周，可能几周，可能，说实话，几年内都会遇到的那种愚蠢的头痛。

221
00:16:41,730 --> 00:16:49,110
但随着时间的推移，你会逐渐看清这些愚蠢的错误，而且会变得越来越容易，因为电脑会非常规范。

222
00:16:49,110 --> 00:16:50,950
它只会做你让它做的事。

223
00:16:50,950 --> 00:16:55,890
如果你说因为它在口头上听起来像 studio.h，它就不会知道这个文件是什么。

224
00:16:55,890 --> 00:16:58,182
所以，事实上，谢谢你这么早就发现了这一点。

225
00:16:58,182 --> 00:16:59,740
这种情况很常见。

227
00:17:00,240 --> 00:17:02,540
听众：你为什么有两个你好文件？

228
00:17:02,540 --> 00:17:03,799
为什么我要打招呼？

229
00:17:03,799 --> 00:17:04,400
是的是的

230
00:17:04,400 --> 00:17:06,400
那我为什么要打招呼？

231
00:17:06,400 --> 00:17:10,520
其中一个是我作为人类创建的名为 hello.c 的程序，它的图片就在这里。

232
00:17:10,520 --> 00:17:17,040
但是，当我运行 make hello 时，这个过程将我的源代码编译成了机器代码。

233
00:17:17,040 --> 00:17:25,700
因此，第二个名为 hello 的文件就包含了服务器能真正理解的所有 0 和 1。

234
00:17:25,700 --> 00:17:27,200
好吧，有问题吗？

235
00:17:27,200 --> 00:17:29,710
我不知道进入哈啰[听不清]

236
00:17:29,710 --> 00:17:38,230
大卫-J-马兰：如果你试着点击 hello 文件，你会在这个环境中看到 VS 代码，引号/单引号，该文件无法在编辑器中显示，因为它是二进制的

237
00:17:38,230 --> 00:17:41,437
又名 0 和 1，或使用不支持的文本编码。

238
00:17:41,437 --> 00:17:42,520
在这种情况下，它是二进制的。

239
00:17:42,520 --> 00:17:43,660
是 0 和 1。

240
00:17:43,660 --> 00:17:47,680
现在，你可以使用软件来查看这些 0 和 1。

241
00:17:47,680 --> 00:17:50,320
对大多数人来说，这不会有什么智力启迪。

242
00:17:50,320 --> 00:17:53,165
因此，VS Code 只能选择完全不向你显示它。

243
00:17:53,165 --> 00:17:56,290
因此，这也是一个常见的错误，即点击了一个你不想要的文件。

244
00:17:56,290 --> 00:18:00,190
但我们确实可以编辑源代码。

245
00:18:00,190 --> 00:18:01,900
好了，我已经编写了这个程序。

246
00:18:01,900 --> 00:18:06,700
它似乎能神奇地起作用，至少只要你把每一个按键都敲对了，就能不费吹灰之力。

247
00:18:06,700 --> 00:18:08,440
到底发生了什么事？

248
00:18:08,440 --> 00:18:09,460
效果如何？

249
00:18:09,460 --> 00:18:17,740
首先，请注意，即使我没有突出显示或选择菜单按钮，也已经用颜色编码了。

250
00:18:17,740 --> 00:18:22,510
然而，我并没有用谷歌文档的方式来突出显示，当然也没有改变颜色。

251
00:18:22,510 --> 00:18:29,600
事实证明，VS Code 和当今大多数编程环境都能自动为你提供语法高亮功能。

252
00:18:29,600 --> 00:18:36,760
因此，语法高亮是时下典型文本编辑器的一项功能，它可以分析你输入的代码。

253
00:18:36,760 --> 00:18:47,570
当它注意到某些类型的按键，如代表函数、条件、循环或变量的按键--上周的许多词汇--它就会以不同的方式突出显示出来

255
00:18:48,070 --> 00:18:51,430
例如，我们很快就会看到的主线，在这里是紫色的。

256
00:18:51,430 --> 00:18:53,890
Int 和 void 以及 include 均为红色。

257
00:18:53,890 --> 00:18:55,630
你好，世界是蓝色的。

258
00:18:55,630 --> 00:18:57,390
我的括号是绿色的。

259
00:18:57,390 --> 00:18:59,290
这也完全因程序员而异。

260
00:18:59,290 --> 00:19:04,870
事实上，如果您想在自己的环境中更改问题集 1 的这些颜色，您可以四处看看

261
00:19:04,870 --> 00:19:07,190
通过齿轮图标进行 VS 代码设置。

262
00:19:07,190 --> 00:19:09,820
您可以更换不同的颜色主题。

263
00:19:09,820 --> 00:19:13,480
语法高亮并不像 Scratch 中那样有特定的颜色方案。

264
00:19:13,480 --> 00:19:16,485
一般来说，每个人都有自己的喜好。

265
00:19:16,485 --> 00:19:20,830
但目前这里发生的只是语法高亮的概念。

266
00:19:20,830 --> 00:19:25,510
那么，在我运行代码（而不是编写代码）之前，代码中还发生了什么？

267
00:19:25,510 --> 00:19:28,790
如果我把所有的颜色都去掉，看起来就有点像这样了。

268
00:19:28,790 --> 00:19:32,500
然后，为了便于讨论，让我继续给它涂上更像 Scratch 的颜色。

269
00:19:32,500 --> 00:19:45,070
回想一下，我们的第一个 Scratch 程序只是在屏幕上说 hello, world，它有一个绿色的旗子点击图标--拼图，大致是橙色的，然后下面有一个紫色的 say 块。

270
00:19:45,070 --> 00:19:50,950
因此，虽然这是 C 语言版本，但如果我们把时间倒回到上周，这也是 Scratch 中的同一个程序。

271
00:19:50,950 --> 00:19:53,090
但现在的情况却完全一样。

272
00:19:53,090 --> 00:20:03,190
因此，如果你回想一下上周，你有一些函数，比如紫色字体中的 say 函数，它可能会接受一个或多个参数，比如影响屏幕显示内容的输入。

273
00:20:03,190 --> 00:20:08,480
然后，功能、调用有时会产生副作用，比如屏幕上会出现语音气泡。

274
00:20:08,480 --> 00:20:18,790
因此，上周当我们使用 say 代码块并在左侧传入 hello, world 的参数时，我们在屏幕上得到了这样的视觉副作用，即在语音气泡中显示 hello, world。

275
00:20:18,790 --> 00:20:23,230
这正是 VS 代码中发生的事情，但文字上要丰富得多。

276
00:20:23,230 --> 00:20:25,900
让我们再仔细看看代码本身。

277
00:20:25,900 --> 00:20:38,350
让我挥挥手，相当于绿旗点击了我代码的一部分，让我们只关注 Scratch 中的 say 块和 C 语言中的相应函数。

278
00:20:38,350 --> 00:20:44,830
因此，如果我想把上周的 say 块转换成 C. 块，我就需要这样做、

279
00:20:44,830 --> 00:20:48,520
我首先会使用打印功能--虽然这实际上是个谎言。

280
00:20:48,520 --> 00:20:50,440
实际上是 printf 函数。

281
00:20:50,440 --> 00:20:52,030
Printf 表示格式化。

282
00:20:52,030 --> 00:20:55,360
它只是一个允许你在屏幕上格式化文本的功能。

283
00:20:55,360 --> 00:20:58,570
C 语言中没有 say 函数，只有 printf 函数。

284
00:20:58,570 --> 00:21:08,050
多年前，麻省理工学院所做的是，他们将历史上存在的 printf 简化为本质上的 say，以满足更多用户的需求。

285
00:21:08,050 --> 00:21:16,250
但请注意，现在如果我想把左边的 Scratch 代码转换成右边的 C 代码，形状是一样的。

286
00:21:16,250 --> 00:21:23,510
因此，麻省理工学院特意使用了这个白色的椭圆形，如果只是因为它让人联想到也有括号的话。

287
00:21:23,510 --> 00:21:31,240
因此，在右边，如果我想给 printf 函数传递一个参数或输入，我就会使用开括号和关括号。

288
00:21:31,240 --> 00:21:37,460
然后，我在括号中输入我想在屏幕上打印的内容--在本例中，是 "你好，逗号，世界"。

289
00:21:37,460 --> 00:21:42,160
但请注意，我特意留出了一些空间，因为在 C 语言的世界里，你需要多敲几下键盘。

290
00:21:42,160 --> 00:21:52,100
任何时候，当你键入一些文本（用计算机科学术语来说，也就是一串文本）时，你都需要为其加注引号，这里是双引号。

291
00:21:52,100 --> 00:21:54,520
左边双引号，右边双引号。

292
00:21:54,520 --> 00:22:01,660
请注意，我在这里还加入了一个略带神秘色彩的符号--反斜杠 n，我之前也打了这个符号，并口头说过、

293
00:22:01,660 --> 00:22:05,480
最后还有一个麻烦的结尾，那就是分号。

294
00:22:05,480 --> 00:22:08,890
这就是我们从 Scratch 开始的原因。

295
00:22:08,890 --> 00:22:10,960
这样，拖放就可以了。

296
00:22:10,960 --> 00:22:16,630
在 C 语言中，printf、括号、双引号、所需文本、反斜杠 n、末尾的分号。

297
00:22:16,630 --> 00:22:18,970
语法开销太大了。

298
00:22:18,970 --> 00:22:21,290
但归根结底，这只是一种功能。

299
00:22:21,290 --> 00:22:27,130
你会习惯括号、引号、分号之类的麻烦。

300
00:22:27,130 --> 00:22:33,380
但事情很容易出错，即使是这样的代码行也很容易出错。

301
00:22:33,380 --> 00:22:34,190
那就让我来吧。

302
00:22:34,190 --> 00:22:37,070
让我回到 VS 代码，那里有完全相同的代码。

303
00:22:37,070 --> 00:22:40,910
请注意，第 5 行正是这一行代码。

304
00:22:40,910 --> 00:22:42,910
因此，这就相当于 "说 "字块。

305
00:22:42,910 --> 00:22:46,090
让我们考虑一下，在早期甚至现在，我可能会犯哪些错误

306
00:22:46,090 --> 00:22:49,930
20 年后，在了解到这一点后，这在一般情况下是很常见的。

307
00:22:49,930 --> 00:22:52,180
假如我忘了那里的分号。

308
00:22:52,180 --> 00:22:53,380
太简单了

309
00:22:53,380 --> 00:22:54,910
你最终会做到这一点。

310
00:22:54,910 --> 00:22:59,920
现在，让我们看看当我回到终端窗口，再次尝试编译代码时会发生什么。

311
00:22:59,920 --> 00:23:02,590
为了保持整洁，我要清空屏幕。

312
00:23:02,590 --> 00:23:06,460
但这只是为了便于讲课，以便我们只关注最近的命令。

313
00:23:06,460 --> 00:23:09,940
不过，我现在要去重新做一次 "你好"。

314
00:23:09,940 --> 00:23:13,690
这将确保我的程序被重新编译。

315
00:23:13,690 --> 00:23:14,950
而这是一个手动过程。

316
00:23:14,950 --> 00:23:16,060
我修改了代码。

317
00:23:16,060 --> 00:23:18,670
硬盘上的 0 和 1 没有变化。

318
00:23:18,670 --> 00:23:21,980
我需要重新编译，以输出最新的机器代码。

319
00:23:21,980 --> 00:23:22,580
那么，我们开始吧。

320
00:23:22,580 --> 00:23:24,830
我按下回车键，像以前一样祈祷。

321
00:23:24,830 --> 00:23:29,320
但我还是不小心把分号去掉了。

322
00:23:29,320 --> 00:23:29,980
我的天啊

323
00:23:29,980 --> 00:23:33,700
现在的错误行数比实际代码行数还多。

324
00:23:33,700 --> 00:23:35,770
这也需要一些时间来适应。

325
00:23:35,770 --> 00:23:42,760
我们所使用的程序并不一定是为最不舒适的受众编写的，而是真正为当年的专业程序员编写的。

326
00:23:42,760 --> 00:23:47,750
但通过实践、经验和错误，你也会开始注意到这里的规律。

327
00:23:47,750 --> 00:23:49,090
这就是我输入的内容。

328
00:23:49,090 --> 00:23:51,220
在手势提示后打招呼。

329
00:23:51,220 --> 00:23:57,010
现在我被骂的内容如下：hello.c、冒号、5、冒号、29。

330
00:23:57,010 --> 00:23:58,420
那是什么意思？

331
00:23:58,420 --> 00:24:03,460
我在第 5 行的第 29 个字符上弄错了。

332
00:24:03,460 --> 00:24:07,448
一般来说，除非你真的想把它算出来，否则特定人物并没有什么用处。

333
00:24:07,448 --> 00:24:08,630
但第 5 行是一个很好的线索。

335
00:24:09,130 --> 00:24:11,660
这说明我在第 5 行的某个地方出了差错。

337
00:24:12,160 --> 00:24:13,360
那么，错误出在哪里呢？

338
00:24:13,360 --> 00:24:16,242
希望在表达式后加上分号。

339
00:24:16,242 --> 00:24:20,103
这个错误其实很明显，现在我看到了，才意识到，哦，等等。

340
00:24:20,103 --> 00:24:21,520
好了，这是我的一行代码。

341
00:24:21,520 --> 00:24:30,550
在这里，可以说是 ASCII 艺术--文字文本代表图形--它要我在这一行的末尾加上绿色的分号。

342
00:24:30,550 --> 00:24:33,850
生成 1 个错误，内置错误--所以这里有一些深奥的东西。

343
00:24:33,850 --> 00:24:36,340
但我的程序无法编译。

344
00:24:36,340 --> 00:24:39,470
当您看到这样的错误时，说明它没有工作。

345
00:24:39,470 --> 00:24:40,360
有什么解决办法？

346
00:24:40,360 --> 00:24:45,470
显然，解决方法就是回到这里，在这里加上分号。

347
00:24:45,470 --> 00:24:48,760
现在，如果我用 make hello 重新编译代码--

348
00:24:48,760 --> 00:24:52,990
我现在还不会清除屏幕，只是想让你们看看我的不同之处--现在它就这样工作了。

349
00:24:52,990 --> 00:24:55,550
所以，我们又回到了从前。

350
00:24:55,550 --> 00:25:02,240
好吧，让我在这里暂停一下，问问大家对我刚才的发言是否有任何疑问。

351
00:25:02,240 --> 00:25:04,460
这些错误信息最初会变得很频繁。

353
00:25:04,960 --> 00:25:08,848
听众：那么，你是需要在行后加上分号，还是只需要其中的一部分？

354
00:25:08,848 --> 00:25:10,390
大卫-J-马兰：问得好。

355
00:25:10,390 --> 00:25:12,960
您是需要在每一行后面都加上分号，还是只需要在某些行后面加上分号？

356
00:25:12,960 --> 00:25:14,022
原来，只是一些。

357
00:25:14,022 --> 00:25:18,240
今天，你们将通过实践、演示和举例来学习这一点。

358
00:25:18,240 --> 00:25:22,810
一般来说，可以在语句后加上分号。

359
00:25:22,810 --> 00:25:25,230
这就是这行代码的专业术语。

360
00:25:25,230 --> 00:25:25,950
这是一个声明。

361
00:25:25,950 --> 00:25:29,230
把它想象成相当于英语句子的代码。

362
00:25:29,230 --> 00:25:34,830
因此，代码中的分号就像英语中的句号，表示你完成了特定的思考。

363
00:25:34,830 --> 00:25:37,650
在其他地方，"现在 "不需要分号。

364
00:25:37,650 --> 00:25:39,750
我们还会看到你把它们放在其他地方的例子。

365
00:25:39,750 --> 00:25:46,980
但通常是在一行代码的末尾，而不是像大括号那样纯粹的语法。

366
00:25:46,980 --> 00:25:51,600
关于我刚刚纠正并给自己造成的错误的其他问题？

369
00:25:55,170 --> 00:25:56,170
戴维-J-马兰：正确。

370
00:25:56,170 --> 00:25:58,950
因此，第 5 行最有可能出错。

371
00:25:58,950 --> 00:26:02,250
字符 29 表示 29 个字符。

372
00:26:02,250 --> 00:26:04,800
在这种情况下，它实际上是在给我一个建议。

373
00:26:04,800 --> 00:26:09,750
编译器并不总是知道如何给我建议，尤其是当我把代码弄得一团糟的时候。

374
00:26:09,750 --> 00:26:13,260
但通常情况下，它会尽力给你这样的答案。

376
00:26:14,170 --> 00:26:16,930
听众：你怎么会先写下 hello.c 代码？

377
00:26:16,930 --> 00:26:22,940
大卫-J-马兰：啊，那为什么我第一次输入的是代码，空格，hello.c，而现在我输入的是 make hello？

378
00:26:22,940 --> 00:26:24,180
两个不同的过程。

379
00:26:24,180 --> 00:26:31,280
因此，当我输入代码、空格、hello.c 时，是因为我想打开 VS Code 并创建一个名为 hello.c 的新文件。

380
00:26:31,280 --> 00:26:34,910
这就像在 Mac 或 PC 上打开 "文件"、"新建 "一样。

381
00:26:34,910 --> 00:26:42,560
此后，一旦文件存在并在这里打开，它就会自动保存，你就不需要一直按 Command-S 或 Control-S 了。

382
00:26:42,560 --> 00:26:46,110
现在我可以用 make hello 一次又一次地编译它。

383
00:26:46,110 --> 00:26:54,020
因此，从理论上讲，除非我想创建一个名为相同内容的全新文件，否则我应该永远不需要再键入代码、空格、hello.c。

384
00:26:54,020 --> 00:26:57,200
好吧，那么这里的另一段语法呢？

385
00:26:57,200 --> 00:26:58,790
让我清空一下终端窗口。

386
00:26:58,790 --> 00:27:03,380
你也可以按下 Control-L 键，把所有东西都扔掉，只是为了美观。

387
00:27:03,380 --> 00:27:11,460
假设我省略了反斜线 n 这一串符号，因为我一开始并不确定为什么要省略它。

388
00:27:11,460 --> 00:27:20,450
如果我重新编译并重新运行这个版本的程序，有谁想猜测一下，尤其是如果你以前从未编过程序，可能会发生什么情况？

389
00:27:20,450 --> 00:27:25,130
我保留了分号，但去掉了反斜线 n。

390
00:27:25,130 --> 00:27:28,390
有什么直觉吗？

391
00:27:28,390 --> 00:27:29,920
好吧

392
00:27:29,920 --> 00:27:34,190
听众：下一个美元符号会在你的 "你好，世界 "之后出现吗？

393
00:27:34,190 --> 00:27:35,190
戴维-J-马兰：会的。

394
00:27:35,190 --> 00:27:38,740
下一个美元符号将出现在 "你好，世界 "之后。

395
00:27:38,740 --> 00:27:40,564
但你为什么会这么想？

396
00:27:40,564 --> 00:27:43,010
听众：因为反斜杠 n 会产生新行？

397
00:27:43,010 --> 00:27:44,010
戴维-J-马兰：没错。

398
00:27:44,010 --> 00:27:48,060
反斜线 n 实际上是一个特殊的符号序列，用于创建新行。

399
00:27:48,060 --> 00:27:55,420
因此，就你的观点而言，如果我重新编译这个程序，让 hello, Enter -- 没有语法错误，所以这次编译成功了。

400
00:27:55,420 --> 00:27:57,180
因此不需要反斜杠 n。

401
00:27:57,180 --> 00:27:58,800
你确实需要分号。

402
00:27:58,800 --> 00:28:03,510
但如果没有反斜杠 n，请看我这次使用 ./hello 会发生什么。

403
00:28:03,510 --> 00:28:07,230
现在，我确实看到了 "你好"、"逗号"、"世界"，然后是一个奇怪的美元符号。

404
00:28:07,230 --> 00:28:08,460
这仍然是一个提示。

405
00:28:08,460 --> 00:28:12,270
我仍然可以输入命令，比如清除，一切都会被清理干净。

406
00:28:12,270 --> 00:28:13,710
但这看起来有点傻。

407
00:28:13,710 --> 00:28:18,240
如果我在这里用 ./hello 再运行一次，用户体验就会大打折扣。

408
00:28:18,240 --> 00:28:24,460
按照惯例，当你运行完程序后，最好清理一下，把光标移到用户的下一行。

409
00:28:24,460 --> 00:28:34,980
因此，反斜杠 n 只是一个特殊符号，也被称为转义序列，C 知道它表示将光标移到下一行。

410
00:28:34,980 --> 00:28:39,640
在其他语言中，Python 也使用同样的符号。

411
00:28:39,640 --> 00:28:44,850
现在，如果我回到这里的代码，例如

412
00:28:44,850 --> 00:28:47,220
我尝试用不同的方式来做这件事。

413
00:28:47,220 --> 00:28:49,020
假设我不加反斜线 n。

414
00:28:49,020 --> 00:28:52,860
我只是像正常人在谷歌文档或微软 Word 中一样按下回车键。

415
00:28:52,860 --> 00:28:55,107
让我继续尝试编译这个程序。

416
00:28:55,107 --> 00:28:56,940
你希望这样做能奏效，对吗？

417
00:28:56,940 --> 00:29:02,220
你会希望它能打印出 hello, world（你好，世界），然后是一行空白，因为我把光标移到了下一行。

419
00:29:02,790 --> 00:29:07,290
如果我运行 make hello now 并尝试编译，C 语言并不喜欢这样。

420
00:29:07,290 --> 00:29:17,070
现在，我又遇到了一个不同的错误，还是在第 5 行，这次是从第 12 个字符开始的--错误，缺少终止双引号字符，然后是一些其他深奥的东西。

421
00:29:17,070 --> 00:29:21,900
然后，这听起来不太妙--这次出现了致命错误，发出了太多错误，现在停止。

422
00:29:21,900 --> 00:29:23,470
所以我真的搞砸了。

423
00:29:23,470 --> 00:29:25,320
那么，为什么我不能这样做呢？

424
00:29:25,320 --> 00:29:26,190
只是因为

425
00:29:26,190 --> 00:29:31,380
设计 C 语言的人认为，如果有一串文本，就必须保持在同一行上。

426
00:29:31,380 --> 00:29:32,760
它可能会变得很长。

427
00:29:32,760 --> 00:29:36,150
它可以软包，也就是说，不需要按回车键。

428
00:29:36,150 --> 00:29:38,220
但你不能按回车键来创建新行。

429
00:29:38,220 --> 00:29:43,958
如果故意要换行，就必须使用反斜杠 n 转义字符。

430
00:29:43,958 --> 00:29:45,250
所以，让我来做这件事吧。

431
00:29:45,250 --> 00:29:46,710
让我把它放回去。

432
00:29:46,710 --> 00:29:48,720
让我回到终端窗口。

433
00:29:48,720 --> 00:29:50,080
我再清理一下屏幕。

434
00:29:50,080 --> 00:29:54,090
现在，让我继续 make hello，重新编译到该版本-- ./hello。

436
00:29:54,900 --> 00:29:57,780
你好，我们又开始工作了。

437
00:29:57,780 --> 00:30:04,920
好了，现在让我们来分析一下这段代码的其他方面，因为光是在屏幕上说 "你好，世界 "就有很多事情要做。

438
00:30:04,920 --> 00:30:10,145
今天，我们将忽略 int main(void) 和这些大括号。

439
00:30:10,145 --> 00:30:12,520
至于为什么会有这个问题，我们很快就会说到。

440
00:30:12,520 --> 00:30:19,180
不过，现在只需把 int main(void) 和这些大括号看作是点击绿旗时的 C 语言。

442
00:30:19,680 --> 00:30:20,638
你只需要它在那里。

443
00:30:20,638 --> 00:30:22,320
这样才能让你的计划顺利进行。

444
00:30:22,320 --> 00:30:26,340
主系统确实会有一些特殊的功能，但下次再说吧。

445
00:30:26,340 --> 00:30:28,950
但我为什么要在这里写这行代码呢？

446
00:30:28,950 --> 00:30:33,990
正确的拼写确实是 stdio.h，即 S-T-D-I-O dot H。

447
00:30:33,990 --> 00:30:37,500
而且这次是有角度的支架，有点新意。

448
00:30:37,500 --> 00:30:40,290
有一个哈希值，然后是一个包含关键字。

449
00:30:40,290 --> 00:30:45,165
如果你不知道那是什么东西，把它扔掉看看会发生什么也没什么坏处。

450
00:30:45,165 --> 00:30:46,360
所以，请允许我删除这一行。

451
00:30:46,360 --> 00:30:50,160
让我回到终端窗口，清空屏幕，然后再次运行 make hello。

452
00:30:50,160 --> 00:30:53,290
现在让我们试着编译这个没有第一行的程序。

454
00:30:53,790 --> 00:30:56,340
我不明白，让我们拭目以待吧。

455
00:30:56,340 --> 00:31:09,150
好吧，这又是一个错误，但让我们看看，hello.c 第 5 行，第 5 个字符--所以这是很早期的错误，隐式声明了类型为 int 的库函数 printf，然后是 dot、dot、dot。

456
00:31:09,150 --> 00:31:14,490
因此，隐式声明库函数 printf -- 所以这听起来非常隐晦。

457
00:31:14,490 --> 00:31:16,920
你会更好地理解这些短语。

458
00:31:16,920 --> 00:31:22,620
但显然，我确实需要 stdio.h 的 include 行。

460
00:31:23,820 --> 00:31:33,330
根据这一症状，你直觉第一行代码首先要为我们做什么？

461
00:31:33,330 --> 00:31:35,370
为什么直觉上它必须存在？

462
00:31:35,370 --> 00:31:37,290
听众：这就是[听不清]的功能。

463
00:31:37,290 --> 00:31:38,290
戴维-J-马兰：没错。

464
00:31:38,290 --> 00:31:42,137
这就像导入一个资料库，这样你就可以在屏幕上打印东西了。

465
00:31:42,137 --> 00:31:45,220
在 Scratch 中，大部分拼图都不需要这样做。

466
00:31:45,220 --> 00:31:47,950
但你可能还记得，在第 0 周的中途、

467
00:31:47,950 --> 00:31:59,170
我点击了 Scratch 屏幕左下方的扩展按钮，并为文本转语音导入了一些额外的拼图片段，这样我们就能听到令人毛骨悚然的人性化语音了。

468
00:31:59,170 --> 00:32:00,100
猫的嘴。

469
00:32:00,100 --> 00:32:04,390
这就像是添加了一个库--别人写的代码。

470
00:32:04,390 --> 00:32:06,550
在这种情况下，它是第三方。

471
00:32:06,550 --> 00:32:08,380
但我让自己接触到了它。

473
00:32:09,250 --> 00:32:13,900
原来，在 C 语言中并不能自动获得 printf。

474
00:32:13,900 --> 00:32:20,020
您必须包含一个所谓的头文件，声明该函数的存在。

475
00:32:20,020 --> 00:32:22,570
现在，历史上这样做的原因只是效率问题。

476
00:32:22,570 --> 00:32:30,610
在电脑运行速度较慢、资源有限的年代，你不会想让自己使用整个厨房水槽的所有功能。

477
00:32:30,610 --> 00:32:34,690
您只想包含您真正关心的功能。

478
00:32:34,690 --> 00:32:42,680
如今，这是一个复制/粘贴步骤，因为你几乎总是想在屏幕上打印出一些东西，至少在编写类似程序时是这样。

479
00:32:42,680 --> 00:32:50,350
但这些所谓的头文件包含了所谓标准 I/O 库中所有函数的足够信息。

480
00:32:50,350 --> 00:32:53,450
而标准 I/O 只是指标准输入和输出。

481
00:32:53,450 --> 00:32:54,700
这样做合适吗？

482
00:32:54,700 --> 00:32:57,010
因为打印是非常基本的输出。

483
00:32:57,010 --> 00:33:01,310
原来，从人类键盘获取输入信息还有其他功能--稍后再详述。

484
00:33:01,310 --> 00:33:07,630
但是，如果您想用 C 语言在屏幕上打印某些内容，您确实需要在代码的顶部包含这个头文件。

485
00:33:07,630 --> 00:33:11,350
这基本上是在通知编译器，嘿，编译器、

486
00:33:11,350 --> 00:33:18,320
我想使用标准 I/O 库的功能，包括本例中的 printf。

487
00:33:18,320 --> 00:33:24,040
如果你不小心省略了头文件，它将无法工作，因为它不知道 printf 是什么。

488
00:33:24,040 --> 00:33:27,970
在这种情况下，这是一些不被认可的符号。

489
00:33:27,970 --> 00:33:37,590
好吧，那么，关于这行代码、这行代码或这些头文件的问题是什么？

490
00:33:37,590 --> 00:33:40,890
好吧，你可能会问，那你怎么知道存在哪些功能呢？

491
00:33:40,890 --> 00:33:43,990
您如何知道您可能真的想要包含哪些文件？

492
00:33:43,990 --> 00:33:48,720
事实证明，C 语言是一门历史悠久的语言，它有大量的文档资料。

493
00:33:48,720 --> 00:33:52,770
需要注意的是，它的文档并不一定对用户那么友好。

494
00:33:52,770 --> 00:34:01,680
不过，我们为课程提供的是 C 语言官方文档的简化版，该文档的网址是 manual.cs50.io。

495
00:34:01,680 --> 00:34:06,150
因此，在 C 语言和其他语言的世界里，都有所谓的手动页面。

496
00:34:06,150 --> 00:34:14,560
老实说，这些只是基于文本的文档，通常是用一种你必须是一个经验丰富的程序员才能理解的语气写成的。

497
00:34:14,560 --> 00:34:24,074
因此，我们在这一版本的相同文档中的做法是，我们导入了所有原始的官方文档，但我们添加了不太流畅的英文翻译版本

498
00:34:24,074 --> 00:34:27,713
你在课堂上可能会用到的很多功能，只是为了帮助你入门。

499
00:34:27,713 --> 00:34:30,630
因此，从长远来看，您并不需要这些文件。

500
00:34:30,630 --> 00:34:39,969
不过，为了方便起见，我们还是把它翻译成你可能会欣赏的术语，比如说，从一个助教那里，而不是从这些文件的原作者那里。

501
00:34:39,969 --> 00:34:52,830
例如，如果你想了解 stdio.h 文件中有哪些函数，你可以访问这样的 URL，或者在 manual.cs50.io 上搜索。

502
00:34:52,830 --> 00:34:58,350
这将显示该函数库中所有可用函数的列表，并打印是否确实是其中之一。

503
00:34:58,350 --> 00:35:04,110
然后，你可以进一步点击，找到这样一个 URL，它将为你提供如何使用 printf 的所有文档。

504
00:35:04,110 --> 00:35:07,560
事实证明，除了打印 "你好，世界"，你还可以做更多。

505
00:35:07,560 --> 00:35:09,450
我们今天就来浅谈一下。

506
00:35:09,450 --> 00:35:18,160
但事实证明，对于 "我能做什么，怎么做？"这样的问题，文档始终是您的权威来源。

507
00:35:18,160 --> 00:35:25,980
同时，CS50 有自己的库，可以通过名为 cs50.h 的头文件访问。

508
00:35:25,980 --> 00:35:34,110
事实证明，在 C 语言中，一旦你习惯了所有的大括号、小括号、引号等，相对而言，输出实际上是非常容易的。

509
00:35:34,110 --> 00:35:36,670
但输入就比较困难了。

510
00:35:36,670 --> 00:35:41,100
如果你以前学过编程，用 Python 输入并不难。

511
00:35:41,100 --> 00:35:42,540
在 Java 中做到这一点并不难。

512
00:35:42,540 --> 00:35:46,312
我们几周后就会知道原因。

513
00:35:46,312 --> 00:35:56,430
但在课程的前几周，我们实际上为你提供了一些类似于 "训练轮 "的东西，我们在 cs50.h 文件中声明了一些函数。

514
00:35:56,430 --> 00:35:59,220
它的文档存放在这样一个 URL 上。

515
00:35:59,220 --> 00:36:01,230
稍后，我们将使用其中的几种。

516
00:36:01,230 --> 00:36:11,790
您会看到 CS50 为您提供了一些函数，如 get_char 用于从用户键盘上获取一个字符，get_int 用于从用户键盘上获取一个整数、

517
00:36:11,790 --> 00:36:16,930
get_string，从用户键盘上获取文本序列，以及其他一些函数。

518
00:36:16,930 --> 00:36:26,710
那么，让我们实际使用一下这些函数吧，重温一下我们上次用 Scratch 写的第二个程序，在输出中添加一些输入，怎么样？

519
00:36:26,710 --> 00:36:28,830
因此，Scratch 的第一个版本只是 hello, world。

520
00:36:28,830 --> 00:36:31,200
每次点击绿旗时都说同样的话。

521
00:36:31,200 --> 00:36:33,180
不过，回顾第 2 版，它做到了这一点。

522
00:36:33,180 --> 00:36:35,190
它问用户：你叫什么名字？

523
00:36:35,190 --> 00:36:40,870
然后，以某种方式返回一个返回值，我们称之为 "返回值"。

524
00:36:40,870 --> 00:36:46,420
然后，我们把 "你好 "和 "这个名字 "连在一起，在屏幕上说一些更有趣的话。

525
00:36:46,420 --> 00:36:48,420
那么，这个模型是什么样的呢？

526
00:36:48,420 --> 00:36:49,560
还是老样子。

527
00:36:49,560 --> 00:36:54,480
中间有一个函数，这个函数就像是我们算法的代码实现。

528
00:36:54,480 --> 00:37:00,000
这需要一个或多个参数，比如你最终想在屏幕上说些什么？

529
00:37:00,000 --> 00:37:03,580
在这种情况下，返回值实际上是一个返回值。

530
00:37:03,580 --> 00:37:08,490
因此，在征求意见的情况下，我们可以像上周一样，再次考虑这个问题块。

531
00:37:08,490 --> 00:37:12,420
输入的内容就是你想问用户的任何英语单词。

532
00:37:12,420 --> 00:37:14,670
然后返回一个值。

533
00:37:14,670 --> 00:37:17,550
而在 MIT 的世界答案中，这是默认调用的。

534
00:37:17,550 --> 00:37:22,300
但我们会看到，在 C 语言中，你可以在变量中任意调用这些返回值。

535
00:37:22,300 --> 00:37:24,100
但这不同于副作用。

536
00:37:24,100 --> 00:37:28,980
副作用是指屏幕上经常出现的视觉效果，如语音气泡或你好，世界。

537
00:37:28,980 --> 00:37:34,020
返回值实际上是从函数中返回的值，可以使用或重复使用。

538
00:37:34,020 --> 00:37:38,400
那么，本周如何将上周的 Scratch 代码块转换为 C 代码呢？

539
00:37:38,400 --> 00:37:42,580
如果您想询问用户姓名之类的信息，可以这样做。

540
00:37:42,580 --> 00:37:45,600
您使用的是 CS50 函数 get_string。

541
00:37:45,600 --> 00:37:49,950
你还可以用括号来表示这里是输入，那里也是输入。

542
00:37:49,950 --> 00:37:54,300
然后，您就可以输入您想问用户的句子--引号/非引号，您叫什么名字？

543
00:37:54,300 --> 00:37:57,150
但在 C 语言中确实需要引号。

544
00:37:57,150 --> 00:37:59,220
因此，我也会继续添加这些内容。

545
00:37:59,220 --> 00:38:08,998
虽然很微妙，但我还是特意在问号之后、双引号之前加了一个空格，这样光标就会移动一步，因为在这种情况下、

546
00:38:08,998 --> 00:38:11,790
我们不会像在 Scratch 中那样得到一个特殊的语音框。

547
00:38:11,790 --> 00:38:19,800
光标会留在原处，所以我们会看到，从美学角度看，它只是将闪烁的光标在屏幕上的句子后移动了一个空格。

548
00:38:19,800 --> 00:38:27,180
好吧，但问题是，使用 Scratch 时，我们会自动将用户的答案存储在一个名为 "答案 "的特殊变量中。

549
00:38:27,180 --> 00:38:30,270
在 C 语言中，你必须说得更具体一些。

550
00:38:30,270 --> 00:38:40,420
在 C 语言中，如果要从函数（如 get_string）中获取返回值，必须使用等号，然后在左边输入变量名。

551
00:38:40,420 --> 00:38:42,280
变量的选择由您决定。

552
00:38:42,280 --> 00:38:44,290
我可以给它起任何名字--X、Y、Z。

553
00:38:44,290 --> 00:38:47,470
我更愿意将其描述为 "回答 "与 "什么 "之间的 "平等"。

554
00:38:47,470 --> 00:38:48,880
麻省理工学院用 Scratch 做到了这一点。

555
00:38:48,880 --> 00:38:53,090
但请注意，这本身并不代表平等。

556
00:38:53,090 --> 00:38:55,640
这就是本案中的任务。

557
00:38:55,640 --> 00:39:03,590
因此，在 C 语言中，当您使用单个等号时，意味着将右边的值复制到左边的值上--从右到左。

558
00:39:03,590 --> 00:39:05,390
这对我们有什么好处？

559
00:39:05,390 --> 00:39:14,750
好吧，如果 get_string 是一个提示用户 "引号/非引号，你叫什么名字 "的函数，而且我声称它有一个返回值，那就意味着它把一些值交还给了我。

560
00:39:14,750 --> 00:39:17,960
但如何利用这些价值，则取决于 C 语言中的我。

561
00:39:17,960 --> 00:39:21,520
因此，如果我想将该值复制到一个变量中，以便使用和重复使用、

562
00:39:21,520 --> 00:39:27,340
我使用了等号，并在等号的左侧编造了我想要的任何变量名。

563
00:39:27,340 --> 00:39:28,450
有一定的规则。

564
00:39:28,450 --> 00:39:29,700
有一些惯例。

565
00:39:29,700 --> 00:39:34,570
但一般来说，如果使用全小写的单词，情况就会很好。

566
00:39:34,570 --> 00:39:37,040
但 C 比这更迂腐。

567
00:39:37,040 --> 00:39:43,330
以前学过编程的人可能不习惯这样做，比如在 Python 中，我们将在几周后进入这个世界。

568
00:39:43,330 --> 00:39:48,670
您还必须告诉 C 您要存储的值的类型。

569
00:39:48,670 --> 00:39:55,270
因此，如果我确实需要用户提供一串文本，那么不是整数，也不是单个字符。

570
00:39:55,270 --> 00:39:59,270
我想要一整串文本，比如一个短语、一个句子、一个名字，在这种情况下 --

571
00:39:59,270 --> 00:40:04,250
我必须告诉 C，这个变量的类型是字符串。

572
00:40:04,250 --> 00:40:06,267
所以有点啰嗦，但你会习惯的。

573
00:40:06,267 --> 00:40:07,600
你只需做到准确无误。

574
00:40:07,600 --> 00:40:12,760
你要告诉计算机这个变量中的值是什么类型的。

575
00:40:12,760 --> 00:40:19,210
好吧，就差一点就对了，但我还是漏掉了一些重要的东西，让人很恼火。

576
00:40:19,210 --> 00:40:20,470
还缺什么？

578
00:40:21,070 --> 00:40:21,970
观众：分号？

579
00:40:21,970 --> 00:40:23,178
戴维-J-马兰：所以是分号。

580
00:40:23,178 --> 00:40:24,230
这是一份声明。

581
00:40:24,230 --> 00:40:27,040
如果你愿意，这就像是一个完整的思想。

582
00:40:27,040 --> 00:40:31,680
在 "代码 "中，我确实需要用结尾的分号来结束它。

583
00:40:31,680 --> 00:40:35,720
好了，虽然说起来比较费劲，但让我们试着在我的代码中使用它。

584
00:40:35,720 --> 00:40:40,250
让我回到 VS 代码，这里有我的代码的第 0 版。

585
00:40:40,250 --> 00:40:51,370
让我继续在 hello.c 的顶部包含另一个文件，即 include cs50.h，这样我就可以访问 get_string 和其他我可能需要的文件了。

586
00:40:51,370 --> 00:40:56,710
现在，让我在大括号内添加一行代码。

587
00:40:56,710 --> 00:41:04,847
让我继续这么做--字符串 answer 等于 get_string、quote/unquote、what's your name、问号。

588
00:41:04,847 --> 00:41:07,180
我要在双引号前多加一个空格。

589
00:41:07,180 --> 00:41:10,430
我确实要用分号来结束我的想法。

590
00:41:10,430 --> 00:41:14,260
现在，请允许我故意犯一个错误，以说明问题。

591
00:41:14,260 --> 00:41:19,840
现在让我尝试将 hello, world 改为 hello, comma, answer。

592
00:41:19,840 --> 00:41:24,520
现在，尽管这是几行新代码，但也许你已经能看出我在哪些地方出错了。

593
00:41:24,520 --> 00:41:26,980
不过，让我现在试着制作这个程序吧。

594
00:41:26,980 --> 00:41:27,970
到目前为止，一切顺利。

595
00:41:27,970 --> 00:41:29,120
因此没有错误信息。

596
00:41:29,120 --> 00:41:30,140
所以这是件好事。

597
00:41:30,140 --> 00:41:34,000
让我继续运行 ./hello，你会看到提示。

598
00:41:34,000 --> 00:41:35,650
你叫什么名字 问号

599
00:41:35,650 --> 00:41:43,600
注意，光标确实向右移了一个空格，这是因为我觉得在那里留一个小空格会更漂亮，而不是把它留在问号后面。

600
00:41:43,600 --> 00:41:44,530
让我输入我的名字。

601
00:41:44,530 --> 00:41:48,340
但是，即使你以前从未做过编程，我也在这里搞砸了。

602
00:41:48,340 --> 00:41:51,240
按下回车键后，屏幕上会出现什么？

603
00:41:51,240 --> 00:41:52,240
听众：你好，请回答。

604
00:41:52,240 --> 00:41:53,115
是的。

605
00:41:53,115 --> 00:41:54,280
你好，请回答，很有可能。

607
00:41:54,730 --> 00:41:56,855
因为电脑会从字面上理解我。

608
00:41:56,855 --> 00:41:59,020
如果我说 "你好"，请回答。

609
00:41:59,020 --> 00:42:03,260
这就是要输出到屏幕上的文本字符串，后面跟着一行新的字符。

610
00:42:03,260 --> 00:42:08,530
因此，我们需要用某种方法将答案输入这行代码。

611
00:42:08,530 --> 00:42:14,140
这并不像从头开始那样简单，你可以直接抓取第二个 say 块，然后将变量拖放到那里。

612
00:42:14,140 --> 00:42:15,670
实际上，我们需要一种新的语法。

613
00:42:15,670 --> 00:42:22,900
起初看起来很奇怪，但如今在软件中随处可见，尤其是在 C 语言和某些其他语言的世界中。

614
00:42:22,900 --> 00:42:27,610
因此，请允许我提出如下解决方案。

615
00:42:27,610 --> 00:42:32,350
记得我们用 Scratch 做这个的时候，最优雅的解决方案是这样的。

616
00:42:32,350 --> 00:42:36,550
我们仍然使用了 say 块，它与今天的 printf 类似。

617
00:42:36,550 --> 00:42:43,340
但我使用连接拼图和 Scratch 将 hello、逗号、空格和人类的名字组合在一起。

618
00:42:43,340 --> 00:42:45,790
那么，我们如何将这些代码翻译成 C 语言呢？

619
00:42:45,790 --> 00:42:47,830
现在看起来有点不一样了。

620
00:42:47,830 --> 00:42:53,530
我将从 printf 开始，用一些括号和一个分号代表 say 块。

621
00:42:53,530 --> 00:42:55,240
但我现在该如何加入呢？

622
00:42:55,240 --> 00:42:58,330
这就是拼图没有完美转换的地方。

623
00:42:58,330 --> 00:43:00,290
这将是实现这一目标的方法。

624
00:43:00,290 --> 00:43:03,430
输入 hello、逗号和占位符。

625
00:43:03,430 --> 00:43:07,810
这就是 C 语言中的格式代码，专门用于 printf。

626
00:43:07,810 --> 00:43:11,350
它只是表示这是一个字符串的占位符。

627
00:43:11,350 --> 00:43:12,740
同样，字符串只是文本。

628
00:43:12,740 --> 00:43:23,903
因此，这意味着，嘿，电脑，打印出字面意思，你好，逗号，空格，然后不是字面意思 %s。%s 被特殊处理，表示在这里输入某个值。

629
00:43:23,903 --> 00:43:25,570
好吧，我还需要什么？

630
00:43:25,570 --> 00:43:32,460
好吧，这仍然是一些文字，所以我还是要用双引号把它包围起来。

631
00:43:32,460 --> 00:43:37,870
为了保持整洁和将光标移到下一行，我仍然要使用反斜线 n。

632
00:43:37,870 --> 00:43:45,120
因此，C 语言的最后一步是以某种方式将答案与单词 hello 连接起来。

633
00:43:45,120 --> 00:43:51,000
而实现这一功能的方法就是使用 printf，不传递一个参数，这也是我一直在做的。

634
00:43:51,000 --> 00:43:53,820
我一直在给它传递一串文本，引号/非引号。

635
00:43:53,820 --> 00:44:02,760
我现在要添加一个逗号，然后输入我希望 printf 返回并插入 %s 的值的名称。

636
00:44:02,760 --> 00:44:04,410
而 printf 在这方面就很聪明。

637
00:44:04,410 --> 00:44:10,980
如果在逗号后有一个 %s 和一个附加参数，它就会从右向左插入。

638
00:44:10,980 --> 00:44:16,470
如果逗号后有两个 %s 和两个变量，也没关系。

639
00:44:16,470 --> 00:44:22,380
如果用逗号分隔，就会将第一个变量插入第一个 %s 中，将第二个变量插入第二个 %s 中。

640
00:44:22,380 --> 00:44:24,750
因此，操作顺序就是从左至右。

641
00:44:24,750 --> 00:44:30,302
虽然没有这么漂亮或简单，但 C 语言就是这么做的。

642
00:44:30,302 --> 00:44:32,760
好吧，让我暂停一下，因为这里面有很多符号。

643
00:44:32,760 --> 00:44:35,080
有关于这项技术的问题吗？

645
00:44:35,580 --> 00:44:39,725
听众：为什么在上一节中不使用反斜杠 n？

646
00:44:39,725 --> 00:44:41,600
大卫-J-马兰：是的，一个非常好的问题。

647
00:44:41,600 --> 00:44:45,550
我刚才为什么要把反斜杠 n 排除在外？

648
00:44:45,550 --> 00:44:48,280
真的，如果你愿意，这只是我的审美观。

649
00:44:48,280 --> 00:44:49,760
除此之外，没有其他充分的理由。

650
00:44:49,760 --> 00:44:54,460
因此，如果我回过头来看我的代码，你就会正确地发现，我的代码中没有反斜杠 n。

651
00:44:54,460 --> 00:44:57,400
这只是因为，不管我有什么风格、

652
00:44:57,400 --> 00:45:00,460
我希望在问题之后输入姓名。

653
00:45:00,460 --> 00:45:04,030
我完全可以在这里加一个反斜杠，而不是空格。

654
00:45:04,030 --> 00:45:06,490
这样我就可以在下面打字了。

655
00:45:06,490 --> 00:45:07,490
完全没问题

656
00:45:07,490 --> 00:45:09,670
只是想给你看点不一样的东西。

657
00:45:09,670 --> 00:45:10,210
接得好

659
00:45:10,660 --> 00:45:12,070
听众：你能举出一个有两个 %s 的例子吗？

660
00:45:12,070 --> 00:45:14,470
戴维-J-马兰：我能举一个有两个%的例子吗？

662
00:45:15,250 --> 00:45:17,570
因此，让我在 VS 代码中这样做。

663
00:45:17,570 --> 00:45:20,050
让我清空终端窗口，清理一下。

664
00:45:20,050 --> 00:45:21,170
让我来吧

665
00:45:21,170 --> 00:45:26,080
与其到处调用变量答案，不如让我先调用它。

666
00:45:26,080 --> 00:45:27,490
我要问两个问题。

667
00:45:27,490 --> 00:45:28,880
你叫什么名字？

668
00:45:28,880 --> 00:45:41,720
现在让我做字符串 last 等于 get_string--哎呀，大写字母很重要，让我把大写字母 S 改一下--引号/非引号、你姓什么、问号、分号。

669
00:45:41,720 --> 00:45:47,320
现在我们输入一个 %s 和第二个 %s。

670
00:45:47,320 --> 00:45:52,720
巧合的是，我现在要输入第一个第一个和最后一个最后一个。

671
00:45:52,720 --> 00:45:55,240
现在我要回到终端窗口。

672
00:45:55,240 --> 00:46:00,280
打招呼--祈祷一切顺利--./你好。

673
00:46:00,280 --> 00:46:02,620
这是我的第一个问题，大卫。

674
00:46:02,620 --> 00:46:04,240
这是我的第二个问题，马兰。

676
00:46:05,650 --> 00:46:06,670
你好，大卫-马兰。

677
00:46:06,670 --> 00:46:08,440
因此，它只是从左到右插入。

678
00:46:08,440 --> 00:46:12,670
不过，我所做的一切都是为了与 Scratch 保持一致--让我继续再撤消一次。

679
00:46:12,670 --> 00:46:15,130
我再回去回答，就像这样。

680
00:46:15,130 --> 00:46:17,800
我还是只问名字吧。

681
00:46:17,800 --> 00:46:19,300
我要删除最后一次提及。

682
00:46:19,300 --> 00:46:21,520
我将删除提及的第二个 %s。

683
00:46:21,520 --> 00:46:27,720
现在如果我重新编译这个更简单的版本，哦，我确实搞砸了--不是故意的。

684
00:46:27,720 --> 00:46:29,220
我做错了什么？

685
00:46:29,220 --> 00:46:31,353
听众：你忘了改第 7 行的第一行。

686
00:46:31,353 --> 00:46:33,270
戴维-J-马兰：是的，所以只是新手的错误。

687
00:46:33,270 --> 00:46:39,610
因此，为了与第 0 周保持一致，我把变量改回了答案，但这里没有改动。

688
00:46:39,610 --> 00:46:42,750
因此，我首先使用了未声明的标识符。

689
00:46:42,750 --> 00:46:46,470
它是未声明的，因为我在前一行声明了答案。

690
00:46:46,470 --> 00:46:47,950
我没有先申报。

691
00:46:47,950 --> 00:46:51,060
所以，凭直觉，我确实想把它改成这样。

692
00:46:51,060 --> 00:46:56,740
现在让我再打一次招呼，./hello，这次只输入我的名字。

693
00:46:56,740 --> 00:46:59,400
这就是了 你好 大卫

694
00:46:59,400 --> 00:47:02,220
有问题吗？

697
00:47:04,608 --> 00:47:06,150
啊，占位者 --

698
00:47:06,150 --> 00:47:09,240
我放大一下 - - 只是一个百分点，然后是一个 s。

699
00:47:09,240 --> 00:47:23,400
因此，这里的字符串内部是 %s，然后我在引号外加了一个逗号，然后是我要为 %s 输入值的变量名称。

700
00:47:23,400 --> 00:47:30,300
注意，第 7 行的括号内有两个逗号。

701
00:47:30,300 --> 00:47:37,290
然而，我认为 printf 目前只接受两个参数。

702
00:47:37,290 --> 00:47:41,582
为什么有两个逗号却只有两个参数？

703
00:47:41,582 --> 00:47:45,700
如果有两个逗号，你会认为会有三个论点，对吗？

704
00:47:45,700 --> 00:47:49,700
逗号在引号之间逗号在引号之间，所以算作逗号。

705
00:47:49,700 --> 00:47:50,700
戴维-J-马兰：没错。

706
00:47:50,700 --> 00:47:53,160
引号之间的逗号只是英语中的一种用法。

707
00:47:53,160 --> 00:47:55,240
这是把 "你好 "和 "名字 "分开。

708
00:47:55,240 --> 00:48:05,580
因此，这就是为什么它不仅要加引号，而且像 VS Code 这样的程序还倾向于用不同的语法高亮显示它，以便让你觉得它与众不同、

709
00:48:05,580 --> 00:48:10,830
尽管在这种情况下，它有点微妙--淡蓝色与白色的对比--但它确实在尽力而为。

710
00:48:10,830 --> 00:48:13,150
关于这个占位符的其他问题？

712
00:48:13,650 --> 00:48:21,943
听众：如果你想在最后加上一个感叹号，是在答案变量后面加上逗号，还是要另起一行？

713
00:48:21,943 --> 00:48:23,360
大卫-J-马兰：啊，问得好。

714
00:48:23,360 --> 00:48:28,230
如果我想在名字后面添加一个感叹号，是否还需要添加另一个占位符等等？

715
00:48:28,230 --> 00:48:29,980
实际上，我可以做得更简单。

716
00:48:29,980 --> 00:48:33,610
我可以把感叹号放在百分号后面。

717
00:48:33,610 --> 00:48:35,830
我本身并不需要额外的占位符。

718
00:48:35,830 --> 00:48:45,580
如果我现在放大并再次运行 hello、./hello，然后只输入我的名字--没有感叹号--现在你会更兴奋地看到，hello、逗号、David。

719
00:48:45,580 --> 00:48:46,510
所以 printf 很聪明。

720
00:48:46,510 --> 00:48:51,400
它会找出 %s 所在的位置，然后去替换它。

721
00:48:51,400 --> 00:49:01,240
现在，我想说的是，编程中的一个普遍现象是，当我们决定如何设计某个东西时，往往会把自己逼入绝境，后悔当初的决定。

722
00:49:01,240 --> 00:49:11,680
有谁能想到在这个字符串中使用 %s 作为占位符来 printf 会产生什么问题吗？

723
00:49:11,680 --> 00:49:14,635
如果我们以这种特殊的方式使用百分数，会出什么问题呢？

725
00:49:16,775 --> 00:49:17,650
是的。

726
00:49:17,650 --> 00:49:20,320
如果你真的想说，不管出于什么奇怪的原因、

727
00:49:20,320 --> 00:49:23,245
屏幕上的 %s -- 老实说，哪怕只有一个 %。

728
00:49:23,245 --> 00:49:29,650
原来，printf 字符串中的百分号是特殊处理的。

729
00:49:29,650 --> 00:49:31,460
那么，这里有什么解决办法呢？

730
00:49:31,460 --> 00:49:34,690
解决类似问题有不同的模式。

731
00:49:34,690 --> 00:49:40,990
但假设你想说，比如说，我得到了 100%。

732
00:49:40,990 --> 00:49:43,480
让我来彻底改变一下。

733
00:49:43,480 --> 00:49:47,290
所以，我在你的测试中得到了 100%的分数。

734
00:49:47,290 --> 00:49:50,860
好了，让我先去打个招呼，回车。

735
00:49:50,860 --> 00:49:52,950
好了，转换指定符无效。

736
00:49:52,950 --> 00:49:57,410
我的意思是，我不知道这意味着什么，但它强调百分号是有问题的。

737
00:49:57,410 --> 00:50:00,730
原来，人类早在几年前就决定，唉，好吧，该死的。

738
00:50:00,730 --> 00:50:01,615
我们已经使用了 %。

739
00:50:01,615 --> 00:50:04,990
那么，两个百分号就意味着一个百分号，真的。

740
00:50:04,990 --> 00:50:09,727
所以，现在如果我重新运行 make hello、aha、./hello，就能得到 100% 的结果。

741
00:50:09,727 --> 00:50:15,190
因此，老实说，有些事情你必须去问别人，你必须去 Google，你必须去文档中查找。

742
00:50:15,190 --> 00:50:17,840
但这类问题总有解决的办法。

743
00:50:17,840 --> 00:50:19,930
值得庆幸的是，这种情况并不常见。

745
00:50:21,230 --> 00:50:22,360
哦，只是说说而已。

746
00:50:22,360 --> 00:50:23,060
还有其他问题吗？

748
00:50:23,560 --> 00:50:27,622
听众：所以，如果你有多个[听不清]

749
00:50:27,622 --> 00:50:31,380
DAVID J. MALAN：如果你有多个变量，那就是按左右顺序排列的。

750
00:50:31,380 --> 00:50:35,520
因此，printf 会分析你在引号之间传递的第一个文本字符串。

751
00:50:35,520 --> 00:50:41,207
无论第一个 % 是什么，逗号后传入的第一个变量都会被插入其中。

752
00:50:41,207 --> 00:50:44,832
然后，第二个连接到第二个、第三个，再连接到第三个，以此类推。

753
00:50:44,832 --> 00:50:47,130
因此，它只是基于从左到右。

755
00:50:48,220 --> 00:50:50,760
听众：这更像是一个澄清问题。

756
00:50:50,760 --> 00:50:52,453
%s 到底是什么意思？

757
00:50:52,453 --> 00:50:54,120
戴维-J-马兰：这只是一个占位符。

758
00:50:54,120 --> 00:50:59,070
它被称为格式代码，通俗地说，就是在这里输入某个值。

759
00:50:59,070 --> 00:51:04,560
而 printf -- 几十年前编写 printf 的人类决定对 %s 进行特殊处理。

761
00:51:04,890 --> 00:51:05,490
只是因为

762
00:51:05,490 --> 00:51:06,900
他们需要一些占位者。

763
00:51:06,900 --> 00:51:10,110
他们认为，没有人会真的想输入 %s。

764
00:51:10,110 --> 00:51:12,420
如果他们这样做了，他们可以只做 %%。

765
00:51:12,420 --> 00:51:24,960
因此，他们决定以这样一种方式来实现 printf，即让代码分析输入的任何文本，查找 %s，然后以某种方式将后续值插入该占位符。

766
00:51:24,960 --> 00:51:28,390
问题是

768
00:51:28,890 --> 00:51:30,870
观众：如果我们想用自己名字的缩写或别的什么呢？

769
00:51:30,870 --> 00:51:38,070
戴维-J-马兰：啊，那如果你想写单个字符呢，比如首字母，比如 D M 或 D J M，代表姓、名、中、后，绝对可以。

770
00:51:38,070 --> 00:51:44,310
这也是你们两个人谈到 C 语言中数据类型的一个完美切入点。

771
00:51:44,310 --> 00:51:48,135
原来，在 C 语言中，不仅字符串是文本。

772
00:51:48,135 --> 00:51:52,560
在接下来的几周里，我们将更详细地了解到字符串的真实面目。

773
00:51:52,560 --> 00:51:55,620
但是，程序并不是只能输出文本字符串。

774
00:51:55,620 --> 00:51:58,860
它们确实可以输出单字符，如首字母缩写。

775
00:51:58,860 --> 00:52:01,020
它们也可以输出整数。

776
00:52:01,020 --> 00:52:05,868
原来，printf 对各种不同的数据类型有不同的格式代码。

777
00:52:05,868 --> 00:52:13,920
未来几周，我们将看到的数据类型包括以下列表，你会发现它与 CS50 功能几乎完全一致

778
00:52:13,920 --> 00:52:17,722
如 get_char、get_int 和 get_string。

779
00:52:17,722 --> 00:52:23,490
我们之所以把这些函数称为 "函数"，是因为每个函数都是为了返回不同类型的值。

780
00:52:23,490 --> 00:52:26,070
在这个示例中，我们已经使用了 get_string。

781
00:52:26,070 --> 00:52:29,880
我们很快就会看到 get_int，我们也会看到使用其他功能的机会。

782
00:52:29,880 --> 00:52:38,400
但这些确实是可用数据类型的菜单，再加上其他数据类型--点、点、点--您在用 C 语言编写程序时可以使用的数据类型。

783
00:52:38,400 --> 00:52:48,420
因此，你有责任事先决定，我是想在这个变量中存储一个 int，还是一个字符串，或者，在编写更高级的代码时，存储一个图像、声音或视频。

784
00:52:48,420 --> 00:52:51,030
这些都可以是不同的数据类型，点点点。

785
00:52:51,030 --> 00:52:54,300
但现在我们只关注这些基元。

786
00:52:54,300 --> 00:52:54,988
这可真不少。

787
00:52:54,988 --> 00:52:57,030
我们先休息五分钟。

788
00:52:57,030 --> 00:52:57,680
还没有饼干。

789
00:52:57,680 --> 00:53:00,180
但五分钟后，我们会再回来，深入探讨更多细节。

790
00:53:00,180 --> 00:53:02,097
今天第二次休息时，我们将吃饼干。

791
00:53:05,640 --> 00:53:07,295
好了，我们回来了。

792
00:53:07,295 --> 00:53:11,587
因此，如果你一直在家里玩，但在路上遇到了一些颠簸，这完全是正常的。

793
00:53:11,587 --> 00:53:18,020
事实上，一般来说，讲座的目的是让大家从概念上了解我们在这一周内要去的地方。

794
00:53:18,020 --> 00:53:25,730
但实际上，通过动手实验和问题集，你才真正有机会按照自己的步调来解决这些问题。

795
00:53:25,730 --> 00:53:28,880
但今天，让我再给你们介绍几种构件。

796
00:53:28,880 --> 00:53:31,460
这两项翻译最初将从 Scratch 开始。

797
00:53:31,460 --> 00:53:43,370
也就是说，比如条件式，比如现在在 C 语言中，在知道了如何使用函数（至少是 get_string 和 printf）之后，我们可以使用变量，比如我之前创建的字符串、

798
00:53:43,370 --> 00:53:47,100
我现在如何在其中加入决策和条件等内容？

799
00:53:47,100 --> 00:53:50,780
那么，在 Scratch 中使用条件时，我们在左边使用了这种语法。

800
00:53:50,780 --> 00:53:56,360
在 Scratch 中，您可以这样表达 x 和 y 这两个变量之间是否存在这种关系。

801
00:53:56,360 --> 00:54:01,020
如果 x 小于 y，则在屏幕上显示 x 小于 y。

802
00:54:01,020 --> 00:54:03,320
好吧，让我用 C 代码翻译一下。

803
00:54:03,320 --> 00:54:09,530
因此，在 C 语言中，假设 x 和 y 已经存在，相应的代码将如下所示--稍后详述。

804
00:54:09,530 --> 00:54:13,140
请注意，我们将一再看到一种模式。

805
00:54:13,140 --> 00:54:20,390
在 x 和小于 y 的周围要加括号，所以布尔表达式周围要加括号。

806
00:54:20,390 --> 00:54:27,680
布尔表达式是 "真/假"、"是/否 "的答案，是您为了决定是否要做某件事而提出的问题。

807
00:54:27,680 --> 00:54:29,310
所以你要用括号。

808
00:54:29,310 --> 00:54:38,660
在函数中，我们对 printf 使用括号，而对 get_string 使用括号，这在风格上是一种奇怪的不一致。

809
00:54:38,660 --> 00:54:44,690
使用关键字 if 时，作为最佳做法，应在 if 一词后加上空格。

810
00:54:44,690 --> 00:54:49,070
在使用 printf 或 get_string 等函数时，就不应该这样做。

811
00:54:49,070 --> 00:54:55,970
两种方法都可以使用，但你会发现这些都是大多数人遵守的约定俗成的风格--所以在这里使用 "如果 "时要留出空格。

812
00:54:55,970 --> 00:55:02,360
好了，现在大括号内就是要有条件执行的实际代码。

813
00:55:02,360 --> 00:55:12,740
因此，如果您想仅在 C 语言中 x 小于 y 的情况下打印出 x 小于 y，您可以使用这个开放式大括号--到目前为止，您可能还很少在键盘上使用它--

814
00:55:12,740 --> 00:55:14,820
和下面的封闭式卷曲支撑。

815
00:55:14,820 --> 00:55:25,050
如果你愿意的话，这些都是 "if "下面的一行或多行代码，与这里的橙色块与这里的紫色拼图块拥抱的方式非常相似。

816
00:55:25,050 --> 00:55:27,050
因此，C 语言中没有图形，全是文本。

817
00:55:27,050 --> 00:55:31,760
因此，你可以认为这些大括号代表的是同一个意思。

818
00:55:31,760 --> 00:55:41,430
顺便提一句，如果 if 条件中只有一行代码，严格来说，就不需要大括号。

819
00:55:41,430 --> 00:55:43,670
不过，为了保持良好的风格，还是要把它们写进去。

820
00:55:43,670 --> 00:55:46,040
这将使你的意图更加明显。

821
00:55:46,040 --> 00:55:52,700
如果你想用 Scratch 来表达这个意思--你可能会走的两条路，可以说是向左或向右，怎么样？

822
00:55:52,700 --> 00:55:56,480
那么，如果 x 小于 y，我想说 x 小于 y。

823
00:55:56,480 --> 00:56:01,190
否则，我想说的是相反的，在这种情况下，x 不小于 y。

824
00:56:01,190 --> 00:56:03,710
因此，我是根据布尔表达式做出决定的。

825
00:56:03,710 --> 00:56:14,690
在 C 语言中，这几乎是一样的，但你要在其中加入关键字 else（所以 MIT 在 Scratch 中借用了相同的关键字），以及另一对大括号，分别是 open 和 close。

826
00:56:14,690 --> 00:56:17,150
你现在可能猜到里面装的是什么了吧。

827
00:56:17,150 --> 00:56:22,905
那么，你可以打印出 x 小于 y，或者打印出 x 不小于 y。

828
00:56:22,905 --> 00:56:25,280
好吧，如果有三岔路口怎么办？

829
00:56:25,280 --> 00:56:29,370
在 Scratch 中，如果你愿意的话，这在图形上确实有点不方便。

830
00:56:29,370 --> 00:56:36,110
但请注意，在 Scratch 中，我们可以这样表达 if x 小于 y，即 x 小于 y。

831
00:56:36,110 --> 00:56:40,760
否则，如果 x 大于 y，就说 x 大于 y。

832
00:56:40,760 --> 00:56:45,470
否则，如果 x 等于 y，就说 x 等于 y。

833
00:56:45,470 --> 00:56:48,770
这里有一点小矛盾。

834
00:56:48,770 --> 00:56:54,435
就在不久前，我在 C 语言中声称，等号代表什么操作？

835
00:56:54,435 --> 00:56:55,310
听众：分配任务。

836
00:56:55,310 --> 00:56:57,770
DAVID J. MALAN：从右到左分配任务。

837
00:56:57,770 --> 00:57:06,360
由于 Scratch 是为孩子们设计的，他们并不想在语义上纠缠不清，所以 Scratch 中的等号意味着平等。

838
00:57:06,360 --> 00:57:09,050
不过，我们马上就需要用 C 语言来解决这个问题。

839
00:57:09,050 --> 00:57:11,750
在 C 语言中，等号表示从右向左赋值。

840
00:57:11,750 --> 00:57:14,210
在 Scratch 中，它的字面意思就是你所期望的。

841
00:57:14,210 --> 00:57:20,780
好了，让我们把这段代码翻译成 C 语言。

842
00:57:20,780 --> 00:57:29,100
你也许可以看到，这个解决方案有点愚蠢，与早些时候人类把自己逼入另一个死角时的%%解决方案并无二致。

843
00:57:29,100 --> 00:57:36,620
你说 "如果"，你说 "如果"，你又说 "如果"，我们是如何解决使用单个等号的问题的？

844
00:57:36,620 --> 00:57:47,090
在 C 语言中，当你想表示相等时--左边的东西是否等于右边的东西--你可以使用两个紧挨着的等号，中间没有空格。

845
00:57:47,090 --> 00:57:53,640
但现在，无论你是用 Scratch 还是用 C 语言，这段代码在左侧和右侧都是正确的。

846
00:57:53,640 --> 00:57:58,400
但现在我们可以挑剔我们的代码，特别是其中的设计。

847
00:57:58,400 --> 00:58:04,280
从逻辑上讲，有人能对这段代码的设计（Scratch 或 C 语言）提出批评吗？

848
00:58:04,280 --> 00:58:06,200
我觉得我们可以做得更好。

849
00:58:06,200 --> 00:58:07,576
后面怎么样？

850
00:58:07,576 --> 00:58:12,930
听众：在大于或小于之后的唯一选项是[INNAUDIBLE]。

851
00:58:12,930 --> 00:58:13,930
戴维-J-马兰：太好了。

852
00:58:13,930 --> 00:58:22,510
从逻辑上讲，必须是 x 小于 y，或者 x 大于 y，或者根据结论，必须等于 y。

853
00:58:22,510 --> 00:58:26,170
那你为什么还要浪费我或电脑的时间问第三个问题呢？

854
00:58:26,170 --> 00:58:31,510
因为从逻辑上讲，正如你所指出的，这应该是不言而喻的。

855
00:58:31,510 --> 00:58:33,220
所以这只是一个小调整。

856
00:58:33,220 --> 00:58:37,120
在 x 等于 y 的情况下，你可能要做额外的工作。

857
00:58:37,120 --> 00:58:38,350
因此，我们可以对其进行改进。

858
00:58:38,350 --> 00:58:47,110
就像在 Scratch 中，你可以只使用一个 else 块，同样，在 C 语言中，我们是否也可以将这段代码简化为一个 else，一种逻辑上的 "一网打尽"？

859
00:58:47,110 --> 00:58:52,400
这只是处理现实，当然，这将是最终的情况。

860
00:58:52,400 --> 00:58:56,770
好了，现在我们可以用布尔表达式来表达条件式了。

861
00:58:56,770 --> 00:58:59,030
接下来，让我们在这里做点什么吧。

862
00:58:59,030 --> 00:59:00,610
让我回到 VS 代码。

863
00:59:00,610 --> 00:59:05,020
我已经关闭了 hello.c，现在我想创建第二个文件，以便进行一些演示。

864
00:59:05,020 --> 00:59:11,440
请记住，您可以通过键入代码、空格和要创建的文件名来创建新文件。

865
00:59:11,440 --> 00:59:13,565
例如，我可能会做 compare.c。

866
00:59:13,565 --> 00:59:17,740
我想编写一个程序，开始比较一些数值，以进行演示。

867
00:59:17,740 --> 00:59:25,180
但在此之前，请允许我打开右侧的文件资源管理器，向你展示一下，它的功能与 Mac 或 PC 相似。

868
00:59:25,180 --> 00:59:30,010
你可以在这里点击一个图标，然后点击加号图标，就会出现一个蓝色框。

869
00:59:30,010 --> 00:59:34,120
我可以输入 compare.c，然后手动创建它。

870
00:59:34,120 --> 00:59:37,930
请注意，即使我没有输入代码，也能打开标签页。

871
00:59:37,930 --> 00:59:42,820
同样，在左边，你有一个图形用户界面（GUI），尽管只是一个简单的图形用户界面。

872
00:59:42,820 --> 00:59:47,260
在右侧和底部，你有一个命令行界面，但它们是一体的。

873
00:59:47,260 --> 00:59:58,930
不过，好在如果我不小心或有意关闭了这个文件，只要运行同样的命令--代码、空格、compare.c.，就可以重新打开它，而无需创建一个新文件。

874
00:59:58,930 --> 01:00:00,340
因此，代码是 VS 代码的一部分。

875
01:00:00,340 --> 01:00:02,140
这只是一个方便用户的快捷方式。

876
01:00:02,140 --> 01:00:05,888
但它只是创建一个文件或打开一个现有文件。

877
01:00:05,888 --> 01:00:08,930
为了给代码腾出更多空间，我要隐藏文件资源管理器。

878
01:00:08,930 --> 01:00:10,222
让我们开始吧。

879
01:00:10,222 --> 01:00:15,340
让我们编写一个程序，比较人类输入的两个值，但这次不是字符串。

880
01:00:15,340 --> 01:00:17,170
让我们使用一些实际的整数。

881
01:00:17,170 --> 01:00:23,260
好的，我将继续在顶部包含 CS50 库的头文件--cs50.h。

882
01:00:23,260 --> 01:00:25,804
我还将包含 stdio.h。

884
01:00:26,668 --> 01:00:31,190
一种是通过 get_string、get_int 等方式提供方便用户的输入。

885
01:00:31,190 --> 01:00:35,560
在使用 stdio.h 的情况下，我可以通过 printf 得到用户友好的输出结果。

886
01:00:35,560 --> 01:00:40,310
现在，我只是盲打这行代码，以后几周我们会再来讨论它。

887
01:00:40,310 --> 01:00:44,920
但就目前而言，这类似于 Scratch 中点击绿旗时的代码。

888
01:00:44,920 --> 01:00:46,460
现在，让我们开始吧。

889
01:00:46,460 --> 01:00:51,713
让我继续从用户那里获取_int，然后问用户：X 是什么，问号。

890
01:00:51,713 --> 01:00:53,380
我不打算费心去做一条新的生产线。

891
01:00:53,380 --> 01:00:56,410
为了美观起见，我想把它们都放在一条线上。

892
01:00:56,410 --> 01:00:59,710
但是，当我取回一个 int 时，就像取回一个字符串一样、

893
01:00:59,710 --> 01:01:01,580
我得到了一个返回值。

894
01:01:01,580 --> 01:01:06,040
因此，如果我想将 get_int 的结果存储在某个地方，我应该怎么做呢？

895
01:01:06,040 --> 01:01:07,927
我最好把它放在一个变量中。

896
01:01:07,927 --> 01:01:09,760
我可以随意调用变量。

897
01:01:09,760 --> 01:01:12,790
以前，我使用的是答案、第一个或最后一个。

898
01:01:12,790 --> 01:01:14,410
现在我要使用 x。

899
01:01:14,410 --> 01:01:19,870
但从逻辑上讲，这里还有两件事要做，尽管我们在技术上还没有做到这一点。

900
01:01:19,870 --> 01:01:21,130
我还需要做什么？

901
01:01:21,130 --> 01:01:22,410
听众：一个分号。

902
01:01:22,410 --> 01:01:24,535
戴维-J-马兰：所以我需要在末尾加上分号。

903
01:01:24,535 --> 01:01:26,010
观众：首先是int。

904
01:01:26,010 --> 01:01:27,885
戴维-J-马兰：还有开头的 int。

905
01:01:27,885 --> 01:01:32,840
从今天开始，程序员需要决定在变量中存储什么内容。

906
01:01:32,840 --> 01:01:35,750
你只需要告诉电脑，它就会知道。

907
01:01:35,750 --> 01:01:41,240
现在，作为 Python 等语言和更现代语言的预告片，人类意识到，哎呀，这太愚蠢了。

908
01:01:41,240 --> 01:01:44,115
为什么电脑不能识别出我在这里输入了一个 int？

909
01:01:44,115 --> 01:01:45,800
我为什么要主动告诉它？

910
01:01:45,800 --> 01:01:50,990
因此，在现在的一些语言中，比如 Python 会去掉一些这样的语法，去掉分号。

911
01:01:50,990 --> 01:01:54,530
但现在我们要看的，其实是这一切运作的起源。

912
01:01:54,530 --> 01:01:57,380
好了，我已经用分号结束了这一行。

913
01:01:57,380 --> 01:01:58,440
让我再做一件事。

914
01:01:58,440 --> 01:02:02,390
让我再问一下用户，"Y "是什么，问号。

915
01:02:02,390 --> 01:02:06,680
因此，希望用户能做出几乎相同但不同的反应。

916
01:02:06,680 --> 01:02:18,950
让我简单地问一下，如果 x 小于 y，在括号中，然后是一些大括号，让我继续打印出来，引号/无引号，x 小于 y 反斜杠 n。

917
01:02:18,950 --> 01:02:20,600
顺便说一句

918
01:02:20,600 --> 01:02:23,240
我好像打得很快。

919
01:02:23,240 --> 01:02:25,610
有些是因为 VS Code 在帮助我。

920
01:02:25,610 --> 01:02:29,720
让我回到第一行，输入 if，按回车键。

921
01:02:29,720 --> 01:02:33,630
现在，我只能在键盘上输入开放式大括号。

922
01:02:33,630 --> 01:02:36,410
这是目前许多文本编辑器的一项功能。

923
01:02:36,410 --> 01:02:37,980
它完成了你思想的一部分。

925
01:02:38,480 --> 01:02:42,660
这样就可以省下一个按键，确保不会不小心忘记关闭。

926
01:02:42,660 --> 01:02:45,750
因此，有时你会发现一些你没有键入的事情正在发生。

927
01:02:45,750 --> 01:02:49,550
这只是 VS Code 或你未来使用的程序想帮你而已。

928
01:02:49,550 --> 01:02:57,050
我现在就手动输入 printf x 小于 y 反斜杠 n 引号分号。

929
01:02:57,050 --> 01:03:02,000
让我现在试着运行一下，我们看看--让我们看看。

930
01:03:02,000 --> 01:03:09,050
所以 make -- 不是 hello -- 而是 make compare，因为这个文件叫 compare.c，点击 Enter。

931
01:03:09,050 --> 01:03:12,320
没有输出是好事，因为这意味着我没有搞砸。

932
01:03:12,320 --> 01:03:16,580
让我用 ./compare 代替 ./hello，回车。

934
01:03:17,390 --> 01:03:18,410
1 怎么样？

936
01:03:19,040 --> 01:03:19,840
两个怎么样？

937
01:03:19,840 --> 01:03:22,230
X 小于 y。

938
01:03:22,230 --> 01:03:23,387
好吧，让我们再试一次。

939
01:03:23,387 --> 01:03:25,220
在这里，我还能帮你省下一些按键。

940
01:03:25,220 --> 01:03:26,360
让我清理一下屏幕。

941
01:03:26,360 --> 01:03:35,310
在 VS 代码中，您也可以使用键盘上的方向键来回滚时间，而不用不停地键入 ./this 和 ./that。

942
01:03:35,310 --> 01:03:37,940
因此，如果我按一次 "向上 "键，就会出现我写的最后一条命令。

943
01:03:37,940 --> 01:03:41,480
如果我做两次，就会出现我写的倒数第二个命令。

944
01:03:41,480 --> 01:03:46,550
所以，有时候如果你看到我做事很快，那只是因为我在作弊，在翻阅我的历史记录。

945
01:03:46,550 --> 01:03:51,380
好吧，让我继续重新运行 ./compare，回车。

946
01:03:51,380 --> 01:03:52,670
这次我们反过来

947
01:03:52,670 --> 01:03:55,100
2 表示 x，1 表示 y。

948
01:03:55,100 --> 01:03:56,870
当然，现在没有产出了。

949
01:03:56,870 --> 01:04:00,170
好吧，从逻辑上讲，这是意料之中的，因为我们这里没有其他人。

950
01:04:00,170 --> 01:04:00,980
那就加上这个吧。

951
01:04:00,980 --> 01:04:12,350
Else -- 现在打开我的大括号，让 VS Code 帮我完成其中一个 -- printf, quote/unquote, x is not less than y 反斜线 n 分号。

952
01:04:12,350 --> 01:04:16,430
让我再试一次-- ./compare，回车。

953
01:04:16,430 --> 01:04:19,100
同样，2 表示 x，1 表示 y。

954
01:04:19,100 --> 01:04:22,990
我们应该看看

955
01:04:22,990 --> 01:04:24,830
我做错了什么？

956
01:04:24,830 --> 01:04:27,050
为什么我看不到其他输出？

958
01:04:27,550 --> 01:04:29,592
听众：你在重建时更改了代码。

959
01:04:29,592 --> 01:04:30,690
您需要对其进行编译。

960
01:04:30,690 --> 01:04:31,290
戴维-J-马兰：没错。

961
01:04:31,290 --> 01:04:34,415
你必须养成修改代码后重新编译的习惯。

962
01:04:34,415 --> 01:04:39,000
否则，在手动编译之前，服务器中的 0 和 1 都是旧的。

963
01:04:39,000 --> 01:04:41,040
所以我们要解决这个问题 - -进行比较，回车。

964
01:04:41,040 --> 01:04:42,030
无错误信息。

965
01:04:42,030 --> 01:04:45,420
./compare, 2, 1.

966
01:04:45,420 --> 01:04:47,320
现在我又得到了输出结果。

967
01:04:47,320 --> 01:04:49,230
所以 x 不小于 y。

968
01:04:49,230 --> 01:04:52,390
如果我再加上第三个条件呢？

969
01:04:52,390 --> 01:04:55,650
那么，我们可以高效或低效地做到这一点。

970
01:04:55,650 --> 01:04:57,270
让我继续完善这个问题。

971
01:04:57,270 --> 01:05:03,780
因此，如果 x 大于 y，我们就从字面上说，x 大于 y。

972
01:05:03,780 --> 01:05:07,950
现在，如果 x 等于 y，我就可以做 x else。

973
01:05:07,950 --> 01:05:11,080
但我认为，我们已经说过这是不必要的低效。

974
01:05:11,080 --> 01:05:12,810
所以，我们还是来个 "一网打尽 "吧。

975
01:05:12,810 --> 01:05:19,960
在这里，我要说的是，引号/非引号，x 等于 y 反斜线 n，在这里加引号。

976
01:05:19,960 --> 01:05:24,070
因此，我认为现在通过这段代码，我们已经处理了所有三种情况。

977
01:05:24,070 --> 01:05:28,680
让我继续正确地重新编译 - make compare, ./compare.

978
01:05:28,680 --> 01:05:32,340
现在 1 和 2 都小于 y。

979
01:05:32,340 --> 01:05:33,510
让我再跑一遍。

980
01:05:33,510 --> 01:05:36,690
2 和 1 -- x 大于 y。

981
01:05:36,690 --> 01:05:41,100
最后，1 和 1，x 等于 y。

982
01:05:41,100 --> 01:05:43,270
因此，在大多数情况下，我们的代码越来越长。

983
01:05:43,270 --> 01:05:47,700
我们已经写了 21 行代码，尽管其中一些只是屏幕上的单个字符。

984
01:05:47,700 --> 01:05:49,410
其他一切几乎都一样。

985
01:05:49,410 --> 01:06:01,810
我在 get_int 函数中使用了 CS50 库的头文件，在 printf 函数中使用了 stdio.h，其余的也都是新的条件语法。

986
01:06:01,810 --> 01:06:08,237
那么，对于这样一些基本比较的 C 语言实现，有什么问题吗？

987
01:06:08,237 --> 01:06:08,820
有问题吗？

989
01:06:09,320 --> 01:06:14,530
只是一个语法问题只是一个语法问题--开头的括号需要另起一行吗？

990
01:06:14,530 --> 01:06:15,190
大卫-J-马兰：问得好。

991
01:06:15,190 --> 01:06:17,440
开头的括号需要另起一行吗？

992
01:06:17,440 --> 01:06:18,610
在 CS50 中，是的。

993
01:06:18,610 --> 01:06:25,540
您将看到，作为提交流程的一部分，我们会将您的代码与风格指南进行比较，这是行业规范。

994
01:06:25,540 --> 01:06:29,290
一家公司会有自己的风格和代码外观。

995
01:06:29,290 --> 01:06:35,080
一般来说，公司内部都有自动化工具来帮助对代码进行反馈，或将其风格化。

996
01:06:35,080 --> 01:06:38,410
除了我们在课堂上使用的风格，还有其他风格。

997
01:06:38,410 --> 01:06:48,430
我们特意保留并要求您将大括号放在自己的行上，这完全是因为它类似于 Scratch 块的拥抱性质

998
01:06:48,430 --> 01:06:51,370
并清楚地表明它们是平衡的、开放的和封闭的。

999
01:06:51,370 --> 01:06:59,420
不过，在某些语言和某些程序员那里，另一种常见的范式是在每个程序上都做类似的处理。

1000
01:06:59,420 --> 01:07:03,670
因此，开头的大括号和这里是同一行。

1001
01:07:03,670 --> 01:07:05,030
我们不建议这样做。

1002
01:07:05,030 --> 01:07:07,900
这在 JavaScript 世界和其他一些世界非常流行。

1003
01:07:07,900 --> 01:07:16,210
但在现实世界中，最终还是要由每个程序员和/或他们所在的公司（如果适用）来决定这些事情。

1004
01:07:16,210 --> 01:07:21,140
好吧，那么除了这些条件句之外，如果我们想做一些可能很常见的事情呢？

1005
01:07:21,140 --> 01:07:28,360
因此，现在您使用的几乎所有软件或网站，都要求您通过输入 "是 "或 "否"，或者只输入 "是 "或 "否"，来同意一些条款和条件。

1006
01:07:28,360 --> 01:07:30,280
Y代表 "是"，N代表 "否"。

1007
01:07:30,280 --> 01:07:33,195
那么，我们该如何实施某种协议制度呢？

1008
01:07:33,195 --> 01:07:34,070
让我来吧

1009
01:07:34,070 --> 01:07:37,810
让我创建一个新程序，第三个程序名为 agree.c。

1010
01:07:37,810 --> 01:07:41,230
因此，我将编写代码 agree.c，为自己添加一个新标签。

1011
01:07:41,230 --> 01:07:44,230
我将一如既往地从包含 cs50.h 开始。

1012
01:07:44,230 --> 01:07:46,480
让我们加入 stdio.h。

1013
01:07:46,480 --> 01:07:53,200
然后让我执行我的 int main(void)--同样，为了今天的目的，我们认为这只是复制/粘贴。

1014
01:07:53,200 --> 01:08:00,520
如果我只想得到 Y 或 N，而不是 Yes 或 No，我们可以在这里使用一个更简单的变量。

1015
01:08:00,520 --> 01:08:03,800
只有一个字符、一个字符、一个字符如何？

1016
01:08:03,800 --> 01:08:09,760
因此，我可以使用 get_char 来询问用户，例如，你是否同意，问号。

1017
01:08:09,760 --> 01:08:12,880
但和以前一样，我需要把它存放在某个地方。

1018
01:08:12,880 --> 01:08:15,130
所以我不想要字符串，因为那是单字符。

1019
01:08:15,130 --> 01:08:16,180
我不想要 int。

1020
01:08:16,180 --> 01:08:17,380
我只想要一个 char。

1021
01:08:17,380 --> 01:08:21,500
字面意思是 C -H -A然后我想叫它什么都行

1022
01:08:21,500 --> 01:08:27,040
如果你有一个只有一个 char 类型变量的简单程序，将其称为 c，这是传统的做法。

1023
01:08:27,040 --> 01:08:28,569
如果是 int，则称其为 i。

1024
01:08:28,569 --> 01:08:29,830
如果是字符串，则称为 s。

1025
01:08:29,830 --> 01:08:32,590
现在，我只想简单地称之为 c。

1026
01:08:32,590 --> 01:08:34,370
现在我要问一个问题。

1027
01:08:34,370 --> 01:08:50,380
因此，如果 c 等于等于，引号/非引号 y 怎么样，那么就让我继续打印出同意反斜杠 n，就好像他们同意我的条款和条件一样。

1028
01:08:50,380 --> 01:08:51,880
否则，让我们拭目以待。

1029
01:08:51,880 --> 01:09:03,609
否则，如果字符等于，引号/无引号，n，那么让我继续打印，比如说，不同意，就好像他们不同意，引号/无引号。

1030
01:09:03,609 --> 01:09:07,060
我想，最初就这样吧。

1031
01:09:07,060 --> 01:09:11,830
现在，你会发现一个奇怪的地方，也许是一个不一致的地方。

1032
01:09:11,830 --> 01:09:15,760
虽然有些微妙，但有谁想说出来吗？

1033
01:09:15,760 --> 01:09:19,720
我做了一些稍微不同的事情，但还没有解释清楚。

1034
01:09:19,720 --> 01:09:20,380
你看到了吗？

1035
01:09:20,380 --> 01:09:22,625
听众：单引号。

1036
01:09:22,625 --> 01:09:23,500
是的。

1037
01:09:23,500 --> 01:09:30,590
因此，我突然用单引号来表示单个字符，而用双引号来表示实际的文本字符串。

1038
01:09:30,590 --> 01:09:41,380
这在 C 语言中是必要的。当您处理字符串时，如文本字符串，如某人的姓名、句子、段落等任何超过一个字符的内容，您通常会使用双引号。

1039
01:09:41,380 --> 01:09:42,399
事实上，你必须这样做。

1040
01:09:42,399 --> 01:09:49,819
在处理特意设置的单字符时，如我在这里输入 y 或 n，必须使用单引号。

1042
01:09:50,319 --> 01:09:54,550
因为这样可以确保计算机知道这确实是一个字符，而不是字符串。

1043
01:09:54,550 --> 01:09:55,930
因此，双引号适用于字符串。

1044
01:09:55,930 --> 01:09:57,520
单引号表示字符。

1045
01:09:57,520 --> 01:10:00,550
说到这里，让我继续放大。

1046
01:10:00,550 --> 01:10:04,780
让我在终端窗口中运行 make agree，回车。

1047
01:10:04,780 --> 01:10:08,770
看起来运行正常，所以让我继续进行 ./agree 操作。

1048
01:10:08,770 --> 01:10:12,250
让我先输入 y。

1049
01:10:12,250 --> 01:10:13,090
开始了

1052
01:10:16,540 --> 01:10:17,470
让我再试一次。

1053
01:10:17,470 --> 01:10:18,580
重新运行 ./同意。

1054
01:10:18,580 --> 01:10:20,170
没有呢？

1056
01:10:22,480 --> 01:10:25,720
为什么它的表现不符合我的预期？

1057
01:10:25,720 --> 01:10:28,480
听众：因为你输入了大写的Y和大写的N。

1058
01:10:28,480 --> 01:10:32,230
大卫-J-马兰：是的，我有点作弊，在开始输入时按了大写锁定键。

1060
01:10:32,730 --> 01:10:37,540
因为我特意想用大写字母而不是小写字母打字，这也算合情合理。

1061
01:10:37,540 --> 01:10:42,770
如果你只是需要一个简单的答案，却强迫用户打开或关闭大写锁定键，那就有点令人讨厌了。

1062
01:10:42,770 --> 01:10:45,310
这不是最好的用户体验。

1063
01:10:45,310 --> 01:10:47,200
但如果我合作的话，它就会起作用。

1064
01:10:47,200 --> 01:10:52,030
让我不按大写锁定键再运行一次，小写 "是"。

1065
01:10:52,030 --> 01:10:55,210
啊，成功了，"不 "的小写是 "n"。

1066
01:10:55,210 --> 01:10:55,990
这招还真管用。

1067
01:10:55,990 --> 01:10:57,910
但我怎样才能让它同时发挥作用呢？

1068
01:10:57,910 --> 01:10:59,180
这样如何？

1069
01:10:59,180 --> 01:11:01,400
让我来补充两个可能性。

1070
01:11:01,400 --> 01:11:10,720
因此，如果 c 等于引号/无引号大写 Y，那么也要执行 printf agreed 反斜杠 n。

1071
01:11:10,720 --> 01:11:20,980
下面，如果 c 等于单引号大写 N，则继续打印，同样，不同意。

1072
01:11:20,980 --> 01:11:23,770
我现在要说，这是正确的。

1073
01:11:23,770 --> 01:11:26,980
我很快就会同意的，./同意。

1074
01:11:26,980 --> 01:11:28,210
我会使用大写字母。

1075
01:11:28,210 --> 01:11:29,170
现在可以用了。

1076
01:11:29,170 --> 01:11:30,610
我要用大写字母。

1077
01:11:30,610 --> 01:11:32,200
它又成功了。

1078
01:11:32,200 --> 01:11:34,510
但这也许不是最好的设计。

1079
01:11:34,510 --> 01:11:39,220
让我把终端窗口隐藏起来，在屏幕上同时显示这些内容。

1080
01:11:39,220 --> 01:11:43,195
为什么说这不是最好的设计，尽管它是正确的？

1081
01:11:46,250 --> 01:11:51,170
我们还可以用另一个术语，比如[SNIFFS]，这个代码闻起来有点怪怪的。

1082
01:11:51,170 --> 01:11:52,450
这是一个实际的艺术术语。

1083
01:11:52,450 --> 01:11:54,100
这里有代码的味道。

1084
01:11:54,100 --> 01:11:55,930
有点不对劲。

1086
01:11:56,620 --> 01:11:57,894
你怎么看？

1088
01:12:06,895 --> 01:12:07,770
是的。

1089
01:12:07,770 --> 01:12:09,370
同样的输出一再出现。

1090
01:12:09,370 --> 01:12:10,530
我是说，我是手动输入的。

1091
01:12:10,530 --> 01:12:17,080
但老实说，我还不如直接复制粘贴我原来的大部分代码，为两个大写字母反复做一遍。

1092
01:12:17,080 --> 01:12:26,875
因此，如果第 10 行和第 14 行相同，第 18 行和第 22 行相同，那么其余的 if 和 else if 几乎相同、

1093
01:12:26,875 --> 01:12:28,500
[有些代码的味道。

1094
01:12:28,500 --> 01:12:29,370
设计不合理。

1096
01:12:29,820 --> 01:12:32,778
因为如果我现在想改变现状，就像上周在 Scratch 中一样、

1097
01:12:32,778 --> 01:12:37,120
我可能需要修改多个地方的代码，否则复制/粘贴永远不是一件好事。

1098
01:12:37,120 --> 01:12:42,760
而且，如果我想添加支持 "是 "和 "否 "的完整单词，那就真的会变得很长。

1099
01:12:42,760 --> 01:12:44,170
那么，我们该如何解决这个问题呢？

1100
01:12:44,170 --> 01:12:47,160
事实证明，我们可以把这些想法结合起来。

1101
01:12:47,160 --> 01:12:49,470
因此，让我先尝试改进 "是"。

1102
01:12:49,470 --> 01:12:54,325
事实证明，如果我删除该条款，我就能真正地把东西放在一起。

1103
01:12:54,325 --> 01:13:02,350
在 Scratch 中，有几块拼图（如果你还没发现的话）上面有 "或 "和 "和 "两个单词，可以让你组合布尔表达式。

1104
01:13:02,350 --> 01:13:06,600
这样，要么这个是真的，要么这个是真的，要么这个和这个都是真的。

1105
01:13:06,600 --> 01:13:09,270
在 C 语言中，你不能只说 "或"。

1106
01:13:09,270 --> 01:13:12,850
而不是使用两个竖条。

1107
01:13:12,850 --> 01:13:16,260
从逻辑上讲，竖条在一起表示或。

1108
01:13:16,260 --> 01:13:21,780
因此，我可以说，C 等于引号/引号大写的 Y，同意。

1109
01:13:21,780 --> 01:13:24,270
现在我可以删除下面的代码了。

1110
01:13:24,270 --> 01:13:32,340
让我继续说，竖条两次 c 等于大写的引号/无引号 N。

1111
01:13:32,340 --> 01:13:36,870
现在，我的程序大约减少了三分之一，这很好。

1112
01:13:36,870 --> 01:13:38,140
减少冗余。

1113
01:13:38,140 --> 01:13:49,860
如果我重新打开终端窗口，重新运行 make of agree、./agree，现在我可以输入小 Y 或大 Y，小写和大写也是一样的。

1114
01:13:49,860 --> 01:13:56,407
N.关于这个语法，现在你们可以把想法结合起来，把事情做得更严密一些，还有什么问题吗？

1115
01:13:56,407 --> 01:13:57,990
还会有其他类似的把戏。

1117
01:13:58,942 --> 01:14:01,615
听众：难道就没有忽略案件的功能吗？

1118
01:14:01,615 --> 01:14:03,240
大卫-J-马兰：这真是一个好问题。

1119
01:14:03,240 --> 01:14:06,030
难道就没有忽略案件的功能吗？

1120
01:14:06,030 --> 01:14:07,890
简而言之，有。

1121
01:14:07,890 --> 01:14:10,950
实际上，大约一周后，我们就会看到如何做到这一点。

1122
01:14:10,950 --> 01:14:19,890
而在其他语言中，有更多的方法可以将用户输入的内容规范化，丢弃他们可能不小心输入的空格字符，强制所有内容小写。

1123
01:14:19,890 --> 01:14:23,372
在 C 语言中，要做到这一点，我们需要付出更多的努力。

1124
01:14:23,372 --> 01:14:26,080
但事实上，最早在下周，我们就会看到如何做到这一点。

1125
01:14:26,080 --> 01:14:29,490
但现在我们要比较的确实只是这些字面数值。

1126
01:14:29,490 --> 01:14:30,570
还有其他问题吗？

1127
01:14:30,570 --> 01:14:33,874
听众：所以我们假设用户输入的是他们建议的内容。

1128
01:14:33,874 --> 01:14:37,618
如果他们输入一个数字，你如何处理？

1129
01:14:37,618 --> 01:14:39,160
大卫-J-马兰：问得好。

1130
01:14:39,160 --> 01:14:45,360
因此，我们假定，在这个程序和我之前的所有程序中，人类都很合作，当我询问他们的名字时，他们都输入了大卫的名字。

1131
01:14:45,360 --> 01:14:50,040
而不是 123，或者，在这种情况下，他们输入的是一个字符而不是一个完整的单词。

1132
01:14:50,040 --> 01:14:53,520
因此，这也是使用图书馆的常见功能之一。

1133
01:14:53,520 --> 01:15:01,330
因此，举例来说，如果我再次运行 "同意"，并说 "当然"、"输入 "之类的话，它就会完全拒绝。

1135
01:15:01,830 --> 01:15:05,850
因为 s、u、r、e 是一串字符。

1136
01:15:05,850 --> 01:15:07,320
这不是一个单独的字符。

1137
01:15:07,320 --> 01:15:11,380
现在，我可以直接说 x，当然，它既不是 y 也不是 n。

1138
01:15:11,380 --> 01:15:14,190
但它能容忍这种情况，因为它是一个单独的字符。

1139
01:15:14,190 --> 01:15:19,210
但是，CS50 的程序库内置了一些拒绝非预期输入的功能。

1140
01:15:19,210 --> 01:15:26,940
因此，如果使用 get_int，而用户输入的不是数字 1 或 2，而是 cat、C-A-T，它就会再次提示用户，再次提示用户。

1141
01:15:26,940 --> 01:15:34,068
如果用 C 语言手动操作，最终也要编写这么多代码来检查所有这些错误。

1142
01:15:34,068 --> 01:15:38,190
这就是为什么我们要在几周内使用这些训练轮，以使代码更加健壮。

1143
01:15:38,190 --> 01:15:40,500
但几周后，我们将收回自由。

1144
01:15:40,500 --> 01:15:44,970
你会看到并理解它是如何做到这一切的。

1145
01:15:44,970 --> 01:15:46,750
好吧，这样如何？

1146
01:15:46,750 --> 01:15:54,567
现在，让我们切换到更像 Scratch 的程序，创建一个名为 meow 的程序，即 meow.c。

1147
01:15:54,567 --> 01:15:56,650
我们将不提供任何音频功能。

1148
01:15:56,650 --> 01:15:57,750
我们只能依靠印刷品。

1149
01:15:57,750 --> 01:16:03,000
假设我想写一个程序，看看能不能模拟猫叫。

1150
01:16:03,000 --> 01:16:04,960
因此，我现在还不需要任何用户输入。

1151
01:16:04,960 --> 01:16:06,960
所以我打算使用 stdio.h。

1152
01:16:06,960 --> 01:16:09,940
在这里，我将照例执行 int main(void)。

1153
01:16:09,940 --> 01:16:13,710
然后，我将继续执行 printf meow backslash n。

1154
01:16:13,710 --> 01:16:16,650
让这只猫喵喵叫三声，就像上周一样。

1155
01:16:16,650 --> 01:16:18,870
所以我要 "喵喵喵 "地叫。

1156
01:16:18,870 --> 01:16:22,350
顺便提一下，每当你突出显示线条时，就会看到小圆点出现。

1157
01:16:22,350 --> 01:16:26,460
这只是一个视觉提示，让你知道自己缩进了多少空格。

1158
01:16:26,460 --> 01:16:30,133
VS Code 和许多编辑器一样，会自动为你缩进代码。

1159
01:16:30,133 --> 01:16:32,550
我没有每次都按四下空格键。

1160
01:16:32,550 --> 01:16:34,020
我连 Tab 都没打。

1161
01:16:34,020 --> 01:16:41,933
不过，在 C 语言中，习惯做法确实是在适当的地方将行缩进四个空格--所以不是三个，也不是五个。

1162
01:16:41,933 --> 01:16:45,850
这些圆点可以帮助你看清事物，使它们排成一排，成为一种良好的风格。

1163
01:16:45,850 --> 01:16:49,600
好吧，我现在就说明，这个计划确实可行。

1164
01:16:49,600 --> 01:16:52,560
让喵喵叫--有点可爱--现在又喵喵叫了。

1165
01:16:52,560 --> 01:16:54,000
那里，三次。

1167
01:16:54,540 --> 01:16:55,500
它喵喵叫了三声。

1168
01:16:55,500 --> 01:16:57,060
当然，这并不是精心设计的。

1169
01:16:57,060 --> 01:16:58,935
上周的 Scratch 设计得并不好。

1171
01:17:00,480 --> 01:17:03,130
我应该怎么做？

1173
01:17:03,630 --> 01:17:04,120
听众：循环？

1174
01:17:04,120 --> 01:17:05,412
听众：这可能是一个循环。

1175
01:17:05,412 --> 01:17:07,140
是的。

1176
01:17:07,140 --> 01:17:09,310
这是一个完美的循环机会。

1178
01:17:09,810 --> 01:17:18,390
因为如果你想改变这些单词的大写字母，或者你想把狗的发音改成 "汪汪 "什么的，你就得改一个、两个、三个地方。

1179
01:17:18,390 --> 01:17:20,160
这也太傻了吧？

1180
01:17:20,160 --> 01:17:23,020
在代码中，您最好在一个地方进行更改。

1181
01:17:23,020 --> 01:17:24,880
那我该怎么做呢？

1182
01:17:24,880 --> 01:17:27,120
是的，我们可以引入一个循环。

1183
01:17:27,120 --> 01:17:32,710
但我们还需要另一个在 Scratch 中使用过的构件，那就是变量。

1184
01:17:32,710 --> 01:17:38,520
因此，请记住，一个变量，就像一个代数--x、y、z，什么的--可以为你存储一个值。

1185
01:17:38,520 --> 01:17:42,630
Scratch 中的变量可能是这样的

1186
01:17:42,630 --> 01:17:46,890
使用这块橙色拼图可以设置任何名称的变量，而不仅仅是 x、y 或 z。

1187
01:17:46,890 --> 01:17:51,840
但你也可以给它起个更直观的名字，比如计数器，还可以将它设置为等于某个值。

1188
01:17:51,840 --> 01:17:57,570
在 C 语言中，这样做的方法与我们迄今为止看到的一些语法的精神类似。

1189
01:17:57,570 --> 01:18:01,740
首先要输入变量的名称、一个等号，然后输入值。

1190
01:18:01,740 --> 01:18:05,470
您也要对其进行初始化，因此要从右向左复制。

1192
01:18:05,970 --> 01:18:09,570
因为等号同样表示从右到左的分配。

1193
01:18:09,570 --> 01:18:10,740
但这还不够。

1194
01:18:10,740 --> 01:18:12,282
你可能已经有了这种直觉。

1195
01:18:12,282 --> 01:18:16,170
为了创建变量，这行代码大概还缺什么？

1196
01:18:16,170 --> 01:18:16,767
听众： Int.

1197
01:18:16,767 --> 01:18:20,610
马兰：所以我们需要 int 来确保计算机知道这确实是一个 int。

1198
01:18:20,610 --> 01:18:23,802
最后还有分号。

1199
01:18:23,802 --> 01:18:25,260
至此，我的思考结束了。

1200
01:18:25,260 --> 01:18:28,660
所以比 Scratch 更令人讨厌，但我们开始发现其中的规律。

1201
01:18:28,660 --> 01:18:30,810
因此，并非每一种语法都是新的。

1202
01:18:30,810 --> 01:18:33,480
好吧，如果你想将计数器递增 1、

1203
01:18:33,480 --> 01:18:37,480
Scratch 使用动词 change，意思是将数值添加到计数器中。

1204
01:18:37,480 --> 01:18:43,930
因此，如果我想递增一个名为 counter 的现有变量，这种语法就比较有趣了。

1205
01:18:43,930 --> 01:18:48,690
原来代码是这样的，这看起来几乎是个悖论。

1206
01:18:48,690 --> 01:18:51,990
计数器如何等于计数器加 1？

1207
01:18:51,990 --> 01:18:53,160
数学不是这样的。

1208
01:18:53,160 --> 01:18:56,860
但同样，一个等号是从右往左赋值的。

1209
01:18:56,860 --> 01:19:03,930
这就是说，不管计数器的值是多少，都把它加上 1，然后把这个值从右向左复制到计数器本身。

1210
01:19:03,930 --> 01:19:13,330
您仍然需要分号，但我认为在更新现有变量时，您不需要提及关键字 int。

1211
01:19:13,330 --> 01:19:23,370
因此，只有在 C 语言中创建变量时，才会使用字符串（string）、int 或其他我们最终会看到的词--只有在首次创建或初始化变量时才会使用。

1212
01:19:23,370 --> 01:19:25,780
此后，如果你想改变它，它也只是存在而已。

1213
01:19:25,780 --> 01:19:27,060
这是你给的词。

1214
01:19:27,060 --> 01:19:29,950
电脑很聪明，至少能记住它的类型。

1215
01:19:29,950 --> 01:19:32,100
因此，这一行现在已经完成

1216
01:19:32,100 --> 01:19:37,740
事实证明，在代码中，正如我们将要看到的那样，想要把一些东西加起来、把一些东西递增一个是很常见的。

1217
01:19:37,740 --> 01:19:40,710
因此，同一个想法实际上有不同的语法。

1218
01:19:40,710 --> 01:19:43,290
这里的专业术语是 "句法糖"。

1219
01:19:43,290 --> 01:19:49,900
在代码中，做同一件事往往有很多种方法，尽管它们最终实现的功能完全相同。

1220
01:19:49,900 --> 01:19:57,765
因此，举例来说，如果在使用 CS50 几天后，您觉得在某个程序中不停地打字有点乏味，您可以将其简化为这样。

1221
01:19:57,765 --> 01:19:59,340
这就是语法糖。

1222
01:19:59,340 --> 01:20:06,480
你可以使用等号加号，只在左边提到一次变量名，它就知道这意味着前一件事。

1223
01:20:06,480 --> 01:20:10,420
只是稍微简洁了一些。

1224
01:20:10,420 --> 01:20:12,900
在数值上加 1 也是很常见的事情。

1225
01:20:12,900 --> 01:20:13,800
而且不一定是 1。

1226
01:20:13,800 --> 01:20:14,800
但在这种情况下，确实如此。

1227
01:20:14,800 --> 01:20:20,550
但如果确实是 1，则可以进一步收紧代码，直接这样做，counter++。

1228
01:20:20,550 --> 01:20:26,472
因此，在 C 语言中任何时候看到 ++，都意味着在该变量上加 1。

1229
01:20:26,472 --> 01:20:28,680
在另一个方向上还有其他方法。

1230
01:20:28,680 --> 01:20:38,490
如果要从变量中减去 1，可以使用前面的任何一种语法，用减号代替加号，或者更简洁地用反--。

1231
01:20:38,490 --> 01:20:42,520
这是典型的 C 语言程序员的做法。

1232
01:20:42,520 --> 01:20:47,500
好吧，如果没有变量，我们就用循环来解决喵星人的问题。

1233
01:20:47,500 --> 01:20:49,320
因此，在 Scratch 中，我们可以看到这样的循环。

1234
01:20:49,320 --> 01:20:52,680
当然，这让猫喵喵叫了三声。

1235
01:20:52,680 --> 01:20:54,480
如何在 C 语言中做到这一点？

1236
01:20:54,480 --> 01:21:03,520
但如果你能理解每一行的内容，我们就能顺理成章地知道发生了什么。

1237
01:21:03,520 --> 01:21:12,330
我想，这就是用 C 语言实现循环迭代三次的一种方法。

1238
01:21:12,330 --> 01:21:18,990
我们从这样两块超级简单的拼图，变成了 1、2、3、4、5、6 行代码，所有这些都非常复杂。

1239
01:21:18,990 --> 01:21:20,740
于是事态迅速升级。

1240
01:21:20,740 --> 01:21:21,960
但是，每一行都在做什么呢？

1241
01:21:21,960 --> 01:21:24,120
我们还会看到其他更简单的方法。

1242
01:21:24,120 --> 01:21:28,710
因此，我们将一个名为 counter 的变量初始化为 3，就像之前一样。

1244
01:21:29,370 --> 01:21:32,800
那么，"循环 "或 "重复三次 "是什么意思呢？

1245
01:21:32,800 --> 01:21:41,080
好吧，这就像做一件事三次，然后做，然后倒数，然后做，然后倒数，然后做，直到数完为止。

1246
01:21:41,080 --> 01:21:44,910
这就是声明一个名为 counter 的变量，并将其设置为 3。

1247
01:21:44,910 --> 01:21:52,440
然后，我在 C 语言中诱导一个循环，其精神与重复 3 相似，但你必须自己做更多的数学计算。

1248
01:21:52,440 --> 01:21:59,200
因此，我在括号中提出的问题是：当计数大于 0 时，我想做什么？

1249
01:21:59,200 --> 01:22:04,080
好吧，根据大括号内的缩进，我想喵一次。

1250
01:22:04,080 --> 01:22:06,990
然后，说白了，最后一行代码是做什么用的？

1251
01:22:06,990 --> 01:22:12,120
如果计数器一开始是 3，那么减去 1 后就变成了 2。

1252
01:22:12,120 --> 01:22:13,320
然后呢？

1253
01:22:13,320 --> 01:22:21,010
尽管 Scratch 中有一个漂亮的箭头，但这里没有、

1254
01:22:21,010 --> 01:22:28,870
C 知道要重复、重复、再重复地这样做，不断地问这个问题，然后在最后更新这个值。

1255
01:22:28,870 --> 01:22:33,690
因此，如果我只强调其中的几个步骤，变量一开始就是 3。

1256
01:22:33,690 --> 01:22:35,100
实际上，让我简化一下 2.

1257
01:22:35,100 --> 01:22:43,480
我之前说过，在使用单变量时，除非有多个变量，否则人们通常只用 i 表示 int，用 c 表示 char，用 s 表示 string。

1258
01:22:43,480 --> 01:22:44,730
所以，让我把代码写得更紧凑些。

1259
01:22:44,730 --> 01:22:47,220
而这已经让它看起来更容易接受一些。

1260
01:22:47,220 --> 01:22:50,320
实际上，让我把它进一步收紧，增加一个步骤。

1261
01:22:50,320 --> 01:22:54,653
现在，这段代码已经尽可能紧凑、简洁了。

1262
01:22:54,653 --> 01:22:56,320
那么，这里究竟会发生什么呢？

1263
01:22:56,320 --> 01:22:59,550
第一行代码执行后，i 初始化为 3。

1264
01:22:59,550 --> 01:23:00,900
然后我们检查条件。

1265
01:23:00,900 --> 01:23:03,840
当 i 大于 0 时，i 是否大于 0？

1266
01:23:03,840 --> 01:23:05,580
嗯，显然是我的三根手指。

1267
01:23:05,580 --> 01:23:07,590
所以我们在屏幕上打印出了喵喵。

1268
01:23:07,590 --> 01:23:13,110
然后从 i 中减去 1，此时 i 的值为 2。

1269
01:23:13,110 --> 01:23:15,330
然后代码返回到条件。

1270
01:23:15,330 --> 01:23:17,580
注意，这里的条件是在括号里的。

1271
01:23:17,580 --> 01:23:19,420
这是另一个布尔表达式。

1272
01:23:19,420 --> 01:23:23,340
因此，循环可以使用布尔表达式，就像条件使用

1273
01:23:23,340 --> 01:23:24,990
布尔表达式来做决定。

1274
01:23:24,990 --> 01:23:31,330
不过，这个循环不是决定做这件事还是做那件事，而是决定是否要一而再、再而三地做同一件事。

1275
01:23:31,330 --> 01:23:40,450
当它一行接一行地敲击代码时，最终会敲到 1，然后敲到 0，最后停止。

1276
01:23:40,450 --> 01:23:51,570
换个角度看--这里有一些道具--假设这个球是你的变量，你用三个压力球将它初始化为 3，你就可以做三次，对吗？

1277
01:23:51,570 --> 01:23:56,653
如果我想送出三个压力球--这是你免费获得压力球的机会，无需回答任何问题。

1278
01:23:56,653 --> 01:23:57,400
好了，我们走吧。

1279
01:23:57,400 --> 01:24:00,180
因此，我们开始从我的变量中减去 1。

1280
01:24:00,180 --> 01:24:01,830
我还剩下两个。

1282
01:24:02,460 --> 01:24:04,845
好吧 别告诉桑德斯

1283
01:24:04,845 --> 01:24:07,470
[哦，对不起

1286
01:24:08,580 --> 01:24:10,350
好吧，结局很糟糕。

1289
01:24:11,570 --> 01:24:17,037
但现在的教育意义在于，我的变量被进一步递减，以至于------------。

1290
01:24:17,037 --> 01:24:18,370
我不会再扔那么远了。

1291
01:24:18,370 --> 01:24:19,620
我做不到

1292
01:24:19,620 --> 01:24:20,143
开始了

1293
01:24:20,143 --> 01:24:21,060
好了，我们开始吧。

1294
01:24:21,060 --> 01:24:22,740
最后一项减法。

1295
01:24:22,740 --> 01:24:24,880
现在我们的变量是空的。

1296
01:24:24,880 --> 01:24:28,380
所以我们有三个压力球，这就是变量的全部。

1297
01:24:28,380 --> 01:24:29,475
这是某种存储设备。

1298
01:24:29,475 --> 01:24:32,100
当然，它实际上是在计算机内存中实现的。

1299
01:24:32,100 --> 01:24:35,860
但从隐喻的角度来看，它其实只是一个具有一定价值的碗。

1300
01:24:35,860 --> 01:24:39,840
在这种情况下，每次做减法时，都是在改变变量的值。

1301
01:24:39,840 --> 01:24:44,610
当然，括号中的代码只是在检查：碗是空的吗？

1302
01:24:44,610 --> 01:24:46,570
碗是空的吗？

1303
01:24:46,570 --> 01:24:50,350
也就是，i 是否大于 0？

1304
01:24:50,350 --> 01:24:55,210
对我们如何以这种方式实现循环有任何疑问吗？

1305
01:24:55,210 --> 01:24:58,080
下课后我还欠你一个压力球呢

1306
01:24:58,080 --> 01:24:59,820
对环路有疑问？

1307
01:24:59,820 --> 01:25:03,240
好吧，事实证明，这有点难看。

1308
01:25:03,240 --> 01:25:09,422
当你不得不写出这一连串的步骤时，编程的乐趣就开始消失了。

1309
01:25:09,422 --> 01:25:11,380
原来，还有其他方法可以做到这一点。

1310
01:25:11,380 --> 01:25:16,410
但首先，让我们从逻辑上看看，你还可以用什么方式来表达，因为我们一直使用零，这有点奇怪。

1311
01:25:16,410 --> 01:25:19,890
因此，还有一种方法就是反转逻辑。

1312
01:25:19,890 --> 01:25:23,820
你完全可以从变量开始，称 i 等于 1。

1313
01:25:23,820 --> 01:25:28,290
然后你可以问，i 是否小于或等于 3？

1314
01:25:28,290 --> 01:25:30,210
注意这里的新语法。

1315
01:25:30,210 --> 01:25:37,870
在典型的键盘上，有数字小于或等于号，或大于或等于号，就像你在数学课上写的 1 大于另一个一样。

1316
01:25:37,870 --> 01:25:45,360
因此，在 C 语言中，您可以使用两个字符：小于，后面跟一个等号，或者，如果合适的话，大于，后面跟一个等号。

1317
01:25:45,360 --> 01:25:47,370
这就顺理成章地抓住了这一想法。

1318
01:25:47,370 --> 01:25:50,580
请注意，我正在改变我的问题。

1319
01:25:50,580 --> 01:25:55,830
我将 i 初始化为 1，然后将其最终递增到 2，再递增到 3。

1320
01:25:55,830 --> 01:26:00,340
但因为我做的是小于或等于，所以还是会从 1、2、3 开始。

1321
01:26:00,340 --> 01:26:01,530
这样也行得通。

1322
01:26:01,530 --> 01:26:03,810
同样，我们还可以用另一种方法来解决这个问题。

1323
01:26:03,810 --> 01:26:11,640
我们可以将 i 初始化为 0，然后我们可以说，好吧，i 小于 3，然后继续递增。

1324
01:26:11,640 --> 01:26:14,940
而我所展示的最后一种形式实际上是最经典的。

1325
01:26:14,940 --> 01:26:18,420
从 1 到 3 的思考方式可能最像人类。

1326
01:26:18,420 --> 01:26:23,740
从 3 到 0，倒计时，这可能是最有压力的思考方式。

1327
01:26:23,740 --> 01:26:35,610
但通常情况下，大多数程序员在熟悉了从 0 开始计数后的常用语法是，始终从 0 开始计数，然后向上数到小于要向上数的值。

1328
01:26:35,610 --> 01:26:40,043
因此，在这里将其改为小于或等于 3 是不正确的，为什么？

1329
01:26:40,043 --> 01:26:42,960
如果我把小于改为小于或等于，结果会怎样？

1330
01:26:42,960 --> 01:26:44,340
它只会喵两声。

1331
01:26:44,340 --> 01:26:47,780
是的 它还会喵喵叫 第四次 对吧?

1332
01:26:47,780 --> 01:26:51,150
因为你会从 0 开始，然后是 1、2、3。

1333
01:26:51,150 --> 01:26:53,220
小于或等于 3 -- 抱歉 --

1334
01:26:53,220 --> 01:26:55,420
3 会给你第四次。

1335
01:26:55,420 --> 01:26:58,650
因此，我们确实希望 "比 "只少一个。

1336
01:26:58,650 --> 01:27:02,490
好吧，既然我们有了这些选择，那我就再给你们一个选择。

1337
01:27:02,490 --> 01:27:07,210
这种写法也需要更多时间来适应，但可能是更常见的写法。

1338
01:27:07,210 --> 01:27:11,590
请允许我提出如下实施建议。

1339
01:27:11,590 --> 01:27:13,390
让我回到我的代码这里。

1340
01:27:13,390 --> 01:27:21,000
让我来看看我的几个 printfs，最终除了一个之外，我都删除了。

1341
01:27:21,000 --> 01:27:22,750
让我们用代码来实现这一点。

1342
01:27:22,750 --> 01:27:36,930
所以，让我们做 int i 得到 0，然后当 i 小于 3 时，让我们继续说 printf quote/unquote meow-- melow-- meow backslash n。

1343
01:27:36,930 --> 01:27:41,310
然后我们要做 i 减 minus 还是 plus plus？

1344
01:27:41,310 --> 01:27:42,237
观众：Plus plus.

1345
01:27:42,237 --> 01:27:47,120
大卫-J-马兰：所以加加，因为我们从 0 开始，一直到 3。

1346
01:27:47,120 --> 01:27:52,970
因此，让我在清除终端后继续制作喵星人，./meow，结果还是一样正确。

1347
01:27:52,970 --> 01:27:56,730
但它的设计要更好一些。

1349
01:27:57,230 --> 01:28:00,770
因为现在如果我想把它从 3 次改为 30 次、

1350
01:28:00,770 --> 01:28:01,850
我可以在那里更改。

1351
01:28:01,850 --> 01:28:03,770
我可以重新编译我的代码。

1352
01:28:03,770 --> 01:28:06,020
我可以用 ./meow 来完成。

1353
01:28:06,020 --> 01:28:09,450
我不必再复制粘贴 27 次才能达到这种效果。

1354
01:28:09,450 --> 01:28:13,400
我甚至可以通过改变一个位置来改变单词的内容。

1355
01:28:13,400 --> 01:28:15,920
但事实证明，还有其他方法可以做到这一点。

1356
01:28:15,920 --> 01:28:20,502
我建议，我们也向你介绍一下所谓的 for 循环。

1357
01:28:20,502 --> 01:28:27,500
因此，如果你想把某件事重复三次，完全可以采用我们刚才看到的 while 循环方法，也可以这样做。

1358
01:28:27,500 --> 01:28:34,200
这个需要更多时间去适应，但它把所有相同的逻辑都整合到了一条线上。

1359
01:28:34,200 --> 01:28:36,830
请注意，这里有一个关键词。

1360
01:28:36,830 --> 01:28:42,110
在这里，"for "只是一个介词，一般意味着 "这里有一个循环"。

1361
01:28:42,110 --> 01:28:46,097
这里的括号内不仅仅是布尔表达式。

1362
01:28:46,097 --> 01:28:47,930
这就是事情变得有点奇怪的地方。

1363
01:28:47,930 --> 01:28:54,230
有三样东西--分号左边、两个分号中间和分号右边。

1364
01:28:54,230 --> 01:28:58,198
这确实是我们唯一能看到分号的地方，而且很奇怪。

1365
01:28:58,198 --> 01:28:59,990
通常情况下，它都在线路的末端。

1366
01:28:59,990 --> 01:29:04,920
现在是两个人在队伍中间，但这是人类多年前决定的方式。

1367
01:29:04,920 --> 01:29:06,080
这是在干什么？

1368
01:29:06,080 --> 01:29:07,850
几乎一样。

1369
01:29:07,850 --> 01:29:12,320
它将把一个名为 i 的变量初始化为 0。

1370
01:29:12,320 --> 01:29:14,240
然后进行检查。

1371
01:29:14,240 --> 01:29:22,980
如果小于 3，它将执行大括号中的操作，最后将 i 递增并重复。

1372
01:29:22,980 --> 01:29:28,340
首先，i 初始化为 0，就像之前一样。

1373
01:29:28,340 --> 01:29:30,170
然后对这一条件进行检查。

1374
01:29:30,170 --> 01:29:32,150
这是一个布尔表达式。

1375
01:29:32,150 --> 01:29:34,610
是或否，真或假，就是它的答案。

1376
01:29:34,610 --> 01:29:40,550
如果 i 小于 3（从 0 开始就应该小于 3），那么我们将继续打印出喵喵。

1377
01:29:40,550 --> 01:29:42,350
然后，i 将被递增。

1378
01:29:42,350 --> 01:29:43,580
因此，它从 0 开始。

1379
01:29:43,580 --> 01:29:45,170
现在是 1。

1380
01:29:45,170 --> 01:29:48,150
此时，将再次检查布尔表达式。

1381
01:29:48,150 --> 01:29:50,840
这样你就不会一直把 i 改回 0。

1382
01:29:50,840 --> 01:29:53,210
第一步只有一次。

1383
01:29:53,210 --> 01:29:56,270
但现在，你重复了其他三个亮点。

1384
01:29:56,270 --> 01:29:57,770
我检查 i 是否小于 3。

1386
01:29:58,320 --> 01:29:59,600
所以我打印了喵喵。

1387
01:29:59,600 --> 01:30:00,875
然后将 i.

1388
01:30:00,875 --> 01:30:03,410
我检查 i（现在为 2）是否小于 3。

1390
01:30:03,980 --> 01:30:06,380
我打印出 "喵喵"。

1391
01:30:06,380 --> 01:30:07,100
我现在检查。

1392
01:30:07,100 --> 01:30:08,120
i 小于 3 吗？

1393
01:30:08,120 --> 01:30:11,360
不，不是的，因为 3 并不小于 3。

1394
01:30:11,360 --> 01:30:12,800
整件事就这样停止了。

1395
01:30:12,800 --> 01:30:17,420
大括号下面的代码（如果有的话）将开始执行。

1396
01:30:17,420 --> 01:30:22,610
就像在 Scratch 中一样，你可以跳出循环和拼图的束缚。

1397
01:30:22,610 --> 01:30:31,520
那么，关于循环的另一种语法，又名 for 循环，有什么问题吗？

1398
01:30:31,520 --> 01:30:34,195
听众：你能再解释一下为什么不回到 0 吗？

1399
01:30:34,195 --> 01:30:35,570
大卫-J-马兰：对不起，再说一遍？

1400
01:30:35,570 --> 01:30:37,400
听众：你能再解释一下为什么不重置为 0 吗？

1401
01:30:37,400 --> 01:30:38,275
是的。

1402
01:30:38,275 --> 01:30:40,400
我能再解释一下为什么不重置为 0 吗？

1403
01:30:40,400 --> 01:30:41,690
老实说，只是因为

1404
01:30:41,690 --> 01:30:43,490
这就是他们选择的语法。

1405
01:30:43,490 --> 01:30:47,660
第一个分号前的第一部分只执行一次，原因就在于此。

1406
01:30:47,660 --> 01:30:48,740
设计就是这样。

1407
01:30:48,740 --> 01:30:51,660
其他一切都循环往复。

1408
01:30:51,660 --> 01:30:55,610
这只是使用稍多行代码的另一种语法。

1409
01:30:55,610 --> 01:30:57,818
使用 while 循环只需六行代码。

1410
01:30:57,818 --> 01:30:59,387
从逻辑上讲，这是一码事。

1411
01:30:59,387 --> 01:31:05,240
程序员们一旦适应了这种方式，往往会更喜欢这种方式，因为它能更简洁地表达所有相同的想法。

1412
01:31:05,240 --> 01:31:06,380
仅此而已。

1414
01:31:06,890 --> 01:31:07,620
听众：这就是我的问题。

1415
01:31:07,620 --> 01:31:08,412
大卫-J-马兰：好的。

1416
01:31:08,412 --> 01:31:11,210
所以，让我们把这一点应用到我的喵星人例子中吧。

1417
01:31:11,210 --> 01:31:12,590
让我回到代码这里。

1418
01:31:12,590 --> 01:31:14,898
请注意，如果我突出显示所有这些句子、

1419
01:31:14,898 --> 01:31:16,190
我想我们可以把它做得更严密一些。

1420
01:31:16,190 --> 01:31:21,350
让我把这些都去掉，改成 for int i equals 0。

1421
01:31:21,350 --> 01:31:22,790
我说的是平等。

1422
01:31:22,790 --> 01:31:24,260
大多数程序员都会说 "得到"。

1423
01:31:24,260 --> 01:31:28,130
因此，int i gets 0 意味着赋值--单词 get。

1424
01:31:28,130 --> 01:31:32,360
现在我要做的是 i 小于 3 i++。

1425
01:31:32,360 --> 01:31:37,670
现在，我要在这里输入 printf quote/unquote meow backslash n。

1426
01:31:37,670 --> 01:31:39,450
因此，确实有点紧张。

1427
01:31:39,450 --> 01:31:41,408
我是说，有两行只是大括号。

1428
01:31:41,408 --> 01:31:43,580
现在真正有价值的代码只有两行。

1429
01:31:43,580 --> 01:31:47,460
让我继续做喵，./喵。

1430
01:31:47,460 --> 01:31:51,680
同样，我们又恢复了业务，其中三台只进行印刷。

1431
01:31:51,680 --> 01:31:56,330
好吧，我们还应该探讨最后一种结构，因为它有时很有用。

1432
01:31:56,330 --> 01:31:58,010
这是一个永远的街区。

1433
01:31:58,010 --> 01:32:02,750
如果在 Scratch 中永远只说 "喵"，或者至少不等待，那就有点奇怪了。

1434
01:32:02,750 --> 01:32:07,490
但是，Scratch 中确实有一个永久块，它的意思是永远执行以下操作。

1435
01:32:07,490 --> 01:32:11,360
我想，我上周口头提出了至少一个例子，说明这一点是有用的。

1436
01:32:11,360 --> 01:32:13,040
一直喵喵叫，有点烦人。

1437
01:32:13,040 --> 01:32:19,100
但是，你能想到在哪些常见情况下，你可能需要编写代码或使用一个永远循环的程序吗？

1439
01:32:19,657 --> 01:32:21,740
观众：在整场比赛中播放音乐。

1440
01:32:21,740 --> 01:32:22,970
是的，玩音乐。

1441
01:32:22,970 --> 01:32:26,495
就像 Spotify 的播放列表一样，不断重复就会形成某种循环。

1442
01:32:26,495 --> 01:32:28,310
观众：检查碰撞

1443
01:32:28,310 --> 01:32:32,548
DAVID J. MALAN：在 Scratch 中检查碰撞，查看是否有东西从墙上或另一个精灵上弹起。

1445
01:32:33,590 --> 01:32:36,512
观众：Oh, checking for input.

1446
01:32:36,512 --> 01:32:37,970
检查输入。

1447
01:32:37,970 --> 01:32:43,300
所以是的，get_string 本质上就是永远等着我输入一些内容，直到我输入为止。

1448
01:32:43,300 --> 01:32:44,470
看看时间看看时间

1449
01:32:44,470 --> 01:32:47,860
大卫-J-马兰：查看时间，实际上是维持人类的时间，就像挂钟一样。

1450
01:32:47,860 --> 01:32:48,550
在你后面？

1451
01:32:48,550 --> 01:32:49,420
是一样的吗？

1452
01:32:49,420 --> 01:32:50,590
听众：我想说的是检查时间。

1453
01:32:50,590 --> 01:32:52,173
大卫-J-马兰：好的，看看时间。

1454
01:32:52,173 --> 01:32:52,900
还有一个？

1455
01:32:52,900 --> 01:32:53,995
还能检测按键。

1456
01:32:53,995 --> 01:32:58,182
就像在 Scratch 中一样，只是在等待某种事件的发生，就像在手机或浏览器上一样。

1457
01:32:58,182 --> 01:33:04,520
因此，有很多例子表明，你可能想永远做某件事情--只是为了让你看到相应的 C 构建模块。

1458
01:33:04,520 --> 01:33:14,950
虽然有点奇怪，但这可能是 C 语言中最标准的方法。

1459
01:33:14,950 --> 01:33:18,850
您的电脑打印永远 "喵喵 "叫--您一般会这样做。

1461
01:33:19,490 --> 01:33:26,020
好吧，while 循环希望在括号中加入一个布尔表达式，而布尔表达式又是一个 "是/否"、"真/假 "的问题。

1462
01:33:26,020 --> 01:33:35,950
但是，如果你想让这个问题的答案总是 "是"，或者说，总是 "真"，那么在 C 语言和许多语言中，就会直接说 "真"，因为 "真

1463
01:33:35,950 --> 01:33:38,800
T-R-U-E--永远不会神奇地变成假的。

1464
01:33:38,800 --> 01:33:41,570
我的意思是，它只是编程语言中的一个特殊词汇。

1465
01:33:41,570 --> 01:33:45,680
因此，说 "同时真实"，只是意味着永远做以下事情。

1466
01:33:45,680 --> 01:33:54,220
在 true 和 false 变得普遍之前，另一种常见的范式是这样做--更改 while 1。

1467
01:33:54,220 --> 01:33:59,770
你可能会在网上的例子和文本等中看到，而 "1 "实际上是一回事。

1468
01:33:59,770 --> 01:34:04,840
计算机通常会将任何 0 值解释为假值。

1469
01:34:04,840 --> 01:34:11,210
任何值为 1 或任何其他非零值通常都被解释为 "真"。

1470
01:34:11,210 --> 01:34:15,400
因此，这也会产生同样的效果，即说 while true 或 while 1。

1471
01:34:15,400 --> 01:34:18,700
一般说来，虽然现在的情况可能更清楚一些。

1472
01:34:18,700 --> 01:34:20,650
现在，永远喵喵叫可不是什么好事。

1473
01:34:20,650 --> 01:34:23,770
但假设我这样做是有意还是无意呢？

1474
01:34:23,770 --> 01:34:24,950
好吧，让我们试试这个。

1475
01:34:24,950 --> 01:34:26,570
在这里，我将进入我的代码。

1476
01:34:26,570 --> 01:34:32,180
我要去掉 for 循环，将 while 循环改为 true 循环，怎么样？

1477
01:34:32,180 --> 01:34:36,100
在这种情况下，好吧，我们保留它 - 让我们做到这一点。

1478
01:34:36,100 --> 01:34:38,230
让喵喵进来

1479
01:34:38,230 --> 01:34:41,840
你会看到这个，使用了未声明的标识符 true。

1480
01:34:41,840 --> 01:34:46,360
这其实是在暗示我提到的旧方法是 0 和 1。

1481
01:34:46,360 --> 01:34:48,220
如今，你可以说 "真"，也可以说 "假"。

1482
01:34:48,220 --> 01:34:53,560
但是，"真 "和 "假 "本身就是必须包含的特殊词语。

1483
01:34:53,560 --> 01:35:03,640
事实证明，如果你想使用像这样的特殊布尔值，还有一个我们没有见过的头文件叫 stdbool，它基本上是将 true 和 false 创建为关键字。

1484
01:35:03,640 --> 01:35:06,550
另外，CS50 也包含相同的文件。

1485
01:35:06,550 --> 01:35:08,980
因此，在 CS50 中更常见的情况是这样的。

1486
01:35:08,980 --> 01:35:13,360
现在，如果我清空终端窗口，运行 make meow，然后运行 ./meow 并点击

1487
01:35:13,360 --> 01:35:21,350
进入，好吧，不幸的是，当你在云端使用浏览器时，这并不是最好的办法。

1488
01:35:21,350 --> 01:35:24,970
这确实是一个浏览器，只是在这里全屏显示。

1489
01:35:24,970 --> 01:35:29,462
这意味着我通过互联网向我的电脑发送了数百万只喵星人。

1490
01:35:29,462 --> 01:35:32,170
所以，这种情况总会发生在你身上，但可能不会发生在喵喵身上。

1491
01:35:32,170 --> 01:35:34,150
但你将失去对终端窗口的控制。

1493
01:35:34,420 --> 01:35:35,170
因为你搞砸了。

1494
01:35:35,170 --> 01:35:36,250
这就是一个无限循环。

1495
01:35:36,250 --> 01:35:37,090
你不是故意的

1496
01:35:37,090 --> 01:35:37,690
或许你是这样想的。

1497
01:35:37,690 --> 01:35:39,232
你很想知道会发生什么。

1498
01:35:39,232 --> 01:35:41,590
你是做什么的？

1499
01:35:41,590 --> 01:35:43,930
喵喵声何时停止？

1500
01:35:43,930 --> 01:35:45,910
我们有什么办法？

1501
01:35:45,910 --> 01:35:48,550
那么，Control-C 将是你的朋友。

1502
01:35:48,550 --> 01:35:51,070
有时，在云环境中，你必须多次点击。

1503
01:35:51,070 --> 01:35:55,540
但用于取消的 Control-C 会中断正在运行的程序。

1504
01:35:55,540 --> 01:36:02,560
我保证，几乎所有的人都会在某些时候不小心引入一个无限循环，因为你的计算稍有偏差。

1505
01:36:02,560 --> 01:36:09,545
有疑问时，点击终端窗口并按下 Control-C 键--有时要按多次--这样就能取消正在发生的一切。

1506
01:36:09,545 --> 01:36:11,170
在这种情况下，我可能是故意的。

1507
01:36:11,170 --> 01:36:14,330
但事实上，有时并不是有意为之。

1508
01:36:14,330 --> 01:36:23,890
好了，我们对整个图形用户界面已经习以为常了，事实上，我输入的命令和点击的按钮也是如此。

1509
01:36:23,890 --> 01:36:31,630
让我来告诉你，我们一直在使用的操作系统是什么，那就是 Linux。

1510
01:36:31,630 --> 01:36:38,680
当然，我一直在口头上暗指 Mac 和 PC，因为现在几乎所有人的台式机或笔记本电脑都在运行 macOS 或 Windows。

1511
01:36:38,680 --> 01:36:43,330
不过，还有很多其他操作系统，其中最流行的就是 Linux。

1512
01:36:43,330 --> 01:36:51,610
如今，Linux 经常被用于服务器，如托管电子邮件的公司、托管网站或应用程序的公司等。

1513
01:36:51,610 --> 01:36:56,950
某些计算机科学家或计算机科学专业的学生经常喜欢吹嘘他们运行 Linux，因为那是个东西。

1514
01:36:56,950 --> 01:37:07,480
但实际上，它只是 macOS 或 Windows 的替代品，如果你需要，它既能为你提供图形用户界面，也能为你提供命令行环境。

1515
01:37:07,480 --> 01:37:12,550
现在，有趣的事实来了--Windows 和 macOS 确实有终端窗口或与之相当的功能。

1516
01:37:12,550 --> 01:37:16,150
最终，你可能会在自己的 Mac 或 PC 上使用它来解决某些问题。

1517
01:37:16,150 --> 01:37:26,500
不过，Linux 和其他操作系统一样，都以其命令行环境而著称，我在前面已经把命令行环境与图形用户界面（GUI）区分为命令行界面（CLI）。

1518
01:37:26,500 --> 01:37:29,450
这其实指的是终端窗口。

1519
01:37:29,450 --> 01:37:39,640
因此，如果我回到 VS Code，事实上，让我关闭我的标签页，将注意力完全集中在终端窗口上，这个终端窗口实际上就是你的命令行界面

1520
01:37:39,640 --> 01:37:42,390
到您自己的云服务器上。

1521
01:37:42,390 --> 01:37:51,430
这里的专业术语是，你们每个人都将在云中拥有自己的容器，这就像你们自己的电脑一样，在互联网上的某个地方运行，拥有自己的用户名和密码

1522
01:37:51,430 --> 01:37:57,430
如果你愿意的话，你自己的硬盘，你自己的家庭文件夹，里面有你在课堂上的所有文件。

1523
01:37:57,430 --> 01:38:01,390
除非您启用了实时共享，否则只有您自己才能访问。

1524
01:38:01,390 --> 01:38:06,400
因此，当你在这里输入命令时，看起来就像在自己的 Mac 或 PC 上输入一样。

1525
01:38:06,400 --> 01:38:15,830
但实际上，它们是通过浏览器发送到云端的某个服务器，在那里，你可以控制自己的账户。

1526
01:38:15,830 --> 01:38:19,390
原来还有其他值得了解的命令。

1527
01:38:19,390 --> 01:38:21,292
今天我们就给大家介绍其中的几种。

1528
01:38:21,292 --> 01:38:24,710
在接下来的几周里，你们也将有机会与其他人一起玩耍。

1529
01:38:24,710 --> 01:38:26,260
但这些都是一些基础知识。

1530
01:38:26,260 --> 01:38:33,640
它们都非常简洁，因为对于在命令行中键入的内容，人类一般都不想键入很长的命令。

1531
01:38:33,640 --> 01:38:35,890
因此，这里很多都是缩写。

1532
01:38:35,890 --> 01:38:44,480
现在，我首先要说的最常见的可能是 ls，一个小写的 l 和一个小写的 s，简明扼要地代表列表。

1533
01:38:44,480 --> 01:38:47,380
所以，如果我现在进入我的终端窗口，直到现在、

1534
01:38:47,380 --> 01:38:56,110
我只输入了 code 和 make，前者是 VS 代码中用来创建和打开文件的，后者是用来触发代码编译的，如果我现在输入 ls 呢？

1535
01:38:56,110 --> 01:39:02,000
这将列出我当前文件夹中的所有文件，也就是我的云硬盘。

1536
01:39:02,000 --> 01:39:05,780
所以，如果我按下回车键，你会看到一大堆结果。

1537
01:39:05,780 --> 01:39:07,240
现在，它们也有了颜色编码。

1538
01:39:07,240 --> 01:39:09,910
这里的白色是以 .c 结尾的。

1539
01:39:09,910 --> 01:39:15,790
这些是我今天上课时编写的源代码文件-- agree.c、compare.c、hello.c 和 meow.c。

1540
01:39:15,790 --> 01:39:24,382
你也许能猜到，这里的绿色按钮按照惯例会在尾部打上星号，表示它们很特别，代表什么呢？

1541
01:39:24,382 --> 01:39:25,340
其他四人之一。

1543
01:39:26,315 --> 01:39:27,800
机器码？机器码？

1544
01:39:27,800 --> 01:39:29,520
是的，机器代码。

1545
01:39:29,520 --> 01:39:34,340
因此，这些都是我的实际程序，除去 .c 扩展名，它们的名称完全相同。

1546
01:39:34,340 --> 01:39:36,830
星号表示它们是可执行的。

1547
01:39:36,830 --> 01:39:39,582
在 macOS 或 Windows 世界中，您需要双击。

1548
01:39:39,582 --> 01:39:47,400
但在命令行环境中，这意味着你要执行 ./ 命令，然后输入不带星号的名称，以执行或运行其中的代码。

1549
01:39:47,400 --> 01:39:54,990
所以，如果我打开文件资源管理器 -- 我在电脑上按 Command-B 作为快捷键 -- 你会看到完全一样的东西。

1550
01:39:54,990 --> 01:39:59,210
因此，ls 是列出账户文件的命令行界面。

1551
01:39:59,210 --> 01:40:03,060
但在这里，因为我使用的是 VS Code 或类似程序、

1552
01:40:03,060 --> 01:40:06,213
我还获得了图形用户界面。

1553
01:40:06,213 --> 01:40:07,880
所以，这只是两个不同的地方。

1554
01:40:07,880 --> 01:40:09,680
您可以使用任何您觉得合适的方式。

1555
01:40:09,680 --> 01:40:14,720
但随着时间的推移，你会自然而然地对终端窗口更加熟悉，并能单独使用。

1556
01:40:14,720 --> 01:40:16,773
那么，这份清单上还有什么呢？

1557
01:40:16,773 --> 01:40:23,330
在休息期间，我看到你们中至少有人创建了一个名为 hello 的文件，而不是 hello.c。

1558
01:40:23,330 --> 01:40:27,230
所以你是在不小心的情况下按了回车键。

1559
01:40:27,230 --> 01:40:30,420
然后，你像这样输入所有代码。

1560
01:40:30,420 --> 01:40:34,760
然后在终端窗口中，你试图输入 make hello。

1561
01:40:34,760 --> 01:40:38,960
而现在这样做实际上什么也没做。

1562
01:40:38,960 --> 01:40:40,820
我不能 - 我打 -

1563
01:40:40,820 --> 01:40:42,380
我正在尝试运行命令。

1564
01:40:42,380 --> 01:40:44,690
我的许可被拒绝了，你们中至少有一个人是这样。

1565
01:40:44,690 --> 01:40:45,433
这是为什么呢？

1566
01:40:45,433 --> 01:40:46,850
好吧，让我们快速检查一下。

1567
01:40:46,850 --> 01:40:53,180
如果我执行 ls 命令，就会看到 hello，但 hello 旁边没有星号，这意味着它不可执行。

1568
01:40:53,180 --> 01:40:53,930
这就是我的密码。

1570
01:40:54,470 --> 01:40:57,540
请注意，我的标签顶部确认了，哦，我搞砸了。

1571
01:40:57,540 --> 01:41:00,740
我没有给我的文件取名为 hello.c，但这是必须的。

1572
01:41:00,740 --> 01:41:01,920
那你该怎么办？

1573
01:41:01,920 --> 01:41:05,810
好吧，你可以非常黑客地复制这个，创建一个新文件，然后粘贴进去。

1574
01:41:05,810 --> 01:41:06,770
或者不，不，不。

1575
01:41:06,770 --> 01:41:09,890
我们现在知道如何重命名，因为这是我们的选项之一。

1576
01:41:09,890 --> 01:41:11,100
让我来吧。

1577
01:41:11,100 --> 01:41:17,600
让我用 mv 命令移动、hello、hello.c，然后按回车键。

1578
01:41:17,600 --> 01:41:20,250
你会看到标签页关闭，因为 hello 已不存在。

1579
01:41:20,250 --> 01:41:25,130
但如果我现在键入 ls，你会看到，啊，有 hello.c。

1580
01:41:25,130 --> 01:41:28,910
如果我现在打开那个文件，哇，里面都是我的代码。

1581
01:41:28,910 --> 01:41:37,350
现在，如果我制作 hello -- 制作 hello -- 我就能得到一个可执行文件，在这个文件中，世界被还原了。

1582
01:41:37,350 --> 01:41:43,020
因此，mv 不仅是一个重命名命令，最终还可以用来移动文件。

1583
01:41:43,020 --> 01:41:45,230
您还可以创建目录或文件夹。

1584
01:41:45,230 --> 01:41:48,950
例如，如果我再次进入 VS 代码，假设

1585
01:41:48,950 --> 01:41:52,760
我把鼠标悬停在这里，点击的不是加号文件图标，而是加号文件夹、

1586
01:41:52,760 --> 01:41:57,620
例如，我可以在班级中创建一个名为 pset1 的文件夹，用于问题集 1。

1587
01:41:57,620 --> 01:42:02,840
现在你会发现它是空的，因为我的所有其他文件都在我账户的默认文件夹中。

1588
01:42:02,840 --> 01:42:05,460
但我也可以这样进去。

1589
01:42:05,460 --> 01:42:13,430
我可以点击 "文件"，现在我可以创建一个名为 mario.c 的新文件，例如，这是第一个问题之一。

1590
01:42:13,430 --> 01:42:18,960
但你现在会发现，mario.c 位于 pset1 文件夹内。

1591
01:42:18,960 --> 01:42:23,300
因此，如果我放大并在终端窗口输入 ls、

1592
01:42:23,300 --> 01:42:26,720
我在任何地方都看不到 mario.c。

1593
01:42:26,720 --> 01:42:28,688
但我确实看到了 pset1 文件夹。

1594
01:42:28,688 --> 01:42:31,730
它是浅蓝色的，后面有一条斜线，你不必输入。

1595
01:42:31,730 --> 01:42:33,300
它只是表示这是一个文件夹。

1596
01:42:33,300 --> 01:42:37,640
现在，我可以在左上方清楚地看到 pwet1 包含 mario.c。

1597
01:42:37,640 --> 01:42:42,800
但如果我想在这里制作马里奥，就没有制作目标马里奥的规则。

1598
01:42:42,800 --> 01:42:44,510
它似乎并不存在。

1599
01:42:44,510 --> 01:42:46,650
那是因为你进入了错误的目录。

1600
01:42:46,650 --> 01:42:51,560
因此，在命令行界面中，并不是点击文件夹就能打开的。

1601
01:42:51,560 --> 01:42:55,250
您必须更改目录或文件夹。

1602
01:42:55,250 --> 01:42:57,660
cd 将是那里的命令。

1603
01:42:57,660 --> 01:43:00,600
因此，如果我想真正进入该目录、

1604
01:43:00,600 --> 01:43:04,070
我可以进行 cd、空格、pset1、回车。

1605
01:43:04,070 --> 01:43:05,960
现在你会看到我的提示变化。

1606
01:43:05,960 --> 01:43:09,200
这只是一个常见的惯例，但并不是唯一的惯例。

1607
01:43:09,200 --> 01:43:12,470
现在我还有一个美元符号，表示我可以在哪里输入命令。

1608
01:43:12,470 --> 01:43:16,520
但在它之前，我会看到一个提示，不断提醒我在哪个文件夹中。

1609
01:43:16,520 --> 01:43:26,120
我们故意把它放在那里，就像很多 Linux 用户一样，只是为了提醒自己在哪里，因为不像 macOS 或 Windows，在那里会有一个漂亮的大窗口告诉你在哪里、

1610
01:43:26,120 --> 01:43:29,000
在命令行中，需要用文字提醒您。

1611
01:43:29,000 --> 01:43:33,350
但现在如果我输入 ls 并按回车键，会看到什么？

1612
01:43:33,350 --> 01:43:34,340
听众：马里奥.c

1613
01:43:34,340 --> 01:43:36,170
是的，Mario.C。

1614
01:43:36,170 --> 01:43:43,940
现在，如果我想打开它 -- 如果我想真正编译它，我可以在这个目录下运行 make mario，一旦我真正键入了所有代码。

1615
01:43:43,940 --> 01:43:50,810
请放心，在问题集和实验中，我们几乎总是--当然，在上课的前几周--会给你准确的命令让你输入。

1616
01:43:50,810 --> 01:43:55,100
由于这对你们中的许多人来说都很陌生，你们很可能会不小心键入错误的命令。

1617
01:43:55,100 --> 01:43:56,000
没什么大不了的。

1618
01:43:56,000 --> 01:43:58,850
请记住，您有不同的方法来解决这些问题。

1619
01:43:58,850 --> 01:44:02,198
你已经有了图形化的文件资源管理器，它应该会让你感觉更熟悉一些。

1620
01:44:02,198 --> 01:44:14,420
但是，随着时间的推移，你会开始知道，而且老实说，你可能更喜欢这些命令，比如 cd 表示更改目录，cp 表示复制文件，ls 表示列表，mkdir 表示创建目录------------------。

1621
01:44:14,420 --> 01:44:21,924
用命令行而不是按钮创建新文件夹--mv 表示移动或重命名，rm 表示--

1622
01:44:21,924 --> 01:44:22,770
听众：删除。

1623
01:44:22,770 --> 01:44:23,728
DAVID J. MALAN: 删除。

1624
01:44:23,728 --> 01:44:24,960
所以一定要小心。

1625
01:44:24,960 --> 01:44:26,520
Rmdir，删除目录。

1626
01:44:26,520 --> 01:44:28,860
还有几十、几百条其他命令。

1627
01:44:28,860 --> 01:44:33,310
你不需要很多，但随着时间的推移，我们会开始接触到更多的表面。

1628
01:44:33,310 --> 01:44:40,380
但归根结底，这个命令行界面将是一个更强大的机制，一个更有能力的机制，最终也是一个更高效的机制

1629
01:44:40,380 --> 01:44:51,880
虽然知道初期会有一些成长的烦恼，但因为对你们中的许多人来说可能太陌生了。

1630
01:44:51,880 --> 01:44:56,475
所以说，我们还有一些问题要解决，但我们今天答应了要做饼干。

1631
01:44:56,475 --> 01:44:58,350
我们先休息 10 分钟。

1632
01:44:58,350 --> 01:45:00,150
现在，我们在前厅供应饼干。

1633
01:45:00,150 --> 01:45:02,910
我们10分钟后回来

1634
01:45:02,910 --> 01:45:04,740
好了，我们回来了。

1635
01:45:04,740 --> 01:45:10,740
到目前为止，我们所做的每一个 C 语言代码示例都是为了展示一个特定的主题。

1636
01:45:10,740 --> 01:45:17,880
但我们认为，我们可以试着退一步，解决一个更普遍的问题，让大家了解在给定一个问题集的情况下，比如说，或者仅仅是

1637
01:45:17,880 --> 01:45:25,260
更笼统地说，在不清楚练习重点是什么的情况下，如何着手解决编程问题？

1638
01:45:25,260 --> 01:45:31,500
昔日我最喜欢的游戏之一就是这款 "超级马里奥兄弟"。

1639
01:45:31,500 --> 01:45:37,450
但在这款最初的二维侧滚动游戏中，有很多这样的作品。

1640
01:45:37,450 --> 01:45:40,260
例如，天空中就有四个问号。

1641
01:45:40,260 --> 01:45:49,920
我们会发现，最初在 C 语言和许多编程语言中，专注于黑白类型的交互式文本程序要容易得多，也容易得多。

1642
01:45:49,920 --> 01:45:55,830
但不久之后，更多的是图形声学类型的程序。

1643
01:45:55,830 --> 01:46:00,720
但现在，请允许我建议我们尝试用 ASCII 艺术来实现 --

1644
01:46:00,720 --> 01:46:09,120
ASCII，又是将数字映射为字母的代码，至少对于英语来说，是将这些数字映射为天空中问号的文字版本。

1645
01:46:09,120 --> 01:46:11,130
因此，让我转到 VS Code。

1646
01:46:11,130 --> 01:46:16,923
我将创建我自己版本的 mario.c，它与你们在问题集 1 中遇到的版本不同。

1647
01:46:16,923 --> 01:46:24,810
事实上，在问题集 1 中，你将面临的挑战是建立一个类似的小东西，尽管用的是 ASCII 艺术的标签，而不是图形。

1648
01:46:24,810 --> 01:46:28,120
在 mario.c 中，我想先解决这个简单的问题。

1649
01:46:28,120 --> 01:46:29,710
因此，这一切都涉及输出。

1650
01:46:29,710 --> 01:46:33,090
因此，我将包含 stdio.h，以便使用 printf。

1651
01:46:33,090 --> 01:46:37,043
我将做我的 int main(void)--更多关于为什么我们要继续这样做的内容将在今后几周内陆续介绍。

1652
01:46:37,043 --> 01:46:42,210
最初我只想做一些简单的操作，比如 1、2、3、4，反斜杠 n。

1653
01:46:42,210 --> 01:46:50,410
这是我能用纯文本在天空中实现四个问号的最简单方法。

1654
01:46:50,410 --> 01:46:54,180
所以，让我继续制作马里奥，./马里奥，然后就可以了。

1655
01:46:54,180 --> 01:46:55,830
我们有这四个问号。

1656
01:46:55,830 --> 01:46:58,830
当然，我们也看到有更好的办法。

1657
01:46:58,830 --> 01:47:03,150
如果你想把它概括为五个问号，那就是六个、

1658
01:47:03,150 --> 01:47:08,100
60 个不同的问号，循环始终是不重复的答案。

1659
01:47:08,100 --> 01:47:17,100
因此，也许我应该更灵活地改写一下，这样说：在 i 中得到 0，i 小于 4，i++。

1660
01:47:17,100 --> 01:47:25,800
然后在 for 循环内部，现在我可以只做一个问号，但我认为我刚才做的并不正确。

1661
01:47:25,800 --> 01:47:29,280
有谁发现了美学上的错误？

1662
01:47:29,280 --> 01:47:34,200
是啊，如果我想打印同样的东西，为什么这样做不对？

1664
01:47:34,710 --> 01:47:38,275
反斜杠 n反斜杠 n，你说要用到[INNAUDIBLE]. .

1665
01:47:38,275 --> 01:47:39,150
是的。

1666
01:47:39,150 --> 01:47:44,760
因此，我不认为我需要在每个问号后都加上反斜杠 n，因为我们的目标同样是在天空中出现这一排问号。

1667
01:47:44,760 --> 01:47:50,700
因此，如果我现在重新编译这个程序，编译出 mario、./mario，OK，就差不多了。

1668
01:47:50,700 --> 01:47:54,820
但现在，我又回到了美元符号不在自己一行的情况。

1669
01:47:54,820 --> 01:47:59,890
所以我想我需要一条新的线路，但我不认为我想在这里，因为这不会有好结果。

1670
01:47:59,890 --> 01:48:01,015
我想去哪里？

1671
01:48:03,310 --> 01:48:03,960
有什么直觉吗？

1673
01:48:05,610 --> 01:48:07,380
是啊，所以在外面循环。

1674
01:48:07,380 --> 01:48:11,640
因此，我可以在第 8 行的下方和第 9 行的上方新建一个。

1675
01:48:11,640 --> 01:48:15,273
现在完全可以像这样打印一行新的内容。

1676
01:48:15,273 --> 01:48:17,190
您不必用它打印任何其他东西。

1677
01:48:17,190 --> 01:48:18,970
它本身就是一个角色。

1678
01:48:18,970 --> 01:48:21,900
让我们最后再做一次马里奥，./马里奥。

1679
01:48:21,900 --> 01:48:24,010
好了，现在我们言归正传。

1680
01:48:24,010 --> 01:48:31,380
那么，如果我们想做 "马里奥 "中的其他场景，比如这里有很多像这些砖块一样的垂直障碍物的场景呢？

1681
01:48:31,380 --> 01:48:38,160
如果我现在想打印出一列三块砖--我会用标签来代替任何图形--好吧、

1682
01:48:38,160 --> 01:48:40,650
我想我们快到了，对吗？

1683
01:48:40,650 --> 01:48:44,080
我想我现在可以了，也许会轻松一些。

1684
01:48:44,080 --> 01:48:49,050
我可以回到这里，把问号改成更像砖块的东西，比如这个散列符号。

1685
01:48:49,050 --> 01:48:56,368
我想现在我确实需要新的行字符，因为当我现在制作马里奥时，./马里奥，OK，这就是我的四人墙。

1686
01:48:56,368 --> 01:48:56,910
哦，等等。

1687
01:48:56,910 --> 01:48:58,050
我不想要四个。

1688
01:48:58,050 --> 01:49:02,320
我只想在这个特定场景中保持一致，所以我只想要三个。

1689
01:49:02,320 --> 01:49:04,780
因此，我仍然可以在一个地方进行更改。

1690
01:49:04,780 --> 01:49:06,330
而这里，又是这种范式。

1691
01:49:06,330 --> 01:49:15,870
即使你使用的是 4 或 3，如果你养成了从 0 开始数数的习惯，你就会一直数到你想要数到的数值，但不会数完。

1692
01:49:15,870 --> 01:49:20,055
这就是为什么我用 less than 而不是 less than 或 equal to 的原因。

1693
01:49:20,055 --> 01:49:25,360
因此，这将是常见的范例，尽管你可以像我们之前看到的那样，用不同的方式来计算它。

1694
01:49:25,360 --> 01:49:27,965
但如果事态进一步升级呢？

1695
01:49:27,965 --> 01:49:35,400
在地下版的 "超级马里奥兄弟 "中，有很多这样的地下障碍物，包括像这样的砖块网格。

1696
01:49:35,400 --> 01:49:45,400
让我猜想一下，如果你把它切成小块，它大概是一个 3 乘 3 的砖块网格，所有砖块都漂亮地交错在一起，形成了这样一块又大又大的砖块。

1697
01:49:45,400 --> 01:49:56,580
因此，如果我想打印出一个 3 乘 3 的网格，现在事情变得有点有趣了，因为到目前为止，我都是水平打印一行或垂直打印一列。

1698
01:49:56,580 --> 01:49:58,380
但我们还没有看到任何代码可以

1699
01:49:58,380 --> 01:50:02,670
我是在打印，还是像游戏中暗示的那样生活在两个不同的维度中。

1700
01:50:02,670 --> 01:50:05,560
但我建议我们可以这样做。

1701
01:50:05,560 --> 01:50:10,500
让我继续说，好吧，假设我想打印一个 3 乘 3 的砖块网格。

1702
01:50:10,500 --> 01:50:16,590
其实是我想打印三排砖块。

1703
01:50:16,590 --> 01:50:18,063
一个网格为三行。

1704
01:50:18,063 --> 01:50:22,345
那么，如果我把这个高层次的想法简化一下，该怎么做呢？

1705
01:50:22,345 --> 01:50:24,720
好吧，让我先把 printf 去掉。

1706
01:50:24,720 --> 01:50:33,390
让我来说明一下，这个 for 循环虽然还没有做任何有用的事情，但它会做多少次？

1707
01:50:33,390 --> 01:50:34,530
好的，三次

1708
01:50:34,530 --> 01:50:35,850
这个 for 循环就可以运行了。

1709
01:50:35,850 --> 01:50:39,390
只需使用 i 进行计数，它就能做三次。

1710
01:50:39,390 --> 01:50:51,090
好吧，如果我现在想打印出同一行的三块砖，这和我们之前打印天空中四个问号的方法很相似。

1711
01:50:51,090 --> 01:50:52,960
因此，我们已经看到了解决方案。

1712
01:50:52,960 --> 01:50:55,450
我敢说，我们可以把其中一个编入另一个。

1713
01:50:55,450 --> 01:50:58,590
因此，如果我想打印出一排砖块、

1714
01:50:58,590 --> 01:51:11,700
我可以这样做：for in i get 0 i less than 3 i++，然后在这个内循环中，让我像这样打印出一块砖。

1715
01:51:11,700 --> 01:51:17,820
然后，我不喜欢这样下去，但我觉得我把两个想法结合起来了。

1716
01:51:17,820 --> 01:51:23,080
但是，第 5 行和第 7 行目前可能存在什么问题呢？

1717
01:51:23,080 --> 01:51:24,700
这里有什么不好？

1718
01:51:24,700 --> 01:51:25,345
是啊，在后面？

1719
01:51:25,345 --> 01:51:27,665
听众：你用的是同一个整数 i。

1720
01:51:27,665 --> 01:51:30,040
戴维-J-马兰：是的，我使用的是同样的整数 i，也就是

1721
01:51:30,040 --> 01:51:32,080
我觉得这会给我带来麻烦。

1722
01:51:32,080 --> 01:51:38,470
如果我想在这里计算三件事，但我劫持了这个变量，并在循环中使用它、

1723
01:51:38,470 --> 01:51:41,560
我觉得我应该避免这种名字的碰撞。

1724
01:51:41,560 --> 01:51:43,930
那么，除了 i 之外，还有什么好的替代品呢？

1725
01:51:43,930 --> 01:51:47,980
程序员如果以这种方式嵌套循环，通常会选择 j。

1726
01:51:47,980 --> 01:51:52,600
如果您需要更多描述性变量，当然可以将其改为行和列。

1727
01:51:52,600 --> 01:51:54,940
但 i 和 j 是非常典型的。

1728
01:51:54,940 --> 01:51:59,020
所以我要继续这样做，用 j++ 代替 i++。

1729
01:51:59,020 --> 01:52:00,280
让我试着编译一下。

1730
01:52:00,280 --> 01:52:04,330
因此，创建马里奥，回车，./马里奥。

1731
01:52:04,330 --> 01:52:06,560
好吧，这里有几处出错了。

1732
01:52:06,560 --> 01:52:08,480
这不是一个 3 乘 3 的网格。

1733
01:52:08,480 --> 01:52:12,855
但如果算上这些东西，我确实至少印了多少？

1734
01:52:12,855 --> 01:52:14,485
你或许可以从逻辑上猜一猜。

1735
01:52:14,485 --> 01:52:15,110
听众：九个

1736
01:52:15,110 --> 01:52:17,110
是的，这里有九个哈希值。

1737
01:52:17,110 --> 01:52:21,340
不幸的是，它们都在同一条线路上，而不是在三条不同的线路上。

1738
01:52:21,340 --> 01:52:24,910
那么，从逻辑上讲，我能从哪里解决这个问题呢？

1739
01:52:24,910 --> 01:52:26,535
我一定要把所有砖块都打印出来。

1740
01:52:26,535 --> 01:52:28,077
他们只是层次不对而已。

1742
01:52:28,646 --> 01:52:32,620
听众：如果在第一个循环处另起一行，那么就会有三行独立的行。

1743
01:52:32,620 --> 01:52:33,495
是的。

1744
01:52:33,495 --> 01:52:38,000
因此，在第一个循环，也就是这个内循环，也就是嵌套循环之后换一行。

1745
01:52:38,000 --> 01:52:41,030
所以，让我先在这里打印出一个反斜线 n。

1746
01:52:41,030 --> 01:52:42,073
这是在干什么？

1747
01:52:42,073 --> 01:52:47,270
我想，只要在完成一行后将光标移到下一行，就能解决这个问题。

1748
01:52:47,270 --> 01:52:52,070
所以，让我继续做马里奥，回车，./马里奥，现在我们开始工作了。

1749
01:52:52,070 --> 01:52:59,350
因此，这是同一个图形的一个非常简单的版本，但我现在利用了两个不同的想法--或者说是同一个想法的两倍。

1750
01:52:59,350 --> 01:53:03,970
我使用一个循环来控制光标一行一行地移动。

1751
01:53:03,970 --> 01:53:10,960
但在这个循环中，我从左到右，点、点、点、点、点、点，像这样打印出每个独立的砖块。

1752
01:53:10,960 --> 01:53:13,600
现在，这里还是有点马虎。

1753
01:53:13,600 --> 01:53:26,420
如果我想让它始终是一个正方形，只是因为它在游戏中是这个样子的，那么，我可以用这个方法把它改成一个 4 乘 4 的正方形，或者用这个方法把它改成一个 5 乘 5 的网格--哎呀--。

1754
01:53:26,420 --> 01:53:30,010
为什么在下列情况下，不断改变数字可能不是最好的设计呢？

1755
01:53:30,010 --> 01:53:33,330
我想改变尺寸？

1756
01:53:33,330 --> 01:53:34,440
哪里会出问题？

1758
01:53:35,010 --> 01:53:38,255
如果是正方形，[听不清]

1759
01:53:38,255 --> 01:53:39,130
是的。

1760
01:53:39,130 --> 01:53:43,060
如果它始终是正方形，高度与宽度相同，我就是在自找麻烦，对吗？

1761
01:53:43,060 --> 01:53:44,110
最终，我还是会搞砸的。

1762
01:53:44,110 --> 01:53:45,680
我打算换一个，但不换另一个。

1763
01:53:45,680 --> 01:53:48,070
那么它就会变成一个长方形，而不是正方形。

1764
01:53:48,070 --> 01:53:50,410
因此，我可能应该用不同的方法来解决这个问题。

1765
01:53:50,410 --> 01:53:51,160
那就让我来吧。

1766
01:53:51,160 --> 01:54:01,000
在我的主函数顶端，让我继续给自己一个名为 maybe n 的变量，表示我想要的横向和纵向砖块数量。

1767
01:54:01,000 --> 01:54:03,550
我将初始化为 3。

1768
01:54:03,550 --> 01:54:06,610
这里不用 3，直接用 n。

1769
01:54:06,610 --> 01:54:13,000
但我会在两个地方都这样做，这样，从今往后，如果我想把它改成 4，或 5，或其他任何地方、

1770
01:54:13,000 --> 01:54:13,845
我都做完了。

1771
01:54:13,845 --> 01:54:16,720
设计得更好是因为出错的概率更低。

1772
01:54:16,720 --> 01:54:19,840
但从技术上讲，我还是有可能搞砸的。

1773
01:54:19,840 --> 01:54:28,985
从技术上讲，我可能不小心写了一行像 n++ 这样的代码，或者我可以直接更改该变量的值，即使我并不想让它发生变化。

1774
01:54:28,985 --> 01:54:31,693
也许是因为我是个糟糕的程序员，我复制/粘贴错了、

1775
01:54:31,693 --> 01:54:34,240
我的同事不知道 n 代表什么、

1776
01:54:34,240 --> 01:54:41,020
我可以通过上移到第 5 行来保护自己和我的代码，避免出现类似的人为错误。

1777
01:54:41,020 --> 01:54:44,170
而不是像在 Scratch 中那样，只声明一个简单的变量、

1778
01:54:44,170 --> 01:54:50,740
我可以使用关键字 const 将代码声明为常量，从而进一步强化我的代码。

1779
01:54:50,740 --> 01:55:02,320
现在，这只是 C 语言和其他一些语言的一个功能，通过主动说 n 是一个常数，特别是数字 5 或以前的数字 3，来保护你自己。

1780
01:55:02,320 --> 01:55:05,530
您不能意外地在其他地方编写代码来更改它。

1781
01:55:05,530 --> 01:55:08,420
计算机将抛出错误并捕捉该错误。

1782
01:55:08,420 --> 01:55:12,160
因此，这只是一种防御性更强的编程方式。

1783
01:55:12,160 --> 01:55:13,235
有些语言有这种功能。

1784
01:55:13,235 --> 01:55:14,110
有些语言则没有。

1785
01:55:14,110 --> 01:55:15,970
但总的来说，这是一种很好的做法。

1786
01:55:15,970 --> 01:55:23,570
它能让你的代码设计得更好，因为你、同事或其他使用代码的人同样不容易犯错。

1787
01:55:23,570 --> 01:55:26,420
因此，让我把默认值改回 3。

1788
01:55:26,420 --> 01:55:28,580
但现在我在两个地方都用 n。

1789
01:55:28,580 --> 01:55:33,250
如果我做了马里奥，./马里奥，我们又回到了最初的起点。

1790
01:55:33,250 --> 01:55:35,560
但代码设计得更好一些。

1791
01:55:35,560 --> 01:55:37,330
让我也注意到这一点。

1792
01:55:37,330 --> 01:55:40,720
一直以来，我都在说正确性很重要。

1793
01:55:40,720 --> 01:55:41,740
设计很重要。

1794
01:55:41,740 --> 01:55:43,700
还有一个风格问题。

1795
01:55:43,700 --> 01:55:48,940
我一直在刻意编写漂亮的代码，而不仅仅是语法高亮，因为语法高亮是自动的。

1796
01:55:48,940 --> 01:55:52,060
但请注意，我把所有内容都很好地缩进了。

1797
01:55:52,060 --> 01:55:57,400
只要我使用大括号，比如第 4 行和第 14 行，所有内容都会缩进一级。

1798
01:55:57,400 --> 01:56:04,520
当我在第 7 行和第 13 行添加大括号时，所有内容也都很好地缩进了。

1799
01:56:04,520 --> 01:56:10,090
从技术上讲，计算机并不关心这种空白。

1800
01:56:10,090 --> 01:56:17,080
你可能会因为风格怪异或马虎而把事情弄得一团糟。

1801
01:56:17,080 --> 01:56:20,170
但实际上，这段代码仍然是正确的。

1802
01:56:20,170 --> 01:56:28,270
如果我重新编译--让我打开终端窗口--make mario，没有错误，./mario，工作得非常好。

1803
01:56:28,270 --> 01:56:36,860
但你可以想象，现在读这篇文章有多烦人，当然是对助教而言，但对第二天的你而言，对必须读你代码的同事而言，肯定也是如此。

1804
01:56:36,860 --> 01:56:38,020
这就是坏作风。

1805
01:56:38,020 --> 01:56:44,230
它仍然有效，而且设计得很好，因为你在编写代码时采取了防御措施，使用了常量。

1806
01:56:44,230 --> 01:56:46,420
但是，我的天哪，风格太糟糕了。

1807
01:56:46,420 --> 01:56:53,710
现在，你经常会发现有一些工具可以帮助你以符合课程或公司风格的方式格式化代码。

1808
01:56:53,710 --> 01:56:57,220
但这种肌肉记忆也是需要长期培养的。

1809
01:56:57,220 --> 01:57:03,565
在 VS 代码为您输出代码行时，请采纳这些建议，因为它正试图以可读的方式格式化您的代码。

1810
01:57:03,565 --> 01:57:11,800
而且，我的天哪，如果你的代码中确实存在错误，甚至连缩进都不正确，你这个人类是绝对无法理解的

1811
01:57:11,800 --> 01:57:13,690
发生了什么，在哪里。

1812
01:57:13,690 --> 01:57:16,060
你只是在给自己找麻烦。

1813
01:57:16,060 --> 01:57:21,190
因此，也要养成这种习惯，彰显良好的风格。

1814
01:57:21,190 --> 01:57:24,880
好吧，我建议我们不要只用 3 乘 3 的网格。

1815
01:57:24,880 --> 01:57:26,840
我们希望它更有活力一些。

1816
01:57:26,840 --> 01:57:32,020
因此，假设我们不再使用常数，而是使用一个名为 n 的整数。

1817
01:57:32,020 --> 01:57:38,320
然后，让我们通过 get_int 向用户询问网格的大小，就像我们之前所做的那样。

1818
01:57:38,320 --> 01:57:40,150
我把它放在这里。

1819
01:57:40,150 --> 01:57:46,450
然后，我就可以继续以更动态的方式运行 make mario 来编译它--哎呀。

1820
01:57:46,450 --> 01:57:49,930
哦，我不小心搞砸了。

1821
01:57:49,930 --> 01:57:53,785
它在暗示我做什么，尽管很隐晦？

1822
01:57:53,785 --> 01:57:56,660
听众：您必须包含 cs50.h。

1823
01:57:56,660 --> 01:57:59,930
戴维-J-马兰：是的，我忘了把 CS50 头文件放在最上面。

1824
01:57:59,930 --> 01:58:03,420
这就是为什么它不知道 get_int 实际上是有效的。

1825
01:58:03,420 --> 01:58:04,880
所以这很容易解决。

1826
01:58:04,880 --> 01:58:07,730
我要在这里加入 cs50.h。

1827
01:58:07,730 --> 01:58:10,790
现在我要清空我的终端，然后重新运行 make mario。

1828
01:58:10,790 --> 01:58:12,800
现在我们没事了

1829
01:58:12,800 --> 01:58:14,550
现在请注意我的尺寸。

1830
01:58:14,550 --> 01:58:16,490
因此，如果我输入 3，情况就和以前一样了。

1831
01:58:16,490 --> 01:58:20,900
如果我输入 10，它就更大了，但现在都是自动发生的。

1832
01:58:20,900 --> 01:58:23,360
但有些东西我们没有检测到。

1833
01:58:23,360 --> 01:58:25,940
例如，假设我输入 cat。

1834
01:58:25,940 --> 01:58:28,770
正如我之前所说，get_int 函数可以处理这个问题。

1835
01:58:28,770 --> 01:58:30,687
这是使用图书馆的特点之一。

1836
01:58:30,687 --> 01:58:32,570
您不必处理错误的输入。

1837
01:58:32,570 --> 01:58:36,200
但我们只设计了一个名为 get_int 的函数来获取一个整数。

1838
01:58:36,200 --> 01:58:40,680
我们不知道你是想让它是正数、负数、零，还是它们的组合。

1839
01:58:40,680 --> 01:58:48,440
而且，允许用户输入负 1 来表示网格大小，或者输入负 3 来表示网格大小，也有点奇怪。

1840
01:58:48,440 --> 01:58:51,230
事实上，你的代码什么也没做，所以至少不会崩溃。

1841
01:58:51,230 --> 01:58:52,730
但这有点愚蠢，对吗？

1842
01:58:52,730 --> 01:58:57,150
如果用户想要一个网格，最好能强制他们给我们一个正值。

1843
01:58:57,150 --> 01:58:58,530
那么，我们怎样才能做到这一点呢？

1844
01:58:58,530 --> 01:59:08,190
好吧，我可以在这里说，如果 n 小于 1 -- 所以，如果是 0 或负数，这是我不想要的，我能做什么呢？

1845
01:59:08,190 --> 01:59:12,380
好吧，我可以说，好吧，再次提示用户尺寸。

1846
01:59:12,380 --> 01:59:18,530
现在请注意，我没有再次声明 n，因为一旦 n 存在，你就不必再提及数据类型了。

1847
01:59:18,530 --> 01:59:19,790
我们之前已经说过了。

1848
01:59:19,790 --> 01:59:21,510
但这有点愚蠢。

1850
01:59:22,010 --> 01:59:25,190
因为现在你给了用户第二次机会，好了，现在也许

1851
01:59:25,190 --> 01:59:33,020
好吧，如果这个版本的 n 小于 1，那我们就第三次提示用户。

1852
01:59:33,020 --> 01:59:35,240
我的意思是，你可以看到这愚蠢的走向。

1853
01:59:35,240 --> 01:59:39,860
不断递归地重复输入同样的内容，这不可能是正确的解决方案。

1854
01:59:39,860 --> 01:59:40,790
它会在哪里停止？

1855
01:59:40,790 --> 01:59:44,810
你必须给他们有限的机会，否则就会把你的代码弄得一团糟。

1856
01:59:44,810 --> 01:59:48,170
那么，什么才是直观上更好的解决方案呢？

1857
01:59:48,170 --> 01:59:49,128
听众：一个 while 循环。

1858
01:59:49,128 --> 01:59:50,920
戴维-J-马兰：是的，所以是某种循环。

1859
01:59:50,920 --> 01:59:52,160
我们已经看到了一个 while 循环。

1860
01:59:52,160 --> 01:59:54,240
我们看到过 for 循环，所以可能是其中之一。

1861
01:59:54,240 --> 01:59:55,290
让我试试这个。

1862
01:59:55,290 --> 01:59:58,760
让我删掉这些乱七八糟的东西，回到第一个问题上来。

1863
01:59:58,760 --> 01:59:59,790
让我来吧

1864
01:59:59,790 --> 02:00:09,560
因此，当 n 小于 1 时，当数字不是我们想要的时，让我们在一个循环中再次提示用户大小。

1865
02:00:09,560 --> 02:00:15,470
现在，这里的情况也有所改善，因为只有两个信息请求。

1866
02:00:15,470 --> 02:00:19,640
但很明显，除了 int 之外，第 6 行和第 9 行基本相同。

1867
02:00:19,640 --> 02:00:26,300
如果我改变了尺寸，如果我增加了这个，如果我改变了这里的措辞，把它改成另一种语言、

1868
02:00:26,300 --> 02:00:27,350
我必须在两个地方进行修改。

1869
02:00:27,350 --> 02:00:27,850
真糟糕

1870
02:00:27,850 --> 02:00:29,330
复制/粘贴，糟糕。

1871
02:00:29,330 --> 02:00:31,040
那么，怎样做会更好呢？

1872
02:00:31,040 --> 02:00:37,730
事实证明，C 语言中还有另一种模式可以解决这个问题，即代码重复的问题。

1873
02:00:37,730 --> 02:00:41,210
如果我只写一次代码就好了。

1874
02:00:41,210 --> 02:00:45,510
我可以使用第三种名为 do while 循环的循环来做到这一点。

1875
02:00:45,510 --> 02:00:48,000
事实证明，在 C 语言中，你可以做到这一点。

1876
02:00:48,000 --> 02:00:53,370
如果要获取一个变量（如 n）的值，首先要创建一个没有初始值的变量。

1877
02:00:53,370 --> 02:00:56,870
所以 int n 分号意味着我们不知道它的值是多少，没错。

1878
02:00:56,870 --> 02:00:57,590
不过没关系。

1879
02:00:57,590 --> 02:00:59,840
我们最终会为它增值。

1880
02:00:59,840 --> 02:01:02,870
那我就这么说了，照着字面意思做。

1881
02:01:02,870 --> 02:01:04,460
我要打开我的卷曲牙套。

1882
02:01:04,460 --> 02:01:05,930
我想做什么？

1883
02:01:05,930 --> 02:01:11,750
我想将 get_int 的返回值赋值给 n，并提示用户输入大小。

1884
02:01:11,750 --> 02:01:14,040
那你想什么时候做？

1885
02:01:14,040 --> 02:01:17,900
我想在 n 小于 1 的情况下这样做。

1886
02:01:17,900 --> 02:01:23,570
现在，这段代码可以实现完全相同的目标，但却永远不会重复我自己。

1888
02:01:24,230 --> 02:01:31,175
注意这些代码的第 6 行，给我一个整型变量 n。

1889
02:01:31,175 --> 02:01:33,300
它最初没有价值，但没关系。

1890
02:01:33,300 --> 02:01:34,640
你可以做到这一点。

1891
02:01:34,640 --> 02:01:36,380
第 7 行说，请执行以下操作。

1892
02:01:36,380 --> 02:01:41,660
get_int，提示用户字的大小，然后将该值存储在 n 中。

1893
02:01:41,660 --> 02:01:53,670
但是，由于 C 代码从上到下、从左到右运行，因此在第 11 行提出这样的问题是合理的："好的，当前的 n 值（它肯定是在第 8 行得到的）小于 1 吗？

1894
02:01:53,670 --> 02:01:58,400
如果用户不合作--他们输入了 0、负 1 或负 3--会发生什么？

1895
02:01:58,400 --> 02:02:04,530
它会回到这里，重复、重复、重复 do while 循环中的所有内容。

1896
02:02:04,530 --> 02:02:08,480
因此，C 语言中的 do while 循环是其他语言所没有的。

1897
02:02:08,480 --> 02:02:10,730
Python 没有 do while 循环。

1898
02:02:10,730 --> 02:02:20,570
这也许是最简洁的方法了，尽管你必须在上面声明变量、创建变量，然后在下面检查变量，这有点奇怪。

1899
02:02:20,570 --> 02:02:22,980
除此之外，它与 while 循环类似。

1900
02:02:22,980 --> 02:02:26,150
它只是颠倒了你提问的顺序。

1901
02:02:26,150 --> 02:02:28,820
对这一结构有任何疑问？

1902
02:02:28,820 --> 02:02:35,640
一般来说，当你想从用户那里获得输入并确保它满足某些要求时，"一边做一边看 "就会非常有用。

1903
02:02:35,640 --> 02:02:39,530
好了，在刚才的插曲之后，我们有了这个基础。

1904
02:02:39,530 --> 02:02:41,750
如何清理这些代码？

1905
02:02:41,750 --> 02:02:47,720
最后，让我们来看看我们的代码不能做或不能很好地做或不能正确地做的事情。

1906
02:02:47,720 --> 02:02:53,520
请允许我提议，在《马里奥》的最终版本中，请允许我添加一些所谓的评论。

1907
02:02:53,520 --> 02:02:59,173
原来，在 C 语言代码中，可以定义所谓的注释，也就是自我注解。

1908
02:02:59,173 --> 02:03:00,840
有些人在 Scratch 中发现了这些。

1909
02:03:00,840 --> 02:03:04,680
你可以用黄色的小便签来添加引文或解释。

1910
02:03:04,680 --> 02:03:07,020
在 C 语言中，有几种写注释的方法。

1911
02:03:07,020 --> 02:03:13,860
一般来说，注释是给你自己、你的助教、你的同事的笔记，说明你的代码在做什么、为什么或怎么做。

1912
02:03:13,860 --> 02:03:17,860
这是一个小小的解释性说明，用英语或其他人类语言写成。

1913
02:03:17,860 --> 02:03:27,870
因此，举例来说，在我实现这个版本的马里奥时，我可能会先问自己这样一个问题 --

1914
02:03:27,870 --> 02:03:34,350
首先，我可能会在第一段代码上方的新行中给自己写下这样的备注：获取网格大小。

1915
02:03:34,350 --> 02:03:43,560
这只是一个简短的英语解释性说明，一般会解释接下来的六行左右，也就是下一大块或代码块。

1916
02:03:43,560 --> 02:03:46,500
如果对每一行都进行注释，就有点过分了。

1917
02:03:46,500 --> 02:03:49,680
在某些情况下，程序员应该知道每行代码的作用。

1918
02:03:49,680 --> 02:03:58,110
不过，如果能瞥一眼第 6 行以两个斜线开头的注释就好了，因为语法高亮显示它是灰色的。

1919
02:03:58,110 --> 02:03:59,070
这不符合逻辑。

1920
02:03:59,070 --> 02:04:00,440
这只是一个自我提醒。

1921
02:04:00,440 --> 02:04:05,160
它通常会给我一个小抄，告诉我下面的代码行应该做什么和/或为什么。

1922
02:04:05,160 --> 02:04:08,910
下面还有第二段代码，一共有几行。

1923
02:04:08,910 --> 02:04:14,130
但合在一起，这只是砖块的打印网格。

1924
02:04:14,130 --> 02:04:23,760
因此，我又给自己写了一条评论，通过添加一些英文解释，让人们更容易理解这 20 多行代码在做什么。

1925
02:04:23,760 --> 02:04:33,600
但现在我有了这些，如果能把这些功能抽象出来，把尺寸和网格打印抽象出来，不是很好吗？

1926
02:04:33,600 --> 02:04:37,590
换句话说，假设你不知道从哪里开始解决这个问题。

1927
02:04:37,590 --> 02:04:43,530
现在的问题是要实现一个程序，打印出一个大小可变的砖块网格--

1928
02:04:43,530 --> 02:04:46,440
3，或 4，或 5，或人类输入的任何数字。

1929
02:04:46,440 --> 02:04:56,310
如果你真的不知道从哪里开始，注释其实是一个很好的入门方法，因为注释可以近似于我们所说的上周伪代码。

1930
02:04:56,310 --> 02:05:02,080
伪代码是简明扼要的英语，能让人明白你的意思，就像上次搜索电话簿一样。

1931
02:05:02,080 --> 02:05:06,910
所以，如果你真的不知道从哪里开始，你可以这样做。

1932
02:05:06,910 --> 02:05:14,610
举例来说，我可以在第一步说 "获取网格大小"，然后在第二步说 "打印砖块网格"。

1933
02:05:14,610 --> 02:05:16,410
到目前为止，我的计划就进行到这里。

1934
02:05:16,410 --> 02:05:18,690
现在用伪代码实现了这一点。

1935
02:05:18,690 --> 02:05:20,910
我有一些大型的占位符。

1936
02:05:20,910 --> 02:05:22,380
我还有工作要做。

1937
02:05:22,380 --> 02:05:26,050
不过，至少我在评论中有一个高层次的问题解决方案。

1938
02:05:26,050 --> 02:05:28,230
现在我甚至可以走到这一步。

1939
02:05:28,230 --> 02:05:34,650
我可以说，好吧，假设已经存在一个名为 get size 的函数。

1940
02:05:34,650 --> 02:05:36,220
我可以这样做

1941
02:05:36,220 --> 02:05:38,790
我可以用 int n 等于 get_size。

1942
02:05:38,790 --> 02:05:43,000
现在，我只能暂时假设存在一个名为 get_size 的抽象概念。

1943
02:05:43,000 --> 02:05:43,500
没有。

1944
02:05:43,500 --> 02:05:45,420
CS50 库不附带此功能。

1945
02:05:45,420 --> 02:05:47,520
但我可以发明它，我敢打赌。

1946
02:05:47,520 --> 02:05:49,110
我还能怎么做？

1947
02:05:49,110 --> 02:05:57,060
好吧，我们暂且假设也有一个名为 print_grid 的函数，可以打印出大小为 n 的网格。

1948
02:05:57,060 --> 02:05:58,950
因此，这里也是一个抽象概念。

1949
02:05:58,950 --> 02:06:00,330
这些拼图并不存在。

1950
02:06:00,330 --> 02:06:01,800
这些功能尚不存在。

1951
02:06:01,800 --> 02:06:06,240
但在 C 语言中，就像在 Scratch 中一样，我可以创建自己的函数。

1952
02:06:06,240 --> 02:06:07,600
我该怎么做？

1953
02:06:07,600 --> 02:06:09,630
好吧，让我稍后再往下看。

1954
02:06:09,630 --> 02:06:12,810
按照惯例，您一般希望将 main 放在代码的顶部。

1956
02:06:13,110 --> 02:06:18,090
因为它是主要功能，人眼会通过它来查看某个代码文件做了什么。

1957
02:06:18,090 --> 02:06:19,360
让我来吧

1958
02:06:19,360 --> 02:06:26,010
我想自己创建一个名为 get_size 的函数，它的作用就是获取用户想要的尺寸。

1959
02:06:26,010 --> 02:06:28,380
我希望这个函数返回一个整数。

1960
02:06:28,380 --> 02:06:34,920
这样做的语法是这样的，类似于变量，即该函数返回的数据类型。

1961
02:06:34,920 --> 02:06:37,450
我不需要这个函数接受任何输入。

1962
02:06:37,450 --> 02:06:45,810
因此，我将使用一个新的关键字，这个关键字其实到目前为止我们一直在使用--下次再详述--它叫做 void，意思是这个 get_size 函数不接受任何输入。

1963
02:06:45,810 --> 02:06:46,950
它确实有输出。

1964
02:06:46,950 --> 02:06:48,138
它会输出一个 int。

1965
02:06:48,138 --> 02:06:50,430
而这只是你写的奇怪顺序。

1966
02:06:50,430 --> 02:06:55,920
在括号内写入输出格式、函数名称和输入（如果有）。

1967
02:06:55,920 --> 02:06:57,727
现在我可以实现 get_size。

1968
02:06:57,727 --> 02:06:59,310
但我已经实现了 get_size。

1969
02:06:59,310 --> 02:07:01,140
至少在故事的这个阶段是这样、

1970
02:07:01,140 --> 02:07:03,180
我至少知道该怎么做了。

1971
02:07:03,180 --> 02:07:12,270
最后，我通过反复试验，终于发现，如果我声明一个变量，并执行以下操作 n 等于 get_int，就会提示用户变量的大小、

1972
02:07:12,270 --> 02:07:22,830
当 n 小于 1 时，我继续这样做，一旦该代码块完成，这里有一个新的 C 语言关键字，可以返回 n 值。

1973
02:07:22,830 --> 02:07:27,330
因此，我一直把某些函数返回的这些值称为返回值。

1974
02:07:27,330 --> 02:07:36,970
在 C 语言中，有一个名为 return 的关键字，它可以将相关值交还给任何使用该关键字的函数。

1975
02:07:36,970 --> 02:07:47,280
因此，简而言之，在第 15 行和第 21 行之间，这里有一些与我们之前的解决方案相同的代码，可以从用户那里获取正值 n。

1976
02:07:47,280 --> 02:07:48,720
是 1，还是 2，或者更高。

1977
02:07:48,720 --> 02:07:51,180
不是 0，就是不小于 1。

1978
02:07:51,180 --> 02:07:56,360
一旦我们得到了这个值，我们就把它作为返回值交还给它。

1979
02:07:56,360 --> 02:07:58,990
注意我是如何在第 7 行使用这个函数的。

1980
02:07:58,990 --> 02:08:01,630
就像 get_int 和 get_string 一样、

1981
02:08:01,630 --> 02:08:04,650
我在调用函数--在这种情况下，括号里什么都没有。

1982
02:08:04,650 --> 02:08:09,970
但是，我使用赋值操作符将其返回值复制到我的变量 n 中。

1983
02:08:09,970 --> 02:08:19,090
现在，我有了一个以前不存在的函数 get_size，无论如何都能得到一个正整数。

1984
02:08:19,090 --> 02:08:21,710
现在是网格问题，我该怎么做呢？

1985
02:08:21,710 --> 02:08:27,160
我该如何发明一个名为 print_grid 的函数，它只接受一个参数，即一个数字，并打印出该大小的网格？

1986
02:08:27,160 --> 02:08:29,180
好吧，让我们从这里下去。

1987
02:08:29,180 --> 02:08:32,050
我要写下 print_grid 这个函数的名称。

1988
02:08:32,050 --> 02:08:33,590
该功能只需打印即可。

1989
02:08:33,590 --> 02:08:35,440
正如我们一直说的那样，它有副作用。

1990
02:08:35,440 --> 02:08:38,230
所以我只能说它没有返回值。

1991
02:08:38,230 --> 02:08:39,040
就是无效。

1992
02:08:39,040 --> 02:08:40,820
它本身没有输出。

1993
02:08:40,820 --> 02:08:42,670
这只是美学上的副作用。

1994
02:08:42,670 --> 02:08:44,660
但这确实是一种争论。

1995
02:08:44,660 --> 02:08:52,337
参数就是输入，C 语言的语法是命名输入的类型和变量的名称。

1996
02:08:52,337 --> 02:08:53,920
我想怎么说都行。

1997
02:08:53,920 --> 02:08:54,940
我称之为尺寸。

1998
02:08:54,940 --> 02:08:56,140
我可以称之为 n。

1999
02:08:56,140 --> 02:09:01,030
在不同的函数中使用同一个变量也是可以的，但为了明确起见，我会把它叫做 size。

2000
02:09:01,030 --> 02:09:18,790
在这个函数中，我将从内存中复制与之前相同的代码。for int i gets 0, i less than size-- 而不是 3-- i++，在这个函数内部，for int j gets 0, j is less than size j++、

2001
02:09:18,790 --> 02:09:28,660
并在其中用 printf 打印出一个哈希值，在循环之后打印出一行新的内容，就这样。

2002
02:09:28,660 --> 02:09:30,370
诚然，我做得很快。

2003
02:09:30,370 --> 02:09:32,860
但这和我之前写的代码是一样的。

2004
02:09:32,860 --> 02:09:39,190
但现在，就像我在使用 Scratch 时一样，让我随心所欲地敲几下回车键，把代码移到看不见、摸不着的地方。

2005
02:09:39,190 --> 02:09:40,900
现在我有了抽象概念。

2006
02:09:40,900 --> 02:09:48,160
我现在有了名为 get_size 和 print_grid 的拼图，虽然语法需要适应一下，但它们现在就是存在的。

2007
02:09:48,160 --> 02:09:50,590
但我确实需要做一件事。

2008
02:09:50,590 --> 02:09:59,500
由于 C 语言有点天真，如果我尝试立即制作马里奥并点击回车键，函数 get_size 的隐式声明就会无效。

2009
02:09:59,500 --> 02:10:03,460
我们以前也看到过这种情况，当时我还没有加入文件。

2010
02:10:03,460 --> 02:10:06,362
当我没有包含 CS50 库时，get_int 无法工作。

2011
02:10:06,362 --> 02:10:09,070
但这不是问题所在，因为这不是从图书馆借来的。

2012
02:10:09,070 --> 02:10:10,270
这是我刚刚发明的。

2013
02:10:10,270 --> 02:10:12,580
C 从字面上理解你。

2014
02:10:12,580 --> 02:10:18,910
如果你在文件底部定义了这些函数，它们就不会存在于第 7 行或第 10 行。

2015
02:10:18,910 --> 02:10:20,690
所以我可以这样做。

2016
02:10:20,690 --> 02:10:26,342
我可以，好吧，好吧，让我把这些内容都高亮显示出来，剪切到剪贴板上，然后粘贴到这里。

2017
02:10:26,342 --> 02:10:27,550
这样就能解决问题。

2018
02:10:27,550 --> 02:10:30,280
我可以把所有这些功能都移到文件的顶部。

2019
02:10:30,280 --> 02:10:33,380
这很烦人，因为现在 main 位于文件底部。

2020
02:10:33,380 --> 02:10:34,930
找到它需要更长的时间。

2021
02:10:34,930 --> 02:10:36,560
这不是一个干净的解决方案。

2022
02:10:36,560 --> 02:10:39,170
让我把它放回原来的位置。

2023
02:10:39,170 --> 02:10:40,730
让我来吧

2024
02:10:40,730 --> 02:10:46,060
这是在 CS50 中，实际上也是在 C 语言编程中，复制/粘贴唯一合理的时候。

2025
02:10:46,060 --> 02:10:58,270
如果复制并粘贴每个函数的第一行代码，然后以分号结束，就可以在文件顶端给编译器足够的提示，逗弄编译器："......"。

2026
02:10:58,270 --> 02:11:01,010
好吧，这些功能以后才会存在。

2027
02:11:01,010 --> 02:11:03,190
但这里有一个提示，它们会存在。

2028
02:11:03,190 --> 02:11:07,660
这样才能让编译器相信你。

2029
02:11:07,660 --> 02:11:11,830
因此，这些其他函数仍然可以放在文件的下方，即 main 的下方。

2030
02:11:11,830 --> 02:11:15,190
但现在，当我做马里奥时 -- 哦，该死的。

2031
02:11:15,190 --> 02:11:17,260
哦，我说的是 print 而不是 printf。

2032
02:11:17,260 --> 02:11:20,860
是我的错--printf。

2033
02:11:20,860 --> 02:11:27,790
因此，如果我制作了马里奥，./马里奥，现在我就可以输入 3，然后我们就可以继续工作了。

2034
02:11:27,790 --> 02:11:32,800
现在看来，这是一种非常粗暴的方式，但却能找到一个复杂得多的解决方案。

2035
02:11:32,800 --> 02:11:35,240
但从某种意义上说，这种解决方案设计得更好。

2037
02:11:35,740 --> 02:11:38,050
因为现在，尤其是在没有评论的情况下、

2038
02:11:38,050 --> 02:11:40,060
我的意思是，看看我的代码有多短。

2039
02:11:40,060 --> 02:11:42,430
我的主函数只有两行代码。

2041
02:11:42,940 --> 02:11:46,338
好吧，我把多汁的内容归入了自己的函数中。

2042
02:11:46,338 --> 02:11:54,380
现在，尤其是当我和同事或其他人一起工作时，你可以想象把大型程序拆分成更小的部分，让不同的人执行不同的部分、

2043
02:11:54,380 --> 02:12:00,410
只要你们事先就输入和输出的实际内容达成一致。

2044
02:12:00,410 --> 02:12:04,300
好了，现在让我们来看看计算机能做什么，做得好和做得不好。

2045
02:12:04,300 --> 02:12:10,610
在数学上，C 语言确实支持一大堆运算符，我们可以通过它们进行加法、减法、乘法和除法运算、

2046
02:12:10,610 --> 02:12:14,025
甚至可以计算一个数除以另一个数的余数。

2047
02:12:14,025 --> 02:12:19,130
事实上，我们何不在一个非常简单的程序中使用这些功能，制作我们自己的计算器呢？

2048
02:12:19,130 --> 02:12:21,400
所以，让我来看看 VS 代码。

2049
02:12:21,400 --> 02:12:25,030
让我继续创建一个名为 calculator.c 的新文件。

2050
02:12:25,030 --> 02:12:33,670
在这个文件中，让我们先加入几个我们现在熟悉的头文件--cs50.h 和 stdio.h。

2051
02:12:33,670 --> 02:12:37,540
那我们就用 int main(void) 来声明 main。

2052
02:12:37,540 --> 02:12:40,250
然后，让我们在 main 中做一些相对简单的事情。

2053
02:12:40,250 --> 02:12:48,040
让我们声明一个 int 并将其称为 x，然后设置它等于 get int 的返回值，提示用户输入 x 的值。

2054
02:12:48,040 --> 02:12:50,240
让我们再给自己一个变量。

2055
02:12:50,240 --> 02:12:51,490
我们称之为 y。

2056
02:12:51,490 --> 02:12:57,780
将其设置为另一次调用 get_int 时的返回值，提示用户输入该值 y。

2057
02:12:57,780 --> 02:13:05,080
最后，让我们非常简单地打印出 x 加 y 的总和，这是一个超级简单的计算器。

2058
02:13:05,080 --> 02:13:10,930
因此，我会使用 printf、quote/unquote、表示整数的 %i、反斜杠 n 来换行。

2059
02:13:10,930 --> 02:13:14,640
然后，我要继续做 x 加 y 的操作，打印出总和。

2060
02:13:14,640 --> 02:13:16,710
现在让我进入终端窗口。

2061
02:13:16,710 --> 02:13:20,340
让我做一个计算器，以便编译代码。

2062
02:13:20,340 --> 02:13:22,080
没有错误信息，这很好。

2063
02:13:22,080 --> 02:13:23,880
让我来做 ./calculator.

2064
02:13:23,880 --> 02:13:28,500
我们来做一个类似 2 加 2 的运算，当然应该等于 4。

2065
02:13:28,500 --> 02:13:29,340
确实如此。

2066
02:13:29,340 --> 02:13:34,677
但事实证明，有时我们会遇到一些限制。

2067
02:13:34,677 --> 02:13:36,510
让我在这里更有雄心壮志一点。

2068
02:13:36,510 --> 02:13:37,890
让我清空终端窗口。

2069
02:13:37,890 --> 02:13:39,990
让我再重新计算一遍。

2070
02:13:39,990 --> 02:13:47,280
这次，让我们输入 20 亿来表示 x，再输入同样的数字表示 y。

2071
02:13:47,280 --> 02:13:52,560
当然，现在 20 亿加 20 亿的答案当然应该是 40 亿。

2072
02:13:52,560 --> 02:13:53,970
但事实并非如此。

2073
02:13:53,970 --> 02:14:02,070
奇怪的是，我们在这里看到了一个负数，这说明加运算符并不像我们希望的那样好用。

2074
02:14:02,070 --> 02:14:04,240
为什么会这样呢？

2075
02:14:04,240 --> 02:14:07,770
原来，电脑内部当然是内存，也就是 RAM、

2076
02:14:07,770 --> 02:14:08,850
随机存取存储器

2077
02:14:08,850 --> 02:14:15,930
根据电脑的大小和电脑的类型，它很可能看起来像这样一个小电路板，上面有一些黑色的小模块

2078
02:14:15,930 --> 02:14:19,320
实际上包含计算机内存的所有字节。

2079
02:14:19,320 --> 02:14:29,670
不幸的是，你我电脑中的内存都是有限的，这意味着无论我们想数到多高，最终都会受到限制。

2080
02:14:29,670 --> 02:14:32,790
可以计数，因为我们的内存是有限的。

2081
02:14:32,790 --> 02:14:35,800
我们没有无限多的 0 和 1 可以玩。

2082
02:14:35,800 --> 02:14:38,640
我们最终必须真正受到约束。

2083
02:14:38,640 --> 02:14:40,072
这意味着什么？

2084
02:14:40,072 --> 02:14:48,120
事实证明，计算机通常使用多达 32 位的 0 或 1 来表示整数，或者用 C 语言表示 int。

2085
02:14:48,120 --> 02:14:55,020
因此，举例来说，我们能用 32 个 int 表示的最小数字，当然是用 32 位表示，当然是 0 --

2086
02:14:55,020 --> 02:14:56,970
像这样的 32 个零

2087
02:14:56,970 --> 02:15:07,200
我们所能表示的最大数字就是把所有的 0 都改成 1，在这种情况下，我们最好能得到一个总数约等于 40 亿的数字。

2088
02:15:07,200 --> 02:15:17,160
如果将所有 32 位都设置为 1，然后进行实际运算，最大值实际上是 4,294,967,295。

2089
02:15:17,160 --> 02:15:24,730
但问题是，我们人类和计算机有时也希望并需要能够表示负数。

2090
02:15:24,730 --> 02:15:33,360
因此，如果想用 0 表示负数和正数，就不能从 0 开始数，一直数到大约 40 亿。

2091
02:15:33,360 --> 02:15:41,890
你必须把差值分开，也许可以把这些 0 和 1 的模式中的一半分配给负数，另一半大致分配给正数。

2092
02:15:41,890 --> 02:15:52,500
因此，事实上，在实际操作中，即使使用 32 位，大多数计算机的最高计数，当然是在这样一个使用 int 的 C 语言程序中，大约为 20 亿。

2093
02:15:52,500 --> 02:15:57,180
即 2 147 483 647。

2094
02:15:57,180 --> 02:16:06,630
但反过来说，我们现在也可以使用不同的比特模式来表示负数，最低可以达到负 20 亿（或多或少）。

2095
02:16:06,630 --> 02:16:16,360
当然，这意味着，如果我们只有有限的比特数，而且只能数到这么高，那么在某个时候，我们的比特数就会用完，可以这么说。

2096
02:16:16,360 --> 02:16:23,080
换句话说，我们会遇到通常所说的整数溢出，即想要使用的比特数超过可用的比特数。

2097
02:16:23,080 --> 02:16:26,767
结果，你的可用空间被挤占。

2098
02:16:26,767 --> 02:16:28,600
这实际上意味着什么呢？

2099
02:16:28,600 --> 02:16:37,080
好吧，假设你只有三个比特，但我要灰化出第四个比特，以表达我们最终想在哪里多放一个比特。

2100
02:16:37,080 --> 02:16:45,360
如果这当然是 0，根据第 0 周的讨论，这就是 1、2、3、4、5、6、7。

2101
02:16:45,360 --> 02:16:56,250
理想情况下，在二进制中，如果要在 7 的基础上再加 1，就必须在数学上加上 1，理想情况下就是 1000。

2102
02:16:56,250 --> 02:17:07,799
但是，如果你没有四比特，而你的计算机又仅有三比特，甚至不是 32 比特，而是三比特，这意味着你实际上代表的不是 1000、

2103
02:17:07,799 --> 02:17:10,620
而是 000。

2104
02:17:10,620 --> 02:17:17,850
这里没有空间来存储我灰显的第四位，也就是说，你的整数可能会溢出。

2105
02:17:17,850 --> 02:17:27,129
而一旦到了 7，加上 1 后的下一个数字实际上就会是 0，或者更糟，就像我们在代码中看到的那样，是一个负值。

2106
02:17:27,129 --> 02:17:30,209
那么，我们可以做些什么来消除这种担忧呢？

2107
02:17:30,209 --> 02:17:32,490
C 语言并不只有整数或 ints。

2108
02:17:32,490 --> 02:17:38,468
它还有长整数，顾名思义，就是更长的整数，这意味着它们有更多的位可用。

2109
02:17:38,468 --> 02:17:40,079
让我回到我的代码中。

2110
02:17:40,080 --> 02:17:41,430
我会清除终端窗口。

2111
02:17:41,430 --> 02:17:47,010
让我继续把我的整数改成字面上的长这里，长这里。

2112
02:17:47,010 --> 02:17:53,227
我必须把 CS50 库中的函数改为 get_long，而不是 get_int。

2113
02:17:53,227 --> 02:17:55,769
这的确是我们在图书馆中提供的另一项功能。

2114
02:17:55,770 --> 02:17:57,808
让我把 get_int 也改为 get_long。

2115
02:17:57,808 --> 02:18:01,479
我将保持变量名不变，但还需要做一个改动。

2116
02:18:01,480 --> 02:18:09,629
事实证明，printf 还支持其他格式代码--因此不仅支持整数的 %i 或字符串的 %s，还支持其他格式代码，例如

2117
02:18:09,629 --> 02:18:16,379
%li表示长整数，%f表示带小数的浮点数。

2118
02:18:16,379 --> 02:18:21,690
既然如此，我们就把 printf 行改成 %li 而不是 %i。

2119
02:18:21,690 --> 02:18:29,159
现在让我再做一次计算，回车 -- 现在没有明显的错误 -- ./calculator。

2120
02:18:29,160 --> 02:18:31,740
2 加 2 还是等于 4。

2121
02:18:31,740 --> 02:18:44,629
但现在，如果我再做一次计算，让我们再做一次 20 亿以及 y 的 20 亿，之前，我们溢出了整数的大小，得到了一些奇怪的负数

2122
02:18:44,629 --> 02:18:48,340
因为该模式被误解为负数。

2123
02:18:48,340 --> 02:18:57,850
但是，传统的长程序不是使用 32 位，而是使用 64 位，这意味着当我们把 20 亿加 20 亿时，我们有足够多的空闲位。

2124
02:18:57,850 --> 02:19:04,840
而现在，事实上我们得到了 40 亿的正确答案，这确实符合一个长条的大小。

2125
02:19:04,840 --> 02:19:07,459
现在，一个长条可以数到很高。

2126
02:19:07,459 --> 02:19:12,340
事实上，它可以数到这么多，9 万亿。

2127
02:19:12,340 --> 02:19:14,888
因此，这将给我们带来更多的机会。

2128
02:19:14,888 --> 02:19:17,836
当然，它最终也是有限的。

2129
02:19:17,837 --> 02:19:22,930
因此，如果您的数字需要比这更大，您可能还是会遇到问题。

2130
02:19:22,930 --> 02:19:25,430
现在，我们可能还会遇到另一个问题。

2131
02:19:25,430 --> 02:19:28,660
我们甚至可以从这个简单的计算器中看到这一点。

2132
02:19:28,660 --> 02:19:35,770
计算机还可能会出现所谓的截断现象，尤其是在进行涉及浮点数值的数学运算时，这种现象更为严重。

2133
02:19:35,770 --> 02:19:43,610
是带小数点的数字--你可能会不小心在不知情的情况下截断数值--即丢失小数点后的所有内容。

2134
02:19:43,610 --> 02:19:45,549
事实上，让我回到《VS 代码》这里。

2135
02:19:45,549 --> 02:19:46,900
我会清除我的终端窗口。

2136
02:19:46,900 --> 02:19:52,520
我们还是用多头，但这里用除法代替加法。

2137
02:19:52,520 --> 02:19:55,090
因此，让我把这个加号换成除号运算符。

2138
02:19:55,090 --> 02:19:59,020
让我用 make calculator 重新编译一下代码。

2139
02:19:59,020 --> 02:20:06,370
让我继续运行 ./计算器，让我继续做一些事情，比如 1 表示 x，3 表示 y。

2140
02:20:06,370 --> 02:20:08,380
我们会看到 等等

2141
02:20:08,380 --> 02:20:11,500
我知道，1 除以 3 应该是 1/3。

2142
02:20:11,500 --> 02:20:21,890
但在浮点数值中，应该是 0.33333，也许在小学时会在上面划一条小线，但实际上，这是一个无限的 3。

2143
02:20:21,890 --> 02:20:30,040
然而，我们似乎连小数点后的三位数也失去了一位，因为答案回到这里时只有 0。

2144
02:20:30,040 --> 02:20:31,700
为什么会这样呢？

2145
02:20:31,700 --> 02:20:42,640
好吧，如果我知道两个整数相除后得到的是分数，一个带小数点的浮点数值，我就不能继续使用整数或偶数了、

2146
02:20:42,640 --> 02:20:46,370
在这种情况下，多头不支持小数点。

2147
02:20:46,370 --> 02:20:56,560
因此，让我继续将这里的格式代码从 %li 改为 %f，这同样将代表浮点数值，而不是长整数或整数。

2148
02:20:56,560 --> 02:21:04,100
让我进一步定义第三个变量 z 为浮点数。

2149
02:21:04,100 --> 02:21:07,300
因此，我会给自己一个变量 z 等于 x 除以 y。

2150
02:21:07,300 --> 02:21:10,720
现在与其打印 x 除以 y，不如直接打印 z。

2151
02:21:10,720 --> 02:21:20,260
因此，我现在是在浮点数值的世界里工作，因为我主动将一个 long 或 int 除以另一个此类数值，如果它意味着有分数的话、

2152
02:21:20,260 --> 02:21:24,710
需要存储为浮点数值，即带有小数点的数值。

2153
02:21:24,710 --> 02:21:34,180
好吧，让我进入终端窗口，重新运行计算器的 Make -- 看起来效果不错 -- ./calculator，再做一次 1 除以 3。

2154
02:21:34,180 --> 02:21:36,868
而在这里，我们看到的仍然都是零。

2155
02:21:36,868 --> 02:21:41,350
因此，我们至少看到了一个小数点，所以我们已经取得了一些进展 感谢 %f 和 float。

2156
02:21:41,350 --> 02:21:46,570
但我们似乎已经截断了 1 除以 3 的值。

2157
02:21:46,570 --> 02:21:48,520
那么，我们究竟该如何解决这个问题呢？

2158
02:21:48,520 --> 02:21:57,340
好吧，如果程序员知道你所处的世界会给你提供带小数点的浮点数值，那么你很可能需要使用所谓的 "功能"。

2159
02:21:57,340 --> 02:22:04,390
即通过明确告诉编译器，将一种数据类型转换为另一种数据类型。

2160
02:22:04,390 --> 02:22:05,480
现在，我该怎么做呢？

2161
02:22:05,480 --> 02:22:07,100
好吧，让我们回到我的代码这里。

2162
02:22:07,100 --> 02:22:18,310
如果从根本上说，问题在于 C 仍将 x 和 y 视为整数，或者严格地说，是没有小数点的长数，并用其中一个除以另一个、

2163
02:22:18,310 --> 02:22:24,830
因此，可以说小数点后面的数字都没有空间了，我为什么不主动这样做呢？

2164
02:22:24,830 --> 02:22:33,910
让我使用一种略微新颖的带括号的语法，指定要主动将 x 从 long 转换为 float。

2165
02:22:33,910 --> 02:22:39,950
让我主动说明，我也想把 y 从 long 转换为 float。

2166
02:22:39,950 --> 02:22:49,330
现在让我继续相信，nz 不应该是 long 除以 long 或 int 除以 int 的结果，而应该是 float 除以 float 的结果。

2167
02:22:49,330 --> 02:22:55,300
让我清空终端窗口，再次运行 make calculator -- 看起来运行正常 -- ./calculator。

2168
02:22:55,300 --> 02:23:05,380
现在是 1、3，希望现在我们能看到我的代码输出了 0.333333。

2169
02:23:05,380 --> 02:23:11,710
我想，如果我们在小数点后继续显示更多的数字，理论上我们就能看到尽可能多的三分球。

2170
02:23:11,710 --> 02:23:13,900
但还有一个问题。

2171
02:23:13,900 --> 02:23:22,180
特别是当我们在使用有限内存的计算机中以这种方式处理数字时，我们可能会遇到的另一个挑战--除了整数之外

2172
02:23:22,180 --> 02:23:27,100
除了截断之外，溢出也被称为浮点不精确。

2173
02:23:27,100 --> 02:23:34,060
就像我们不能只用 int 或 long 来表示我们想要的大整数一样，因为会有一个上限、

2174
02:23:34,060 --> 02:23:39,220
同样，我们的数字精确度也会受到限制。

2175
02:23:39,220 --> 02:23:41,560
事实上，让我们回到《VS 代码》这里。

2176
02:23:41,560 --> 02:23:43,430
我将再次清除终端窗口。

2177
02:23:43,430 --> 02:23:52,250
这一次，让我使用一些不太可能的语法来指定我不想看到小数点后的默认数字（%f 会自动给出）。

2178
02:23:52,250 --> 02:23:57,520
让我们继续，在小数点后显示 20 个小数点。

2179
02:23:57,520 --> 02:24:08,440
这种奇怪的语法不是 %f，而是 %.20，表示我想看到 20 位数字，而不是小数点后的默认数字。

2180
02:24:08,440 --> 02:24:10,390
让我重新计算一下。

2181
02:24:10,390 --> 02:24:12,550
让我再做一次 ./计算器。

2182
02:24:12,550 --> 02:24:14,890
我们先做 1，再做 3。

2183
02:24:14,890 --> 02:24:17,560
这下更奇怪了，对吧？

2184
02:24:17,560 --> 02:24:21,580
从小学开始，你大概就知道 1 除以 3 当然是 1/3。

2185
02:24:21,580 --> 02:24:28,180
但这应该是 0.33333，无限多次，或者在纸上，在它上面画一条小线。

2186
02:24:28,180 --> 02:24:31,660
但计算机在这里做了一些奇怪的近似计算。

2187
02:24:31,660 --> 02:24:37,480
是一大堆 3，然后是 4326744079590。

2188
02:24:37,480 --> 02:24:42,100
那么，在引擎盖下真正发生的，还是浮点不精确的问题。

2189
02:24:42,100 --> 02:24:52,300
如果你只有有限的比特数，而内存又是有限的，那么计算机在直观上确实只能做到如此精确。

2190
02:24:52,300 --> 02:24:57,190
等同于计算机决定了某种表示浮点数值的方法。

2191
02:24:57,190 --> 02:25:07,040
但问题是，根据小学数学，有无限多的数字和无限多的浮点数值，因为只要你愿意，你可以不断增加数字。

2192
02:25:07,040 --> 02:25:14,500
因此，考虑到计算机实现这些浮点数值的方式，它基本上是在为我们提供最接近的近似值。

2193
02:25:14,500 --> 02:25:17,740
现在，我们该如何改善这种状况呢？

2194
02:25:17,740 --> 02:25:19,180
那么，还有一个选择。

2195
02:25:19,180 --> 02:25:24,760
我可以使用 double 来代替 float，顾名思义，它使用的位数是 float 的两倍。

2196
02:25:24,760 --> 02:25:27,820
因此，它通常使用 64，而不是 32。

2197
02:25:27,820 --> 02:25:31,570
这就像 long 和 int 之间的区别一样，给了我们更多的位。

2198
02:25:31,570 --> 02:25:34,480
但在本例中，这将用于提高精确度。

2199
02:25:34,480 --> 02:25:36,850
让我们继续将 x 改为 double。

2200
02:25:36,850 --> 02:25:38,740
让我们把 y 改为双数。

2201
02:25:38,740 --> 02:25:41,530
现在，让我们继续使用相同的格式代码--

2202
02:25:41,530 --> 02:25:45,220
对于双打来说，%.20f 还是没问题的。

2203
02:25:45,220 --> 02:25:46,990
让我来计算一下。

2204
02:25:46,990 --> 02:25:48,970
让我来做 ./calculator.

2205
02:25:48,970 --> 02:25:51,460
现在让我来做 1 除以 3。

2206
02:25:51,460 --> 02:25:53,770
我们仍然有一些不精确的地方。

2207
02:25:53,770 --> 02:25:56,590
如果我们关注的不仅仅是 20 位数，那就更多了。

2208
02:25:56,590 --> 02:25:59,900
不过，现在小数点后面的三位数更多了。

2209
02:25:59,900 --> 02:26:03,640
因此，它至少越来越精确，但并不完美。

2210
02:26:03,640 --> 02:26:06,520
但至少更加精确。

2211
02:26:06,520 --> 02:26:14,980
因此，在进行数值、科学研究时，至少在使用 C 语言时，这些问题是必须牢记的。

2212
02:26:14,980 --> 02:26:18,910
这些现实世界中的硬件限制，反过来又限制了语言。

2213
02:26:18,910 --> 02:26:21,952
现在，在本学期的晚些时候，我们将过渡到一种名为 Python 的语言。

2214
02:26:21,952 --> 02:26:29,470
实际上，这至少可以解决我们的一个问题，即在我们需要时自动提供更多比特，至少对于整数来说是这样。

2215
02:26:29,470 --> 02:26:33,140
但即使是浮点数不精确的问题也将继续存在。

2216
02:26:33,140 --> 02:26:35,170
现在，这些问题到底有多现实？

2217
02:26:35,170 --> 02:26:45,010
早在 1999 年，我们就尝到了这种甜头，当时全世界都意识到，在那之前的几年里，实施计算机可能并不是一个最好的主意。

2218
02:26:45,010 --> 02:26:48,910
只用两位数就能存储齿轮，从而使其中的齿轮和软件更易于使用。

2219
02:26:48,910 --> 02:27:01,400
比如，很多计算机出于空间和成本的考虑，习惯于偷工减料，只用两位数来记录年份，而不是存储 1999 来代表 1999 年。

2220
02:27:01,400 --> 02:27:14,290
这样做的问题是，如果系统在 1999 年之前没有更新以支持 2000 年、2001 年等年份，那么就像以前的整数溢出一样，一些计算机可能会

2221
02:27:14,290 --> 02:27:16,990
在他们记忆中的年份 "99 "后面加上 1。

2222
02:27:16,990 --> 02:27:28,390
应该是 2000 年，但如果他们只用两位数表示年份，他们可能会把年份误认为是 1900 年，有些系统很可能就是这样，从字面上理解就是

2223
02:27:28,390 --> 02:27:30,740
可以说是倒退了一大步。

2224
02:27:30,740 --> 02:27:37,240
现在，你会认为这种问题已经过去了，尤其是当我们越来越了解代码和计算的局限性时。

2225
02:27:37,240 --> 02:27:42,160
但实际上，在短短几年内，我们将再次遇到同样的问题。

2226
02:27:42,160 --> 02:27:50,800
2038 年 1 月 19 日，我们现在大多数计算机中用于记录时间的比特将耗尽。

2227
02:27:50,800 --> 02:27:58,870
原来，多年前，人类决定使用 32 位整数来记录时间过去了多少秒。

2228
02:27:58,870 --> 02:28:01,090
他们在过去选择了一个有点随意的日期--

2229
02:28:01,090 --> 02:28:03,350
1970 年 1 月 1 日

2230
02:28:03,350 --> 02:28:06,860
从那时起，他们就开始数秒了。

2231
02:28:06,860 --> 02:28:14,710
因此，如果一台计算机存储了某个秒数，它就会告诉计算机，从 1970 年 1 月 1 日这个特定日期开始，已经过去了多少秒。

2232
02:28:14,710 --> 02:28:23,470
不幸的是，使用 32 位整数时，正如我们所看到的，你只能数到这么高，然后就会溢出变量的大小。

2233
02:28:23,470 --> 02:28:32,080
因此，作为人类、作为社会、作为计算机科学家，如果我们不能在 2038 年 1 月 19 日这一天抢占先机，就有可能出现这种情况、

2234
02:28:32,080 --> 02:28:42,460
该位可能会翻转，从而溢出这些整数的大小，使我们在计算上回到 1901 年 12 月 13 日。

2235
02:28:42,460 --> 02:28:48,560
这就是说，有了这些计算能力和代码，我们就有责任真正写出正确的代码。

2236
02:28:48,560 --> 02:28:50,560
下周，我们将剥开其中的几层。

2237
02:28:50,560 --> 02:28:54,550
但现在，这是第一周，祝你在第 1 组问题上好运。

