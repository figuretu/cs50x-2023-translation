2
00:01:12,600 --> 00:01:13,590
好的。

3
00:01:13,590 --> 00:01:24,120
这里是 CS50，这是第二周，我们将从较低的层次来了解事物是如何工作的，事实上，本课程的目标之一就是这种自下而上的理解

4
00:01:24,120 --> 00:01:29,920
这样，几周后，甚至几年后，当你遇到一些新技术时，你就能回想起来，希望

5
00:01:29,920 --> 00:01:36,060
在本周的一些基本构件和基元的基础上，真正推导出未来技术的工作原理。

6
00:01:36,060 --> 00:01:41,380
但一路走来，我们会发现--也许，要做到 "只见树木，不见森林 "有点困难。

7
00:01:41,380 --> 00:01:44,783
因此，最终的目标仍然是解决问题。

8
00:01:44,783 --> 00:01:53,280
为此，我们请来了一些勇敢的志愿者，他们已经站了出来。

9
00:01:53,280 --> 00:01:58,320
如果我们能打开一些戏剧性的灯光，见见今天的志愿者。

10
00:01:58,320 --> 00:02:00,430
在我的左边

12
00:02:00,930 --> 00:02:01,960
我叫亚历克斯。

13
00:02:01,960 --> 00:02:05,340
我是学院的一年级学生，来自北卡罗来纳州的教堂山。

14
00:02:05,340 --> 00:02:07,080
戴维-马兰：欢迎亚历克斯。

15
00:02:07,080 --> 00:02:09,180
在亚历克斯的右边

16
00:02:09,180 --> 00:02:10,050
我是莎拉

17
00:02:10,050 --> 00:02:13,230
我来自加拿大多伦多，也是学院的一年级学生。

18
00:02:13,230 --> 00:02:14,188
太棒了。

19
00:02:14,188 --> 00:02:15,869
欢迎亚历克斯和莎拉。

20
00:02:15,869 --> 00:02:25,650
因此，你们本周要解决的问题集 2 中的一个问题是分析文章的阅读水平，即某人的阅读水平是一年级水平、二年级水平还是三年级水平。

21
00:02:25,650 --> 00:02:28,570
级，一直到 12、13 级或更高。

22
00:02:28,570 --> 00:02:36,750
你可能从来没有想过，当然是在代码方面，比如你如何分析一些文本、书籍，并找出它的阅读水平。

23
00:02:36,750 --> 00:02:40,330
然而，我们成长过程中的老师肯定知道或直观地感受到了这一点。

24
00:02:40,330 --> 00:02:42,450
让我们来看看一些示例文本。

25
00:02:42,450 --> 00:02:45,960
比如，亚历克斯，你最近在读什么书？

26
00:02:45,960 --> 00:02:52,502
一条鱼、两条鱼、红鱼、蓝鱼

27
00:02:52,502 --> 00:02:53,460
太棒了。

28
00:02:53,460 --> 00:02:58,890
那么，您认为亚历克斯目前的阅读水平在哪个年级？

29
00:02:58,890 --> 00:03:01,500
请随时大声喊出来。

30
00:03:01,500 --> 00:03:02,730
第一个，第一个？

31
00:03:02,730 --> 00:03:10,410
因此，本周你会看到，如果你在亚历克斯的文本上运行代码，实际上会发现他的阅读水平低于一年级。

32
00:03:10,410 --> 00:03:12,400
但为什么会这样呢？

33
00:03:12,400 --> 00:03:19,020
你对我们指责亚历克斯的阅读水平的直觉是什么？

34
00:03:19,020 --> 00:03:20,990
请随时大声喊出来。

36
00:03:21,490 --> 00:03:24,520
因此，音节很少，单词很短，句子也很短。

37
00:03:24,520 --> 00:03:30,370
因此，我们或许可以从这篇短文中推断出一些启发式的结论，那就是这篇短文最适合年龄较小的儿童阅读。

38
00:03:30,370 --> 00:03:33,370
相比之下，萨拉，你都读了些什么？

39
00:03:33,370 --> 00:03:35,470
杜斯利先生和杜斯利夫人

40
00:03:35,470 --> 00:03:41,050
Four Privet Drive 很自豪地说，他们完全正常，非常感谢。

41
00:03:41,050 --> 00:03:47,952
他们是你最不可能想到会卷入任何奇怪或神秘事件的人，因为他们不喜欢胡言乱语。

42
00:03:47,952 --> 00:03:48,910
好的。

43
00:03:48,910 --> 00:03:55,230
不管你读这篇课文时是哪个年级，莎拉的阅读水平似乎在哪个年级？

44
00:03:55,230 --> 00:03:57,570
所以是八年级，二年级。

46
00:03:58,080 --> 00:04:03,240
因此，我什么都听过一些，所以，至少根据代码，实际上应该是七年级。

47
00:04:03,240 --> 00:04:05,130
直觉是什么？

48
00:04:05,130 --> 00:04:09,917
尽管我们可能不同意到底是哪个年级，但为什么说这是一个更高的年级呢？

49
00:04:09,917 --> 00:04:11,250
听众：复杂的句子。

50
00:04:11,250 --> 00:04:12,000
是的

51
00:04:12,000 --> 00:04:14,218
所以句子复杂，句子较长。

52
00:04:14,218 --> 00:04:18,519
因此，莎拉确实说了更多的话，因为纸上的内容太多了。

53
00:04:18,519 --> 00:04:26,910
因此，我们将在下周的问题集 2（如果你解决了这个问题集 2）中，通过代码来转化这些想法，这样你就能最终定量地推断出这些东西。

54
00:04:26,910 --> 00:04:29,190
但要做到这一点，我们必须理解文本。

55
00:04:29,190 --> 00:04:32,610
因此，让我们首先感谢我们的志愿者，然后再进入下一层。

58
00:04:40,600 --> 00:04:41,490
你可以留着这些。

59
00:04:41,490 --> 00:04:42,222
哦，好的

60
00:04:42,222 --> 00:04:43,180
好的。

61
00:04:43,180 --> 00:04:50,210
除此以外，让我们考虑一下本周可能会看到的其他文字，即类似这样的文字。

62
00:04:50,210 --> 00:04:53,860
我在屏幕上看到的就是我们今天开始所说的密码文本。

63
00:04:53,860 --> 00:04:56,530
它是对某些信息进行加密的结果。

64
00:04:56,530 --> 00:05:00,908
而加密，或者更笼统地说，密码学的艺术和科学就在我们身边。

65
00:05:00,908 --> 00:05:03,700
您在网络、手机和银行中使用的都是它。

66
00:05:03,700 --> 00:05:07,000
任何试图保证数据安全的东西都在使用加密技术。

67
00:05:07,000 --> 00:05:11,140
但加密的级别会有所不同，有强加密，也有弱加密。

68
00:05:11,140 --> 00:05:22,030
你在屏幕上看到的并不是那么强大，但我们今天稍后会看到如何解密，并揭示与密码文本相对应的明文是什么。

69
00:05:22,030 --> 00:05:26,197
但是，为了做到这一点，我们必须开始摘掉一些训练用的轮子。

70
00:05:26,197 --> 00:05:32,230
信不信由你，即使你的时间会看到过去一周的第一次，可能，可能已经相当在杂草丛生。

71
00:05:32,230 --> 00:05:39,760
而比 C 更复杂的是，我们一直在提供并将继续提供某些训练车轮。

72
00:05:39,760 --> 00:05:49,730
例如，CS50 图书馆就是其中之一，甚至在最初几周，我们暂时对一些主题的解释也会有所简化--可以说是抽象化了。

73
00:05:49,730 --> 00:05:58,210
但是，我们的最终目标是让您了解其中的每一个细节，这样在 CS50 之后，您就能真正自立于世，并理解和融会贯通。

74
00:05:58,210 --> 00:06:01,040
以及未来的任何技术。

75
00:06:01,040 --> 00:06:06,110
因此，让我们先来看看上周开始的第一个项目，也就是这个项目。

76
00:06:06,110 --> 00:06:14,890
说到底，printf 函数才是真正有趣的部分，但在它之上和之下还有很多技术性的东西。

77
00:06:14,890 --> 00:06:21,730
大括号、小括号、void 和 include 等单词，当然还有斜括号等等。

78
00:06:21,730 --> 00:06:30,190
但最终，我们需要将 C 语言源代码转换为机器代码，即计算机能够理解的二进制 0 和 1。

79
00:06:30,190 --> 00:06:33,700
当然，为了做到这一点，我们运行 -- 我们编译了代码。

80
00:06:33,700 --> 00:06:37,400
我们运行了 make，然后就能在那里实际运行代码了。

81
00:06:37,400 --> 00:06:44,510
因此，让我到 VS 代码中快速重新创建 hello.c。

82
00:06:44,510 --> 00:06:51,970
因此，我可能在这里包含 stdio.h，int main void。

83
00:06:51,970 --> 00:06:57,430
然后在这里，我很简单地输入了 "你好"、"逗号"、"世界"、"反斜线"、"尾引号 "等等。

84
00:06:57,430 --> 00:07:01,693
上次编译时，我确实运行了 make hello，然后是 Enter。

85
00:07:01,693 --> 00:07:03,860
希望您没有看到任何错误，这是一件好事。

86
00:07:03,860 --> 00:07:07,840
如果你进行点、斜线、你好的操作，你就会看到该程序的结果。

87
00:07:07,840 --> 00:07:12,950
但事实证明，正如我上周提到的，make 实际上并不是一个编译器。

88
00:07:12,950 --> 00:07:19,030
它是一个程序，可以清晰地编译你的程序，但它本身只是将使用实际编译器的过程自动化。

89
00:07:19,030 --> 00:07:27,640
现在有很多不同的编译器，而它实际上使用的是一种叫做 Clang 的 C 语言编译器。

90
00:07:27,640 --> 00:07:30,190
而 Clang 是时下相当流行的编译器。

91
00:07:30,190 --> 00:07:40,310
还有一种已经存在很久的编译器叫 GCC，但这些只是不同的人、不同的公司、不同的团体所创建的编译器类型的特定名称。

92
00:07:40,310 --> 00:07:50,703
但是，如果你在第 1 周手动使用编译器，你就必须多了解一些情况，因为它比单独编译更令人费解。

93
00:07:50,703 --> 00:07:59,360
事实上，让我回到终端窗口，清空一下屏幕，然后运行原始编译器命令。

94
00:07:59,360 --> 00:08:03,620
因此，让我手动操作一下，就能实现自动化。

95
00:08:03,620 --> 00:08:10,450
因此，如果我想将 hello.c 编译成可执行程序，我就可以运行它、

96
00:08:10,450 --> 00:08:17,110
clang、空格、hello.c，然后回车。

97
00:08:17,110 --> 00:08:22,010
现在没有输出了，在这种情况下，没有错误是件好事，但请注意这一点。

98
00:08:22,010 --> 00:08:32,140
如果我继续输入 ls，就会发现在我的当前文件夹中突然创建了一个文件，文件名很奇怪，叫 a.out。

99
00:08:32,140 --> 00:08:33,580
这代表汇编输出。

100
00:08:33,580 --> 00:08:39,440
长话短说，这其实就是运行 Clang 时创建的程序的默认名称。

101
00:08:39,440 --> 00:08:44,000
现在看来，这个程序的名字很糟糕，因为它无法描述程序的功能。

102
00:08:44,000 --> 00:08:55,420
因此，最好的办法也许是：好吧，不要用 a.out，没错，它仍然打印 hello.world，但并不是一个真正有明确名称的程序，最好给它取名为 hello。

103
00:08:55,420 --> 00:08:56,240
我能做些什么呢？

104
00:08:56,240 --> 00:09:01,820
我可以像上周学过的那样--嗯，我可以用 Linux 的 mv 命令把 a.out 重命名为 hello。

105
00:09:01,820 --> 00:09:04,480
所以，我要把一个.移出来，变成 "你好"。

106
00:09:04,480 --> 00:09:06,370
但这似乎也有点乏味。

107
00:09:06,370 --> 00:09:07,720
现在我有三个步骤。

108
00:09:07,720 --> 00:09:12,190
比如写代码、编译代码，然后在运行之前重命名代码。

109
00:09:12,190 --> 00:09:13,580
我们可以做得更好。

110
00:09:13,580 --> 00:09:20,380
事实证明，某些命令（如 clang）支持我们今天开始所说的命令行参数。

111
00:09:20,380 --> 00:09:30,400
与函数参数不同，命令行参数只是在终端提示符下，在命令后键入的一个附加单词或关键短语

112
00:09:30,400 --> 00:09:33,440
窗口，修改该命令的行为。

113
00:09:33,440 --> 00:09:35,600
它的配置更具体一些。

114
00:09:35,600 --> 00:09:45,220
因此，你在屏幕上看到的是一个更好的运行 clang 的命令，现在我可以根据这个 o 指定这个命令的输出。

115
00:09:45,220 --> 00:09:46,610
那么，我的意思是什么呢？

116
00:09:46,610 --> 00:09:54,955
好吧，让我再次清空终端窗口，然后更明确地输入 clang -o hello hello.c，然后回车。

117
00:09:54,955 --> 00:10:02,860
同样，什么也没有发生，但这是件好事，因为你没有看到任何错误，而且现在我刚刚创建的程序确实叫做 Hello。

118
00:10:02,860 --> 00:10:07,280
因此，它所达到的效果确实与 make 所达到的效果完全相同，但又如何呢？

119
00:10:07,280 --> 00:10:11,075
我不需要输入和记住像这条命令这么长的内容。

120
00:10:11,075 --> 00:10:12,700
这也有点像白色谎言。

121
00:10:12,700 --> 00:10:22,840
原来，我们已经在云中为您预配置了 VS Code，让您也能使用 Clang 的其他一些功能，而这些功能如果由您自己编写会更加繁琐。

122
00:10:22,840 --> 00:10:28,130
因此，这就是为什么我们将其提炼为最终只是运行制造。

123
00:10:28,130 --> 00:10:37,720
所以，让我在这里暂停一下，先看看大家对我用 C 语言编写的第一个程序有什么疑问，现在先用 make 编译，然后重新开始

124
00:10:37,720 --> 00:10:46,820
现在用 clang 手动编译，我们称之为命令行参数。-o、空格、hello，然后是文件名。

126
00:10:47,320 --> 00:10:48,780
AUDIENCE：什么是.out？

127
00:10:48,780 --> 00:10:49,530
是的

128
00:10:49,530 --> 00:10:51,870
因此，a.out 是一个历史名称。

129
00:10:51,870 --> 00:10:55,240
它指的是汇编程序的输出--很快会有更多介绍。

130
00:10:55,240 --> 00:11:02,970
如果在任何文件上运行编译器，都会自动获得默认的文件名，这样就有了一个标准的文件名。

131
00:11:02,970 --> 00:11:05,213
但这个计划的名字并不好听。

132
00:11:05,213 --> 00:11:09,880
而不是在 Mac 或 PC 上运行 Microsoft Word，就像双击 .out。

133
00:11:09,880 --> 00:11:17,370
因此，有了这些命令行参数，你就可以自定义 Clang 的输出，并将其称为 hello 或任何你想要的名字。

134
00:11:17,370 --> 00:11:23,020
关于 Clang 编译器的其他问题？

136
00:11:23,520 --> 00:11:25,510
听众：什么是-o？

137
00:11:25,510 --> 00:11:30,500
你只有读过手册、上过课才会知道，这意味着输出。

138
00:11:30,500 --> 00:11:38,680
所以 -o 意味着将 Clang 的输出改为名为 hello 的文件，而不是默认的 a.out。

139
00:11:38,680 --> 00:11:44,810
这也是一个细节问题，你需要在网页上查找，阅读手册，或者听我这样的人告诉你。

140
00:11:44,810 --> 00:11:48,890
事实上，可供选择的方案远不止这些，但我们在此也只是浅尝辄止。

142
00:11:49,390 --> 00:11:53,530
如果我们现在知道了这些，那么在引擎盖下面究竟还发生了什么呢？

143
00:11:53,530 --> 00:12:03,430
好吧，让我们仔细看看我的代码，不仅是这个版本，还有上周稍微复杂一点的版本，看起来有点像这样，其中包括

144
00:12:03,430 --> 00:12:11,810
我添加了一些来自用户的动态输入，这样我就可以不对所有人说 "你好，世界"，而是对实际运行这个程序的人说 "你好，大卫 "或 "你好"。

145
00:12:11,810 --> 00:12:17,770
因此，事实上，让我继续在 VS 代码中修改我的代码，以便与上周的代码保持一致。

146
00:12:17,770 --> 00:12:19,190
所以还没有新代码。

147
00:12:19,190 --> 00:12:22,820
稍后，我将以稍有不同的方式对其进行编译。

148
00:12:22,820 --> 00:12:29,020
所以我做了上周的字符串，我想，答案等于字符串，引号-引号、

149
00:12:29,020 --> 00:12:30,100
"你叫什么名字？"

150
00:12:30,100 --> 00:12:31,540
就像在 Scratch 中一样。

151
00:12:31,540 --> 00:12:37,450
然后在下面，我没有做世界，而是开始写答案，但写得并不顺利。

152
00:12:37,450 --> 00:12:42,940
打印出 "你好，大卫 "或 "你好，某某"，我最终做了什么？

154
00:12:44,722 --> 00:12:45,680
抱歉，再大点声？

155
00:12:45,680 --> 00:12:46,430
听众：%s？

156
00:12:46,430 --> 00:12:51,020
DAVID MALAN：是的，所以 %s，也就是 printf 知道如何处理的所谓格式代码。

157
00:12:51,020 --> 00:12:52,470
我还得补充一点。

158
00:12:52,470 --> 00:12:54,850
除了 %s 还有别人吗？

159
00:12:54,850 --> 00:12:56,050
AUDIENCE：变量名称。

160
00:12:56,050 --> 00:13:00,190
DAVID MALAN：我要插入占位符 %s 的变量名。

161
00:13:00,190 --> 00:13:01,630
在这种情况下，它就是答案。

162
00:13:01,630 --> 00:13:11,560
现在让我做一个改进，因为我们已经进入了第 2 周，我们将开始编写更多行的代码，尽管 Scratch 总是将问谜题的返回值称为答案。

163
00:13:11,560 --> 00:13:14,480
瞧，我们可以完全控制变量的名称。

164
00:13:14,480 --> 00:13:19,870
现在，如果我使用 get_string，最好不要总是通用地调用我的变量 answer。

165
00:13:19,870 --> 00:13:21,050
就这么说吧。

166
00:13:21,050 --> 00:13:23,680
所以，现在这只是一个风格问题。

167
00:13:23,680 --> 00:13:34,000
让我把变量改成 name，这样我、你、TF 或 TA 就能更清楚地知道这个变量代表什么，而不是更笼统地回答。

168
00:13:34,000 --> 00:13:41,050
好了，说了这么多，让我回到终端窗口，上周我又运行 make 编译了这个一模一样的程序。

169
00:13:41,050 --> 00:13:43,270
现在，让我直接使用 clang。

170
00:13:43,270 --> 00:13:45,490
所以哐当

171
00:13:45,490 --> 00:13:49,330
我还是把这个版本叫做 hello--space，hello.c。

172
00:13:49,330 --> 00:13:51,080
因此，命令与之前的完全相同。

173
00:13:51,080 --> 00:13:56,330
唯一不同的是，我增加了几行代码来获取用户的输入。

174
00:13:56,330 --> 00:13:59,960
让我按下回车键，现在，该死的，我们的第一个错误。

175
00:13:59,960 --> 00:14:05,420
因此，从 clang 和 make 输出并不是一件好事，在这里，我们看到了一些特别隐秘的东西。

176
00:14:05,420 --> 00:14:13,480
因此，函数 "main "中出现了对 "get_string "字符串的未定义引用，然后链接器命令失败，退出代码为 1。

177
00:14:13,480 --> 00:14:22,130
因此，实际上有很多专业术语在里面，今天会挑明，但我的提示是，显然我的问题出在主要方面，尽管这并不奇怪，因为这里没有其他事情发生。

178
00:14:22,130 --> 00:14:26,830
get_string 是一个问题，问题在于它是一个未定义的引用。

179
00:14:26,830 --> 00:14:28,990
然而，请注意，我做得很好。

180
00:14:28,990 --> 00:14:39,070
我添加了 CS50 头文件，上周我曾说过，这足以让编译器知道函数的存在，但问题是，即使这样做了，事实上、

181
00:14:39,070 --> 00:14:51,860
虽然 Clang 知道 get_string 的存在，但要它在计算机硬盘上找到真正实现 get_string 本身的 0 和 1 并不足够。

182
00:14:51,860 --> 00:14:55,333
因此，换句话说，按照上周的说法，这句话是一个小小的暗示。

183
00:14:55,333 --> 00:14:59,560
这是向 Clang 发出的预告，告诉它你即将在某处看到并使用这个函数。

184
00:14:59,560 --> 00:15:11,470
但是，如果你真的想使用 CS50 很久以前编写的 0 和 1，并将其融入到你的程序中，让你的程序真正知道如何从用户那里获取输入，那就好办了、

185
00:15:11,470 --> 00:15:15,440
我得继续运行一个稍有不同的命令。

186
00:15:15,440 --> 00:15:16,250
那就让我来吧。

187
00:15:16,250 --> 00:15:23,020
让我清空终端窗口，以消除干扰，我建议现在运行这条命令。

188
00:15:23,020 --> 00:15:35,050
几乎和之前一样，clang -o、空格、hello，然后是 hello.c，但最后多了一个命令行参数，是 -l--而不是数字 1。

189
00:15:35,050 --> 00:15:39,370
因此，-lcs 中间没有空格。

190
00:15:39,370 --> 00:15:48,850
现在，"升 "将导致 CS50 所输入的所有 0 和 1 被链接到你的代码、你的几行代码或我的代码中。

191
00:15:48,850 --> 00:15:58,537
但这是编译器需要的第二步，以便知道如何实际执行和编译您的代码和 CS50 的代码。

192
00:15:58,537 --> 00:16:00,370
并不是只有 CS50 才这样做。

193
00:16:00,370 --> 00:16:10,000
如果你在 C 语言中使用任何不自带的第三方库，你可以使用 -l 诸如此类的命令，不管他们给自己的库起了什么名字。

194
00:16:10,000 --> 00:16:14,298
但你不必像我们迄今为止所使用的那样，为内置设备这样做。

195
00:16:14,298 --> 00:16:16,090
好吧，让我来试试这个。

196
00:16:16,090 --> 00:16:23,620
我将回到 VS 代码，现在让我继续运行 clang -o hello，然后运行 hello.c。

197
00:16:23,620 --> 00:16:29,590
现在不用直接敲回车键，而是敲-lcs50，l 和 cs50 之间不留空格，然后敲回车键。

198
00:16:29,590 --> 00:16:33,310
现在不会发生任何不好的事情，我也可以做 ./hello。

199
00:16:33,310 --> 00:16:34,180
你叫什么名字？

200
00:16:34,180 --> 00:16:37,633
我输入大卫，回车，现在我们看到你好，大卫。

201
00:16:37,633 --> 00:16:46,460
老实说，这才是我们真正要解决的问题，现在这只会给编译和运行代码的过程增加麻烦。

202
00:16:46,460 --> 00:16:55,240
因此，现实情况是，尽管这确实是正在发生的事情，但这就是为什么我们使用上周，并将继续使用本周的原因，因为它只是

203
00:16:55,240 --> 00:16:57,130
为您自动完成整个过程。

204
00:16:57,130 --> 00:17:05,858
但最理想的做法是了解问题出在哪里，因为你在问题集 1 中看到的任何错误信息，以及接下来几周看到的任何错误信息，可能都不是来自 make、

205
00:17:05,858 --> 00:17:10,780
它们来自引擎盖下的 Clang，因为 make 只是在自动执行这一过程。

206
00:17:10,780 --> 00:17:17,560
但使用 make 时，你只需写下 make 和程序名称，而不必担心任何命令行参数。

207
00:17:17,560 --> 00:17:22,240
那么，对使用 dash -lcs50 或其他方法编译有疑问吗？

209
00:17:23,042 --> 00:17:24,959
听众：[听不清]有什么好处？

210
00:17:24,960 --> 00:17:26,220
戴维-马兰：对不起，有什么好处？

211
00:17:26,220 --> 00:17:27,512
听众：手动使用 Clang

212
00:17:27,512 --> 00:17:30,000
DAVID MALAN：手动使用 Clang 有什么好处？

213
00:17:30,000 --> 00:17:30,870
没有，真的没有。

214
00:17:30,870 --> 00:17:35,055
事实上，main 所做的只是说--make 所做的只是让我们少敲几下键盘。

215
00:17:35,055 --> 00:17:42,090
不过，如果你更喜欢控制，只要记住各种命令行参数，完全可以手动运行 Clang。

217
00:17:42,660 --> 00:17:47,335
你为什么要解释？那么你为什么要解释[听不清] So why did you have to explain [INAUDIBLE]

218
00:17:47,335 --> 00:17:48,210
大卫-马兰：没错。

219
00:17:48,210 --> 00:17:55,470
为什么我必须解释--即用 cs50.h 头文件为 CS50 提供提示，而用 standardio.h 却不必这样做？

220
00:17:55,470 --> 00:18:03,060
Standardio.h 是 C 语言的自带库，就像我们今天开始看到的其他一些 C 语言库一样。

221
00:18:03,060 --> 00:18:07,890
不过，CS50 并非随处都内置在 C 语言中，因此您必须明确地将其添加到 C 语言中。

223
00:18:08,767 --> 00:18:11,970
听众：你能定义什么命令行参数吗？

224
00:18:11,970 --> 00:18:22,200
戴维-马兰：命令行参数是你在命令行--也就是你的终端--输入的单词或短语，目的是影响程序的行为。

225
00:18:22,200 --> 00:18:22,742
AUDIENCE：OK.

226
00:18:22,742 --> 00:18:24,430
所以，你给它什么，它就是什么。

227
00:18:24,430 --> 00:18:24,565
是的

228
00:18:24,565 --> 00:18:25,660
它可以更改默认设置。

229
00:18:25,660 --> 00:18:33,460
在我们的图形用户界面（GUI）世界里，你和我可能会点击一些方框，选择一些菜单选项，以同样的方式配置程序的行为。

230
00:18:33,460 --> 00:18:39,600
在命令行界面上，你必须一次性说出所有内容，这就是我们使用命令行参数的原因。

232
00:18:40,605 --> 00:18:43,243
是让[听不清]

233
00:18:43,243 --> 00:18:43,910
DAVID MALAN: No.

234
00:18:43,910 --> 00:18:45,470
Make 不仅仅适用于 CS50。

235
00:18:45,470 --> 00:18:52,020
如今，在任何使用 C、C++ 甚至其他语言的项目中，它都被广泛使用。

236
00:18:52,020 --> 00:18:57,530
事实上，你在这一类中看到的大多数命令，除非结尾有 5-0，否则都是全球通用的。

237
00:18:57,530 --> 00:19:00,758
只有那些后缀为 50 的课程才是特定课程。

238
00:19:00,758 --> 00:19:06,890
即使是这些命令，我们也会逐步卸下训练轮，以便准确了解这些命令的作用。

239
00:19:06,890 --> 00:19:09,053
好吧，我们刚才做了什么？

240
00:19:09,053 --> 00:19:15,967
当然，我们刚才所做的一切，我一直称之为编译，但让我们先钻一个兔子洞，这样你就能理解编译代码的含义了、

241
00:19:15,967 --> 00:19:26,060
实际上，有一大堆步骤正在进行，这将使许多功能得以实现，例如，公司可以编写代码，然后将其转换为在 Mac 和 PC 上运行的代码

242
00:19:26,060 --> 00:19:27,240
或电话之类的东西。

243
00:19:27,240 --> 00:19:35,840
因此，这不仅仅是将源代码转换为机器代码的问题，从上周开始，你我所知道的编译实际上涉及四个步骤。

244
00:19:35,840 --> 00:19:41,450
这些都不是你必须时刻牢记的术语，因为我们会再次抽象出很多内容。

245
00:19:41,450 --> 00:19:51,080
不过，我们已经走过了一次兔子洞，让我们考虑一下这四个步骤中的每一个步骤，它们已经为你自动进行了一周，其中第一个步骤叫做预处理。

246
00:19:51,080 --> 00:19:52,260
这意味着什么？

247
00:19:52,260 --> 00:19:54,450
那么，让我们考虑一下之前的那个程序。

248
00:19:54,450 --> 00:19:57,830
请注意，有两行代码是以哈希标记开头的。

249
00:19:57,830 --> 00:20:02,338
这是 C 语言中的一个特殊符号，也就是所谓的预处理器指令。

250
00:20:02,338 --> 00:20:07,005
你不需要记住这样的术语，但这只是意味着它与其他线路有些不同。

251
00:20:07,005 --> 00:20:13,315
任何带有哈希符号的内容都应进行预处理，即在进行任何其他操作之前先进行初步分析。

252
00:20:13,315 --> 00:20:17,100
那么，让我们来看看上面这两条线，到底发生了什么。

253
00:20:17,100 --> 00:20:23,390
有了这两行，就有了两个头文件，当然是 cs50.h 和 stdio.h。

254
00:20:23,390 --> 00:20:28,550
这些文件在哪里，因为它们似乎从未出现在你的 VS 代码中。

255
00:20:28,550 --> 00:20:35,900
如果你键入 LS -- 如果你在图形用户界面中打开文件资源管理器，你可能从未见过 cs50.h 或 stdio.h。

256
00:20:35,900 --> 00:20:45,690
它们之所以能正常工作，是因为在你 Mac 或 PC 上使用的硬盘驱动器或云端的某个地方有一个文件夹，就像我们的情况一样。

257
00:20:45,690 --> 00:20:50,210
这个文件夹的传统名称是 /usr/include。

258
00:20:50,210 --> 00:20:51,857
而 user 则是故意拼错的。

259
00:20:51,857 --> 00:20:55,760
这只是略微简洁了一些，虽然我们为什么要去掉那一个字母有点奇怪。

260
00:20:55,760 --> 00:21:03,990
但 usr/include 只是服务器上的一个文件夹，其中包含 cs50.h、stdio.h 和其他一些内容。

261
00:21:03,990 --> 00:21:15,470
因此，事实上，如果你在 VS Code 中的终端窗口中键入 LS space /usr/include，当你在云中使用代码空间时，就能看到该文件夹中的所有文件。

262
00:21:15,470 --> 00:21:17,580
但我们已经为你预装了所有这些功能。

263
00:21:17,580 --> 00:21:20,390
因此，让我们来看看这些文件中到底有什么。

264
00:21:20,390 --> 00:21:25,370
如果我把上面这两行以散列包含开头的部分突出显示出来，效果就会很好、

265
00:21:25,370 --> 00:21:32,660
上周我曾暗示过，第一个文件中的内容暗示了 CS50 为你编写了哪些功能。

266
00:21:32,660 --> 00:21:41,000
因此，你可以把这些包含行看作是临时的占位符，用于全局查找和替换。

267
00:21:41,000 --> 00:21:44,270
clang 要做的第一件事就是预处理这个文件。

268
00:21:44,270 --> 00:21:47,300
它会查找任何以散列 include 开头的行。

269
00:21:47,300 --> 00:21:56,443
如果它看到了，就会进入该文件，如 cs50.h，然后复制并粘贴该文件的内容。

270
00:21:56,443 --> 00:21:58,110
你在屏幕上看不到。

271
00:21:58,110 --> 00:22:00,060
但这一切都发生在幕后。

272
00:22:00,060 --> 00:22:13,215
实际上，第一行的内容是在 cs50.h 中的某处对 getString 的声明，就像我们上周说的那样，它看起来可能有点像这样。

273
00:22:13,215 --> 00:22:17,030
上周我们在这方面花的时间还不多，但以后会花更多时间。

274
00:22:17,030 --> 00:22:21,470
请注意，函数就是这样声明的。

275
00:22:21,470 --> 00:22:23,677
也就是说，它是注定要存在的。

276
00:22:23,677 --> 00:22:25,760
当然，函数的名称是 getString。

277
00:22:25,760 --> 00:22:28,310
括号内是参数。

278
00:22:28,310 --> 00:22:33,080
在这种情况下，getString 只有一个参数，我今天声称，但你已经隐约知道了。

279
00:22:33,080 --> 00:22:34,160
这是一个提示。

280
00:22:34,160 --> 00:22:36,860
这是使用 getString 时人类看到的提示。

281
00:22:36,860 --> 00:22:37,790
提示是什么？

282
00:22:37,790 --> 00:22:43,080
嗯，就是一串文字，就像我上周问的 "你叫什么名字？"之类的。

283
00:22:43,080 --> 00:22:46,610
与此同时，正如我们在上周所知道的，getString 有一个返回值。

284
00:22:46,610 --> 00:22:48,140
它会给你回报一些东西。

285
00:22:48,140 --> 00:22:49,610
这也是一个字符串。

286
00:22:49,610 --> 00:22:52,120
因此，这也被称为函数原型。

287
00:22:52,120 --> 00:23:02,030
就是上周末的那篇文章，我把它从文件底部复制粘贴到了顶部，这样就像给铛铛的预告一样，让他知道后面会有什么。

288
00:23:02,030 --> 00:23:11,360
因此，你可以把这些包含行看作是将所有这些函数声明合并到一个名为 cs50.h 的单独文件中、

289
00:23:11,360 --> 00:23:18,470
这样，您就不必每次使用图书馆时都输入这些信息，或者更糟糕的是，您自己也不必复制和粘贴这些行文。

290
00:23:18,470 --> 00:23:22,520
这就是 clang 在第一步预处理中为你做的事情。

291
00:23:22,520 --> 00:23:29,175
其次，也是本例的最后一个问题，当 clang 预处理第二行 include 时会发生什么？

292
00:23:29,175 --> 00:23:33,650
在这个故事中，我们唯一关心的函数当然是 C 语言自带的 printf 函数。

293
00:23:33,650 --> 00:23:40,820
因此，你可以把 printf 的原型或声明理解为这样。

294
00:23:40,820 --> 00:23:42,870
Printf 是函数的名称。

295
00:23:42,870 --> 00:23:49,110
它接收一个要格式化的字符串，如：你好，逗号世界，或你好，逗号 %s。

296
00:23:49,110 --> 00:23:52,120
然后是点、点、点，这其实是有技术含义的。

297
00:23:52,120 --> 00:23:56,340
当然，这意味着您可以插入 0 个变量、1 个变量、2 个或 10 个变量。

298
00:23:56,340 --> 00:23:58,530
因此，点、点、点意味着一些变量的数量。

299
00:23:58,530 --> 00:24:00,072
现在我们还没谈到这个问题。

300
00:24:00,072 --> 00:24:05,490
实际上，printf 返回的是一个数值，一个整数。

301
00:24:05,490 --> 00:24:07,420
但关于这一点，或许下次再谈。

302
00:24:07,420 --> 00:24:10,920
一般来说，程序员不会关注这个问题。

303
00:24:10,920 --> 00:24:21,330
但这就是我们所说的预处理，因此在这个过程的最后，尽管 cs50.h 和 stdio.h 中的代码行数增加了，但实际上只是 clang 在预处理时发生了以下变化

304
00:24:21,330 --> 00:24:31,060
文件，然后将这些文件的内容复制并粘贴到你的代码中，这样你的代码就知道了一切--getString、printf 和其他任何内容。

305
00:24:31,060 --> 00:24:35,230
那么，关于第一步，预处理，有什么问题吗？

308
00:24:49,195 --> 00:24:50,320
大卫-马兰：问得好。

309
00:24:50,320 --> 00:24:54,880
包含文件时，是只包含您需要的内容，还是包含所有内容？

310
00:24:54,880 --> 00:24:56,420
把它想象成包括一切。

311
00:24:56,420 --> 00:24:59,020
因此，如果文件很大，最顶端的代码就会很多。

312
00:24:59,020 --> 00:25:01,880
这就是为什么，如果你回想一下所有的 0 和 1

313
00:25:01,880 --> 00:25:08,892
我在不久前和上周都演示过，只要写下 "你好，世界"，屏幕上就会出现大量的 0 和 1。

314
00:25:08,892 --> 00:25:13,390
很多 0 和 1 可能来自于你实际上并不一定需要的代码。

315
00:25:13,390 --> 00:25:17,740
但其中一些也许是存在的，但也有优化的方法。

316
00:25:17,740 --> 00:25:22,395
好了，编译的第二步令人困惑地叫做 "编译"。

317
00:25:22,395 --> 00:25:27,940
只是，大多数人都用这个词来描述整个过程，而不仅仅是这一步。

318
00:25:27,940 --> 00:25:35,865
但是，一旦编译器在幕后为你预处理了程序，它现在看起来就有点像这样了。

319
00:25:35,865 --> 00:25:39,820
我把 "点"、"点"、"点 "放在这里，只是为了暗示，是的，对于你的问题，上面还有更多的东西。

320
00:25:39,820 --> 00:25:40,987
下面还有更多内容。

321
00:25:40,987 --> 00:25:43,070
只是现在对我们来说没什么意思。

322
00:25:43,070 --> 00:25:44,860
现在我们只有 C 代码了。

323
00:25:44,860 --> 00:25:46,960
没有预处理器指令了。

324
00:25:46,960 --> 00:25:52,670
此时，所有哈希符号和这些代码行都已被预处理并转换成其他内容。

325
00:25:52,670 --> 00:25:56,380
现在事情变得有点诡异了

326
00:25:56,380 --> 00:26:03,310
下面是 clang 或任何编译器编译这样的代码时发生的情况。

327
00:26:03,310 --> 00:26:08,720
它将 C 语言中的此代码转换为汇编代码中的此代码。

328
00:26:08,720 --> 00:26:10,720
因此，这是一种比较可怕的语言。

329
00:26:10,720 --> 00:26:12,580
我自己并没有什么美好的回忆。

330
00:26:12,580 --> 00:26:14,805
很多人都不会用这种语言编程。

331
00:26:14,805 --> 00:26:21,430
如果你选修了计算机科学、系统方面的后续课程，或者更高级别的课程，你可能真的会学到这些知识或其中的一些变体。

332
00:26:21,430 --> 00:26:29,320
但至少有一些人需要了解这些知识，因为这更接近于现在的计算机本身所能理解的东西。

333
00:26:29,320 --> 00:26:37,960
英特尔 CPU 或 AMD CPU 是当今电脑和手机的大脑，它们能理解的东西看起来更像这个，而不像 C。

334
00:26:37,960 --> 00:26:42,430
这完全是个深奥的问题，但我只想强调几句话。

335
00:26:42,430 --> 00:26:44,630
有些东西有点熟悉。

336
00:26:44,630 --> 00:26:47,620
顶部的黄色部分提到了主要内容。

337
00:26:47,620 --> 00:26:49,750
底部提到了 getString。

338
00:26:49,750 --> 00:26:52,070
下面提到了 printf。

339
00:26:52,070 --> 00:27:00,130
因此，这只是另一种名为汇编语言的编程语言，几十年前，人类--包括我自己在学校里--确实用这种语言写过代码。

340
00:27:00,130 --> 00:27:06,070
当然，有些人仍然在写这样的代码，尤其是你可以写出非常非常高效的代码。

341
00:27:06,070 --> 00:27:08,590
但它更神秘。

342
00:27:08,590 --> 00:27:11,380
它对用户不那么友好。

343
00:27:11,380 --> 00:27:23,630
所以，你现在会看到黄色的部分，这些就是所谓的指令，计算机的大脑或 CPU 可以理解这些指令，将数值推来推去、移动它们、减去数值、调用函数、移动、移动、

345
00:27:24,130 --> 00:27:34,120
因此，计算机能理解的低级运算往往是算术运算--减法、加法等--将东西移入或移出内存。

346
00:27:34,120 --> 00:27:37,510
对于我们这样的人来说，编写这样的代码要乏味得多。

347
00:27:37,510 --> 00:27:40,450
这就是为什么你和我倾向于写这样的东西。

348
00:27:40,450 --> 00:27:46,520
理想情况下，像你我这样的人还是倾向于拖放拼图，进一步抽象出这一切。

349
00:27:46,520 --> 00:27:49,420
但就目前而言，这还是被称为汇编语言。

350
00:27:49,420 --> 00:27:54,310
这就是编译器编译代码时发生的情况。

351
00:27:54,310 --> 00:27:57,010
当然，这仍然不是 0 和 1。

352
00:27:57,010 --> 00:27:58,580
所以我们还有两步要走。

353
00:27:58,580 --> 00:28:05,530
因此，当编译器进行到第三步时，就会将代码转换为机器代码。

354
00:28:05,530 --> 00:28:18,550
当编译器为你汇编代码时，它会把我们刚才在屏幕上看到的内容转换成实际的 0 和 1，也就是你的手机或电脑能理解的所谓机器码。

355
00:28:18,550 --> 00:28:24,280
但值得注意的是，这些并不一定是程序中所有的 0 和 1。

356
00:28:24,280 --> 00:28:36,940
是的，它们就是对应于 Hello 程序或 printf 和 getString 等的 0 和 1，但请注意，在这里，我们还需要最后一步。

357
00:28:36,940 --> 00:28:40,100
在这些 0 和 1 中，只有你的代码行。

358
00:28:40,100 --> 00:28:43,540
但是，我们为实现 getString 而编写的 CS50 代码又是怎么回事呢？

359
00:28:43,540 --> 00:28:46,990
几十年前人类为实现 printf 而编写的代码行又如何呢？

360
00:28:46,990 --> 00:28:54,460
这些数据在硬盘上的某个地方，比如在我的 Mac、PC 或云端的某个地方，但我们需要将所有这些 0 和 1 结合起来

361
00:28:54,460 --> 00:29:02,420
将我的代码与 CS50 的代码和标准 I/O 的代码连接在一起。

362
00:29:02,420 --> 00:29:11,440
因此，最后一步的最终结果是，如果我的代码是黄色的，CS50 写的代码是黄色的，C 语言的作者写的代码是黄色的，C 语言的作者写的代码是黄色的。

363
00:29:11,440 --> 00:29:19,960
它本身写道，真正发生的事情是，在某个地方，我们不仅有 hello.c，其中，很明显，我写道，并写道与我们住在这里、

364
00:29:19,960 --> 00:29:28,210
另外，我们假设在电脑的某个地方还有一个 cs50.c 文件，巧合的是，这个文件是我和 CS50 工作人员多年前写的。

365
00:29:28,210 --> 00:29:30,790
此外，在电脑的某个地方，还有另一个文件。

366
00:29:30,790 --> 00:29:34,120
让我简化一下，直接称之为 stdio.c。

367
00:29:34,120 --> 00:29:36,850
实际上，它的具体名称可能是 printf.c。

368
00:29:36,850 --> 00:29:39,460
但它们就在某处，就是另外两个文件。

369
00:29:39,460 --> 00:29:48,100


370
00:29:48,100 --> 00:29:50,810
然后抓取 CS50 写入的 0 和 1。

371
00:29:50,810 --> 00:29:56,240
为了实现标准 I/O 库，它抓取了 C 语言作者编写的 0 和 1。

372
00:29:56,240 --> 00:30:00,750
最后，瞧，把它们连接在一起。

373
00:30:00,750 --> 00:30:03,980
这就是我们之前看到的那团 0 和 1。

374
00:30:03,980 --> 00:30:15,830
这只是预处理你的代码、编译你的代码、组装你的代码、链接你的代码的结果，我的天啊，在这一点上，好像编程对你来说还有什么乐趣可言、

375
00:30:15,830 --> 00:30:19,620
我们把这一切都拿走了，我们把整个过程称为编译。

377
00:30:20,120 --> 00:30:27,890
因为既然我们知道这些步骤的存在，而且聪明人也为我们解决了这个问题，你和我就可以在这个抽象的层面上进行操作了

378
00:30:27,890 --> 00:30:32,420
并假定编译会将源代码转换为机器代码。

379
00:30:32,420 --> 00:30:36,350
对这些中间步骤有疑问吗？

381
00:30:37,360 --> 00:30:41,958
听众：对于链接，不同的部分，如[听不清]？

382
00:30:50,072 --> 00:30:51,280
大卫-马兰：问得好。

383
00:30:51,280 --> 00:30:53,238
那么，这些 "0 "和 "1 "都储存在哪里呢？

384
00:30:53,238 --> 00:30:58,330
当然，code.cs50.io 是基于网络的用户界面。

385
00:30:58,330 --> 00:31:09,000
但是，请再次回顾上周的内容，即使你使用网络浏览器访问 VS 代码，该网络版的 VS 代码也是连接到云中某处的实际服务器上的。

386
00:31:09,000 --> 00:31:15,360
在该服务器上，你有自己的账户和文件，实际上，你有自己的硬盘，实际上是在云中。

387
00:31:15,360 --> 00:31:19,830
把它想象成 Dropbox 或 Box 或 Google Drive 或 OneDrive 或类似的东西。

388
00:31:19,830 --> 00:31:23,310
所以，你有一个我们为你配置好的硬盘。

389
00:31:23,310 --> 00:31:32,700
在那个硬盘上，有你刚写的代码，或者我刚写的代码，cs50.c、stdio.c 以及所有其他代码。

390
00:31:32,700 --> 00:31:36,967
来实现数学函数和 C 支持的其他功能。

391
00:31:36,967 --> 00:31:37,550
问得好。

393
00:31:38,964 --> 00:31:51,935
听众：那么，比方说在 CS50 库中，[INAUDIBLE]这一行我们也是这样[INAUDIBLE]复制粘贴过来的吗？

394
00:31:51,935 --> 00:31:53,060
大卫-马兰：问得好。

395
00:31:53,060 --> 00:31:57,110
哈希值包括我代码顶端的 cs50.h 行。

396
00:31:57,110 --> 00:32:01,310
如果我将其替换为 cs50.c 的内容，这样行得通吗？

397
00:32:01,310 --> 00:32:03,590
简而言之，是的，这样可行。

398
00:32:03,590 --> 00:32:05,400
您可以将所有代码复制到这里。

399
00:32:05,400 --> 00:32:08,577
不过，有些操作顺序可能会发挥作用。

400
00:32:08,577 --> 00:32:10,910
因此，这可能不是复制、粘贴那么简单。

401
00:32:10,910 --> 00:32:13,190
但从概念上讲，是的，就是这么回事。

402
00:32:13,190 --> 00:32:25,670
因此，在 cs50.h 中，只有函数的原型、函数的外观提示、返回类型、名称和参数。

403
00:32:25,670 --> 00:32:29,867
实际代码往往是在点 c 文件中编写的。

404
00:32:29,867 --> 00:32:33,920
现在这有点令人困惑，因为你我都只在点 c 文件中编写过代码。

405
00:32:33,920 --> 00:32:40,460
但在接下来的几周里，你将开始编写一些自己的 dot h 文件，就像 CS50 一样，就像标准 I/O 一样。

406
00:32:40,460 --> 00:32:46,020
但实质上，这行代码只是让我们更容易使用和重复使用已经编写好的代码。

407
00:32:46,020 --> 00:32:47,750
而这正是图书馆的意义所在。

408
00:32:47,750 --> 00:32:50,327
听众：把它们联系起来[听不清]吗？

409
00:32:50,327 --> 00:32:51,910
大点声说。

410
00:32:51,910 --> 00:32:54,472
听众：使用编译器时是否会进行链接？

411
00:32:54,472 --> 00:32:55,180
戴维-马兰：是的。

412
00:32:55,180 --> 00:32:56,980
编译代码时是否进行了链接？

414
00:32:57,480 --> 00:33:04,570
当你运行 "制作 "时，就像我们过去一周所做的那样，所有这四个步骤都在进行。

415
00:33:04,570 --> 00:33:07,780
预处理会将哈希包含行转换为其他内容。

416
00:33:07,780 --> 00:33:14,290
从技术上讲，编译会将其转换为汇编代码，Mac、PC 和服务器更容易理解汇编代码。

417
00:33:14,290 --> 00:33:20,080
汇编程序将这种语言转换成二进制机器码，让计算机真正理解。

418
00:33:20,080 --> 00:33:22,540
然后将所有内容连接在一起。

419
00:33:22,540 --> 00:33:32,860
事实上，如果你回想一下几分钟前我做这个 -lcs50 的时候，我之所以要添加这个，以及我的代码一开始无法编译的原因，是因为我

420
00:33:32,860 --> 00:33:38,650
忘了告诉 clang 在最后一步连接 CS50 的 0 和 1。

421
00:33:38,650 --> 00:33:44,480
我不需要使用 -lstdio，因为它是 C 语言自带的，所以这对世界上的每个人来说都很乏味。

422
00:33:44,480 --> 00:33:47,140
但是，CS50 不带 C，因此我们将其连接进来。

423
00:33:47,140 --> 00:33:49,780
我们也要明确一点，我们不会一直使用 CS50 的资料库。

424
00:33:49,780 --> 00:33:53,072
这将是我们在未来几周内摘下的又一副训练轮。

425
00:33:53,072 --> 00:33:55,000
但现在，它让一些事情变得更简单了。

427
00:33:57,284 --> 00:33:59,750
听众：什么是[INNAUDIBLE]？

428
00:34:08,878 --> 00:34:10,170
大卫-马兰：简而言之，是的。

429
00:34:10,170 --> 00:34:12,870
那么，机器码中的 0 和 1 又是什么意思呢？

430
00:34:12,870 --> 00:34:17,340
是的，机器代码和汇编代码之间是一对一的关系。

431
00:34:17,340 --> 00:34:21,510
汇编代码，虽然不是真正的英语，但至少是我认识的符号。

432
00:34:21,510 --> 00:34:22,800
不是 0 和 1。

433
00:34:22,800 --> 00:34:24,810
当然，机器代码只是 0 和 1。

434
00:34:24,810 --> 00:34:30,630
因此，在 C 语言出现之前，人们只能用汇编代码编程。

435
00:34:30,630 --> 00:34:34,469
在汇编代码出现之前，人们用 0 和 1 进行编码。

436
00:34:34,469 --> 00:34:40,110
你可以想象那是多么痛苦，所以每一种语言都让我们的生活变得越来越轻松。

437
00:34:40,110 --> 00:34:48,090
几周后，我们将过渡到 Python，而 Python 又会让 C 语言变得更加简单，或者说让一般的编码工作变得更加简单。

438
00:34:48,090 --> 00:34:55,060
好了，说了这么多，我们现在能 -- 这可能会出什么问题？

439
00:34:55,060 --> 00:34:59,233
原来，除了编译，从技术上讲，还有反编译。

440
00:34:59,233 --> 00:35:01,150
我们没有这样做，也不会这样做。

441
00:35:01,150 --> 00:35:04,080
但这值得我们思考片刻。

442
00:35:04,080 --> 00:35:14,580
如果不对代码进行编译，而是进行反编译--顾名思义，反编译就是颠倒过程，最好是从机器码--0 和 1--进行转换。

443
00:35:14,580 --> 00:35:22,080
如果你有的只是一个程序，你可以转换它并查看实际的源代码。

444
00:35:22,080 --> 00:35:28,650
如果互联网上的任何人都能在自己的机器上反编译代码，那会有什么坏处呢？

447
00:35:30,270 --> 00:35:35,430
好吧，那就更容易在代码中找到漏洞，哦，利用漏洞。

448
00:35:35,430 --> 00:35:45,080
因此，通过查找你我所犯的错误来黑进软件可能会更容易，因为从字面上看，它们是用代码盯着你看的，而 0 和 1 就不那么明显了。

449
00:35:45,080 --> 00:35:48,140
我所说的反编译的其他缺点？

451
00:35:49,970 --> 00:35:53,690
如果东西是有版权的，或者你甚至不知道如何得到它 --

452
00:35:53,690 --> 00:35:54,440
是的

454
00:35:55,948 --> 00:36:03,660
戴维-马兰：是的，如果你的代码、你的作品是你的知识产权，不管是否有版权，有人可以随便运行一个命令，然后 "嘭 "的一声，这就有点令人讨厌了、

455
00:36:03,660 --> 00:36:05,577
他们可以看到你编写的原始代码。

456
00:36:05,577 --> 00:36:08,490
现在看来，事情并非如此简单。

457
00:36:08,490 --> 00:36:19,400
因此，尽管你可以使用 Hello 或 Microsoft Word 这样的程序，并将其从 0 和 1 转换回某种形式的源代码--无论是 C 语言还是 Java 语言

458
00:36:19,400 --> 00:36:25,800
或 Python 或其他语言，不管它最初是用什么语言编写的--都有可能是一团糟。

460
00:36:26,300 --> 00:36:30,890
因为变量名通常不会保留在 0 和 1 中。

461
00:36:30,890 --> 00:36:33,980
函数名可能不会保留在 0 和 1 中。

462
00:36:33,980 --> 00:36:42,890
代码是代码，逻辑是逻辑，但计算机并不关心你选择了什么漂亮的变量，也不关心你的函数名称有多好听，它只需要知道它们是 0 和 1。

463
00:36:42,890 --> 00:36:46,370
此外，回想一下上周，我们介绍了 C 语言中的循环等内容。

464
00:36:46,370 --> 00:36:49,745
除了 for 循环，还有哪种循环？

466
00:36:50,620 --> 00:36:59,910
DAVID MALAN：所以，while 循环--尽管它们看起来不同，你必须写不同的代码，但它们实现的功能完全相同，也就是说，当你编译 for 循环时

467
00:36:59,910 --> 00:37:07,420
或编译一个 while 循环，如果它们在逻辑上做的是同一件事，那么它们最终可能看起来就像 0 和 1 一样。

468
00:37:07,420 --> 00:37:11,820
因此，并不一定能预测你能拿回原始代码，为什么？

469
00:37:11,820 --> 00:37:19,350
因为 0 和 1 可能不知道是 for 循环还是 while 循环，所以编译时可能会显示其中一个。

470
00:37:19,350 --> 00:37:24,570
老实说，反编译虽然可行，但也是逆向工程的一种方法。

471
00:37:24,570 --> 00:37:34,020
如果你有足够的能力开始阅读已经反编译过的代码，并能读懂其中的杂乱无章，那么你就有可能具备从头开始编写相同程序的才能。

473
00:37:34,650 --> 00:37:40,410
现在看来，这也许有点言过其实，但它并不像你最初想象的那样容易或具有威胁性。

474
00:37:40,410 --> 00:37:50,040
因此，一般来说，代码一旦编译完成，要对其进行逆向工程就相当具有挑战性，既费时又费钱，就像在现实世界中一样，对吗？

475
00:37:50,040 --> 00:37:52,860
如今，我们每个人的口袋里都可能装着某种手机。

476
00:37:52,860 --> 00:37:57,060
没有什么能阻止你以某种方式打开它，四处探寻，重现那里的一切。

477
00:37:57,060 --> 00:37:59,130
这很可能是一个巨大的工作量。

478
00:37:59,130 --> 00:38:03,310
到那时，也许你应该发明手机，而不是试图逆向工程它。

479
00:38:03,310 --> 00:38:06,330
因此，在物理世界中也有同样的想法。

480
00:38:06,330 --> 00:38:13,050
那么，对于这些形式的编译甚至反编译有什么问题吗？

481
00:38:13,050 --> 00:38:17,160
好吧，现在看来，不仅是我，你们也有可能犯错。

482
00:38:17,160 --> 00:38:26,490
你写的代码有漏洞--代码中的漏洞就是一个错误，不管是逻辑错误还是其他错误，代码就是不能按照你的意图正确运行。

483
00:38:26,490 --> 00:38:35,320
到目前为止，你的调试技巧很可能就是回顾我在课堂上的表现，或者在网上或当面提问。

484
00:38:35,320 --> 00:38:39,570
但归根结底，如果你有一些自己的工具来调试代码，那就更好了。

485
00:38:39,570 --> 00:38:41,587
老实说，这是一项终身技能。

486
00:38:41,587 --> 00:38:47,910
你不可能从 CS50 中脱颖而出，甚至 20 年后，你也不可能一直写出正确的代码（如果你写的是代码的话）。

487
00:38:47,910 --> 00:38:50,820
比如，我们所有员工都在继续写 bug。

488
00:38:50,820 --> 00:38:55,540
希望他们能变得更成熟一些，而不是像 "哎呀，我漏掉了一个分号 "那样。

489
00:38:55,540 --> 00:38:57,660
但即使是这样的错误，我们也会犯。

490
00:38:57,660 --> 00:39:03,550
但是，在解决这些问题时，有一些工具和技术可以让你的生活变得更轻松。

491
00:39:03,550 --> 00:39:06,360
现在，"窃听器 "这个词实际上已经存在了几十年。

492
00:39:06,360 --> 00:39:13,650
不过，有一个有趣的故事是，第一个记录在案的真正错误实际上与哈佛大学有某种联系。

493
00:39:13,650 --> 00:39:22,890
事实上，这是 1947 年与哈佛 Mark II 计算机有关的日志，如果你读了这里的注释--我将放大--这个

494
00:39:22,890 --> 00:39:29,160
是在这台大型计算机主机内发现了一只真正的蛀虫，它造成了某种问题。

495
00:39:29,160 --> 00:39:33,610
当时在场的工程师们还觉得这很有趣：哇，物理错误居然能解释这个问题。

496
00:39:33,610 --> 00:39:39,090
它被永远地粘在了这张纸上，我相信这张纸现在正在史密森尼博物馆展出。

497
00:39:39,090 --> 00:39:43,260
尽管如此，这也只是一个逻辑错误的代表。

498
00:39:43,260 --> 00:39:53,640
实际上，这个故事经常被一位著名的数学家，也就是后来的计算机科学家格蕾丝-霍珀博士复述。

499
00:39:53,640 --> 00:39:57,210
它的前身是哈佛 Mark I 计算机。

500
00:39:57,210 --> 00:40:04,103
如果你曾在河对岸的工程大楼里待过一段时间，你就能看到这台计算机的许多部分。

501
00:40:04,103 --> 00:40:07,020
当你第一次走进科学与工程学院的时候，你会发现墙边有一个"......

503
00:40:07,530 --> 00:40:11,070
事实上，正如你在成长过程中可能听说过的，这是一台大型计算机。

504
00:40:11,070 --> 00:40:18,240
这就是 Mac 和 PC 当年的样子，它们都有一个非常实体的东西，基本上实现了零的功能

505
00:40:18,240 --> 00:40:22,410
而你我认为理所当然的那些东西，现在都已微型化，装进了我们的笔记本电脑和手机中。

506
00:40:22,410 --> 00:40:23,910
所以这里有一段历史。

507
00:40:23,910 --> 00:40:27,390
如果有机会去校园那边看看，一定要去。

508
00:40:27,390 --> 00:40:31,350
但是，让我们考虑一下，我们如何解决的当然不是物理上的错误，而是逻辑上的错误。

509
00:40:31,350 --> 00:40:40,320
让我们考虑一下上周发生的事情，我们试图用标签打印这三块砖头，非常简单。

510
00:40:40,320 --> 00:40:44,400
所以，让我马上去看看 VS Code。

511
00:40:44,400 --> 00:40:47,080
我现在要打开一个事先写好的程序。

512
00:40:47,080 --> 00:40:51,510
我把它带到课堂上是因为它有一个漏洞，我想知道如何解决这个漏洞。

513
00:40:51,510 --> 00:40:56,160
因此，让我打开 buggy0.c，这是我代码的第 0 版。

514
00:40:56,160 --> 00:40:58,200
让我们快速浏览一下这里的内容。

515
00:40:58,200 --> 00:40:58,950
很短。

516
00:40:58,950 --> 00:41:07,797
它只包含 stdio.h，使用 printf，使用 for 循环，目的很简单，就是打印出那列三个砖块。

517
00:41:07,797 --> 00:41:13,360
现在，它已经足够短了，如果你们中的一些人已经熟悉了 C 语言，你们可能已经看到了逻辑错误。

518
00:41:13,360 --> 00:41:16,200
这不是语法错误，因为它可以编译和运行。

519
00:41:16,200 --> 00:41:17,280
但这里有个漏洞。

520
00:41:17,280 --> 00:41:27,745
假设我是 C 语言的新手，我对 C 语言很不熟悉，现在是凌晨 2 点，我就是看不到这个错误，那么我有什么办法来发现这样的错误呢？

521
00:41:27,745 --> 00:41:29,370
首先，我们来看看症状。

522
00:41:29,370 --> 00:41:31,740
让我进入终端窗口。

523
00:41:31,740 --> 00:41:36,120
我将使用 make buggy0，因为文件名还是 buggyo.c。

524
00:41:36,120 --> 00:41:37,260
我不会用 clang。

525
00:41:37,260 --> 00:41:39,880
事实上，从现在开始我再也不会手动使用 clang 了。

526
00:41:39,880 --> 00:41:42,430
我只想用 make，因为它能让我们的生活更轻松。

527
00:41:42,430 --> 00:41:43,560
确实可以编译。

528
00:41:43,560 --> 00:41:45,390
没有错误，所以不是语法问题。

529
00:41:45,390 --> 00:41:47,670
这不是什么分号丢失之类的傻事。

530
00:41:47,670 --> 00:41:59,610
但是，当我运行 ./buggy0 时，我当然会看到 1、2、3、4 -- 当然，这与我为该列设计的 1、2、3 块砖并不一致。

531
00:41:59,610 --> 00:42:02,970
然而，我还是像往常一样，从 0 开始计数。

532
00:42:02,970 --> 00:42:03,930
我有三个。

533
00:42:03,930 --> 00:42:05,280
我要去三个。

534
00:42:05,280 --> 00:42:06,780
那么，我的逻辑错误在哪里？

535
00:42:06,780 --> 00:42:10,150
如果你还没有明显地意识到这一点，那么，我该如何解决这个问题呢？

536
00:42:10,150 --> 00:42:16,080
首先，解决 bug 的最佳方法也许就是使用 printf，至少在早期是这样。

537
00:42:16,080 --> 00:42:20,020
到目前为止，我们已经在屏幕上使用了 "冲刺说"、"你好 "等功能。

538
00:42:20,020 --> 00:42:22,530
但 printf 只是一个用于打印任何内容的函数。

539
00:42:22,530 --> 00:42:31,350
你没有理由不临时使用 printf 来打印变量的内容、程序内部的情况，以便找出错误所在。

540
00:42:31,350 --> 00:42:32,940
之后你就可以删除这行代码了。

541
00:42:32,940 --> 00:42:34,600
它不必永远留在那里。

542
00:42:34,600 --> 00:42:35,740
那就让我来吧。

543
00:42:35,740 --> 00:42:45,690
与其在 VS 代码中直接打印出哈希符号，不如让我在这里做一下安全检查，打印出 i 的值。

544
00:42:45,690 --> 00:42:51,610
所以，让我继续说，i is -- 现在我想说 i is this。

545
00:42:51,610 --> 00:42:54,540
当然，我并不是这样打印出 i 的值的。

546
00:42:54,540 --> 00:42:58,930
如果我想打印出 i 的值，应该在这里输入什么？

547
00:42:58,930 --> 00:43:02,160
所以 %i 表示整数，而不是 %s 表示字符串。

548
00:43:02,160 --> 00:43:03,410
因此，它们仍然是占位符。

549
00:43:03,410 --> 00:43:04,930
但我们使用 %s 表示整数。

550
00:43:04,930 --> 00:43:09,250
现在，如果我想打印出 i，只需将逗号作为第二个参数，然后再打印出 i。

551
00:43:09,250 --> 00:43:13,000
好了，让我回到终端窗口。

552
00:43:13,000 --> 00:43:15,760
让我重新编译程序，因为我改动了它。

553
00:43:15,760 --> 00:43:18,880
./buggy0 仍能正常工作。

554
00:43:18,880 --> 00:43:22,540
现在，让我增大终端窗口的大小。

555
00:43:22,540 --> 00:43:25,510
你可以看到一些诊断信息。

556
00:43:25,510 --> 00:43:26,560
这不是我们的目标。

557
00:43:26,560 --> 00:43:30,070
这不是你应该提交的作业问题（如果有的话）。

558
00:43:30,070 --> 00:43:34,450
但它可以帮助我们诊断地知道，好的，当 i 为零时，这里有一个哈希值。

559
00:43:34,450 --> 00:43:36,182
当 i 为 1 时，这里有一个哈希值。

560
00:43:36,182 --> 00:43:37,390
当 i 是 2 时，这里有一个散列。

561
00:43:37,390 --> 00:43:39,017
当 i 为 3 时，这里有一个散列。

562
00:43:39,017 --> 00:43:39,850
等一下

563
00:43:39,850 --> 00:43:41,530
一、二、三、四。

564
00:43:41,530 --> 00:43:44,360
很明显，我打印的次数太多了。

565
00:43:44,360 --> 00:43:48,130
因此，让我缩小终端窗口，回顾一下这里的代码。

566
00:43:48,130 --> 00:43:53,080
我想问问大家，错误究竟出在哪里？

567
00:43:53,080 --> 00:43:56,080
或者说，相应的解决方案是什么？

568
00:43:56,080 --> 00:43:57,561
是的，在中间。

570
00:44:00,020 --> 00:44:03,550
DAVID MALAN：是的，与其用小于或等于，不如用小于。

571
00:44:03,550 --> 00:44:05,300
所以，你得在这里选一条道。

572
00:44:05,300 --> 00:44:10,880
如果要从 0 开始计数，一般使用小于，直至，但不是通过值。

573
00:44:10,880 --> 00:44:17,300
或者，如果你愿意，就像人类世界一样，从 1 开始往上数，你也可以使用小于或等于，但必须保持一致。

574
00:44:17,300 --> 00:44:22,610
一般来说，作为程序员，如果要做类似这样的规范性工作，就一定要从 0 开始计数。

575
00:44:22,610 --> 00:44:27,860
但实际上，解决的办法就是通过将大于小于或等于小于来改变这种情况。

576
00:44:27,860 --> 00:44:36,500
如果我用 make buggy0 重新编译这个程序，然后再做一次 .buggy0 -- 让我增大终端窗口的大小。

577
00:44:36,500 --> 00:44:39,050
现在，你看，OK，输出几乎一样。

578
00:44:39,050 --> 00:44:44,330
但事实上，i 从 0 开始，一直到 3，但不是通过 3。

579
00:44:44,330 --> 00:44:48,920
好了，简而言之，printf 可以成为你的第一个诊断工具。

580
00:44:48,920 --> 00:44:51,500
而不是只盯着屏幕或举起手

581
00:44:51,500 --> 00:44:57,287
我的意思是，使用 printf 可以打印出感兴趣的内容，从而了解程序内部发生了什么。

582
00:44:57,287 --> 00:45:02,840
一旦你解决了问题，你就可以回到你的代码中，就像我在这里做的那样，缩小我的终端窗口。

583
00:45:02,840 --> 00:45:04,610
我会删除 printf 行。

584
00:45:04,610 --> 00:45:08,870
现在，我已经准备好与全世界分享这个程序，或者把它作为家庭作业之类的提交。

585
00:45:08,870 --> 00:45:11,390
这只是暂时的。

586
00:45:11,390 --> 00:45:15,440
有关于 printf 作为调试工具的问题吗？

588
00:45:18,510 --> 00:45:20,970
好吧，那也只能到此为止了。

589
00:45:20,970 --> 00:45:28,860
老实说，随着程序的不断发展壮大，开始添加 printf、删除 printf 并找出问题所在会变得非常烦人、

590
00:45:28,860 --> 00:45:31,860
如果你有多个 printf，那么，哪个 printf 打印了什么？

591
00:45:31,860 --> 00:45:34,560
仅仅依靠 printf 最终会变得一团糟。

592
00:45:34,560 --> 00:45:41,040
因此，作为一名计算机科学家，计算机科学家编写的软件可以让调试代码变得更容易。

593
00:45:41,040 --> 00:45:48,610
这个软件就是我们通常所说的调试器，它是你可以用来实际解决代码问题的第二个工具。

594
00:45:48,610 --> 00:45:52,690
现在，在 VS 代码的世界里，实际上已经内置了一个调试器。

595
00:45:52,690 --> 00:45:58,260
所以，你将在 VS Code 中看到的图形用户界面并不是 CS50 特有的，它实际上是 VS Code 自带的。

596
00:45:58,260 --> 00:46:03,030
它还支持 C、C++、Java、Python 和许多其他语言。

597
00:46:03,030 --> 00:46:07,650
但不得不承认，刚开始使用调试器有点复杂。

598
00:46:07,650 --> 00:46:13,480
你必须创建一个配置文件，并执行一些恼人的步骤，这些步骤只会妨碍你解决实际问题。

599
00:46:13,480 --> 00:46:17,070
因此，我们为您自动完成了启动调试器的过程。

600
00:46:17,070 --> 00:46:19,680
此后，如何使用它就成了行业标准。

601
00:46:19,680 --> 00:46:23,380
但我们为您省去了创建这些配置文件的麻烦。

602
00:46:23,380 --> 00:46:25,330
所以，假设我想这样做。

603
00:46:25,330 --> 00:46:30,330
假设我想尝试使用专用软件逐步调试这个程序。

604
00:46:30,330 --> 00:46:31,810
我该怎么做呢？

605
00:46:31,810 --> 00:46:41,790
好吧，让我来提议一下，如果我把它恢复到 i 小于或等于 3 的原始版本，我很确定我打印了太多的哈希值。

606
00:46:41,790 --> 00:46:45,160
所以我要这么做 -- 你可能不小心这么做了，或者根本就没这么做。

607
00:46:45,160 --> 00:46:54,390
但请注意，如果你将鼠标悬停在 VS 代码中的 "沟槽 "上，也就是编辑器左侧的部分，你会看到一个灰色的红点。

608
00:46:54,390 --> 00:46:57,240
如果点击这里，它就会变成一个更亮的红点。

609
00:46:57,240 --> 00:46:59,670
这就是我们所说的断点。

610
00:46:59,670 --> 00:47:07,350
这只是一个可视化的指示器，你在这里设置了一个等同于停止的标志，你在告诉调试器，停止在这里运行我的代码。

612
00:47:07,920 --> 00:47:14,380
因为我更喜欢以人的速度而不是电脑的速度来浏览我的代码。

613
00:47:14,380 --> 00:47:16,750
所以我设置了断点，这是第一步。

614
00:47:16,750 --> 00:47:18,580
第二步就很简单了。

615
00:47:18,580 --> 00:47:26,010
不要运行程序本身，而是运行名为 debug50 的命令，然后运行 ./buggy0。

616
00:47:26,010 --> 00:47:33,060
现在，这将启动你的程序，但在调试器内部，调试器是聪明人编写的一个特殊程序，它将赋予你

617
00:47:33,060 --> 00:47:38,970
现在，您可以按照自己的节奏逐行查看代码。

618
00:47:38,970 --> 00:47:43,080
我按下回车键，屏幕上就会出现一些东西--哎呀。

619
00:47:43,080 --> 00:47:45,767
注意，这是我不小心犯的一个常见错误。

620
00:47:45,767 --> 00:47:47,100
看来我修改了代码。

621
00:47:47,100 --> 00:47:49,892
我这样做是因为我修改了小于或等于号。

622
00:47:49,892 --> 00:47:52,860
因此，让我继续重新运行 make buggy0--

624
00:47:53,520 --> 00:47:55,590
很好，现在让我重新运行 debug50--

626
00:47:57,810 --> 00:48:06,010
现在屏幕上出现了一些东西，启动需要一些时间，但一旦启动，你就会看到这个，你仍然会看到你的代码。

627
00:48:06,010 --> 00:48:09,410
但你会看到这个黄色高亮，这可能是你以前从未见过的。

628
00:48:09,410 --> 00:48:13,440
注意，它特别强调了我设置断点的那一行。

630
00:48:13,950 --> 00:48:20,670
这意味着除第 7 行外，调试器已执行了所有这些行。

631
00:48:20,670 --> 00:48:23,340
它已经坏了，不是坏了。

632
00:48:23,340 --> 00:48:27,580
但它在第 7 行暂停执行，因此尚未打印任何哈希值。

633
00:48:27,580 --> 00:48:30,450
你可以看到终端窗口中还没有哈希值。

634
00:48:30,450 --> 00:48:31,980
这是暂停执行。

635
00:48:31,980 --> 00:48:37,410
但调试器的有趣之处在于左侧的内容。

636
00:48:37,410 --> 00:48:41,910
在调试器中，你会在变量下看到所有所谓的局部变量。

637
00:48:41,910 --> 00:48:45,327
我们还没有真正区分本地和所谓的全球。

638
00:48:45,327 --> 00:48:49,390
但现在，局部变量只是指函数中存在的所有变量。

639
00:48:49,390 --> 00:48:52,110
因此，i 目前的值为 0。

640
00:48:52,110 --> 00:48:53,410
好吧，这就说得通了。

641
00:48:53,410 --> 00:48:57,360
那么，现在我该如何逐步查看我的代码并了解它在做什么呢？

642
00:48:57,360 --> 00:49:03,630
在屏幕顶部，你会看到一些播放图标，有点像视频播放器，但它们有特殊含义。

643
00:49:03,630 --> 00:49:07,892
第一个程序会一直播放到节目结束。

644
00:49:07,892 --> 00:49:13,110
因此，只有当你已经解决了问题，只想像以前一样运行完成时，才会点击这个按钮。

645
00:49:13,110 --> 00:49:16,920
但接下来的三个，或者接下来的两个，真的，才是最精彩的。

646
00:49:16,920 --> 00:49:21,930
这里的第二个，如果你把鼠标悬停在它上面，最终你会看到它叫做 "跨步"。

647
00:49:21,930 --> 00:49:28,630
步骤结束意味着调试器将运行当前高亮显示的这行代码，但不会深入研究。

648
00:49:28,630 --> 00:49:32,827
因此，如果是像 printf 这样的函数，它就不会开始逐行执行 printf。

650
00:49:33,327 --> 00:49:36,420
因为我基本可以认为几十年前写的 printf 是正确的。

651
00:49:36,420 --> 00:49:38,050
问题可能出在我身上。

652
00:49:38,050 --> 00:49:46,110
但接下来这一行，如果我真的想走进 printf 代码，弄清楚它是如何工作的，或者在多年后发现其中的某些问题、

653
00:49:46,110 --> 00:49:54,250
你可以进入 printf，然后屏幕会发生变化，你会看到 printf 的每一行，一行接一行--至少如果你安装了 printf 的源代码的话。

654
00:49:54,250 --> 00:49:56,490
好了，我要用第一个，"跨步"。

655
00:49:56,490 --> 00:49:59,130
注意黄色亮点的移动。

656
00:49:59,130 --> 00:50:03,060
看，终端窗口中出现了一个哈希符号。

657
00:50:03,060 --> 00:50:03,780
开始了

658
00:50:03,780 --> 00:50:05,130
有一个散列。

659
00:50:05,130 --> 00:50:07,230
现在，请注意第 5 行已突出显示。

660
00:50:07,230 --> 00:50:09,480
这意味着它在第 5 行暂停。

661
00:50:09,480 --> 00:50:11,350
第 5 行尚未执行。

662
00:50:11,350 --> 00:50:12,600
这意味着什么？

663
00:50:12,600 --> 00:50:16,320
左上角的 i 值仍为 0。

664
00:50:16,320 --> 00:50:24,470
但当我再次点击 "Step Over "时，请注意左上方的情况，i 是屏幕上的一个变量。

665
00:50:24,470 --> 00:50:27,920
现在 i -- 短暂闪烁 -- 值为 1。

666
00:50:27,920 --> 00:50:30,650
现在，如果我再走过去，注意终端窗口。

667
00:50:30,650 --> 00:50:32,120
这是我的第二个哈希。

668
00:50:32,120 --> 00:50:36,380
现在，让我点击 For 循环的 Step Over，注意左上角的变量。

669
00:50:36,380 --> 00:50:38,567
现在 1 变为 2。

670
00:50:38,567 --> 00:50:39,650
现在让我再点击一次。

671
00:50:39,650 --> 00:50:43,220
第三次散列--这里可能暴露了逻辑错误。

672
00:50:43,220 --> 00:50:45,210
让我先跨过这个环。

673
00:50:45,210 --> 00:50:46,520
现在 i 是 3。

674
00:50:46,520 --> 00:50:49,280
等等，我还是要打印一份散列。

675
00:50:49,280 --> 00:50:49,810
就在那儿。

676
00:50:49,810 --> 00:50:50,810
还有第四根哈希线。

677
00:50:50,810 --> 00:50:53,852
在这一点上，希望灯泡，俗话说，已经熄灭了。

678
00:50:53,852 --> 00:50:55,020
我意识到，哦，我搞砸了。

679
00:50:55,020 --> 00:51:02,493
我可以用红色方块完全停止程序，也可以让程序一直运行到最后，这样就可以终止一切。

680
00:51:02,493 --> 00:51:05,660
此时此刻，我只想回到我的代码中，开始修复问题。

681
00:51:05,660 --> 00:51:10,670
例如，你可以关闭文件资源管理器，以隐藏打开的面板。

682
00:51:10,670 --> 00:51:12,320
这就是 debug50。

683
00:51:12,320 --> 00:51:19,520
但这并不是 CS50 的问题，它只是为你启动调试器，这在当今大多数编程环境中都能找到。

684
00:51:19,520 --> 00:51:23,670
关于调试的问题？

687
00:51:24,670 --> 00:51:27,295
听众：它告诉你哪里出了问题？

688
00:51:27,295 --> 00:51:28,420
大卫-马兰：问得好。

689
00:51:28,420 --> 00:51:30,310
它在哪里告诉你哪里出了问题？

690
00:51:30,310 --> 00:51:33,190
因此，很遗憾，它并没有告诉你这些。

691
00:51:33,190 --> 00:51:39,580
您，人类，仍有责任有效地使用这一工具，以更理智的速度浏览您的代码。

692
00:51:39,580 --> 00:51:42,070
但你的大脑仍然需要解决这个问题。

693
00:51:42,070 --> 00:51:49,160
我毫不怀疑，随着人工智能等技术的发展，这样的程序会越来越有用，并开始为我们解答类似的问题。

694
00:51:49,160 --> 00:51:52,990
本学期我们还将向你介绍比这更强大的其他工具。

695
00:51:52,990 --> 00:51:57,820
但就目前而言，它只是一个工具，真正的作用是减慢速度，而不必更改代码。

696
00:51:57,820 --> 00:52:06,820
事实上，左边的面板只是向我显示 i 的变化值，这只是 printf 的一种替代方法，我可以更慢地完成它。

697
00:52:06,820 --> 00:52:10,580
有关调试的其他问题？

699
00:52:11,080 --> 00:52:14,950
让我用这个调试器给你演示最后一个例子。

700
00:52:14,950 --> 00:52:16,750
这个也是我提前写好的。

701
00:52:16,750 --> 00:52:18,730
让我关闭 buggy0.c。

702
00:52:18,730 --> 00:52:22,327
让我打开 buggy1.c，这是我的第二个版本。

703
00:52:22,327 --> 00:52:28,030
让我先关闭终端窗口，给你快速浏览一下这个程序，同样，它也有一个错误。

704
00:52:28,030 --> 00:52:32,830
现在，在这个程序的顶端，有一些我们熟悉的包括：cs50.h 和 stdio.h。

705
00:52:32,830 --> 00:52:34,730
这是我们以前从未见过的。

706
00:52:34,730 --> 00:52:38,830
这是本例中的一个特殊函数，名为 getNegativeInt。

707
00:52:38,830 --> 00:52:41,043
不带参数，返回一个整数。

708
00:52:41,043 --> 00:52:41,710
它有什么作用？

709
00:52:41,710 --> 00:52:45,040
从字面上看，它可以从用户那里得到一个负整数，理想情况下是这样。

710
00:52:45,040 --> 00:52:47,200
但有趣的是，这并不正确。

711
00:52:47,200 --> 00:52:50,090
这就是问题所在，目前 getNegativeInt 已被破坏。

712
00:52:50,090 --> 00:52:51,470
那么，主要做什么呢？

713
00:52:51,470 --> 00:52:55,690
好吧，main 只是调用这个函数，在括号中什么都没输入，也没有输入。

714
00:52:55,690 --> 00:52:58,240
并将返回值保存在 i 中。

715
00:52:58,240 --> 00:53:00,260
然后它就会在屏幕上打印出 i。

716
00:53:00,260 --> 00:53:06,365
因此，老实说，仅凭目测，我觉得用 C 语言编程已经足够自如了，我认为 main 是正确的。

717
00:53:06,365 --> 00:53:07,990
让我来说明一下，main 是正确的。

718
00:53:07,990 --> 00:53:09,698
但下面会有一个窃听器。

719
00:53:09,698 --> 00:53:11,210
下面的窃听器是什么？

720
00:53:11,210 --> 00:53:14,830
让我看看 getNegativeInt 的实现。

721
00:53:14,830 --> 00:53:18,970
注意，第一行 12 与上面的原型相同。

722
00:53:18,970 --> 00:53:26,690
因为 C 语言是从上到下、从左到右读取数据的--编译器在技术上是这样做的。

723
00:53:26,690 --> 00:53:36,820
因此，如果你在这里引用了 getNegativeInt，但直到下面才实现它，而且没有提前告诉 C 它将存在，那么你将再次出现上周我们看到的错误。

724
00:53:36,820 --> 00:53:39,010
好了，getNegativeInt 如何工作？

725
00:53:39,010 --> 00:53:40,960
我们声明一个名为 n 的变量。

726
00:53:40,960 --> 00:53:43,540
我们必须做一个 while 循环，做什么？

727
00:53:43,540 --> 00:53:47,110
它使用的是 cs50 库自带的 getInt，与上周相同。

728
00:53:47,110 --> 00:53:51,670
它提示用户输入负整数，加引号不加引号，并将数值存储在 n 中。

729
00:53:51,670 --> 00:53:56,800
然后，我在 n 小于 0 的情况下完成所有这些操作，对吗？

730
00:53:56,800 --> 00:54:04,970
还记得吗，上周我们曾经做了一个循环，以确保人类合作，不会给我们错误的值，无论是正值、负值还是其他值。

731
00:54:04,970 --> 00:54:06,400
然后我们返回 n。

732
00:54:06,400 --> 00:54:07,570
还有一些微妙之处。

733
00:54:07,570 --> 00:54:15,790
有谁记得--或者有直觉告诉我为什么我在第 14 行而不是第 17 行声明了 n？

734
00:54:15,790 --> 00:54:17,620
这是 C 语言的特殊情况。

736
00:54:23,465 --> 00:54:24,340
大卫-马兰：没错。

737
00:54:24,340 --> 00:54:33,560
在 C 语言中，有这样一个作用域的概念，我们将继续看到这个概念，即一个变量只存在于你最近打开的大括号中。

738
00:54:33,560 --> 00:54:40,900
因此，如果我在第 14 行声明了 n，我就可以在第 13 行和第 21 行之间的任何地方使用它，因为这些都是最近的大括号。

739
00:54:40,900 --> 00:54:53,470
相比之下，正如你所指出的，如果我改成这样说，int n 等于 getInt 等等，并且没有当前的第 14 行，那么，n 就会存在于这些大括号内，但不会存在于这里，这就意味着

740
00:54:53,470 --> 00:54:55,340
太迟了，而且绝对不是在这里。

741
00:54:55,340 --> 00:54:59,480
因此，你只需先声明它，然后再使用和重复使用它。

742
00:54:59,480 --> 00:55:01,545
现在，让我来告诉你如何调试它。

743
00:55:01,545 --> 00:55:03,170
不过，让我先给你看看症状。

744
00:55:03,170 --> 00:55:04,930
让我打开终端窗口。

745
00:55:04,930 --> 00:55:06,970
让我运行 buggy1。

746
00:55:06,970 --> 00:55:13,660
./buggy1，我被要求输入一个负整数。

747
00:55:13,660 --> 00:55:15,280
好吧，让我给它负1 --

749
00:55:16,710 --> 00:55:20,880
主函数应该打印出我输入的内容，但显然没有。

750
00:55:20,880 --> 00:55:21,880
它又在提示我了。

751
00:55:21,880 --> 00:55:23,830
好吧，也许是负 2。

753
00:55:24,330 --> 00:55:26,380
也许是负 3。

755
00:55:27,570 --> 00:55:29,160
好吧，它肯定坏了，对吗？

756
00:55:29,160 --> 00:55:31,528
从逻辑上讲，这似乎是在做相反的事情。

757
00:55:31,528 --> 00:55:33,820
现在，你或许已经明白为什么会出现这种情况了。

758
00:55:33,820 --> 00:55:37,170
这些都是为了演示而特意设计的简单程序。

759
00:55:37,170 --> 00:55:38,470
但让我们这样做吧。

760
00:55:38,470 --> 00:55:42,870
让我继续在 main 中设置断点，尽管我很确定 main 是正确的。

761
00:55:42,870 --> 00:55:47,010
但这只是帮助我开始我的思考过程--从主要的开始，然后从那里继续。

762
00:55:47,010 --> 00:55:51,840
现在让我运行 debug50 ./buggy1--

764
00:55:52,920 --> 00:55:53,700
让我们看看

765
00:55:53,700 --> 00:55:56,880
有了这个断点，图形用户界面就会重新配置。

766
00:55:56,880 --> 00:56:01,260
它会在第 8 行暂停，因为这是 main 中第一行有趣的内容。

767
00:56:01,260 --> 00:56:03,780
所以我也可以把断点放在第 8 行。

768
00:56:03,780 --> 00:56:09,570
它很聪明，知道如果我把它设置为 6，你指的其实是第 8 行，因为那是第一行实际代码。

769
00:56:09,570 --> 00:56:11,280
现在，看看会发生什么。

770
00:56:11,280 --> 00:56:19,470
如果我跨过这一行，请注意 i，它目前的默认值似乎是 0 -- 下次再谈。

771
00:56:19,470 --> 00:56:24,750
但如果我像以前一样点击 "跨步"，系统会提示我输入一个负整数。

772
00:56:24,750 --> 00:56:25,750
让我输入负 1

774
00:56:27,300 --> 00:56:32,470
现在请注意，没有额外的黄色亮点。

776
00:56:32,970 --> 00:56:35,160
从逻辑上讲，我目前卡在哪里？

778
00:56:37,937 --> 00:56:40,770
戴维-马兰：是的，从逻辑上讲，我一定是在那个 do, while 循环中。

779
00:56:40,770 --> 00:56:43,560
即使你不理解，好像这是唯一的解释。

780
00:56:43,560 --> 00:56:46,143
如果您一直收到提示，肯定是出现了循环。

781
00:56:46,143 --> 00:56:49,270
我的代码中只有一个循环，所以可能有问题。

782
00:56:49,270 --> 00:56:52,900
因此，我不能只在 main 中设置一个断点，然后等待它起作用。

783
00:56:52,900 --> 00:56:56,280
所以，让我 -- 让我用红色方块来阻止这一切。

784
00:56:56,280 --> 00:56:58,860
让我想想，好吧，而不是 --

785
00:56:58,860 --> 00:57:02,770
我仍然可以在主程序中设置断点，但让我重新运行调试器。

786
00:57:02,770 --> 00:57:07,930
这一次，不是跨过那行代码，而是让我走进那行代码。

787
00:57:07,930 --> 00:57:09,270
所以，看看现在会发生什么。

788
00:57:09,270 --> 00:57:14,610
与其点击这里的第二个图标，不如让我点击第三个图标，它的名字确实叫 "走进"。

789
00:57:14,610 --> 00:57:17,880
注意黄色高亮显示不会移动到第 9 行。

790
00:57:17,880 --> 00:57:25,170
它潜入第 8 行 -- 第 8 行的函数，从而把我带到第 17 行。

791
00:57:25,170 --> 00:57:28,270
这是一种进入下一个功能的方式。

792
00:57:28,270 --> 00:57:34,380
现在，在第 12 行、第 13 行或第 14 行时，它懒得暂停，因为那里还没有发生任何有趣的事情。

793
00:57:34,380 --> 00:57:37,080
看来，多汁的部分是从第 17 行开始的。

794
00:57:37,080 --> 00:57:40,980
请注意，n 是左上角的变量。

795
00:57:40,980 --> 00:57:42,270
如果我点击

796
00:57:42,270 --> 00:57:45,420
但我现在不想点击 "进入"。

797
00:57:45,420 --> 00:57:52,480
如果我点击 "进入步骤"，会出现什么问题？

800
00:57:54,755 --> 00:57:56,630
戴维-马兰：是的，这将使我们进入 "获取信息 "阶段。

801
00:57:56,630 --> 00:58:02,120
但我认为工作人员对 getInt 的说法是正确的，这不是我们今天的问题，所以我想跨过这个问题。

802
00:58:02,120 --> 00:58:10,670
现在请注意左上角，在我进入终端窗口并输入负 1 这样的内容之前，n 的值不会发生任何变化。

803
00:58:10,670 --> 00:58:14,600
现在请注意，它跳转到了第 19 行，也就是下一个有趣的行。

804
00:58:14,600 --> 00:58:17,240
左上方的 n 的确是负 1。

805
00:58:17,240 --> 00:58:22,760
现在我可以暂停一下，想一想，好吧，当 n 小于 0 的时候。

806
00:58:22,760 --> 00:58:25,280
好了，左上角的 n 是负 1。

807
00:58:25,280 --> 00:58:29,780
好吧，虽然负 1 小于 0，但显然这在数学上是正确的。

808
00:58:29,780 --> 00:58:30,930
那么会发生什么呢？

809
00:58:30,930 --> 00:58:32,130
这是一个 do while 循环。

810
00:58:32,130 --> 00:58:39,410
因此，当我再次点击 "Step Over "时，它会转到这一行，因为它位于循环内部的末尾。

811
00:58:39,410 --> 00:58:42,710
而现在，它在这里一次又一次地循环。

812
00:58:42,710 --> 00:58:44,240
好吧，让我再来一次。

813
00:58:44,240 --> 00:58:45,980
我要走过去，好吗？

814
00:58:45,980 --> 00:58:48,777
我要输入负 2，情况完全一样。

815
00:58:48,777 --> 00:58:50,360
现在是我的机会，在黄线上 --

816
00:58:50,360 --> 00:58:51,260
好吧，等一下。

817
00:58:51,260 --> 00:58:53,450
负 2 显然小于 0。

818
00:58:53,450 --> 00:58:56,080
让我再试一次。

819
00:58:56,080 --> 00:58:57,570
在此点击一次。

820
00:58:57,570 --> 00:58:59,040
好吧，让我给它50。

821
00:58:59,040 --> 00:59:08,970
现在，好了，当 50 小于 0 时，这不是真的，所以循环结束了，因为它不会在 50 小于 0 时执行。

822
00:59:08,970 --> 00:59:09,730
事实并非如此。

823
00:59:09,730 --> 00:59:15,810
所以现在看，当我再点击一次 Step Over 时，它就会完成循环，即使没有其他事情要做。

824
00:59:15,810 --> 00:59:17,610
现在即将返回 n。

825
00:59:17,610 --> 00:59:21,360
它会跳回到主界面，也就是我在第 9 行离开的地方。

826
00:59:21,360 --> 00:59:23,778
现在，它在我的终端窗口中打印出了数字 50。

827
00:59:23,778 --> 00:59:30,700
希望在这一点上，对于你刚才的问题，我的人脑已经意识到，哦，我是个白痴，就像我在那里翻了牌子一样。

828
00:59:30,700 --> 00:59:32,460
所以，我可能 - 让我停止这一点。

829
00:59:32,460 --> 00:59:34,780
我可能想做这样的事情。

830
00:59:34,780 --> 00:59:45,070
如果目标是得到一个负整数，我可能想说，比如 n 大于或等于 0 也行。

831
00:59:45,070 --> 00:59:48,630
因此，当 n 大于或等于 0 时，继续这样做。

832
00:59:48,630 --> 00:59:50,430
这就是我想表达的逻辑。

833
00:59:50,430 --> 00:59:54,900
因此，调试器可以让我不必盯着屏幕，举起一只手，向其他人询问。

834
00:59:54,900 --> 00:59:58,650
至少在这种情况下，它能让我以更健康的速度完成它。

835
00:59:58,650 --> 01:00:04,940
关于 debug50 的问题，即使它不是你在 printf 之后的第一反应，它也应该是你的新朋友。

836
01:00:07,690 --> 01:00:09,190
有关于 debug50 的问题吗？

838
01:00:09,730 --> 01:00:13,960
好吧，我们还可以教你最后一个技巧。

839
01:00:13,960 --> 01:00:22,720
也就是说，除了 printf 和调试器（不是开玩笑）之外，橡皮鸭其实也是一个值得推荐的查找代码错误的解决方案。

840
01:00:22,720 --> 01:00:26,390
对于你刚才的问题，鸭子二号并不能为你解决问题。

841
01:00:26,390 --> 01:00:33,760
不过，如果你想知道为什么这个小家伙在这里呆了这么久，那么有一种技术，在维基百科上有自己的文章，叫做橡皮鸭调试。

842
01:00:33,760 --> 01:00:42,820
这样做的目的是，如果你在宿舍里与代码中的某个错误搏斗，printf 并没有完全向你揭示源代码，调试器也帮不上什么忙、

843
01:00:42,820 --> 01:00:46,960
老实说，如果能把你遇到的问题说清楚，也许会有帮助。

844
01:00:46,960 --> 01:00:54,730
类似于去办公室，与助教或教授交谈，把你的问题一一道来，因为在与鸭子交谈的过程中，事实上

845
01:00:54,730 --> 01:01:01,180
在 n 小于 0 的情况下进行，如果 n 小于 0 -- 请稍候。

846
01:01:01,180 --> 01:01:03,820
我是个白痴，不只是因为和橡皮鸭说话。

847
01:01:03,820 --> 01:01:11,860
你意识到，希望在表达自己时，从字面上看，你可能会听到非零概率的说法，比如你的陈述中存在一些不合逻辑的地方。

848
01:01:11,860 --> 01:01:16,430
只要把事情说清楚，你就会意识到，哦，这就是我的问题所在。

849
01:01:16,430 --> 01:01:19,720
因此，坦率地说，如果你有室友，你也可以用室友来做这件事。

850
01:01:19,720 --> 01:01:28,150
但是，当室友们对你的 C 题集不感兴趣时，橡皮鸭就成了他们的首选。

851
01:01:28,150 --> 01:01:29,933
这是一项非常宝贵的技术。

852
01:01:29,933 --> 01:01:34,510
我承认，我不太喜欢和橡皮鸭一起玩，但我更喜欢和同事，人类同事一起玩。

853
01:01:34,510 --> 01:01:40,360
但是，只要经常把事情说清楚，你就会意识到，哦，我说了一些不合逻辑的话。

854
01:01:40,360 --> 01:01:41,860
现在我可以回去写代码了。

855
01:01:41,860 --> 01:01:46,240
因此，不要通过无休止地盯着屏幕几分钟、几个小时来解决问题。

856
01:01:46,240 --> 01:01:52,900
这时，如果你已经用尽了其他工具，就该休息一下，该走开了，该和鸭子谈谈了。

857
01:01:52,900 --> 01:01:59,020
顺便说一句，今天下课的时候，我们为你们准备了很多橡皮鸭。

858
01:01:59,020 --> 01:02:05,770
多年来，至少在一些人当中，他们旅行时带上鸭子并给我们寄照片已经成为一种习惯。

859
01:02:05,770 --> 01:02:15,940
例如，这里是 CS50 的橡皮鸭调试器，又名 DDB（鸭子调试器），这是一个双关语，意为 GDB（GNU 调试器）。

860
01:02:15,940 --> 01:02:18,740
调试器，这是一个实际的调试软件。

861
01:02:18,740 --> 01:02:25,270
这是 CS50 在波多黎各山上的调试器，也在海边。

862
01:02:25,270 --> 01:02:28,310
他在这里前往旧金山。

863
01:02:28,310 --> 01:02:30,640
另外，在渔人码头海狮旁边。

865
01:02:31,660 --> 01:02:38,950
在斯坦福大学，有一座威廉-盖茨计算机科学大楼，专门用于计算机科学；在三藩市的谷歌公司，也有一座威廉-盖茨计算机科学大楼。

866
01:02:38,950 --> 01:02:41,650
这就是罗马的许愿泉。

867
01:02:41,650 --> 01:02:43,810
最后是斗兽场。

868
01:02:43,810 --> 01:02:46,990
因此，我们很想知道，在未来的几年里，你的鸭子二号会去哪里旅行。

869
01:02:46,990 --> 01:02:49,120
所以，那就相当多了。

870
01:02:49,120 --> 01:02:51,850
我们为什么不在这里休息 5 分钟呢？

871
01:02:51,850 --> 01:02:52,760
还没有点心。

872
01:02:52,760 --> 01:02:54,400
欢迎起身或坐下。

873
01:02:54,400 --> 01:02:56,620
我们五分钟后回来

874
01:02:56,620 --> 01:03:00,020
好了，我们回来了。

875
01:03:00,020 --> 01:03:09,190
如果我们今天的最终目标是更好地理解字符串之类的东西，从而解决文本问题，那么我们不妨考虑一些更简单的数据类型

876
01:03:09,190 --> 01:03:17,330
首先，我们可以如何表示这些，然后看看这是否会让我们发现字符串是如何使用的，以及今天的现代软件是如何使用类似的东西的。

877
01:03:17,330 --> 01:03:27,640
因此，当我们在第零周讨论数据的表示法时，我们有不同的方法，有二进制和十进制，甚至还有一元制。

878
01:03:27,640 --> 01:03:33,980
当我们上周开始讨论同样的代码时，我们开始讨论数据类型。

879
01:03:33,980 --> 01:03:45,070
这些数据类型是告诉计算机的一种方式，比如你想要一个整数、一个字符、一个浮点数值（如实数），甚至是一个字符串，正如我们已经看到的那样。

880
01:03:45,070 --> 01:03:49,930
但事实证明，计算机的资源当然是有限的。

881
01:03:49,930 --> 01:03:53,740
您的电脑只有固定数量的内存或 RAM。

882
01:03:53,740 --> 01:03:55,910
这实际上具有非常现实的意义。

883
01:03:55,910 --> 01:03:59,630
举例来说，下面是我们迄今为止看到的一些数据类型。

884
01:03:59,630 --> 01:04:05,650
事实证明，C 语言中的每一个比特都有特定的位数分配。

885
01:04:05,650 --> 01:04:08,350
当然，这也会因系统而异。

886
01:04:08,350 --> 01:04:13,100
现在的情况并非如此，但多年来，几十年来，计算机的性能越来越好。

887
01:04:13,100 --> 01:04:16,600
最早的计算机可能使用较少的比特来处理其中一些数据类型。

888
01:04:16,600 --> 01:04:18,663
更现代化的计算机可能会使用更多比特。

889
01:04:18,663 --> 01:04:21,830
因此，你们即将看到的数字就是我们目前的基本情况。

890
01:04:21,830 --> 01:04:32,380
因此，说到这些数据类型，"真 "或 "假 "的 bool 会使用一整个字节，这有点奇怪，因为对于 bool 而言，"真 "或 "假 "都是 "真 "或 "假"、

891
01:04:32,380 --> 01:04:33,940
当然，你只需要一个位。

892
01:04:33,940 --> 01:04:41,230
但事实证明，尽管用八个比特或一个字节来表示 "真 "或 "假 "很浪费，但对计算机来说却更容易。

893
01:04:41,230 --> 01:04:42,820
因此，一个 bool 往往是一个字节。

894
01:04:42,820 --> 01:04:47,590
我们经常使用的 int 通常使用 4 个字节，即 32 位。

895
01:04:47,590 --> 01:04:54,040
如果我从零开始快速计算一下，32 位大概有 40 亿个可能的值。

896
01:04:54,040 --> 01:05:01,020
但是，如果你想表示正数和负数，这意味着你可以大致表示负 20 亿，一直到正 20 亿。

897
01:05:01,020 --> 01:05:02,770
这就是 ints 的典型范围。

898
01:05:02,770 --> 01:05:06,820
如果你觉得数字太少，那么还有一种叫多头的东西。

899
01:05:06,820 --> 01:05:15,730
而长字符使用 64 位，这就允许你拥有五亿种可能性，当然，这比 40 亿要多得多。

900
01:05:15,730 --> 01:05:17,410
因此，有时您可能会使用长号。

901
01:05:17,410 --> 01:05:18,670
但即便如此，也是有限的。

902
01:05:18,670 --> 01:05:28,330
因此，正如我们在上周末所讨论的那样，如果你对数据做出某些假设，就会发生不好的事情，因为会出现整数溢出或类似的情况，即事情缠绕在一起。

903
01:05:28,330 --> 01:05:31,538
然后是浮点数，它是一个实数，带有小数点。

904
01:05:31,538 --> 01:05:37,810
按照惯例，它是 4 字节或 32 位，简而言之，只有特定的精度。

905
01:05:37,810 --> 01:05:41,620
它并不一定决定左边或右边有多少个数字。

906
01:05:41,620 --> 01:05:45,250
不过，总的来说，你还是有的、

907
01:05:45,250 --> 01:05:47,650
仍有 40 亿种可能的排列组合。

908
01:05:47,650 --> 01:05:57,700
如果在科学、医疗和金融应用中需要更高的精度，可以使用 8 字节，也就是双倍，这样可以获得更多位数的精度。

909
01:05:57,700 --> 01:06:03,610
按照我们上周看的例子，它们最终会变得不精确，但至少能让你更进一步。

910
01:06:03,610 --> 01:06:12,640
另外，在非常非常重要的应用领域，如金融、医学、军事行动等，真的不能有四舍五入误差-----------------。

911
01:06:12,640 --> 01:06:19,317
长话短说，人类已经用 C 语言和其他语言开发出了甚至超过 8 字节的库。

912
01:06:19,317 --> 01:06:22,150
因此，这些问题是有解决办法的，但办法总是有限的。

913
01:06:22,150 --> 01:06:24,070
你必须选择一个上限。

914
01:06:24,070 --> 01:06:29,470
然后是 char，上周我在询问用户 "y "或 "n"、"是 "或 "否 "时，我们简单地看到了 char。

915
01:06:29,470 --> 01:06:34,360
然后还有一个字符串，我打算用问号来表示，因为字符串完全取决于实际情况。

917
01:06:35,380 --> 01:06:38,890
H-I，感叹号，似乎是三个字节。

918
01:06:38,890 --> 01:06:41,140
D-A-V-I-D，似乎是五个。

919
01:06:41,140 --> 01:06:45,400
因此，字符串显然是可变的，取决于你或人类输入的内容。

920
01:06:45,400 --> 01:06:48,140
我们稍后就会知道这意味着什么。

921
01:06:48,140 --> 01:06:51,580
不过，这是你的 Mac、PC 和手机里的东西。

922
01:06:51,580 --> 01:06:56,187
它可能看起来并不完全像这样，但这是现代计算机的内存模块。

923
01:06:56,187 --> 01:06:57,520
让我们继续使用它。

924
01:06:57,520 --> 01:07:01,360
实际上，这只是代表了任何计算机内存的有限性。

925
01:07:01,360 --> 01:07:06,160
让我们放大电路板上的这些黑色小芯片。

926
01:07:06,160 --> 01:07:16,750
放大，让我提议，这个矩形确实代表了一定数量的字节，就像藏在电路板上这个黑色小电路里面的，我不知道，可能是一个千兆字节、

927
01:07:16,750 --> 01:07:19,300
十亿字节，也许是 100 字节--某个字节数。

928
01:07:19,300 --> 01:07:22,700
这完全取决于电脑和内存条的价格。

929
01:07:22,700 --> 01:07:32,410
但是，如果硬件内部以某种数字方式物理实现的字节数是有限的，那么我们就有理由对这些字节进行编号。

930
01:07:32,410 --> 01:07:38,800
我们可以任意决定左上角是 1 号字节，或者真的是 0 号字节。

931
01:07:38,800 --> 01:07:46,090
旁边的是 1 号，然后是 2 号、3 号、点、点、点、20 亿或其他数字，不管这个存储器有多大。

932
01:07:46,090 --> 01:07:50,530
因此，如果您在 C 语言程序中使用一个变量，它只有一个字节。

933
01:07:50,530 --> 01:07:55,120
就像字符一样，它可能就存储在内存的左上角。

934
01:07:55,120 --> 01:07:57,760
实际上，你并不关心它的物理位置。

935
01:07:57,760 --> 01:08:04,330
但实际上，艺术家的演绎是这样的--一个字符可能会使用计算机内存中的某个单字节。

936
01:08:04,330 --> 01:08:07,450
如果使用 int（4 个字节），则可以得到

937
01:08:07,450 --> 01:08:10,840
4 字节，连续 - 即从左到右，从上到下。

938
01:08:10,840 --> 01:08:16,149
但所有 32 位都会紧挨着，这样计算机就知道这些位确实都属于同一个 int。

939
01:08:16,149 --> 01:08:21,140
如果您需要长数据或双倍数据，在这种情况下您可能需要使用整整 8 个字节。

940
01:08:21,140 --> 01:08:29,845
你只需不断地使用这个内存，就像在 Photoshop 或电子表格中的画布一样，你可以随意移动像素或数据、

941
01:08:29,845 --> 01:08:36,702
这就是计算机内存的真正含义，它是以字节或 8 位为单位存储信息的画布。

942
01:08:36,702 --> 01:08:39,160
现在，我们不需要继续看这些电路板了。

943
01:08:39,160 --> 01:08:41,287
我们可以把它抽象出来，我们经常这样做。

944
01:08:41,287 --> 01:08:45,740
让我们继续放大这个网格，考虑一些非常具体的变量。

945
01:08:45,740 --> 01:08:51,580
因此，让我放大，现在我看到屏幕上的方框更少但更大，每个方框同样代表一个字节。

946
01:08:51,580 --> 01:08:55,130
现在，让我提议我们来玩一些实际的代码。

947
01:08:55,130 --> 01:09:01,060
因此，在 C 语言中，尽管没有完整的程序，却有三个 ints：score1、score2、score3。

948
01:09:01,060 --> 01:09:09,040
巧合的是，我给自己打出了 72 分和 73 分左右的两个分数，然后又打出了 33 分这个相当低的分数。

949
01:09:09,040 --> 01:09:12,048
当然，在上周或两周前，这个数字还会很高。

950
01:09:12,048 --> 01:09:13,840
但现在我们面对的是实际的整数。

951
01:09:13,840 --> 01:09:17,750
因此，这是我在测验或考试中的三个一般分数。

952
01:09:17,750 --> 01:09:19,250
所以，让我来看看 VS 代码。

953
01:09:19,250 --> 01:09:22,210
让我们制作一个名为 scores.c 的程序。

954
01:09:22,210 --> 01:09:24,399
因此，我要编写代码 scores.c。

955
01:09:24,399 --> 01:09:26,149
这将为我提供新文件。

956
01:09:26,149 --> 01:09:28,420
让我来实现这样的功能。

957
01:09:28,420 --> 01:09:37,689
包括 stdio.h，int main(void)，然后在这里，让我做 int score1 将是 72。

958
01:09:37,689 --> 01:09:40,029
Int score2 将为 73。

959
01:09:40,029 --> 01:09:43,149
int score3 将是 33。

960
01:09:43,149 --> 01:09:48,042
然后让我做一些事情，比如写一个程序，把我的三次考试成绩平均起来，诸如此类。

961
01:09:48,042 --> 01:09:56,470
所以，让我来打印一下，引号后加引号，我的平均值是-- 我要继续打印，比如说，%i, /n。

962
01:09:56,470 --> 01:09:58,290
现在，让我输入结果。

963
01:09:58,290 --> 01:10:00,040
这已经是小学数学了。

964
01:10:00,040 --> 01:10:02,210
如何计算三个值的平均值？

965
01:10:02,210 --> 01:10:14,457
嗯，就像在纸上一样，我可以用 score1 加上 score2 再加上括号里的 score3，因为运算顺序是除以 3，因为一共有三个分数。

966
01:10:14,457 --> 01:10:16,040
好吧，我想这是正确的。

967
01:10:16,040 --> 01:10:23,180
事实上，您可以在 C 语言代码中使用括号和加号等运算符。

968
01:10:23,180 --> 01:10:24,327
无语法错误。

969
01:10:24,327 --> 01:10:25,910
这样很好，没有什么遗漏。

970
01:10:25,910 --> 01:10:28,850
现在让我输入 ./scores 查看我的平均测试成绩。

971
01:10:28,850 --> 01:10:32,270
好吧，虽然不是很好，但我想我还是通过了。

972
01:10:32,270 --> 01:10:36,050
事实上，我在这里的平均成绩是 59 分。

973
01:10:36,050 --> 01:10:38,360
是否正好是 59？

974
01:10:38,360 --> 01:10:39,140
让我想想

975
01:10:39,140 --> 01:10:44,870
实际上，与其使用 int 值，不如使用浮点值。

976
01:10:44,870 --> 01:10:46,250
让我来做这件事。

977
01:10:46,250 --> 01:10:48,710
因此，让我重新编译代码，进行评分。

978
01:10:48,710 --> 01:10:50,600
好吧，我有个问题。

979
01:10:50,600 --> 01:10:52,340
让我放大终端窗口。

980
01:10:52,340 --> 01:10:54,710
我们以前不一定见过这种情况。

981
01:10:54,710 --> 01:10:56,510
但第 9 行出现错误。

982
01:10:56,510 --> 01:11:02,180
格式指定的类型是 double，精度很高，但参数的类型是 int。

983
01:11:02,180 --> 01:11:03,300
这意味着什么？

984
01:11:03,300 --> 01:11:09,060
嗯，它用这些绿色的斜线告诉我，%f 和这里的东西之间有问题。

985
01:11:09,060 --> 01:11:13,020
那么，在左边，我的意思是浮点数，或者双倍数。

986
01:11:13,020 --> 01:11:16,835
右边的 score1、score2、score3 是什么数据类型？

987
01:11:16,835 --> 01:11:17,960
好吧，它们是 ints。

988
01:11:17,960 --> 01:11:19,583
所以，铛铛不喜欢这样。

989
01:11:19,583 --> 01:11:24,170
编译器只是不喜欢我在右边使用 ints，但我想在左边使用浮点数。

990
01:11:24,170 --> 01:11:26,670
因此，会有不同的解决方法。

991
01:11:26,670 --> 01:11:32,450
一种方法是像我最初做的那样忽略问题，回到 %i。

992
01:11:32,450 --> 01:11:38,330
另外，对于十进制数字，%d 通常可以替代 %i。

993
01:11:38,330 --> 01:11:42,358
但我们使用 %i 是因为它听起来像 int，所以 %i 在这里也可以使用。

994
01:11:42,358 --> 01:11:44,150
但我不想回避问题。

995
01:11:44,150 --> 01:11:46,500
我想实际显示一个浮点数值。

996
01:11:46,500 --> 01:11:47,730
那么，我该如何解决这个问题呢？

997
01:11:47,730 --> 01:11:50,272
事实证明，我可以用几种不同的方法来解决这个问题。

998
01:11:50,272 --> 01:11:59,330
最简单的方法是确保右边至少有一个数字是浮点数，比如 3.0 而不是 3。

999
01:11:59,330 --> 01:12:01,700
现在我觉得铛铛会更开心。

1000
01:12:01,700 --> 01:12:03,320
让我来打分

1002
01:12:04,400 --> 01:12:05,330
事实上，这也没问题。

1004
01:12:05,930 --> 01:12:14,330
只要右侧有至少一种更精确的数据类型，它就会将所有数据都视为浮点数，这样数学运算就能顺利进行。

1005
01:12:14,330 --> 01:12:17,720
所以./scores，回车，现在，我们走了，对吗？

1006
01:12:17,720 --> 01:12:20,390
我们中的一些人可能真的想要那 1/3 分。

1007
01:12:20,390 --> 01:12:21,980
我们的平均数不是 59。

1008
01:12:21,980 --> 01:12:25,010
是 59 1/3，就像这里的情况一样。

1009
01:12:25,010 --> 01:12:26,750
好了，我们已经解决了这个问题。

1010
01:12:26,750 --> 01:12:30,890
不过，这里还有一个技巧需要展示。

1011
01:12:30,890 --> 01:12:38,760
如果你不想把它改成 3.0，因为那有点奇怪，因为从字面上看有三个分数，这不像是需要有一个小数点、

1012
01:12:38,760 --> 01:12:46,230
您也可以明确地将 3 转换为浮点数，方法是在括号中说明 float。

1013
01:12:46,230 --> 01:12:48,050
这就是所谓的类型化。

1014
01:12:48,050 --> 01:12:52,560
如果可能的话，这将把它后面的内容转换为该数据类型。

1015
01:12:52,560 --> 01:12:59,960
因此，如果我再次这样做，进行评分，现在就不会出错了。./scores，我得到的结果其实是一样的。这里有点四舍五入的问题、

1016
01:12:59,960 --> 01:13:03,650
但我们知道，四舍五入与上周的不精确有关。

1017
01:13:03,650 --> 01:13:06,980
现在，就让我为我的 59.3 分感到高兴吧。

1018
01:13:06,980 --> 01:13:08,360
我现在就要这个。

1019
01:13:08,360 --> 01:13:14,660
但现在对我来说，这已经是一个足够好的正确答案了。

1020
01:13:14,660 --> 01:13:18,650
但我怎么 -- 现在想想 电脑内存里发生了什么？

1021
01:13:18,650 --> 01:13:19,310
好吧，让我们考虑一下。

1022
01:13:19,310 --> 01:13:20,643
这也是记忆的网格。

1023
01:13:20,643 --> 01:13:22,490
每个方框代表一个字节。

1024
01:13:22,490 --> 01:13:25,790
我记忆中的 score1、score2 和 score3 在哪里？

1025
01:13:25,790 --> 01:13:28,790
好吧，让我来提议，score1 在左上角。

1026
01:13:28,790 --> 01:13:32,060
但它占用了 4 个方框的 4 个字节。

1027
01:13:32,060 --> 01:13:38,180
虽然 Score2 在内存中可能会紧靠着它，但情况并不总是这样，我选择了一些简单的例子。

1028
01:13:38,180 --> 01:13:40,910
73 紧挨着它，也占用 4 个字节。

1029
01:13:40,910 --> 01:13:45,320
最后，33 在 score3 中，就在下面。

1030
01:13:45,320 --> 01:13:54,110
现在，如果我们真正观察一下计算机的内存，用显微镜之类的东西看一下，实际上有 32 位、32 位、32 位

1031
01:13:54,110 --> 01:13:59,308
这四组字节中的每一组都代表这些值。

1032
01:13:59,308 --> 01:14:03,308
但同样，就今天而言，我们并不需要反复思考二进制问题。

1033
01:14:03,308 --> 01:14:05,940
实际上，这些十进制数字就存储在这里。

1034
01:14:05,940 --> 01:14:08,240
但我现在认为，这不是最好的设计。

1035
01:14:08,240 --> 01:14:16,970
即使你在 CS50 之前从未做过编程，你在屏幕上看到的内容，作为一个摘录，从什么意义上说，这可能是糟糕的设计，即使它是

1036
01:14:16,970 --> 01:14:19,960
存储三个测试分数的正确方法？

1037
01:14:19,960 --> 01:14:20,960
这里有什么不好？

1039
01:14:21,882 --> 01:14:26,220
分数越多你的分数越多，你[听不清]的分数就越多。

1040
01:14:26,220 --> 01:14:31,740
戴维-马兰：是的，总是像你做的那样--推断出 4 分、5 分、50 分。

1041
01:14:31,740 --> 01:14:36,300
这不可能是精心设计的，因为现在你将有 4 行代码、5 行代码、

1042
01:14:36,300 --> 01:14:42,430
除了我们在变量末尾更新的这个任意数字，50 行代码几乎完全相同。

1043
01:14:42,430 --> 01:14:48,690
因此，的确可能会有更好的方法，尽管至少在 C 语言中，我们还没有看到这种技术。

1044
01:14:48,690 --> 01:14:52,440
但从今天起，解决方案将是一种叫做数组的东西。

1045
01:14:52,440 --> 01:15:03,960
数组是将数据背靠背存储在计算机内存中的一种方式，这样可以方便地访问每个成员。

1046
01:15:03,960 --> 01:15:08,530
换一种说法，使用数组时，您可以这样做。

1047
01:15:08,530 --> 01:15:20,700
与其说 int score1、int score2、int score3，给每个变量赋值，你可以先告诉计算机，请给我一个叫 scores 的变量，虽然它是复数，但你可以随便叫它什么。

1048
01:15:20,700 --> 01:15:24,090
的大小为 3，其中每个都是整数。

1049
01:15:24,090 --> 01:15:30,930
也就是说，在 C 语言中可以这样声明一个数组，它有足够的空间来存储三个整数。

1050
01:15:30,930 --> 01:15:38,880
换句话说，这就是用技术手段告诉计算机，请总共给我 12 个字节--------------。

1051
01:15:38,880 --> 01:15:42,660
一个 int 3 乘以 4，总共是 12 个字节。

1052
01:15:42,660 --> 01:15:47,350
计算机会保证它们在计算机内存中背靠背。

1053
01:15:47,350 --> 01:15:49,360
一会儿就会派上用场。

1054
01:15:49,360 --> 01:15:51,820
所以，让我继续用它做些有用的事情吧。

1055
01:15:51,820 --> 01:15:53,640
让我来存储三个实际分数。

1056
01:15:53,640 --> 01:15:58,500
现在，我可以在这个数组中存储同样的数字分数。

1057
01:15:58,500 --> 01:16:03,040
语法略有不同，但有一个变量叫 scores。

1058
01:16:03,040 --> 01:16:14,280
但是，如果你想从今天开始转到它的第一个位置，你可以使用方括号，先转到位置 0，因为 C 中的东西都是 0 索引的，可以这么说，你从 0 开始计数。

1059
01:16:14,280 --> 01:16:16,410
第一个 int 位于 [0]。

1060
01:16:16,410 --> 01:16:18,030
第二个 int 位于 [1]。

1061
01:16:18,030 --> 01:16:19,530
第三个 int 位于 [2]。

1062
01:16:19,530 --> 01:16:20,730
所以不是一、二、三。

1063
01:16:20,730 --> 01:16:22,090
简直就是 0、1、2。

1064
01:16:22,090 --> 01:16:24,090
这不是你能控制的。

1065
01:16:24,090 --> 01:16:26,250
必须从 0 开始。

1066
01:16:26,250 --> 01:16:33,510
因此，现在这些行创建了一个大小为 3 的数组，然后向数组中插入 1、2、3 个值。

1067
01:16:33,510 --> 01:16:37,770
但这样做的好处是，你只需记住一个变量名。

1068
01:16:37,770 --> 01:16:39,240
这就是所谓的分数。

1069
01:16:39,240 --> 01:16:43,380
是的，您需要进入数组获取单个值。

1070
01:16:43,380 --> 01:16:46,618
您需要使用方括号将索引输入其中。

1071
01:16:46,618 --> 01:16:53,050
但至少你不用为每一个值都声明一个单独的变量，而采用这种黑客式的方法。

1072
01:16:53,050 --> 01:16:56,070
所以，让我回到 scores.c 这里。

1073
01:16:56,070 --> 01:16:57,580
请允许我提议这样做。

1074
01:16:57,580 --> 01:17:00,580
让我用同样的想法来做下面的事情。

1075
01:17:00,580 --> 01:17:02,580
让我把这三个独立的整数去掉。

1076
01:17:02,580 --> 01:17:06,210
让我给自己一个大小为 3 的 int scores 数组。

1077
01:17:06,210 --> 01:17:10,470
这样，score[0] 就会像以前一样，变成 72。

1078
01:17:10,470 --> 01:17:14,070
分数[1] 将为 73。

1079
01:17:14,070 --> 01:17:16,830
分数[2] 将为 33。

1080
01:17:16,830 --> 01:17:18,780
让我把那里的小点去掉。

1081
01:17:18,780 --> 01:17:23,490
好了，现在，如果我再运行一次，让分数 --

1083
01:17:24,642 --> 01:17:29,060
我做错了什么？

1084
01:17:29,060 --> 01:17:31,680
我想我有点太自以为是了。

1085
01:17:31,680 --> 01:17:36,100
让我增加终端窗口。

1086
01:17:36,100 --> 01:17:38,830
我们先来看看第 10 行。

1087
01:17:38,830 --> 01:17:42,310
错误，使用了未声明的标识符，score1。

1088
01:17:42,310 --> 01:17:44,170
我做了什么蠢事？

1090
01:17:45,430 --> 01:17:47,440
你没有把它声明为变量You didn't declare it a variable.

1091
01:17:47,440 --> 01:17:49,420
戴维-马兰：对，所以我没有宣布得分 1。

1092
01:17:49,420 --> 01:17:50,530
我有旧代码。

1093
01:17:50,530 --> 01:17:53,798
所以，老实说，我只是有点超前了，甚至不是故意的。

1094
01:17:53,798 --> 01:17:56,090
让我再缩小一下终端窗口。

1095
01:17:56,090 --> 01:17:57,740
我需要在这里结束我的想法。

1096
01:17:57,740 --> 01:17:58,960
所以，请允许我清理一下我的终端。

1097
01:17:58,960 --> 01:18:05,610
现在让我将其改为 scores[0] 加 scores[1] 加 scores[2]。

1098
01:18:05,610 --> 01:18:10,040
这样就比较啰嗦了，因为我有这些方括号，可以这么说。

1099
01:18:10,040 --> 01:18:12,220
但我认为现在我的代码是一致的。

1100
01:18:12,220 --> 01:18:13,870
所以，现在让我来记分。

1101
01:18:13,870 --> 01:18:14,950
现在可以编译了。

1102
01:18:14,950 --> 01:18:19,870
./scores 给我的确实是相同数值的大致平均值。

1103
01:18:19,870 --> 01:18:24,280
好吧，让我继续说下去，也许能让这个问题更有说服力一些。

1104
01:18:24,280 --> 01:18:31,610
为了检查 72、73、33 等三个考试成绩的平均值而编写一个专门的程序，这有点傻。

1105
01:18:31,610 --> 01:18:37,250
我为什么不把程序变成动态的，然后向人类询问这些分数呢？

1106
01:18:37,250 --> 01:18:39,140
所以，让我这样做吧。

1107
01:18:39,140 --> 01:18:43,480
不如把 72 去掉，改成 getInt。

1108
01:18:43,480 --> 01:18:46,300
我会提示用户打分。

1109
01:18:46,300 --> 01:18:52,510
让我摆脱 73 分的束缚，让它成为 getInt 分数，引号后加引号。

1110
01:18:52,510 --> 01:19:03,680
最后，去掉 33，取而代之的是 getInt、quote unquote、score。getInt 目前是 CS50 的东西，所以我需要一如既往地包含 cs50.h。

1111
01:19:03,680 --> 01:19:08,680
但我认为现在的程序更好，因为现在我只需编译一次，甚至还可以与朋友分享。

1112
01:19:08,680 --> 01:19:12,490
而现在，我们中的任何人都可以在某个班级的测试中取得三个分数的平均值。

1113
01:19:12,490 --> 01:19:16,910
他们不需要知道代码或重写代码就能输入分数。

1114
01:19:16,910 --> 01:19:19,150
所以，让分数发挥作用。

1115
01:19:19,150 --> 01:19:26,320
./scores，现在我可以输入任何我想输入的内容--也许是 72、73 或 33，但得到的答案还是一样的。

1116
01:19:26,320 --> 01:19:33,520
或者我这学期的成绩比较好，100、100，也许是 99，现在我们得到的分数还是很高的。

1117
01:19:33,520 --> 01:19:34,600
但现在它是动态的。

1118
01:19:34,600 --> 01:19:36,080
现在你不需要源代码了。

1119
01:19:36,080 --> 01:19:37,747
您无需重新编译程序。

1120
01:19:37,747 --> 01:19:39,670
就这样一次又一次地成功。

1121
01:19:39,670 --> 01:19:41,090
但这个也是。

1122
01:19:41,090 --> 01:19:45,910
如果我想从用户那里得到三个分数，那么我建议这段代码是正确的。

1123
01:19:45,910 --> 01:19:53,170
但现在突出显示的 6 到 9 行，你认为它们设计得好吗？

1125
01:19:53,680 --> 01:19:54,898
观众：你能循环播放吗？

1126
01:19:54,898 --> 01:19:55,940
是的，对吗？

1127
01:19:55,940 --> 01:19:58,220
我们可以使用一个循环，就是这里的破坏者。

1129
01:19:58,820 --> 01:20:01,590
我的意思是，我的上帝，这就像相同的代码一而再，再而三。

1130
01:20:01,590 --> 01:20:03,465
唯一变化的是数字。

1131
01:20:03,465 --> 01:20:11,810
而且这还应该有一些代码的味道，因为如果我反复输入同样的内容，这显然是一个更好设计的机会。

1132
01:20:11,810 --> 01:20:13,650
那就让我来吧。

1133
01:20:13,650 --> 01:20:18,590
让我继续创建大小为 3 的数组。

1134
01:20:18,590 --> 01:20:26,610
不过，让我使用我们的老朋友 for 循环，for int i 等于 0，i 小于 3，i++。

1135
01:20:26,610 --> 01:20:32,920
然后，在这里，让我做分数括号 - 我们还没有看到过这一点，但任何直觉？

1136
01:20:32,920 --> 01:20:34,220
分数

1137
01:20:34,220 --> 01:20:34,720
听众： i.

1138
01:20:34,720 --> 01:20:40,720
DAVID MALAN：i，因为这将使用任何 i，无论是 0、1 还是 2。

1139
01:20:40,720 --> 01:20:47,000
然后，我就可以得到一个 int，询问用户得分，而不必一再重复。

1140
01:20:47,000 --> 01:20:50,560
所以，如果我没打错字，打出分数，希望一切顺利。

1141
01:20:50,560 --> 01:20:54,665
./分数，72、73、33，我们又开始工作了。

1142
01:20:54,665 --> 01:21:04,940
但现在的代码可以说设计得更好了，因为现在我没有硬编码分数，也没有复制和粘贴任何代码。

1143
01:21:04,940 --> 01:21:10,510
那么，如果我们现在考虑一下电脑内存中的情况，就数值而言是差不多的。

1144
01:21:10,510 --> 01:21:17,210
但变量不是字面上的 score1、score2、score3，而是只有一个变量。

1145
01:21:17,210 --> 01:21:19,030
这是一个名为 scores 的数组。

1146
01:21:19,030 --> 01:21:28,810
但您可以通过使用 scores[0] 获得第一个位置，使用 scores[1] 获得第二个位置，使用 scores[2] 获得第三个位置，从而索引到这三个位置。

1147
01:21:28,810 --> 01:21:29,990
但这是关键。

1148
01:21:29,990 --> 01:21:33,040
内存是连续的。

1149
01:21:33,040 --> 01:21:35,380
屏幕只有这么大，所以它是环绕的。

1150
01:21:35,380 --> 01:21:40,270
但从物理上和数字上看，内存是连续的，从上到下，从左到右。

1151
01:21:40,270 --> 01:21:41,530
这很重要，为什么？

1152
01:21:41,530 --> 01:21:48,790
因为括号中分别表示 0、1、2，所以每一个整数与下一个整数之间只差一个整数。

1153
01:21:48,790 --> 01:21:51,220
它不可能突然就随机出现在这里。

1154
01:21:51,220 --> 01:21:54,070
必须背靠背。

1155
01:21:54,070 --> 01:22:00,710
好了，有了这个范例，我们还能做些什么呢？

1156
01:22:00,710 --> 01:22:06,850
事实证明，值得了解的是，在代码中甚至可以将数组作为参数传递。

1157
01:22:06,850 --> 01:22:11,320
让我快速地把这个程序调出来，以便你们在很久之前就能看到。

1158
01:22:11,320 --> 01:22:13,190
不过，还是让我来吧。

1159
01:22:13,190 --> 01:22:18,130
我建议创建一个函数，帮我完成这种平均处理。

1160
01:22:18,130 --> 01:22:22,510
因此，我要创建一个名为 average 的函数，返回一个浮点数。

1161
01:22:22,510 --> 01:22:28,640
而这东西的论据 -- 让我想想，应该是数组。

1162
01:22:28,640 --> 01:22:33,050
事实证明，如果你想接收一个数字数组，你可以随意称呼它。

1163
01:22:33,050 --> 01:22:39,790
这样就可以告诉 C 语言，函数使用的不是整数，而是整数数组。

1164
01:22:39,790 --> 01:22:41,290
你也不必把它叫做数组。

1165
01:22:41,290 --> 01:22:42,790
我这样做只是为了讨论。

1166
01:22:42,790 --> 01:22:43,660
它可以被称为 x。

1167
01:22:43,660 --> 01:22:44,490
可以是数字。

1168
01:22:44,490 --> 01:22:45,490
它可以是任何其他东西。

1169
01:22:45,490 --> 01:22:49,060
我只是在调用一个数组，以便更明确地知道它是什么。

1170
01:22:49,060 --> 01:22:51,730
现在，我该如何修改下面的代码？

1171
01:22:51,730 --> 01:22:55,130
我想我现在要做的就是这样。

1172
01:22:55,130 --> 01:22:59,110
我要去掉这里的代码，这里是我手动计算平均值的地方。

1173
01:22:59,110 --> 01:23:05,000
让我在这里通过传入整个分数数组来调用平均值函数。

1174
01:23:05,000 --> 01:23:08,890
因此，这只是一个抽象的例子，比如现在我有一个名为平均值的函数。

1175
01:23:08,890 --> 01:23:09,670
我不在乎

1176
01:23:09,670 --> 01:23:12,490
一旦实施，我就不需要记住它是如何工作的。

1177
01:23:12,490 --> 01:23:15,010
它只是稍微收紧了我的主代码。

1178
01:23:15,010 --> 01:23:17,030
不过，我还得落实这一点。

1179
01:23:17,030 --> 01:23:27,010
所以，在我的文件后面--让我再重复一遍，在 C 语言中，只有一次是可以反复重复的，那就是再次键入平均值，然后用 int 数组打开括号--

1180
01:23:27,010 --> 01:23:28,580
但现在不是分号。

1181
01:23:28,580 --> 01:23:30,250
现在，我必须实施这件事。

1182
01:23:30,250 --> 01:23:37,630
我可以用很多不同的方法来实现这个目标 但我事先并不知道

1183
01:23:37,630 --> 01:23:39,040
我不能就这么做

1184
01:23:39,040 --> 01:23:52,130
我不能只做 array[0] 加上 array[1] 再加上 array[2]，除非这个程序只能在三个数字上运行。

1185
01:23:52,130 --> 01:23:55,460
所以，让我来做这件事吧。

1186
01:23:55,460 --> 01:23:58,570
让我首先提出，这里的设计有问题。

1187
01:23:58,570 --> 01:24:01,930
在我的主函数中，什么值重复了两次？

1188
01:24:05,050 --> 01:24:07,550
在突出显示的句子中，有哪些句子让你印象深刻？

1189
01:24:07,550 --> 01:24:09,020
听众：阵列的长度？

1190
01:24:09,020 --> 01:24:11,520
戴维-马兰：是的，阵列的长度只有三个。

1191
01:24:11,520 --> 01:24:18,440
现在看来，我在第 8 行和第 9 行键入数字 3 并不是什么大问题，但这种类似快捷键的做法最终会给你带来麻烦。

1193
01:24:18,860 --> 01:24:26,270
因为最终，你或其他人会进去把数组变大或变小，而你不会意识到神奇的是，同一个数字被放在了两个地方。

1194
01:24:26,270 --> 01:24:29,270
事实上，这就是程序员通常所说的神奇数字。

1195
01:24:29,270 --> 01:24:31,940
神奇数字是一种神奇出现的数字。

1196
01:24:31,940 --> 01:24:36,688
如果你在这里改了，就在这里改，这是你的荣誉制度。

1197
01:24:36,688 --> 01:24:43,190
如果程序员有责任记住他们硬编码的地方，也就是明确写出了三处，那就不会有好结果。

1198
01:24:43,190 --> 01:24:46,250
所以，每次重复使用这样的值时，你知道吗？

1199
01:24:46,250 --> 01:24:56,990
我们也许应该像上周那样，声明一个变量，也许是在程序的最顶端，这样就能很明显地知道它是什么，叫做 n，然后设置它等于 3。

1200
01:24:56,990 --> 01:25:02,390
更好的是，我上周做了什么来确保我不会搞砸并意外更改该值？

1201
01:25:02,390 --> 01:25:03,440
是的，一直如此。

1202
01:25:03,440 --> 01:25:05,810
关键词是 const，简称 const。

1203
01:25:05,810 --> 01:25:11,870
现在我有了一个全局变量，全局变量的意思是我可以在任何地方访问它，它的名字叫 n。

1204
01:25:11,870 --> 01:25:12,680
这是一个 int.

1205
01:25:12,680 --> 01:25:14,450
而且永远都是 3。

1206
01:25:14,450 --> 01:25:23,870
现在，我只需将 3 改为 n，就能稍稍改进我的主函数，因此，如果我，如果有同事意识到，哦，等一下，今年有四次测试。

1207
01:25:23,870 --> 01:25:31,190
将 n 改为 4，重新编译代码后，除了我的平均函数外，其他地方都能正常工作。

1208
01:25:31,190 --> 01:25:33,830
为了统一起见，我把它改回 3。

1209
01:25:33,830 --> 01:25:43,610
现在这样做是行不通的，举例来说，如果只是求和，然后返回除以 3 的结果。

1210
01:25:43,610 --> 01:25:51,130
为什么按照我的定义，现在就不行了呢？

1213
01:25:58,030 --> 01:26:00,980
戴维-马兰：好吧，我可能会返回一个整数值，当

1214
01:26:00,980 --> 01:26:02,870
我打算就此返回一个浮点数。

1215
01:26:02,870 --> 01:26:11,010
但我觉得我没问题，因为我使用了那个小技巧，确保算术表达式中至少有一个数字实际上是浮点数值。

1216
01:26:11,010 --> 01:26:15,650
只需添加 0 点，就能确保所有内容都被视为浮点数。

1217
01:26:15,650 --> 01:26:17,864
所以，我觉得这没问题。

1219
01:26:19,034 --> 01:26:20,701
对不起，声音再大一点。

1220
01:26:20,701 --> 01:26:24,385
这看起来就像你[听不清]。

1221
01:26:24,385 --> 01:26:25,260
大卫-马兰：没错。

1222
01:26:25,260 --> 01:26:33,510
所以左手在这里并没有和右手对话，因为我目前实现的平均值仍然假设只有三次测试或其他。

1223
01:26:33,510 --> 01:26:39,480
但是，等一下，我刚刚费了好大劲才把它修改成 n。

1224
01:26:39,480 --> 01:26:46,690
如果我把它改为 4，也许我就不会对我的平均分感到满意了，因为现在我将完全忽略我的一个考试成绩。

1225
01:26:46,690 --> 01:26:48,450
所以，让我把它改回 3。

1226
01:26:48,450 --> 01:27:00,920
不幸的是，如果现在是一个变量 n，因此，我的分数数量是可变的，那么我如何求出可变数量的平均值呢？

1227
01:27:00,920 --> 01:27:02,630
我的意思是，我的构件是什么？

1230
01:27:10,100 --> 01:27:10,850
是的

1231
01:27:10,850 --> 01:27:14,880
我为什么不用一个循环来遍历数组，边遍历边累加？

1232
01:27:14,880 --> 01:27:19,730
我的意思是，就像小学一样，当你用计算器或纸和铅笔计算平均值时，你只是不断地把数字相加、

1233
01:27:19,730 --> 01:27:22,380
最后再除以总数。

1234
01:27:22,380 --> 01:27:23,520
那么，我该怎么做呢？

1235
01:27:23,520 --> 01:27:30,515
好吧，让我改变一下平均值的实现，首先声明一个名为 sum 的变量，或者其他什么变量，设置它等于 0。

1236
01:27:30,515 --> 01:27:36,590
因此，这就像我在纸上准备数数，或者我的计算器，当然，当你打开它时，通常默认为零。

1237
01:27:36,590 --> 01:27:46,730
现在，让我来做 for，int i 等于 0，i 小于 a -- 不，我没做那个。i 小于 n，i++。

1238
01:27:46,730 --> 01:27:55,910
现在，让我把数组位置 i 中的内容加到当前总和中。

1239
01:27:55,910 --> 01:28:04,560
然后在这里，我想我可以返回一些除以 3.0 -- 不是 3.0，是 n，也许在这里。

1240
01:28:04,560 --> 01:28:08,492
实际上，我想我要去 -- 让我们确保它是一个浮动。

1241
01:28:08,492 --> 01:28:15,540
让我们使用类型转换技巧，以确保我不会不小心亏待了某人，而把小数点后的所有内容都扔掉。

1242
01:28:15,540 --> 01:28:17,300
所以事情很快就升级了，对吗？

1243
01:28:17,300 --> 01:28:18,990
平均值变得更重要了。

1244
01:28:18,990 --> 01:28:22,130
这不仅仅是一行代码，现在它是动态的。

1245
01:28:22,130 --> 01:28:25,070
我将一个名为 sum 的变量初始化为 0。

1246
01:28:25,070 --> 01:28:36,740
在这个循环中，我会不断地将数组[i]中的任何内容加到 sum 中，初始值为 0，具体来说就是数组[0]、数组[1]、数组[2]。

1247
01:28:36,740 --> 01:28:40,970
这样就得出了我返回的总金额除以物品总数。

1248
01:28:40,970 --> 01:28:42,560
现在，我可以稍微收紧一点。

1249
01:28:42,560 --> 01:28:45,650
请注意，这是一种语法糖，用于添加内容。

1250
01:28:45,650 --> 01:28:48,620
我不能使用加号加号，因为这样只能增加一个。

1251
01:28:48,620 --> 01:28:52,630
但我可以在这里使用 "加等号"。

1252
01:28:52,630 --> 01:28:54,880
对此处的实施有疑问？

1253
01:28:54,880 --> 01:29:06,450
真正唯一的收获--或者说最重要的收获是，这是告诉函数它需要整个数组，而不是 int 或类似的单个变量的语法。

1254
01:29:06,450 --> 01:29:11,530
从字面上看，你使用了方括号，但没有在方括号内指定长度。

1256
01:29:12,748 --> 01:29:16,410
听众：顶部有什么变量？

1257
01:29:16,410 --> 01:29:18,410
大卫-马兰：顶部的变量呢？

1259
01:29:22,205 --> 01:29:23,330
大卫-马兰：问得好。

1260
01:29:23,330 --> 01:29:25,220
我在顶部将其定义为什么？

1261
01:29:25,220 --> 01:29:33,840
如果要在数组方括号内使用 N 变量，它必须是整数。

1262
01:29:33,840 --> 01:29:38,360
请注意，第 10 行不再是 3，而是 N。

1263
01:29:38,360 --> 01:29:43,970
因此，无论 N 是 3、4 还是其他什么，我都能在数组中得到多少个整数。

1264
01:29:43,970 --> 01:29:48,320
根据数组的定义，它必须是一个放在方括号中的整数。

1265
01:29:48,320 --> 01:29:50,000
这里有一个常见的困惑。

1266
01:29:50,000 --> 01:29:56,210
创建数组时，也就是声明数组时，要像这样使用方括号，在方括号中输入想要的元素总数。

1267
01:29:56,210 --> 01:30:04,610
当你随后使用数组时，就像我在这里做的一样，你不会再提到 int--就像你不会在变量存在后反复提到 int 一样。

1268
01:30:04,610 --> 01:30:11,990
仍然使用方括号，但不使用 N，而是使用 0 或 1 或 2，或者这里通用的 i。

1269
01:30:11,990 --> 01:30:17,060
因此，在设计 C 语言时，他们有时会使用相同的语法来表达两种不同的想法或语境。

1271
01:30:17,984 --> 01:30:22,645
你必须包括第6行吗？是否必须包括第 6 行？

1272
01:30:22,645 --> 01:30:23,770
大卫-马兰：问得好。

1273
01:30:23,770 --> 01:30:25,900
是否必须包括第 6 行？

1274
01:30:25,900 --> 01:30:29,290
简而言之，是的，因为我们上周遇到了这个问题。

1275
01:30:29,290 --> 01:30:32,750
C 或 clang 会从上到下、从左到右读取代码。

1276
01:30:32,750 --> 01:30:43,610
因此，如果编译器看到第 16 行提到了 average 这个函数，但你没有告诉编译器 average 存在，屏幕上就会出现错误。

1277
01:30:43,610 --> 01:30:51,260
因此，传统的方法是复制粘贴函数的第一行代码，即所谓的原型或声明。

1279
01:30:51,760 --> 01:30:55,662
听众：如果不知道数组的大小，有图书馆吗？

1280
01:30:55,662 --> 01:30:58,120
大卫-马兰：真是个好问题，也是个完美的切入点。

1281
01:30:58,120 --> 01:31:01,078
如果不知道数组的大小，有没有可以使用的库呢？

1283
01:31:01,720 --> 01:31:11,020
因此，如果你们用 Java、Python 或其他语言编程，实际上可以直接问数组：它有多大？

1284
01:31:11,020 --> 01:31:13,778
在 C 语言中，你和我，程序员，必须记住它。

1285
01:31:13,778 --> 01:31:17,445
简而言之，没有任何功能可以自动帮我们完成这项工作。

1286
01:31:17,445 --> 01:31:25,160
事实上，让我提出一个更微妙的主张：如果全局变量真的是用于配置选项，那么使用这样的全局变量是没有问题的。

1288
01:31:25,660 --> 01:31:32,440
把它们放在文件的最上面很方便，因为每个人、你、你的同事、你的助教都会在代码的最上面看到它们。

1289
01:31:32,440 --> 01:31:36,130
但您真的不应该在代码中到处使用它们。

1290
01:31:36,130 --> 01:31:40,610
如果平均函数本身与该特殊变量无关，那就更好了。

1291
01:31:40,610 --> 01:31:42,025
所以，我的意思是这样的。

1292
01:31:42,025 --> 01:31:46,240
你知道如果我真的想设计得好，我应该怎么做吗？

1293
01:31:46,240 --> 01:31:51,400
我应该把数组的长度传给 average 函数。

1294
01:31:51,400 --> 01:31:54,310
我应该给平均函数添加第二个参数--

1295
01:31:54,310 --> 01:31:57,800
比如，我把它叫做 "长度"，但我想怎么叫都行。

1296
01:31:57,800 --> 01:32:05,745
因此，与其在文件底部一直写 N，不如让我动态地写长度。

1297
01:32:05,745 --> 01:32:08,620
这是一个微妙之处--不必为此过于纠结。

1298
01:32:08,620 --> 01:32:13,690
但这只是一个例子，说明同一个函数可以接受两个参数。

1299
01:32:13,690 --> 01:32:19,900
但实际上，在 C 语言中，你必须自己记住数组的长度是多少。

1300
01:32:19,900 --> 01:32:26,560
你不能像那些用 Java 或 Python 编程的人一样，通过一些语法来询问数组。

1303
01:32:35,115 --> 01:32:36,240
大卫-马兰：问得好。

1304
01:32:36,240 --> 01:32:39,198
写一个计算大小的函数会不会设计得更好？

1305
01:32:39,198 --> 01:32:48,180
简而言之，在 C 语言中无法做到这一点。在 C 语言中，只要将数组传入函数，就无法计算出它的大小（如果它是一个通用数组，如整数数组）。

1306
01:32:48,180 --> 01:32:51,040
在一些特殊情况下，你可以这样做。

1307
01:32:51,040 --> 01:32:53,283
但一般来说，在 C 语言中是不可能实现的。

1308
01:32:53,283 --> 01:32:57,180
老实说，如果这让人感到沮丧，那么这就是为什么更多的现代语言会添加该功能的原因。

1310
01:32:57,680 --> 01:33:01,560
因为这真的很烦人，我在这里暗指的就是没有这些信息。

1311
01:33:01,560 --> 01:33:07,540
现在，为了确保我没有在任何地方出错，让我来整理一下这个最终版本的分数。

1313
01:33:08,620 --> 01:33:14,030
............分数，72，73，33，我们还在继续工作。

1314
01:33:14,030 --> 01:33:15,530
因此，这个版本更加复杂。

1315
01:33:15,530 --> 01:33:18,738
我们将一如既往地在课程网站上发布这一版本，以供参考。

1316
01:33:18,738 --> 01:33:30,440
但问题的关键在于，数组不仅可以用作存储多个值的容器，在本例中可以存储三个或更多的值，还可以将它们作为参数传递。

1317
01:33:30,440 --> 01:33:36,100
好了，除此之外，让我们暂时简化一下，考虑一下字符的世界。

1318
01:33:36,100 --> 01:33:39,200
如果我们只有单字节，这会导致什么结果？

1319
01:33:39,200 --> 01:33:44,170
那么，这最终又是如何让我们用字符串来解决可读性和密码学等问题的呢？

1320
01:33:44,170 --> 01:33:48,967
例如，这里有三行代码，脱离上下文，只是存储三个字符。

1321
01:33:48,967 --> 01:33:50,800
你已经可以看到事情的发展方向了。

1322
01:33:50,800 --> 01:33:57,470
显然，使用 c1、c2、c3 这三个变量最终会导致糟糕的设计，因为这里存在大量愚蠢的冗余。

1323
01:33:57,470 --> 01:34:01,330
但请注意，我和上周一样使用了单引号，因为这些都是单字符。

1324
01:34:01,330 --> 01:34:03,647
这在计算机内存中是什么样子的？

1325
01:34:03,647 --> 01:34:05,480
嗯，看起来有点像这样。

1326
01:34:05,480 --> 01:34:12,562
如果我们清除旧的内存，c1、c2、c3 可能会出现在这里，也许不是字面上的左上角。

1327
01:34:12,562 --> 01:34:14,020
这只是艺术家的描绘。

1328
01:34:14,020 --> 01:34:18,440
但 c1、c2、c3 的结局很可能就是这样。

1329
01:34:18,440 --> 01:34:20,020
现在，那里到底有什么？

1330
01:34:20,020 --> 01:34:21,730
其实就是这三个数字

1331
01:34:21,730 --> 01:34:23,350
72, 73, 33.

1332
01:34:23,350 --> 01:34:27,920
但一个字节有多少位？

1333
01:34:27,920 --> 01:34:28,880
只有八个。

1334
01:34:28,880 --> 01:34:35,330
因此，如果我们查看这些字符的二进制表示法，每个字符只有 8 位。

1335
01:34:35,330 --> 01:34:39,140
这足以存储 72、73、33 等小数字。

1336
01:34:39,140 --> 01:34:41,580
我们不是在处理 Unicode 和表情符号之类的问题。

1337
01:34:41,580 --> 01:34:42,837
但问题是一样的。

1338
01:34:42,837 --> 01:34:45,170
您不必使用四个字节来存储这些数字。

1339
01:34:45,170 --> 01:34:51,420
你可以使用不同的数据类型，如字符，而在引擎盖下，它确实会为每个数据使用单字节。

1340
01:34:51,420 --> 01:34:55,850
但这有点像 -- 这并不是我们实现字符串的真正方式，对吧？

1341
01:34:55,850 --> 01:34:59,270
当你想说 "嗨"、"上周 "或 "这个 "时，我们使用双引号。

1342
01:34:59,270 --> 01:35:02,900
我们把所有东西都写在一起，用一个变量，而不是三个，对吗？

1343
01:35:02,900 --> 01:35:06,260
当我输入 David 时，我没有 D-A-V-I-D 的变量。

1344
01:35:06,260 --> 01:35:09,750
我有一个名为 name 的变量，可以存储所有内容。

1345
01:35:09,750 --> 01:35:13,310
因此，在 C 语言中，我们一直在谈论字符串。

1346
01:35:13,310 --> 01:35:17,427
我们最终会发现，字符串并不一定像它们看起来那样。

1347
01:35:17,427 --> 01:35:22,070
但现在，字符串的关键在于它们的长度是可变的，不是吗？

1348
01:35:22,070 --> 01:35:28,250
它们可能是三个字符，Hi，也可能是五个字符，David，或者更小或更大。

1349
01:35:28,250 --> 01:35:33,110
那么，如果到最后我们所拥有的只是我的记忆，我们该如何实施字符串呢？

1350
01:35:33,110 --> 01:35:41,900
这里有一个创建、声明和定义名为 s 的字符串的示例。s 因为只是一个简单的字符串，所以用双引号引出未加引号的 HI！。

1351
01:35:41,900 --> 01:35:44,090
这在计算机内存中是什么样子的？

1352
01:35:44,090 --> 01:35:45,230
好吧，让我们再澄清一遍。

1353
01:35:45,230 --> 01:35:50,960
现在，因为技术上它只存储在一个变量 s 中，所以作为艺术家，我可以这样画它。

1354
01:35:50,960 --> 01:35:52,520
总共有三个字节

1355
01:35:52,520 --> 01:35:53,990
H-I 感叹号。

1356
01:35:53,990 --> 01:35:59,630
但没有 c1、c2、c3，整个过程都是 s。

1357
01:35:59,630 --> 01:36:06,990
但事实证明，有趣的是，字符串在引擎盖下面到底是什么？

1358
01:36:06,990 --> 01:36:12,090
如果记忆中的字符串是这样排列的，那么字符串又是什么呢？

1359
01:36:12,090 --> 01:36:13,190
听众：一个阵列。

1360
01:36:13,190 --> 01:36:15,830
戴维-马兰：从字面上看，这只是一系列角色。

1361
01:36:15,830 --> 01:36:18,590
上周，我们不需要了解数组就能使用字符串。

1362
01:36:18,590 --> 01:36:21,382
这也是训练车轮开始脱落的地方。

1363
01:36:21,382 --> 01:36:23,730
但字符串只是一个字符数组。

1364
01:36:23,730 --> 01:36:26,040
例如 H-I 感叹号。

1365
01:36:26,040 --> 01:36:38,150
因此，从技术上讲，一个名为 s 的数组或字符串实际上是一个名为 s 的变量，它允许你通过 s[0] 获取第一个字符，如果你想的话，可以通过 s[1] 或 s[2] 获取。

1366
01:36:38,150 --> 01:36:47,000
只需将 s 当作数组处理，就能获得单个字符，而在本例中，s 在外壳下确实是一个数组。

1367
01:36:47,000 --> 01:36:48,560
但有一个问题。

1368
01:36:48,560 --> 01:36:51,500
你怎么知道琴弦在哪里结束？

1369
01:36:51,500 --> 01:36:54,560
过去，当我在屏幕上画一些整数时、

1370
01:36:54,560 --> 01:36:57,080
我知道，我声称它们总是占用 4 个字节。

1371
01:36:57,080 --> 01:37:00,200
如果我画了一个长条，它总是占用 8 个字节。

1372
01:37:00,200 --> 01:37:03,530
如果我画了一个字符，它总是占用 1 个字节。

1373
01:37:03,530 --> 01:37:06,533
但一个字符串要占用多少字节呢？

1374
01:37:06,533 --> 01:37:08,450
是的，我的意思是，这是一个正确的答案。

1375
01:37:08,450 --> 01:37:10,490
在这种情况下，似乎是三个。

1376
01:37:10,490 --> 01:37:13,490
但如果是戴维，那就有五个角色了。

1377
01:37:13,490 --> 01:37:16,173
但是，我们该把数字 3 放在哪里呢？

1378
01:37:16,173 --> 01:37:17,840
你把数字 5 放在哪里，对吗？

1379
01:37:17,840 --> 01:37:20,190
这就是电脑中的全部内容。

1380
01:37:20,190 --> 01:37:23,430
这就是摆在我们面前的所有积木。

1381
01:37:23,430 --> 01:37:25,490
那么，我们怎样才能--这三个人去哪儿了？

1382
01:37:25,490 --> 01:37:26,540
那五个人去哪儿了？

1383
01:37:26,540 --> 01:37:29,420
事实证明，你可以用几种不同的方法来解决这个问题。

1384
01:37:29,420 --> 01:37:41,840
但人类多年前决定实现字符串的方式确实是一个数组，但他们在每个字符串数组的末尾都额外增加了一个字节，以明确所谓的哨兵值、

1385
01:37:41,840 --> 01:37:44,480
字符串到此为止。

1387
01:37:45,050 --> 01:37:54,590
这样，如果电脑内存中有两个字符串，比如 "HI "和 "bye"，你就知道其中一个字符串的感叹号和下一个字符串的字母 B 之间的分界线在哪里，对吗？

1388
01:37:54,590 --> 01:37:56,000
你需要某种分隔符。

1389
01:37:56,000 --> 01:38:00,110
所以，真正的秘密是这样的。

1390
01:38:00,110 --> 01:38:07,040
当你在内存中存储字符串时，当你输入字符串时--作为用户，如果你输入 3 个字符，它会使用

1391
01:38:07,040 --> 01:38:10,280
3 加 1 共等于 4 个字节。

1392
01:38:10,280 --> 01:38:14,130
如果输入 David，则总共要使用 5 加 1 等于 6 个字节。

1394
01:38:14,630 --> 01:38:20,210
因为 C 会自动在字符串末尾添加这个特殊的 0。

1395
01:38:20,210 --> 01:38:25,710
我用反斜杠 0 画它，是因为 0 作为字符就是这样表示的。

1396
01:38:25,710 --> 01:38:28,230
但这只是 0，我们很快就会看到。

1397
01:38:28,230 --> 01:38:36,197
因此，无论何时内存中出现字符串，它总是比程序员或人类输入的字符串多占用一个字节。

1398
01:38:36,197 --> 01:38:45,170
事实上，为了便于讨论，如果我们再次将其转换为整数，那么电脑内存中实际存储的内容将是 72、73、33 和 0。

1399
01:38:45,170 --> 01:38:54,530
由于 C 语言的发明过程，计算机很聪明，它知道当你打印出一个字符串时，它会打印出每个字符，直到看到 0、

1400
01:38:54,530 --> 01:38:56,150
然后就停止打印了。

1401
01:38:56,150 --> 01:38:58,470
特别是，printf 知道如何工作。

1402
01:38:58,470 --> 01:39:02,050
这就是 printf 知道何时停止打印的原因。

1403
01:39:02,050 --> 01:39:03,800
小数点并不那么有启发性。

1404
01:39:03,800 --> 01:39:05,940
我们一般会这样写人物。

1405
01:39:05,940 --> 01:39:09,350
同样，反斜杠 0 只是一种特殊符号。

1406
01:39:09,350 --> 01:39:13,190
这是程序员输入的内容，以明确您不是在说：HI！，0。

1407
01:39:13,190 --> 01:39:15,980
你说 "HI！"，然后就是特别的 "0"。

1408
01:39:15,980 --> 01:39:22,220
具体来说，就是用 8 个 0 位来表示字符串的结束。

1409
01:39:22,220 --> 01:39:26,330
从技术上讲，如果你想花哨一点，这个反斜杠零叫做 null、

1411
01:39:27,320 --> 01:39:30,320
事实证明，你以前见过这种情况，虽然我们没有说出来。

1412
01:39:30,320 --> 01:39:33,230
这是过去几周的 ASCII 图表。

1413
01:39:33,230 --> 01:39:39,080
如果我突出显示这一点，十进制数字 0 映射的是什么？

1414
01:39:39,080 --> 01:39:42,830
NUL，程序员用它来表示特殊的空字符。

1415
01:39:42,830 --> 01:39:46,550
全部为 0 位，表示字符串到此为止。

1416
01:39:46,550 --> 01:39:48,510
这一切都会自动为您完成。

1417
01:39:48,510 --> 01:39:53,420
您无需创建这些空字符或零。

1418
01:39:53,420 --> 01:40:00,030
那么，对迄今为止的实施情况还有什么问题吗？

1419
01:40:00,030 --> 01:40:01,820
有问题吗？

1421
01:40:02,320 --> 01:40:03,195
让我来吧

1422
01:40:03,195 --> 01:40:05,310
让我马上回到 VS 代码。

1423
01:40:05,310 --> 01:40:07,770
让我们用一些代码来证实这一点。

1424
01:40:07,770 --> 01:40:10,830
让我继续创建一个名为 hi.c 的小程序。

1425
01:40:10,830 --> 01:40:12,070
我们这样做如何？

1426
01:40:12,070 --> 01:40:14,550
让我加入 stdio.h。

1427
01:40:14,550 --> 01:40:18,670
让我一如既往地输入 int main void。

1428
01:40:18,670 --> 01:40:24,960
现在让我做一件简单但有点糟糕的事，但字符 c1 等于单引号中的引号 unquote、h。

1429
01:40:24,960 --> 01:40:28,590
字符 c2 等于单引号中的引号 I。

1430
01:40:28,590 --> 01:40:32,830
最后，字符 c3 等于感叹号，用单引号表示。

1431
01:40:32,830 --> 01:40:34,500
现在，让我把这个打印出来。

1432
01:40:34,500 --> 01:40:36,960
我不能使用 %s，因为它不是字符串。

1433
01:40:36,960 --> 01:40:40,290
这实际上是三个字符，因为这是我的设计决定。

1434
01:40:40,290 --> 01:40:41,430
但我可以这么做

1435
01:40:41,430 --> 01:40:48,600
%c、%c、%c，我们以前没见过，但 %s 是字符串，%i 是 int、

1436
01:40:48,600 --> 01:40:51,060
%c 确实是字符。

1437
01:40:51,060 --> 01:40:56,280
为了简洁起见，我在最后加了一个反斜杠 n，现在输入 c1、c2、c3。

1438
01:40:56,280 --> 01:41:00,430
因此，这就像是基于字符的字符串打印版本。

1439
01:41:00,430 --> 01:41:01,650
所以，让我来介绍一下 HI！

1440
01:41:01,650 --> 01:41:05,880
然后让我做 ./hi，看起来我使用了带有 %s 的 printf。

1441
01:41:05,880 --> 01:41:09,750
但我的做法是非常手工地打印出每个字符。

1442
01:41:09,750 --> 01:41:16,560
不过，现在最酷的是，一旦你知道了字符只是数字，字符串只是字符，你就可以四处探索了。

1443
01:41:16,560 --> 01:41:21,970
让我把这三个占位符都改成 %i。

1444
01:41:21,970 --> 01:41:23,860
这也完全没问题。

1445
01:41:23,860 --> 01:41:26,310
让我重播一下，打个招呼。

1446
01:41:26,310 --> 01:41:31,570
实际上，让我做一个改动，这样我们就能看到了。

1447
01:41:31,570 --> 01:41:40,350
让我加上空格，为了美观起见，让我输入 hi、./hi、回车，然后就像现在这样，你就能真正看到数字了、

1448
01:41:40,350 --> 01:41:44,085
事实上，我在第零周时声称的"''......

1449
01:41:44,085 --> 01:41:45,960
嗯，这可不是你做琴弦的方法。

1450
01:41:45,960 --> 01:41:50,790
如果用三个变量来表示三个字母的单词，用五个变量来表示五个字母的单词，那就太乏味了。

1451
01:41:50,790 --> 01:41:54,450
当然，我们从上周开始就一直在使用字符串，所以我们还是用字符串来代替吧。

1452
01:41:54,450 --> 01:41:59,370
字符串 s 等于引号未加引号，双引号 "HI!"

1453
01:41:59,370 --> 01:42:02,520
因为这个，不，是因为这些训练轮、

1454
01:42:02,520 --> 01:42:04,560
我需要加入 CS50 库。

1455
01:42:04,560 --> 01:42:06,580
不过，未来几周我们会再讨论这个问题。

1456
01:42:06,580 --> 01:42:10,530
但现在，我要继续创建一个名为 quote unquote 的字符串、

1458
01:42:11,580 --> 01:42:17,610
现在我要把它改成我熟悉的 %s，然后直接打印出 s 本身。

1459
01:42:17,610 --> 01:42:24,750
当然，这和上周的 ./hi 给我的结果是一样的，但现在我们要处理的当然是字符串。

1460
01:42:24,750 --> 01:42:27,610
但是，我们如何才能看得更远一些呢？

1461
01:42:27,610 --> 01:42:28,810
这样如何？

1462
01:42:28,810 --> 01:42:31,530
让我们进一步探索今天的原语。

1463
01:42:31,530 --> 01:42:39,000
尽管 s 是一个字符串，但从技术上讲，我可以通过执行 s[0]，用 %c 打印出它的第一个字符。

1464
01:42:39,000 --> 01:42:43,110
从技术上讲，我可以通过 s[1] 用 %c 打印出第二个字符。

1465
01:42:43,110 --> 01:42:47,820
我可以用 %c 打印出第三个字符，并打印出 s[2]。

1466
01:42:47,820 --> 01:42:52,770
因此，正如你所指出的，这只是从我现在对字符串是数组的理解中逻辑地推导出来的。

1467
01:42:52,770 --> 01:42:57,300
让我做 - -让我做喜，./喜。

1468
01:42:57,300 --> 01:43:00,760
视觉上没有变化，但我现在正在修修补补。

1469
01:43:00,760 --> 01:43:03,400
事实上，如果你真的很好奇，让我来做这件事。

1470
01:43:03,400 --> 01:43:08,250
让我把这些改回 i，改回 i -- 哎呀，改回 i。

1471
01:43:08,250 --> 01:43:14,490
让我再加上第四个，因为我现在真的很好奇，让我们看看 s[3] 中有什么。

1472
01:43:14,490 --> 01:43:16,020
这是第四个字节。

1473
01:43:16,020 --> 01:43:18,990
尽管字符串本身是 H-I、

1474
01:43:18,990 --> 01:43:21,840
我想我们可以证实整个无效的事情。

1475
01:43:21,840 --> 01:43:26,248
输入 hi、./hi、回车，就可以了。

1476
01:43:26,248 --> 01:43:29,580
如果你真的想在弦乐上大显身手，上周就可以这样做了。

1477
01:43:29,580 --> 01:43:33,060
但现在，它只是揭示了引擎盖下的情况。

1478
01:43:33,060 --> 01:43:36,480
那么，这些字符串是什么呢？

1481
01:43:41,293 --> 01:43:42,960
大卫-马兰：我们为什么需要支架？

1483
01:43:45,430 --> 01:43:47,180
大卫-马兰：为什么不需要支架？

1484
01:43:47,180 --> 01:43:47,780
问得好。

1485
01:43:47,780 --> 01:43:51,620
为什么第 6 行不需要括号？

1486
01:43:51,620 --> 01:43:53,300
因为 s 是一个字符串。

1487
01:43:53,300 --> 01:44:02,240
我们将在几周后看到，s 本质上是作为一个数组在引擎盖下实现的，但它会自动为你实现。

1488
01:44:02,240 --> 01:44:06,800
您可以将 s 仅作为变量名处理，而不去掉方括号。

1489
01:44:06,800 --> 01:44:13,730
在使用 int 数组或手动创建字符数组、双倍数组、浮点数组或其他数组时，需要使用方括号。

1490
01:44:13,730 --> 01:44:14,900
但琴弦很特别。

1492
01:44:15,440 --> 01:44:19,190
我的意思是，你写的每个程序似乎都在使用字符串和某种形式的文本。

1493
01:44:19,190 --> 01:44:21,930
我们是人类，我们喜欢文字，而不仅仅是数字之类的东西。

1494
01:44:21,930 --> 01:44:28,580
因此，在 C 语言和许多其他语言中，这种处理方式都有些特殊。

1495
01:44:28,580 --> 01:44:31,170
还有其他问题吗？

1497
01:44:31,670 --> 01:44:33,530
那么，让我们再加上一根弦。

1498
01:44:33,530 --> 01:44:38,660
因此，与其只说："你好！"，我们为什么不考虑推出一个同时说 "你好！"和 "再见！"的程序版本呢？

1499
01:44:38,660 --> 01:44:48,570
我现在认为，如果内存中有两个字符串，那么反斜杠 0 字符、空字符就会变得越来越重要，这样 C 语言就知道如何区分这两个字符串。

1500
01:44:48,570 --> 01:44:51,487
所以，让我先把这两行去掉吧。

1501
01:44:51,487 --> 01:44:55,430
让我重现字符串 s 的等号，引号不含双引号，"HI！"

1502
01:44:55,430 --> 01:44:56,780
让我再给自己来一次。

1503
01:44:56,780 --> 01:44:59,905
因为我只是随便玩玩，所以我会选择非常简短的变量名。

1504
01:44:59,905 --> 01:45:04,410
字符串 t 等于引号加引号，"再见！"

1505
01:45:04,410 --> 01:45:06,470
然后让我把它们都打印出来。

1506
01:45:06,470 --> 01:45:16,910
让我继续打印 %s、反斜杠 n、逗号 s，然后 printf %s 反斜杠 n，再打印 t。

1507
01:45:16,910 --> 01:45:19,970
因此，只需对这两个变量进行非常简单的演示。

1508
01:45:19,970 --> 01:45:26,090
输入 hi、./hi，当然会打印出两行，一行紧接着一行。

1509
01:45:26,090 --> 01:45:27,980
引擎盖下面究竟发生了什么？

1510
01:45:27,980 --> 01:45:29,510
好吧，让我们回到电脑内存。

1511
01:45:29,510 --> 01:45:32,160
HI！"，我想，我声称，情况会大致相同。

1512
01:45:32,160 --> 01:45:36,170
因此，我认为 s 位于左上方，后面是反斜杠 0。

1513
01:45:36,170 --> 01:45:40,035
现在这一点很重要，因为《再见！》很可能会在那里结束。

1514
01:45:40,035 --> 01:45:44,330
从视觉上看，我绘制的这个字节网格可以将其包裹起来，但它是连续的。

1515
01:45:44,330 --> 01:45:58,580
B-Y-E-！空，又名反斜线零，现在对 printf 很有帮助，因为通过这个特殊的空字符，printf 可以知道一个人从哪里开始，在哪里结束。

1516
01:45:58,580 --> 01:46:00,230
但我们现在也可以四处看看。

1517
01:46:00,230 --> 01:46:01,620
我还能在这里做什么？

1518
01:46:01,620 --> 01:46:02,840
这样如何？

1519
01:46:02,840 --> 01:46:15,410
我在这里输入我的代码，回到 VS 代码，让我继续说，好吧，如果我有两个这样的字符串，你知道，让我们把它们放到一个数组中。

1520
01:46:15,410 --> 01:46:20,520
让我们用数组中的数组的方式，在这里进行初创式的排序。

1521
01:46:20,520 --> 01:46:23,060
So string words[2].

1522
01:46:23,060 --> 01:46:25,100
所以，给我一个包含两个字符串的数组就是

1523
01:46:25,100 --> 01:46:28,100
虽然我们还没有使用字符串，但我在这里说的是代码。

1524
01:46:28,100 --> 01:46:29,270
我们只用 ints 做过。

1525
01:46:29,270 --> 01:46:30,770
现在让我来做这件事。

1526
01:46:30,770 --> 01:46:35,480
第一个单词又名 words[0] 和之前一样，等于 HI！

1527
01:46:35,480 --> 01:46:40,940
现在的话[1] 就等于引号不加引号的 "再见！"

1528
01:46:40,940 --> 01:46:48,650
现在我做了完全相同的事情，但同样，我只是避免在代码中出现 s、t、q、r 和所有这些不同的变量。

1529
01:46:48,650 --> 01:46:52,790
我现在只是把它们当作一个字符串数组。

1530
01:46:52,790 --> 01:46:54,750
如何更改下面的代码？

1531
01:46:54,750 --> 01:46:57,380
好吧，如果我想打印第一个单词，我会打印 words[0]。

1532
01:46:57,380 --> 01:46:59,900
如果我想打印第二个单词，我会打印 words[1]。

1533
01:46:59,900 --> 01:47:04,130
目前这不是一个有用的练习，因为我只是在让我的代码变得更复杂。

1534
01:47:04,130 --> 01:47:09,530
但同样，这也让我们可以四处打探，看看发生了什么，因为这里有 HI！和 BYE！。

1535
01:47:09,530 --> 01:47:10,700
但请注意

1536
01:47:10,700 --> 01:47:14,670
如果我真的想变酷，我可以做到这一点。

1537
01:47:14,670 --> 01:47:25,700
让我们打印出 %c、%c、%c、反斜杠 n，然后在这里打印出 %c、%c、%c、%c，这样就有四个了。

1538
01:47:25,700 --> 01:47:28,430
现在，事情变得有趣了。

1539
01:47:28,430 --> 01:47:30,620
Words 是一个字符串数组。

1540
01:47:30,620 --> 01:47:33,400
请允许我再问一次，什么是字符串？

1541
01:47:33,400 --> 01:47:35,060
字符数组。

1542
01:47:35,060 --> 01:47:36,790
所以，就用同样的逻辑吧。

1543
01:47:36,790 --> 01:47:41,110
如果 words 是字符串数组，则用 words[0] 取得第一个字符串。

1544
01:47:41,110 --> 01:47:44,530
如何获取第一个字符串中的第一个字符？

1545
01:47:44,530 --> 01:47:52,150
括号 0、words[0][1]，最后是 words[0][2]。

1546
01:47:52,150 --> 01:47:57,460
现在这里是 words[1]，但第一个字符就在这里。

1547
01:47:57,460 --> 01:48:00,400
单词[1]，第二个字符在这里。

1548
01:48:00,400 --> 01:48:04,720
Words[1]，第三个字符在这里--哎呀--第三个字符在这里。

1549
01:48:04,720 --> 01:48:07,898
第四个字符是 words[1]。

1550
01:48:07,898 --> 01:48:09,190
人们不是这样编程的。

1551
01:48:09,190 --> 01:48:10,840
这只是为了演示。

1552
01:48:10,840 --> 01:48:13,060
我的天哪，已经如此乏味和啰嗦了。

1553
01:48:13,060 --> 01:48:22,990
但是，如果我现在制作 hi、./hi，如果我忘记了 %s 的存在，我就需要手动重新制作 %s，只使用 %c。

1554
01:48:22,990 --> 01:48:25,900
但你确实可以用这种方法来操作数组。

1555
01:48:25,900 --> 01:48:32,200
但是，由于字符串是字符数组，因此也可以用这种方式操作字符串。

1556
01:48:32,200 --> 01:48:34,675
现在对这个语法还有疑问吗？

1557
01:48:37,210 --> 01:48:38,800
有问题吗？

1559
01:48:39,970 --> 01:48:45,830
好吧，让我们继续提议，解决其他几个我们可能没有的问题。

1560
01:48:45,830 --> 01:48:49,150
但首先，我们要快速了解一下引擎盖下面发生了什么。

1561
01:48:49,150 --> 01:49:00,880
如果这里又是我们在屏幕上离开的地方，HI！和 BYE！背靠背，这里就是我刚才处理这些东西的方式。S 括 0、1、2、3，然后是 T 0、1、2、3、4。

1562
01:49:00,880 --> 01:49:04,840
但实际上，一旦我把它们放入一个数组，画面就会变成这样。

1563
01:49:04,840 --> 01:49:07,030
Words[0] 是整个 HI!

1564
01:49:07,030 --> 01:49:08,680
Words[1] 是整个 BYE！。

1565
01:49:08,680 --> 01:49:20,710
但是，如果我真的深入其中，开始对这些字符串中的单个字符进行索引，我所使用的只是新的语法，以便在这里表示这些相同的值。

1566
01:49:20,710 --> 01:49:28,710
那么，在我们继续前进之前，对这些陈述有什么疑问？

1569
01:49:30,030 --> 01:49:33,390
听众：新的行字符不[听不清]吗？

1570
01:49:33,390 --> 01:49:36,030


1571
01:49:36,030 --> 01:49:38,597
听众：新行字符是否占用空间？

1572
01:49:38,597 --> 01:49:40,180
大卫-马兰：啊，真是个好问题。

1573
01:49:40,180 --> 01:49:42,730
新行字符是否占用空间？

1574
01:49:42,730 --> 01:49:45,340
就 printf 而言，确实如此。

1575
01:49:45,340 --> 01:49:53,460
但我并没有在字符串中存储反斜线 n，而是由 printf 手动将其交给我。

1576
01:49:53,460 --> 01:50:00,680
好吧，那么让我们继续考虑如何解决这些字符串现在出现的一些问题，如下所示。

1577
01:50:00,680 --> 01:50:02,760
假设我... 我们开始吧

1578
01:50:02,760 --> 01:50:04,400
让我回到《VS 代码》这里。

1579
01:50:04,400 --> 01:50:09,980
让我继续打开一个名为 length.c 的新文件。

1580
01:50:09,980 --> 01:50:16,130
让我们先考虑一下，我如何才能算出字符串的长度，这与数组的长度是不同的。

1581
01:50:16,130 --> 01:50:20,180
我之前说过，你无法动态计算数组的长度。

1582
01:50:20,180 --> 01:50:26,960
但我能计算出字符串的长度，特别是因为这个空字符的实现细节。

1583
01:50:26,960 --> 01:50:28,500
所以，让我来做这件事吧。

1584
01:50:28,500 --> 01:50:31,940
让我在第二个程序中加入 cs50.h。

1585
01:50:31,940 --> 01:50:35,090
和之前一样，让我加入 stdio.h。

1586
01:50:35,090 --> 01:50:40,970
让我这样做， int main void -- 我要做的第一件事就是从用户那里获取一个字符串。

1587
01:50:40,970 --> 01:50:43,250
我会一如既往地询问用户的姓名。

1588
01:50:43,250 --> 01:50:48,170
因此，我会调用 getString，然后说，你叫什么名字，问号，一如既往。

1589
01:50:48,170 --> 01:50:58,465
然后，如果我想计算出这个字符串的长度，并在屏幕上打印出来，那么我就可以用类似平均值的方法来计算、

1590
01:50:58,465 --> 01:50:59,840
在那里我积累了一些东西。

1591
01:50:59,840 --> 01:51:02,600
让我把 N 初始化为 0。

1592
01:51:02,600 --> 01:51:07,035
让我给自己 - 这不是一个循环，因为我没有 -

1593
01:51:07,035 --> 01:51:08,660
我事先不知道时间有多长。

1594
01:51:08,660 --> 01:51:09,980
但如果我这样做呢？

1595
01:51:09,980 --> 01:51:25,590
虽然 name[n] 的值不等于'/0'--目前的语法很疯狂，但它只是这些不同构件的顶点。

1596
01:51:25,590 --> 01:51:28,970
让我在这里把想法说完，n++。

1597
01:51:28,970 --> 01:51:43,220
然后，在下面用 printf 和 %i 打印出 N 的值。我声称这将显示我输入的任何字符串的长度，无论是 hi、bye 还是 David 或其他任何字符串。

1598
01:51:43,220 --> 01:51:47,535
我将一个变量初始化为零，这很好，因为一般来说，你就是从这里开始计数的。

1599
01:51:47,535 --> 01:51:50,990
而 name[0] 不等于反斜杠 0。

1600
01:51:50,990 --> 01:51:51,930
这是什么意思？

1601
01:51:51,930 --> 01:51:59,390
如果 name 是用户输入的字符串，而 name 又是一个数组，那么 name[0] 将是第一个字符。

1602
01:51:59,390 --> 01:52:03,680
我想问的是，第一个字符不等于反斜杠 0 吗？

1603
01:52:03,680 --> 01:52:08,750
如果我输入大卫，D，就不是了，所以我继续输入，然后在 N 后面加 1。

1604
01:52:08,750 --> 01:52:10,750
然后我要检查 name[1]。

1605
01:52:10,750 --> 01:52:13,895
那么，如果我输入 David，name[1] 就会是 A。

1606
01:52:13,895 --> 01:52:18,740
A 不等于反斜杠 0，因此会反复出现。

1607
01:52:18,740 --> 01:52:23,090
但总共五步之后，它就会到达字节。

1608
01:52:23,090 --> 01:52:26,480
D-A-V-I-D，等一下，那是反斜杠 N。

1609
01:52:26,480 --> 01:52:29,750
循环结束，我打印出总长度。

1610
01:52:29,750 --> 01:52:33,050
一般来说，数组没有空字符。

1611
01:52:33,050 --> 01:52:34,910
然而，字符串确实如此。

1612
01:52:34,910 --> 01:52:39,590
再说一遍，字符串相对于我们迄今为止讨论过的所有其他数据类型都很特殊。

1613
01:52:39,590 --> 01:52:43,220
但是，比如说，我怎样才能以不同的方式做到这一点呢？

1614
01:52:43,220 --> 01:52:47,220
那么，让我们按照我通常的做法，把它作为一个函数来计算。

1615
01:52:47,220 --> 01:52:50,540
但与其自己实施，你知道吗？

1616
01:52:50,540 --> 01:52:57,260
事实证明，字符串如此常见的好处是，有很多其他人以前也解决过这些问题。

1617
01:52:57,260 --> 01:53:00,290
事实上，在 C 语言中有一个完整的字符串库。

1618
01:53:00,290 --> 01:53:04,190
它是通过一个名为 string.h 的头文件来使用的。

1619
01:53:04,190 --> 01:53:08,400
string.h 是一个字符串相关函数库。

1620
01:53:08,400 --> 01:53:18,050
事实上，你可以在 CS50 的 C 语言手册页面中看到 string.h 函数，至少是我们推荐的那些最有用的函数，特别是，如果你在那里搜索的话、

1621
01:53:18,050 --> 01:53:20,290
你会发现有一个叫做 strlen 的函数。

1622
01:53:20,290 --> 01:53:22,055
表示字符串长度。

1623
01:53:22,055 --> 01:53:25,850
命名非常简洁，只是因为它比字符串长度更容易输入。

1624
01:53:25,850 --> 01:53:28,800
但 strlen 会告诉你字符串的长度。

1625
01:53:28,800 --> 01:53:30,990
那么，如何在我的代码中使用它呢？

1626
01:53:30,990 --> 01:53:34,020
事实证明，我可以简化很多。

1627
01:53:34,020 --> 01:53:45,630
让我去掉循环，去掉手工记账，然后这样做-- int n 等于人类名称 name 的 strlen。

1628
01:53:45,630 --> 01:53:51,290
现在，我将像以前一样使用 printf，使用 %i 反斜线 n，并输出 n 的值。

1629
01:53:51,290 --> 01:53:54,380
但目前有一个漏洞。

1630
01:53:54,380 --> 01:53:58,480
我忘记做什么了？

1631
01:53:58,480 --> 01:54:03,260
是的，我必须在屏幕顶部加入头文件，所以让我 -- 在代码的顶部。

1632
01:54:03,260 --> 01:54:10,970
因此，让我在文件顶部包含 string.h，这样 C 就会知道 strlen 确实存在。

1633
01:54:10,970 --> 01:54:14,170
请允许我像以前一样，把长度加长。

1634
01:54:14,170 --> 01:54:18,670
................长度--或者，实际上，真的是第一次，你叫什么名字？

1635
01:54:18,670 --> 01:54:22,360
D -A -V希望我能看到，事实上，5。

1636
01:54:22,360 --> 01:54:26,950
相比之下，如果我再次运行它并输入 HI！，现在我看到了三个。

1637
01:54:26,950 --> 01:54:29,785
因此，strlen 只是该函数库中的一个函数。

1638
01:54:29,785 --> 01:54:30,910
还有很多很多。

1639
01:54:30,910 --> 01:54:40,580
事实上，还有一个库在未来可能会很有用，那就是 ctype 库，它与 C 数据类型有关，其中有很多有用的函数。

1640
01:54:40,580 --> 01:54:49,460
例如，如果您查看在线手册页面中的文档，就会发现我们可以通过一些功能来解决类似问题。

1641
01:54:49,460 --> 01:54:53,680
让我在这里提议 -- 让我看看。

1642
01:54:53,680 --> 01:55:06,700
让我们举个例子--如何检查某些内容是大写还是小写，并将其转换为大写。

1643
01:55:06,700 --> 01:55:10,810
让我回到 VS 代码，编写一个名为 uppercase.c 的程序。

1644
01:55:10,810 --> 01:55:15,220
在这个文件中，我将一如既往地首先包含 cs50.h。

1645
01:55:15,220 --> 01:55:17,710
我将包含 stdio.h。

1646
01:55:17,710 --> 01:55:26,230
我现在还要添加一个 string.h，这样我就可以根据需要访问事物的长度了。

1647
01:55:26,230 --> 01:55:28,570
接下来是 Int main void。

1648
01:55:28,570 --> 01:55:32,230
然后在我的主函数中，我要继续声明一个名为 s 的字符串。

1649
01:55:32,230 --> 01:55:34,240
我要像以前一样调用 getString。

1650
01:55:34,240 --> 01:55:38,170
我将继续询问用户之前调用的字符串。

1651
01:55:38,170 --> 01:55:39,670
我想做一个前后对比。

1652
01:55:39,670 --> 01:55:41,350
用户输入的内容都在前面。

1653
01:55:41,350 --> 01:55:44,770
但此后，我想把所有东西都强制改为大写。

1654
01:55:44,770 --> 01:55:48,740
现在，让我在这个循环中这样做。

1655
01:55:48,740 --> 01:55:53,800
让我打印出 "之后"，这样我们就能在屏幕上看到了。

1656
01:55:53,800 --> 01:56:02,440
让我来做四个 int i 得到 0，i 小于 s 的 strlen，i++。

1657
01:56:02,440 --> 01:56:03,610
我要做什么？

1658
01:56:03,610 --> 01:56:11,230
我要从左到右遍历字符串中的每个字符，从 0 开始，直到 s 的长度。

1659
01:56:11,230 --> 01:56:16,990
如何检查某些内容是否是小写，以便将其强制改为大写？

1660
01:56:16,990 --> 01:56:19,630
事实证明，我真的可以做到这一点。

1661
01:56:19,630 --> 01:56:31,780
如果 s 中位于 i 处的字符大于或等于大写字母 A，则为 "and"、"amppersand"，即 "and"，而不是我们看到的 "or"。

1662
01:56:31,780 --> 01:56:41,800
在过去，s[i] 小于或等于 little z，这在英语逻辑上意味着这确实是小写字母。

1663
01:56:41,800 --> 01:56:44,830
现在如何将这个字符转换成大写字母？

1664
01:56:44,830 --> 01:56:48,160
好吧，我可以直接打印出相同的字符。

1665
01:56:48,160 --> 01:56:52,280
但这并不是答案，因为这并没有改变价值。

1666
01:56:52,280 --> 01:56:54,470
但我能做什么呢？

1667
01:56:54,470 --> 01:57:03,220
好吧，让我在这里快速调出之前的 ASCII 图表，看看我们是否能从中获得一些启示。

1668
01:57:03,220 --> 01:57:09,790
如果我调出同样的 ASCII 图表，假设人类输入的是小写 a，那就是 97。

1669
01:57:09,790 --> 01:57:13,240
什么字母--我想把它转换成大写字母

1670
01:57:13,240 --> 01:57:18,660
A，那么我想把 97 转换成什么数字，每周 0？

1671
01:57:18,660 --> 01:57:21,000
所以 65，我们一直在回想这个问题。

1672
01:57:21,000 --> 01:57:23,010
如果用户输入的是小写 b 呢？

1673
01:57:23,010 --> 01:57:27,550
我想把 98 的值改为 66，以此类推。

1674
01:57:27,550 --> 01:57:30,130
快速计算一下，它们之间相距多远？

1675
01:57:30,130 --> 01:57:37,990
因此，从大写字母到小写字母总是相差 32 个，就像大写字母到小写字母总是相差 32 个一样，奇妙的设计。

1676
01:57:37,990 --> 01:57:39,100
这意味着什么？

1677
01:57:39,100 --> 01:57:42,600
嗯，我想我们之前已经看到，在引擎盖下面，字符只是一个数字。

1678
01:57:42,600 --> 01:57:44,340
你当然可以用它来做算术题。

1679
01:57:44,340 --> 01:57:48,180
同样，如果你理解了这些低级基元，如果我这样做呢？

1680
01:57:48,180 --> 01:57:57,048
无论 s[i] 是什么，如果我在第 13 行知道它是小写，我是要加上还是减去 32 呢？

1681
01:57:57,048 --> 01:57:57,840
听众：减去

1682
01:57:57,840 --> 01:58:06,560
戴维-马兰：所以我想做减法，因为我想从 97 减到 65，或者从 98 减到 66。

1683
01:58:06,560 --> 01:58:16,370
因此，只需将字符视为数字，减去 32，然后用 %c 打印即可，我认为这样就能将小写转换为大写。

1684
01:58:16,370 --> 01:58:24,980
如果你现在快进到现实世界，Microsoft Word 或 Google Docs，如果你曾经选择过菜单选项，偶尔会强制将东西变成大写或小写，从字面上看，那就是

1685
01:58:24,980 --> 01:58:26,480
微软和谷歌所做的一切。

1686
01:58:26,480 --> 01:58:33,810
它们会遍历文档中的每个字符，检查其是否小写，如果是，就会从中减去 32，然后向你显示新值。

1687
01:58:33,810 --> 01:58:36,650
如果不是小写字母呢？

1688
01:58:36,650 --> 01:58:46,490
如果我的目标只是强制全部大写，我想我可以简单一点，只打印出当前的字母，而这个字母就是 s[i]。

1689
01:58:46,490 --> 01:58:50,750
所以，让我现在继续大写，希望不会出错。

1690
01:58:50,750 --> 01:58:57,120
./uppercase，现在我会用大写字母 D 键入 David，但其他内容都要小写。

1691
01:58:57,120 --> 01:59:01,190
但现在的版本是 DAVID--一个美学错误。

1692
01:59:01,190 --> 01:59:05,930
请注意，为了美观起见，我忘了在末尾加上反斜杠 n。

1693
01:59:05,930 --> 01:59:07,640
没问题，我会加进去的。

1694
01:59:07,640 --> 01:59:08,870
让我来弥补我的错误。

1695
01:59:08,870 --> 01:59:12,050
大写，./uppercase，回车。

1696
01:59:12,050 --> 01:59:14,240
D-A-V-I-D，回车，就可以了。

1697
01:59:14,240 --> 01:59:22,070
我还特意在后面又加了一个空格，尽管前后的字母数不同，但这样排列起来会更美观。

1698
01:59:22,070 --> 01:59:28,380
那么，关于将某些内容强制为大写的问题，这本身并没有什么启发性、

1699
01:59:28,380 --> 01:59:33,990
但现在却代表了如何利用这些低级基元的方法。

1702
01:59:36,380 --> 01:59:38,633
好吧，老实说，这太乏味了。

1703
01:59:38,633 --> 01:59:43,550
我的天啊，微软、谷歌、每个人都要写这么多代码才能完成这么简单的事情吗？

1704
01:59:43,550 --> 01:59:46,310
不，这就是为什么我们有图书馆这样的东西。

1705
01:59:46,310 --> 01:59:55,940
现在，越来越多的问题集、项目以及其他方面，你都会更多地使用现成的库，以便解决别人在你之前已经遇到过的问题。

1706
01:59:55,940 --> 01:59:59,570
那么，我现在如何使用这个库 ctype.h？

1707
01:59:59,570 --> 02:00:01,320
好吧，让我回到我的代码中去。

1708
02:00:01,320 --> 02:00:05,090
让我在这里把它加入我的头文件中。

1709
02:00:05,090 --> 02:00:08,030
为了方便浏览，我倾向于按字母顺序排列标题。

1710
02:00:08,030 --> 02:00:13,400
但严格来说，这并不是必须的，但它能让我一目了然地意识到，我是否包含了我需要的东西？

1711
02:00:13,400 --> 02:00:15,570
现在，让我来做这件事。

1712
02:00:15,570 --> 02:00:28,910
原来，如果你阅读 C 类型库的文档，会发现有一个函数，奇妙地叫做 if islower，它的参数是一个字符，本质上就是 s[i]。

1713
02:00:28,910 --> 02:00:33,890
如果返回值为 true（一个布尔值），我将强制它小写。

1714
02:00:33,890 --> 02:00:36,560
但我不用再做这样的计算了。

1715
02:00:36,560 --> 02:00:45,060
原来，在 C 类型库中，也有一个调用 upper 的函数，它将一个字符作为输入，如 s[i]，然后它就会帮你计算。

1716
02:00:45,060 --> 02:00:50,400
这样，你就可以抽象出 32 件事，只知道别人已经为你解决了这个问题。

1717
02:00:50,400 --> 02:00:55,200
否则，我可以保持下面的代码不变，因为我不会更改任何其他内容。

1718
02:00:55,200 --> 02:01:03,710
因此，如果我现在将大写字母改为./uppercase，D-a-v-i-d，只用大写字母 D，现在它仍然可以工作。

1719
02:01:03,710 --> 02:01:07,520
但如果你进一步阅读文档，就会发现 "upper"（上）才是明智之举。

1720
02:01:07,520 --> 02:01:13,040
如果你输入的字符是小写的大写字母，它显然会通过数学运算将其转换为大写字母。

1721
02:01:13,040 --> 02:01:21,540
但是，如果你传入一个已经是大写的字符到 upper，你看到的文档会告诉你，它会保持不变。

1722
02:01:21,540 --> 02:01:23,910
这样我就能把这些都收紧。

1723
02:01:23,910 --> 02:01:25,880
我可以摆脱整个其他。

1724
02:01:25,880 --> 02:01:33,620
现在，我可以摆脱整个程序，实施一个同样正确但设计更好的程序。

1726
02:01:34,250 --> 02:01:39,740
代码行数更少，更容易阅读，出错概率更低，前提是库是正确的。

1727
02:01:39,740 --> 02:01:43,160
现在，它能让我更轻松、更快速地编写代码。

1728
02:01:43,160 --> 02:01:50,190
所以，如果我现在再做最后一次，输入大写字母，回车，./uppercase，然后输入我的名字，仍然有效。

1729
02:01:50,190 --> 02:01:57,740
但现在请注意，我们已经将代码行数减少了很多，尽管现在使用了这个额外的库。

1730
02:01:57,740 --> 02:02:00,140
有问题吗？

1731
02:02:03,930 --> 02:02:09,120
我敢说，尽管这段代码是正确的，但还不一定是精心设计的。

1732
02:02:09,120 --> 02:02:17,900
事实上，在当前的实现中，有一行代码、一个函数调用的效率比它需要的还要低。

1733
02:02:17,900 --> 02:02:24,320
请大家注意这里的第 10 行，我们正在调用 strlen。

1734
02:02:24,320 --> 02:02:29,000
但我们是在 for 循环中调用它，特别是在条件中。

1735
02:02:29,000 --> 02:02:33,720
为什么这不一定是最好的主意呢？

1736
02:02:33,720 --> 02:02:36,810
那么，字符串的长度是否一直在变化？

1737
02:02:36,810 --> 02:02:38,950
我的意思是，肯定不是在这个循环的范围内。

1738
02:02:38,950 --> 02:02:45,242
因此，我们在第 10、11、12 和 13 行的 for 循环中，每次迭代都会问同一个问题。

1739
02:02:45,242 --> 02:02:48,330
s 的长度是多少？

1740
02:02:48,330 --> 02:02:52,660
反过来，我们每次都要调用 strlen，尽管得到的答案是一样的。

1741
02:02:52,660 --> 02:02:59,490
因此，我敢说，更好的解决办法是在代码的前面找出 s 的长度，然后声明一个变量。

1742
02:02:59,490 --> 02:03:07,860
或者，也可以做一些语法上更优雅的事情，事实上，在这样的循环中，一个非常常见的设计是，不只声明一个像 i 这样的变量、

1743
02:03:07,860 --> 02:03:16,530
但实际上，如果要声明第二个变量 n，例如 n 只是一个数字，则应将 n 设置为等于 s 的长度。

1744
02:03:16,530 --> 02:03:24,540
但此后，在这个条件中，我不再一次又一次地调用 s 的 strlen，而是该怎么做呢？

1745
02:03:24,540 --> 02:03:32,730
我可以直接将 i 与 n 本身进行比较，因为现在 n 只会在初始化时计算一次，就像 i 初始化为零一样。

1746
02:03:32,730 --> 02:03:37,350
此后，我们将把正在变化的 i 与不会变化的 n 进行比较。

1747
02:03:37,350 --> 02:03:40,330
因此，从设计上讲，它的效率会略有提高。

1748
02:03:40,330 --> 02:03:47,100
尽管如此，一个好的编译器也能识别出这种优化的可能性，并为我们做到这一点。

1749
02:03:47,100 --> 02:03:54,010
但现在，最好还是养成习惯，培养肌肉记忆，以便自己做出更好的设计决定。

1750
02:03:54,010 --> 02:03:56,380
那么，我们是如何做到这一点的呢？

1752
02:03:59,650 --> 02:04:03,050
好了，今天的最后几项内容。

1753
02:04:03,050 --> 02:04:13,090
因此，我们首先讨论了 clang 使用的命令行参数，即在提示符下键入的命令后的任何内容，无论是 make

1754
02:04:13,090 --> 02:04:21,350
或 clang，甚至 Linux 中的 CD，其后的任何单词，或像 -o 这样的隐晦词都是命令行参数。

1755
02:04:21,350 --> 02:04:22,840
这是命令的输入。

1756
02:04:22,840 --> 02:04:27,280
它不同于函数参数，因为函数参数当然是函数的输入。

1757
02:04:27,280 --> 02:04:28,345
但想法是一样的。

1758
02:04:28,345 --> 02:04:30,970
只是提示符后的语法不同而已。

1759
02:04:30,970 --> 02:04:41,800
原来，命令行参数可以通过访问提示符后的单词在自己的程序中使用。

1760
02:04:41,800 --> 02:04:45,410
请允许我提议，我们可以这样来发明它。

1761
02:04:45,410 --> 02:04:53,560
我建议我们切换回 VS 代码，然后在这里打开一个名为 greet.c 的新文件。

1762
02:04:53,560 --> 02:04:57,070
因此，在 greet.c 中，它将是一个非常简单地问候用户的程序。

1763
02:04:57,070 --> 02:04:59,440
如果我们上周写这篇文章，我们就会这样做。

1764
02:04:59,440 --> 02:05:15,980
包括 cs50.h，然后包括 stdio.h，然后 int main void，然后我们可能会做一些简单的事情，比如字符串 name 等于 getString，引号 unquote，"你叫什么名字？"

1765
02:05:15,980 --> 02:05:21,490
然后，我们会一如既往地打印出 "Hello, %s"，然后输入该名称。

1766
02:05:21,490 --> 02:05:29,140
所以，这是我们已经实施过多次的相同程序，只是为了确保它能正常运行--不过，不对，这不是完全相同的程序。

1767
02:05:29,140 --> 02:05:30,940
分号的位置不对。

1768
02:05:30,940 --> 02:05:32,960
现在是同一个程序。

1769
02:05:32,960 --> 02:05:37,610
因此，请输入问候语，点 ./问候语，我会输入自己的名字。你好，戴维。

1770
02:05:37,610 --> 02:05:38,770
所以我们又回到了那里。

1771
02:05:38,770 --> 02:05:44,110
现在，可以说这个程序有点恼人的是，如果我输入其他内容，比如卡特、

1772
02:05:44,110 --> 02:05:48,910
回车，我必须运行程序，等待提示，输入我的名字，按回车键。

1773
02:05:48,910 --> 02:05:52,360
这很好，但想象一下，如果每个程序都是这样运行的。

1774
02:05:52,360 --> 02:05:58,540
比如 make，假设你只能键入 make，然后等待提示，接着键入要制作的程序名称，然后按 Enter。

1775
02:05:58,540 --> 02:06:07,930
更糟糕的是，在 Linux 中，当你需要更改目录时，比如要解决一个问题时，如果你必须键入 CD、回车，然后键入要更改的文件夹名称、回车----

1776
02:06:07,930 --> 02:06:09,710
我的意思是，这只会让生活变慢。

1777
02:06:09,710 --> 02:06:11,470
所以很快就会让人厌烦。

1778
02:06:11,470 --> 02:06:16,070
因此，命令行参数可以让你一次性表达你的全部想法。

1779
02:06:16,070 --> 02:06:18,200
那么，我该怎么做呢？

1780
02:06:18,200 --> 02:06:22,450
好吧，如果我想在代码中表达命令行参数的概念、

1781
02:06:22,450 --> 02:06:25,640
我可以这样做

1782
02:06:25,640 --> 02:06:34,780
这是我第一次可以上天入地，摆脱这种无效状态，也就是从今天开始，这个程序不需要命令行参数了。

1783
02:06:34,780 --> 02:06:37,540
我可以把它改成这样。

1784
02:06:37,540 --> 02:06:43,490
Int argc，字符串 argv，带括号。

1785
02:06:43,490 --> 02:06:44,950
诚然，现在它很隐晦。

1786
02:06:44,950 --> 02:06:46,150
让我放大画面。

1787
02:06:46,150 --> 02:06:49,300
但我认为，我们现在或许可以推断出发生了什么。

1788
02:06:49,300 --> 02:06:59,230
如果现在的 main 没有 void 作为输入，这意味着它不需要参数，当然，这里的剧透是，现在的 main 将以某种方式获取命令行参数。

1789
02:06:59,230 --> 02:07:05,180
猜猜 argv 现在是什么样子，将来会是什么样子？

1790
02:07:05,180 --> 02:07:08,330
这可能代表什么？

1791
02:07:08,330 --> 02:07:11,390
根据语法，这是一个字符串数组。

1793
02:07:13,223 --> 02:07:15,480
观众：所有的字符都会打出来。

1794
02:07:15,480 --> 02:07:16,050
大卫-马兰：没错。

1795
02:07:16,050 --> 02:07:19,830
这将是您在提示符下输入的所有字符，或者说所有单词。

1796
02:07:19,830 --> 02:07:21,765
Argc，作为一个 int，猜猜看？

1797
02:07:24,360 --> 02:07:30,290
一般来说，"论据数 "代表的是 "论证次数"，不过从技术上讲，你可以把这些东西叫做任何东西。

1798
02:07:30,290 --> 02:07:31,520
但这就是惯例。

1799
02:07:31,520 --> 02:07:41,420
因为我之前说过数组不会记录自己的长度，所以如果你想知道人类在你的程序名称后面的提示符下输入了多少个字，你必须被告知、

1800
02:07:41,420 --> 02:07:45,650
不仅是单词数组，还有数组的长度。

1801
02:07:45,650 --> 02:07:55,020
使用 strlen 可以计算出字符串的长度，但无法计算出字符串数组的长度，即人类输入的单词集合的长度。

1802
02:07:55,020 --> 02:07:56,760
那么，我现在该如何使用它呢？

1803
02:07:56,760 --> 02:07:59,190
好吧，让我来做这件事。

1804
02:07:59,190 --> 02:08:04,190
让我现在就把这个程序改成 printf，引号后加引号、

1805
02:08:04,190 --> 02:08:11,630
"hello, %2 /n"，则 argv[1]。

1806
02:08:11,630 --> 02:08:14,780
因此，这还不是我的代码的最佳版本，但这是我的第一个版本。

1807
02:08:14,780 --> 02:08:21,020
打招呼，现在让我一次完成 ./greet, David。

1808
02:08:21,020 --> 02:08:23,210
进来，你好，戴维。

1809
02:08:23,210 --> 02:08:25,820
现在让我再运行一次，./问候，卡特。

1810
02:08:25,820 --> 02:08:27,620
进来，你好，卡特

1811
02:08:27,620 --> 02:08:32,330
这只是微不足道的改进，但我不必等待 getString 提示我按回车键。

1812
02:08:32,330 --> 02:08:34,370
这只是加快了速度，快了一倍。

1813
02:08:34,370 --> 02:08:36,890
少输入一条命令

1814
02:08:36,890 --> 02:08:41,390
但我故意做了 [1]，但 argv 的开头是什么？

1815
02:08:41,390 --> 02:08:42,170
应该是 [0]。

1816
02:08:44,730 --> 02:08:45,780
那是什么？

1817
02:08:45,780 --> 02:08:48,840
这有时是有用的，但目前还没有。

1818
02:08:48,840 --> 02:08:54,110
假设我现在重新编译代码并运行这个程序，向大卫问好。

1819
02:08:54,110 --> 02:08:58,598
有人想猜猜 argv[0] 中的内容吗？

1821
02:08:59,530 --> 02:09:00,220
再说一遍？

1822
02:09:00,220 --> 02:09:01,230
观众：Greet, hello.

1823
02:09:01,230 --> 02:09:04,530
DAVID MALAN：Greet（问候），Enter（输入），hello（你好），./greet（问候）。

1824
02:09:04,530 --> 02:09:14,460
因此，如果你想对你的程序进行初探，找出它自己的名字，或者至少知道它是如何在命令行、终端上执行的，你可以查看 argv[0]。

1825
02:09:14,460 --> 02:09:21,900
总的来说，可能用处不大，最好还是从 [1] 开始看起，这是程序名称后面的第一个词。

1826
02:09:21,900 --> 02:09:27,690
如果有更多，我可以这样做 argv[2] 怎么样，让我添加第二个 %s。

1827
02:09:27,690 --> 02:09:29,550
让我重新编译问候语。

1828
02:09:29,550 --> 02:09:37,112
让我输入 ./greet David Malan，回车，现在也可以了，按提示输入了两个单词。

1829
02:09:37,112 --> 02:09:38,820
如果我现在真的想在这个问题上耍小聪明的话、

1830
02:09:38,820 --> 02:09:40,445
不过，我可以这样做。

1831
02:09:40,445 --> 02:09:58,440
如果参数数（又称 argc）等于等于，那么假定人类只输入了自己的名字，并执行 printf hello comma %s /n，然后输入 argv[1]。

1832
02:09:58,440 --> 02:10:07,890
否则，如果人类没有提供准确的两个参数，即程序名称和他们自己的姓名，我们就打印出一个默认值，以免他们忘记自己的姓名

1833
02:10:07,890 --> 02:10:09,990
或者他们输入了两个或三个名字。

1834
02:10:09,990 --> 02:10:13,110
让我们把 "你好，逗号世界 "作为默认设置。

1835
02:10:13,110 --> 02:10:15,270
我们将忽略人类输入的内容。

1836
02:10:15,270 --> 02:10:20,850
如果我重新编译，制作问候语，我就可以再次执行 ./greet 和 David，回车。

1837
02:10:20,850 --> 02:10:24,840
哎呀--对不起，我漏掉了什么？

1838
02:10:24,840 --> 02:10:26,640
是啊，新手的错误。

1839
02:10:26,640 --> 02:10:30,090
否则，好吧，再打一次招呼。

1840
02:10:30,090 --> 02:10:34,050
./你好，戴维，回车，这是我的你好，戴维。

1841
02:10:34,050 --> 02:10:37,870
但如果我省略自己的名字，就会得到通用值，就像默认值一样。

1842
02:10:37,870 --> 02:10:41,590
如果我有点好奇，同时输入两个名字，也会被忽略。

1844
02:10:42,090 --> 02:10:44,880
因为我还没有为三个 argc 建立支持。

1845
02:10:44,880 --> 02:10:50,730
我可以做任何我想做的事情，但现在我们可以使用这些积木了。

1846
02:10:50,730 --> 02:10:52,780
好吧，我还能在这里做什么？

1847
02:10:52,780 --> 02:10:57,660
事实证明，我们现在可能需要执行一些最终功能。

1848
02:10:57,660 --> 02:11:06,180
不过请注意，在 C 语言中，尽管你可能会在书本或在线教程中看到，但如今定义主函数的两种正式格式是

1849
02:11:06,180 --> 02:11:17,880
要么是这个，我们已经用了两个多星期了；要么是这个，你把 void 改成 int argc，然后现在是字符串 argv，然后是空括号。

1850
02:11:17,880 --> 02:11:21,400
我们会发现，这也是一种简化，可以说是一种训练。

1851
02:11:21,400 --> 02:11:27,840
但现在，这是两种形式，尽管你会在在线教程甚至书籍中看到，有些人以不同的方式使用 main。

1852
02:11:27,840 --> 02:11:30,142
这是现在需要牢记的两点。

1853
02:11:30,142 --> 02:11:33,360
我要指出的是，这些命令行参数有点杂乱无章。

1854
02:11:33,360 --> 02:11:35,590
可能没想到会在这里的屏幕上看到这个词。

1855
02:11:35,590 --> 02:11:36,490
这意味着什么？

1856
02:11:36,490 --> 02:11:41,880
事实证明，几十年来，Linux 系统自带的一个程序叫做 cowsay。

1858
02:11:42,510 --> 02:11:51,520
可能是因为有一次有人闲得无聊，决定写一个程序，把一头牛在屏幕上说的文字创作成 ASCII 艺术。

1859
02:11:51,520 --> 02:11:55,780
但你使用 cowsay，只是为了好玩，通过命令行参数的方式。

1860
02:11:55,780 --> 02:12:04,770
例如，我建议回到 VS Code，这并不是因为我想写代码，而是我想使用我的终端窗口。

1861
02:12:04,770 --> 02:12:07,320
让我最大化终端窗口。

1862
02:12:07,320 --> 02:12:13,170
让我继续输入 "cowsay "和 "space moo "怎么样？

1863
02:12:13,170 --> 02:12:14,822
所以，cowsay 并不是我写的程序。

1864
02:12:14,822 --> 02:12:16,030
它已经存在了几十年。

1865
02:12:16,030 --> 02:12:18,870
但我们在云中为您将其安装到了 VS 代码中。

1866
02:12:18,870 --> 02:12:21,330
它至少需要一个命令行参数。

1867
02:12:21,330 --> 02:12:23,070
你想让奶牛说什么？

1868
02:12:23,070 --> 02:12:29,490
我可以说 "cowsay moo"，然后点击回车键，瞧，屏幕上就出现了我的 ASCII 艺术作品--一头牛在说 "哞"。

1869
02:12:29,490 --> 02:12:31,090
它可以说多个单词。

1870
02:12:31,090 --> 02:12:33,960
这样我就可以说，你好，世界，输入。

1871
02:12:33,960 --> 02:12:35,800
现在它说，你好，世界。

1872
02:12:35,800 --> 02:12:40,470
因此，这只是一个使用命令行参数的傻瓜程序的例子，但它也会使用其他参数。

1873
02:12:40,470 --> 02:12:45,750
就像 clang 一样，使用连字符来改变程序的输出。

1874
02:12:45,750 --> 02:12:53,520
Dash something 只是命令行参数的一个超级通用约定，当你想用非常简洁的符号来表示某些选项（如输出）时，就可以使用它。

1875
02:12:53,520 --> 02:13:03,460
在 "奶牛 "中，我阅读了文档，发现有一个破折号 f 命令行参数，可以改变奶牛的外观。

1876
02:13:03,460 --> 02:13:11,640
所以，如果我用 cowsay 破折号 f、duck，再加上其他一些词，比如 quack，它就不再是一头牛了。

1877
02:13:11,640 --> 02:13:15,850
命令行参数会把它变成一只可爱的小鸭子。

1878
02:13:15,850 --> 02:13:20,790
最后，只是为了好玩，因为我花了太多时间玩命令行参数。

1879
02:13:20,790 --> 02:13:27,910
Cowsay dash f, dragon, and then how about, rawr, Enter, you can even get this on the screen here.

1880
02:13:27,910 --> 02:13:34,230
因此，这也只是一个例子，说明我们有了这个构建模块后，可以用这些命令行参数做些什么。

1881
02:13:34,230 --> 02:13:36,960
最后，我们还可以用代码做一件事。

1882
02:13:36,960 --> 02:13:48,450
在我们将所有这些点与可读性和加密连接起来之前，我们今天还要介绍最后一个功能，即退出状态。

1883
02:13:48,450 --> 02:13:58,260
原来，每当主函数退出时，它都会返回一个秘密整数，作为程序员或高级用户，你可以猜出它是什么。

1884
02:13:58,260 --> 02:14:02,398
这些退出代码、退出状态通常用来表示错误。

1885
02:14:02,398 --> 02:14:08,560
例如，在过去的几年里，如果你使用缩放功能时出现了错误，你可能会看到这样的屏幕。

1886
02:14:08,560 --> 02:14:11,040
通常没有什么帮助，也许会告诉你点击

1887
02:14:11,040 --> 02:14:13,050
报告问题或联系技术支持。

1888
02:14:13,050 --> 02:14:23,640
但在我们人类世界的 Mac、PC 和手机上，你经常会看到隐晦的错误代码，比如字面上的数字，可能只有 Zoom、微软、谷歌或其他公司知道。

1889
02:14:23,640 --> 02:14:25,050
编写了您正在使用的软件。

1890
02:14:25,050 --> 02:14:32,070
但这个数字对应的是某个地方的某个人知道很可能会发生的特定错误。

1891
02:14:32,070 --> 02:14:38,260
虽然名称不同，但在网络上也有类似的用法，我们稍后将讨论。

1892
02:14:38,260 --> 02:14:41,350
你见过这种情况吗--也许不是性格，而是数量？

1893
02:14:41,350 --> 02:14:43,485
那么，404 意味着什么？

1894
02:14:43,485 --> 02:14:44,880
错误：错误。

1895
02:14:44,880 --> 02:14:47,790
DAVID MALAN：所以，错误，是的，但真的，没有找到。

1897
02:14:48,410 --> 02:14:49,993
我的意思是，这是最神秘的事情。

1898
02:14:49,993 --> 02:14:57,500
我们将在几周后讨论这个数字和其他数字的含义，但在技术领域，数字无处不在，它们通常对技术人员来说意味着什么。

1899
02:14:57,500 --> 02:15:00,270
而对你我这样的人来说，就不那么重要了。

1900
02:15:00,270 --> 02:15:05,900
为什么我们这么多人都认识 404，这有点奇怪，因为它已经存在了足够长的时间，我们都知道它。

1901
02:15:05,900 --> 02:15:10,250
但它实际上只是一个特殊的数字，代表着某种错误。

1902
02:15:10,250 --> 02:15:18,200
事实证明，我们今天要揭示的最后一件事，就是这两周来我们一直认为理所当然的事情--主要的 int 是什么。

1903
02:15:18,200 --> 02:15:24,680
刚才我们已经看到，括号中的内容到目前为止都是无效的，这意味着没有命令行参数。

1904
02:15:24,680 --> 02:15:29,690
现在 int argc string argv 括弧的意思就是，是的，命令行参数。

1905
02:15:29,690 --> 02:15:31,290
我们已经知道了如何访问它们。

1906
02:15:31,290 --> 02:15:37,460
因此，老实说，在过去两周所有的隐晦语法中，最后一块拼图就是 int 的含义。

1907
02:15:37,460 --> 02:15:46,010
Int 始终存在于 main 中，它表明 main 将始终返回一个整数，尽管你我从未明确这样做。

1908
02:15:46,010 --> 02:15:53,928
通常，main 默认返回 0。但如果你看到的错误信息是 0，那就太奇怪了，所以 0 被隐藏起来了。

1909
02:15:53,928 --> 02:15:55,470
你永远不会在屏幕上看到它。

1910
02:15:55,470 --> 02:15:58,670
但由于 C 语言的设计方式，这一切都会自动发生。

1911
02:15:58,670 --> 02:16:01,550
所以，让我在这里写最后一个程序。

1912
02:16:01,550 --> 02:16:05,750
例如，我会调用 status.c 向你展示这些退出状态。

1913
02:16:05,750 --> 02:16:21,350
status.c 的代码，然后在这里，让我做一些简单的事情，比如包含 cs50.h，然后包含 stdio.h，然后 int main -- 实际上，让我们使用命令行参数。 int argc，字符串 argv[]、

1914
02:16:21,350 --> 02:16:23,180
这就是复制、粘贴。

1915
02:16:23,180 --> 02:16:26,000
但现在，让我们这样做吧。

1916
02:16:26,000 --> 02:16:30,780
如果 argc 不等于 -- 为什么我们不这样做呢？

1917
02:16:30,780 --> 02:16:33,740
我们不要像上次一样，只默认为 "你好，世界"。

1918
02:16:33,740 --> 02:16:34,770
让我们对用户大喊大叫吧。

1919
02:16:34,770 --> 02:16:43,160
因此，我们可以说printf 缺少命令行参数这样的话，这样他们就知道自己搞砸了，需要重新正确运行程序。

1920
02:16:43,160 --> 02:16:56,730
否则，就像之前一样，打印出 "你好，逗号 %s"，然后输入 argv[1]，即提示符中的人名。

1921
02:16:56,730 --> 02:17:03,590
现在，让我继续运行状态，./status，我先什么也不输入。

1922
02:17:03,590 --> 02:17:04,700
我被骂了。

1923
02:17:04,700 --> 02:17:10,170
这次，我再输入./status David，就可以正常工作了。

1924
02:17:10,170 --> 02:17:14,090
不过，现在让我给你看一个有点秘密的、隐秘的命令。

1925
02:17:14,090 --> 02:17:18,740
你可以在提示符下输入这个，只是巧合的是，这里还有一个美元符号。

1926
02:17:18,740 --> 02:17:25,490
Echo $?（回声 $?），完全神秘，但它可以让你看到程序结束时的退出状态。

1927
02:17:25,490 --> 02:17:27,558
所以，让我用错误的方式再跑一次。

1928
02:17:27,558 --> 02:17:31,039
./status，我得到了错误信息。

1929
02:17:31,040 --> 02:17:32,780
秘密归还了什么？

1930
02:17:32,780 --> 02:17:33,440
我看不到。

1931
02:17:33,440 --> 02:17:37,280
显然没有错误屏幕，但输入 echo $?

1932
02:17:37,280 --> 02:17:42,170
我可以看到，哦，我的程序默认自动返回 0。

1933
02:17:42,170 --> 02:17:48,690
不过，如果我再次正确运行 ./status David，回车，这就是正确的版本。

1934
02:17:48,690 --> 02:17:52,879
但如果我再次运行 echo $? status，输入的仍然是 0。

1935
02:17:52,879 --> 02:17:55,879
长话短说，这只是错失良机。

1936
02:17:55,879 --> 02:17:59,570
出错时，为什么不返回 0 以外的值？

1937
02:17:59,570 --> 02:18:01,070
默认情况下，0 表示成功。

1938
02:18:01,070 --> 02:18:02,690
它总是自动存在。

1939
02:18:02,690 --> 02:18:04,940
但你可以控制这一点。

1940
02:18:04,940 --> 02:18:11,160
我可以在这里输入我的代码，然后返回 1，否则，如果某些东西工作正常的话、

1941
02:18:11,160 --> 02:18:17,129
默认情况下，我可以返回 0。老实说，如果我省略了返回 0，同样会自动返回 0。

1942
02:18:17,129 --> 02:18:20,718
所以让我先说清楚，好让我知道发生了什么。

1943
02:18:20,718 --> 02:18:26,359
再做一次状态，./status，让我们和大卫一起正确操作。

1944
02:18:26,360 --> 02:18:28,520
进来，你好，戴维。

1945
02:18:28,520 --> 02:18:32,058
回声 $？

1946
02:18:32,058 --> 02:18:33,269
所以一切顺利。

1947
02:18:33,270 --> 02:18:38,240
但现在，如果我执行 ./status 操作，什么都没有，或者执行多个操作，但不只是 David、

1948
02:18:38,240 --> 02:18:40,530
输入后，我收到了错误信息。

1949
02:18:40,530 --> 02:18:45,230
但现在，如果我执行 echo $？

1950
02:18:45,230 --> 02:18:47,330
这意味着什么？

1951
02:18:47,330 --> 02:18:52,459
在图形世界中，我们只需在屏幕上显示类似这样的内容，这对用户来说信息量更大一些。

1952
02:18:52,459 --> 02:18:58,549
但即使在没有图形用户界面的 Linux 世界，即使是我们编写的程序，也可以检查这些退出状态。

1953
02:18:58,549 --> 02:19:07,339
事实上，更自如、更高级的程序员在编写调用程序的代码时，不管是 Cowsay 还是其他任何程序，都可以进行编码、

1954
02:19:07,340 --> 02:19:13,170
检查程序的退出状态，然后决定我的程序是成功了还是失败了？

1955
02:19:13,170 --> 02:19:19,069
现在，在我们散会去吃水果点心之前，让我们把最后的点连起来。

1956
02:19:19,070 --> 02:19:27,650
密码学是本周的应用之一，通过它，你可以发送秘密信息，更好的是，还可以解密秘密信息。

1957
02:19:27,650 --> 02:19:34,040
除此之外，我们还可以使用启发式方法分析文本的可读性，就像我们在第二课开始时确定的那样。

1958
02:19:34,040 --> 02:19:45,980
因此，密码学就是一门艺术，一门对信息进行加密、扰乱的科学，这样，如果你有一条秘密信息要以所谓的明文发送，你就可以通过某种算法来处理它。

1959
02:19:45,980 --> 02:19:49,910
并将其转化为所谓的密文，从而对其进行加密。

1960
02:19:49,910 --> 02:19:59,880
从理论上讲，只有知道你使用了什么算法以及你对算法使用了什么输入的人，才能解密这一过程，并将其转换回原始信息。

1961
02:19:59,880 --> 02:20:03,030
因此，如果我们使用上周的思维模式，问题就来了。

1962
02:20:03,030 --> 02:20:04,910
下面是输入和输出。

1963
02:20:04,910 --> 02:20:13,640
我在这里提出的目标是获取一些纯文本，比如你想发送的信息，回想一下小学时，你是否曾给朋友或暗恋的人递过一张纸条，上面写着 "我爱你"、

1964
02:20:13,640 --> 02:20:16,910
如果老师或其他人拦截试卷，那就有点尴尬了。

1965
02:20:16,910 --> 02:20:19,490
而在英语中，它只是说 "我爱你"，或者其他什么意思。

1966
02:20:19,490 --> 02:20:22,350
如果你至少能以某种方式加密就更好了。

1967
02:20:22,350 --> 02:20:32,040
但对方需要知道你使用了什么算法，以及该算法的输入是什么，这样才能最终解码所谓的密文，也就是输出。

1968
02:20:32,040 --> 02:20:34,190
那么，今天盒子里装的是什么呢？

1969
02:20:34,190 --> 02:20:37,970
那么，与密码学有关的算法被称为密码。

1970
02:20:37,970 --> 02:20:43,250
密码是一种将文本从明文加密为密文的算法的别称。

1971
02:20:43,250 --> 02:20:48,750
问题是，不仅需要有算法，还需要有输入。

1972
02:20:48,750 --> 02:20:53,090
比如说，你今天可能第一次这样画图。

1973
02:20:53,090 --> 02:20:54,257
我们已经在代码中看到了这一点。

1974
02:20:54,257 --> 02:20:57,180
您可以为函数提供多个输入或参数。

1975
02:20:57,180 --> 02:21:02,510
所以，在这个黑盒子里，你能想象传入你想发送的信息，然后再传入一些秘密吗？

1976
02:21:02,510 --> 02:21:10,310
举个例子，假设我小时候能想到的最简单的事情是，与其寄信 A，我为什么不写 B 呢？

1977
02:21:10,310 --> 02:21:13,070
与其写字母 B，我为什么不写字母 C 呢？

1978
02:21:13,070 --> 02:21:16,280
因此，我可以把英语字母表移动一个空格。

1979
02:21:16,280 --> 02:21:18,740
因此，A 变成 B，B 变成 C，点，点，点、

1980
02:21:18,740 --> 02:21:21,690
Z 变成 A。

1981
02:21:21,690 --> 02:21:24,120
假设这部分故事没有标点符号。

1982
02:21:24,120 --> 02:21:32,090
因此，这是一种非常简单的算法--给每个字母加上一个值，然后将这个值作为密文发送。

1983
02:21:32,090 --> 02:21:41,300
现在，老师和同学不仅要知道你使用了这种旋转算法，也就是所谓的凯撒密码，还要知道你使用了什么数字。

1984
02:21:41,300 --> 02:21:45,200
你是每个字母加 1，每个字母加 2，还是每个字母加 25？

1985
02:21:45,200 --> 02:21:51,165
现在，如果他们超级聪明，而且可能不是故事中的那个年纪，他们也可以尝试所有的可能性。

1986
02:21:51,165 --> 02:21:53,040
这将是对算法的攻击。

1987
02:21:53,040 --> 02:21:56,970
这种算法并不复杂，但足以在课堂上传递信息。

1988
02:21:56,970 --> 02:22:06,950
因此，如果现在的两个输入是作为纯文本信息的 HI！和作为所谓密钥（即只有你和对方知道的秘密数字）的 1，那么你

1989
02:22:06,950 --> 02:22:11,040
可能会从一个方面对信息进行加密。

1990
02:22:11,040 --> 02:22:16,198
因此，在这种情况下，举例来说，"HI！"就会变成 "I-J-！"。

1991
02:22:16,198 --> 02:22:19,823
在这一版本的算法中，我们不打算使用数字或标点符号。

1992
02:22:19,823 --> 02:22:23,090
我们只对 A 到 Z 进行操作，无论是大写还是小写。

1993
02:22:23,090 --> 02:22:33,440
因此，现在如果你在课堂上收到一张写有 I-J 的纸条，只要你知道发件人用的是 I-J，作为收件人的你就会知道它是什么、

1994
02:22:33,440 --> 02:22:36,500
因为你只是颠倒了算法，而是减去了 1。

1995
02:22:36,500 --> 02:22:42,975
老师可能不知道这是什么意思，他们也不会花时间去破解信息，所以对他们来说，这看起来就是乱码。

1996
02:22:42,975 --> 02:22:44,600
这就是我们从加密中得到的。

1997
02:22:44,600 --> 02:22:52,700
无论是在课堂上还是在现实世界中，无论是在互联网上还是在其他任何地方，被拦截的人实际上都无法弄清楚，理想情况下，你发送的是什么。

1998
02:22:52,700 --> 02:22:56,300
当然，与之相反的情况确实叫做解密，但过程是一样的。

1999
02:22:56,300 --> 02:22:58,370
我们现在通过负 1。

2000
02:22:58,370 --> 02:23:00,300
这样如何？

2001
02:23:00,300 --> 02:23:02,840
我们为什么不在这里以示威结束呢？

2002
02:23:02,840 --> 02:23:08,360
UIJT XBT DT50--有一些信息。

2003
02:23:08,360 --> 02:23:14,180
如果我们把它传进去，然后做负 1，那么我们如何取出明文呢？

2004
02:23:14,180 --> 02:23:18,200
好吧，如果这是密文，我们从每个字母中减去 1、

2005
02:23:18,200 --> 02:23:28,010
我认为 U 变成了 T，I 变成了 H，J 变成了 I，T 变成了 S，X 变成了 W、

2006
02:23:28,010 --> 02:23:37,580
B 变成 A，T 变成 S，D 变成 C，T 变成 S，这就是 CS50。

2007
02:23:37,580 --> 02:23:40,250
出门时吃只鸭子，在大厅里吃点小吃。

