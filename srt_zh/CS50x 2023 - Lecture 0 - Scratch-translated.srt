1
00:00:02,988 --> 00:00:06,474
[MUSIC PLAYING]

2
00:01:13,310 --> 00:01:15,260
DAVID J. MALAN: All right.

3
00:01:15,260 --> 00:01:22,940
This is CS50, Harvard University's introduction to the intellectual enterprises of computer science and the arts of programming.

4
00:01:22,940 --> 00:01:27,660
My name is David Malan, and I actually took this course myself, back in 1996.

5
00:01:27,660 --> 00:01:29,382
I was a sophomore at the time.

6
00:01:29,382 --> 00:01:40,200
I was actually concentrating in government, because a year prior, as a first year, I'd come into Harvard thinking that I liked history and constitutional law and similar classes in high school.

7
00:01:40,200 --> 00:01:44,180
And so when I got here, I rather gravitated toward that which was familiar.

8
00:01:44,180 --> 00:01:50,300
I figured, if I liked and if I were good at that particular subject in high school, then that's presumably who I'm supposed to be here.

9
00:01:50,300 --> 00:01:57,680
But it wasn't until sophomore year that I got up the nerve to step foot in the CS50 classroom, and even then, it was only out of curiosity.

10
00:01:57,680 --> 00:02:03,170
Like I had no intention of studying computer science of even taking CS50 when I got to campus.

11
00:02:03,170 --> 00:02:07,400
But people were talking about it, and there was a lot of beware.

12
00:02:07,400 --> 00:02:12,560
And it was perhaps for the initiated only, and I didn't really ultimately what computer science was.

13
00:02:12,560 --> 00:02:15,800
But for me, the light bulb went off.

14
00:02:15,800 --> 00:02:24,830
I found that, contrary to what I'd seen in high school, where I saw friends of mine like programming away in the computer lab, heads down, antisocially just doing whatever it was they were doing,

15
00:02:24,830 --> 00:02:29,280
it really wasn't that, once I got to this particular class and this particular place.

16
00:02:29,280 --> 00:02:34,852
It was much more about problem solving more generally and just learning how to express yourself in code, in different languages.

17
00:02:34,852 --> 00:02:37,310
So that you can actually solve problems of interest to you.

18
00:02:37,310 --> 00:02:47,280
Even if you have no intention of being a computer scientist or an engineer, but just want to be able to solve problems, analyze data do interesting things, in the arts, humanities, social sciences,

19
00:02:47,280 --> 00:02:49,710
physical sciences, or really any other field.

20
00:02:49,710 --> 00:02:56,090
And indeed, this particular path led me to computer science, but the hope for CS50 more generally is that, indeed, you

21
00:02:56,090 --> 00:03:02,370
just find your way to applying principles that you'll learn over the coming months to whatever field is of interest to you.

22
00:03:02,370 --> 00:03:07,500
With that said, it was definitely a lot of work and not without its frustrations for me.

23
00:03:07,500 --> 00:03:15,630
But there was no better feeling than like banging your head proverbial against the wall for some number of hours, even days, trying to fix a bug, a mistake in your code.

24
00:03:15,630 --> 00:03:23,600
And then, oh my God, the rush of emotion of accomplishment of pride of exhaustion when you finally solve some problem that's really been weighing on you.

25
00:03:23,600 --> 00:03:26,570
It's just so incredibly gratifying but also empowering.

26
00:03:26,570 --> 00:03:31,200
Because unlike a lot of fields, like computer science was built by humans themselves.

27
00:03:31,200 --> 00:03:35,460
And so if a human built this, surely, you, another human, can understand it as well.

28
00:03:35,460 --> 00:03:42,440
And so even though there's going to be some distractions along the way, you're going to see what looks incredibly cryptic, if you've never programmed before.

29
00:03:42,440 --> 00:03:46,402
Over time and with practice, everything just starts to make more sense.

30
00:03:46,402 --> 00:03:49,950
And with time and with practice, you just get better at this particular field.

31
00:03:49,950 --> 00:03:55,530
And indeed, really, the key to success in programming in general is just to allow yourself enough time.

32
00:03:55,530 --> 00:04:00,950
And so at least, thankfully, I quickly got into the habit of starting early in the week, for instance, when writing actual code.

33
00:04:00,950 --> 00:04:03,200
Why? Because you're going to run up against a wall.

34
00:04:03,200 --> 00:04:04,460
You're not going to see some bug.

35
00:04:04,460 --> 00:04:06,470
Something's not going to jump out at you, and that's fine.

36
00:04:06,470 --> 00:04:11,030
That's when you call it a day, take a break, move onto something else, and then just come back to it.

37
00:04:11,030 --> 00:04:16,310
And that's what keeps programming fun for me, even all of these years later, whether it's teaching or actually applying it.

38
00:04:16,310 --> 00:04:22,170
But there's, down the road, a history of an MIT hack, and it looked a little something like this, in yesteryear.

39
00:04:22,170 --> 00:04:25,280
And there was a little sigh the MIT students, when they made this hack.

40
00:04:25,280 --> 00:04:33,890
On the wall it says, getting an education from MIT is like drinking from a fire hose, which indeed they have connected to what should have been otherwise just a water fountain.

41
00:04:33,890 --> 00:04:39,560
And that's going to be what it feels like, sometimes, not just in computer science per se, but just an unfamiliar field.

42
00:04:39,560 --> 00:04:42,740
If you're not from STEM, if you're not from CS, that's fine.

43
00:04:42,740 --> 00:04:49,430
But so much of it, ultimately, is going to be absorbed by you and going to be within your grasp by terms end.

44
00:04:49,430 --> 00:04:57,440
So just keep in mind, that's very much the intent, but you'll be amazed what you're able to create, to accomplish, just three or so months hence.

45
00:04:57,440 --> 00:05:03,140
Indeed, 2/3 of you, contrary to what you might think are assume, have never taken a CS class before.

46
00:05:03,140 --> 00:05:07,550
So it's absolutely not the case that the person to the left or the right surely must know more than you.

47
00:05:07,550 --> 00:05:09,462
Indeed, it's quite the opposite.

48
00:05:09,462 --> 00:05:17,450
And as you'll see in the coming weeks, as you write your own code and solve your own problems, what ultimately matters in this course is not so much where you end up relative to your classmates

49
00:05:17,450 --> 00:05:20,783
but where you end up relative to yourself when you began.

50
00:05:20,783 --> 00:05:27,380
And it really is all about that delta, whether you've programmed or not, just getting something out of a class like this.

51
00:05:27,380 --> 00:05:34,520
And if it does take time, and if you do feel those frustrations, but you simultaneously eventually feel that sense of accomplishment, that just means it's all working.

52
00:05:34,520 --> 00:05:39,712
And indeed, hopefully, all the more worthwhile and gratifying, ultimately, as a result.

53
00:05:39,712 --> 00:05:41,670
So what are we going to do in the coming weeks?

54
00:05:41,670 --> 00:05:43,550
So here we are in week zero.

55
00:05:43,550 --> 00:05:47,480
We'll soon see why computers and computer scientists start counting, if you will, from 0.

56
00:05:47,480 --> 00:05:54,860
But week 0, is one in which we explore computational thinking, thinking like a computer, and starting to clean up your thought processes.

57
00:05:54,860 --> 00:05:59,360
Getting you to think, to solve problems more methodically, and then ultimately, translating that into code.

58
00:05:59,360 --> 00:06:04,520
And some of you might recognize this environment here, a.k.a. Scratch, coincidentally also from MIT.

59
00:06:04,520 --> 00:06:06,350
You might have used it in grade school.

60
00:06:06,350 --> 00:06:11,760
We'll use it today and a little bit this weekend in the course's first homework assignment or problem set.

61
00:06:11,760 --> 00:06:18,990
But not so much to play around in a way that you might have if you did use it in yesteryears, but to explore ideas of computer science and programming

62
00:06:18,990 --> 00:06:22,650
that we're going to use and reuse every week hereafter as well.

63
00:06:22,650 --> 00:06:26,800
Thereafter, we're going to transition just next week to week one, so to speak.

64
00:06:26,800 --> 00:06:31,979
Whereby, we'll introduce you to a more traditional language, a lower level language, an older language called C.

65
00:06:31,979 --> 00:06:39,030
And in C, you're going to use your keyboard, not so much your mouse and pointing and clicking, but you're going to write code that soon is going to look a little something like this.

66
00:06:39,030 --> 00:06:42,120
And if you've programmed before, you can probably glean what this is going to do.

67
00:06:42,120 --> 00:06:47,560
If you've never programmed before, which is the case for most of you, this too will soon make sense.

68
00:06:47,560 --> 00:06:51,120
But this is the most canonical program that most any programmer ever writes

69
00:06:51,120 --> 00:06:59,430
called Hello, World, and indeed, that and all of the surrounding syntax above and below just that sentence Hello, World, will soon make all the more sense.

70
00:06:59,430 --> 00:07:02,250
You'll learn how to use industry-standard tools, so to speak.

71
00:07:02,250 --> 00:07:04,980
Pictured here is something called Visual Studio code, or VS Code.

72
00:07:04,980 --> 00:07:10,678
You'll use a cloud based version of it initially, so you don't have to suffer with any technical difficulties or headaches like that.

73
00:07:10,678 --> 00:07:18,840
It'll just work right off the bat, but we'll use that to others ultimately to then explore ideas in computer science, principles that you can apply.

74
00:07:18,840 --> 00:07:27,210
And we'll take a look underneath the hood, so to speak, of your computer at your memory or RAM, Random Access Memory, where all of the data is ultimately going to be stored.

75
00:07:27,210 --> 00:07:31,470
We'll also take a look thereafter at bugs. A bug is a mistake in a program.

76
00:07:31,470 --> 00:07:41,040
Here is an actual bug in an actual computer in yesteryear, but we'll teach you how to debug programs, find your own mistakes, find others' mistakes, and improve that code as well.

77
00:07:41,040 --> 00:07:47,340
We'll transition then to algorithms, step-by-step instructions for solving some problems, which we'll touch on today too.

78
00:07:47,340 --> 00:07:51,120
And if you picture here, this is actually a pretty representative problem.

79
00:07:51,120 --> 00:07:55,510
Odds are, you haven't had to deal with something like this, but it's representative sorting, for instance.

80
00:07:55,510 --> 00:08:00,810
If you think of each of these small bars as being a small number, each of the bigger bars is being a bigger number,

81
00:08:00,810 --> 00:08:08,478
you might wonder, well, how could you as a human sort all of these bars, like get all the short bars over here, all the big bars over there?

82
00:08:08,478 --> 00:08:16,533
Well, odds are, if you're like me, you would probably kind of eyeball it, and if you could physically interact, you might just start grabbing the smallest elements first, put them over on the left.

83
00:08:16,533 --> 00:08:20,880
Maybe grab the biggest elements, put them over on the right. But what's your algorithm there?

84
00:08:20,880 --> 00:08:24,930
Like how would you teach someone younger than you, who's never done that before, how to do it?

85
00:08:24,930 --> 00:08:28,740
How would you compel your Mac or PC or phone to do something like that?

86
00:08:28,740 --> 00:08:32,572
You can't just wave your hand, and say, oh, figure it out. Move things around.

87
00:08:32,572 --> 00:08:36,815
You have to express yourself more methodically. So we'll translate even ideas like this into code too.

88
00:08:36,815 --> 00:08:42,780
And that's what the Googles and others of the world are doing constantly, as they sort and organize the world's information.

89
00:08:42,780 --> 00:08:45,490
We'll use metaphors along the way, if it helps.

90
00:08:45,490 --> 00:08:48,990
We'll talk about your computer's memory as being like a postal address.

91
00:08:48,990 --> 00:08:57,560
Like every mailbox in the world has some form of postal address, street, city, state, country, and the like, and it turns out, that's how your Mac, your PC, and your phone also work.

92
00:08:57,560 --> 00:09:02,730
You've got a whole bunch of memory, like the picture before, but you can think of it really as individual mailboxes.

93
00:09:02,730 --> 00:09:08,725
And you can put anything you want in those mailboxes, and you can go to a mailbox to grab information that's from it.

94
00:09:08,725 --> 00:09:12,490
So at the end of the day, that's really all your computer is doing with information.

95
00:09:12,490 --> 00:09:18,870
It's just organizing it, not into mailboxes per se, but a term you probably know called bytes, for instance, instead.

96
00:09:18,870 --> 00:09:22,560
We'll talk about problems that arise even nowadays.

97
00:09:22,560 --> 00:09:32,520
In fact, most of you are familiar with your Mac, PC, even phone like spontaneously rebooting sometimes, crashing, the little annoying spinning beach ball or hourglass icon that happens.

98
00:09:32,520 --> 00:09:33,790
Like what is with that?

99
00:09:33,790 --> 00:09:40,110
Well, those are just bugs in programs that humans at Apple and Google and Microsoft and others, they screwed up, and they wrote buggy code.

100
00:09:40,110 --> 00:09:44,290
And your computer, when it encounters those mistakes, doesn't know what to do.

101
00:09:44,290 --> 00:09:50,110
And so 9 times out of 10, so to speak, it just crashes or freezes or the like, but that kind of stuff will make more sense.

102
00:09:50,110 --> 00:09:55,350
So even the real world will make sense, and pictured here are some lower level terms we'll eventually get to mid-semester.

103
00:09:55,350 --> 00:10:02,440
But generally speaking, when something is going this way, as per this arrow, and something is going this way, as per this arrow, like that does not end well.

104
00:10:02,440 --> 00:10:05,250
And that often is what happens when your computer crashes.

105
00:10:05,250 --> 00:10:11,470
Someone's using memory up here, but someone else is using memory down here, and then they're not really talking left hand and right hand.

106
00:10:11,470 --> 00:10:17,010
So that is just a high level overview of some of the problems we'll encounter, but we'll focus to on data, ultimately.

107
00:10:17,010 --> 00:10:20,530
So pictured here is something fairly technical called a hash table.

108
00:10:20,530 --> 00:10:25,110
It's an amalgam of something we're going to soon call an array and also something we call a link to list.

109
00:10:25,110 --> 00:10:34,440
And these are just fancy terms for describing how you can organize information even more flexibly than just putting individual values in mailboxes.

110
00:10:34,440 --> 00:10:40,510
Like how could you build structures, like actual data structures so to speak, two-dimensional structures at that?

111
00:10:40,510 --> 00:10:48,040
And so what you're seeing here is a glimpse, as some of you might have recognized, of some Harry Potter universe names, but they're organized somewhat alphabetically.

112
00:10:48,040 --> 00:10:58,440
And notice, that any time there's multiple people with a name that starts with H, like Hermione, Harry, and Hagrid, well, they can't all fit in that mailbox, if each of these squares along the left is that same mailbox.

113
00:10:58,440 --> 00:11:02,490
So you have to chain them together. Well, you'll learn how to do that in code.

114
00:11:02,490 --> 00:11:07,440
So that even if you get more data than you expect, if your business is booming, and you're some web-based business,

115
00:11:07,440 --> 00:11:12,790
how do you keep adding and adding information to your software to actually keep up with it?

116
00:11:12,790 --> 00:11:16,480
But this, again, is what code's going to soon look like, as soon as next week,

117
00:11:16,480 --> 00:11:25,190
in week one, this here being C, but we'll transition in a few weeks to a more modern, higher level language, so to speak, called Python.

118
00:11:25,190 --> 00:11:33,520
Indeed, the course very deliberately, back in my day and now this, introduces you first to C, which funny enough, many people don't tend to program in certainly every day.

119
00:11:33,520 --> 00:11:40,540
I use C, generally, September, October, November, December, when teaching CS50 itself. But it's everywhere, nonetheless.

120
00:11:40,540 --> 00:11:52,360
In fact, even today's other languages, with which you might be familiar, like Python and Java and yet others still, you see this same primitive language underneath the hood, because it's so darn fast.

121
00:11:52,360 --> 00:11:59,180
And as you'll learn over the coming weeks, it really gives you access to and an understanding of what's going on conceptually down here.

122
00:11:59,180 --> 00:12:05,180
So that thereafter, after CS50, when you're writing code, you can think at a very high level what's actually going on.

123
00:12:05,180 --> 00:12:11,170
So in fact, in just a few weeks, what looks like this in C is going to look instead like this in Python.

124
00:12:11,170 --> 00:12:16,521
And you'll better understand what's going on underneath the hood, and odds are, after this class, you'll reach for a language

125
00:12:16,521 --> 00:12:22,750
like Python more frequently than C, but you're going to benefit from that bottom-up understanding thereof.

126
00:12:22,750 --> 00:12:28,630
Thereafter and towards term's end, we'll introduce you to a few other ideas, like where do you put large amounts of data?

127
00:12:28,630 --> 00:12:32,690
In things called databases, not things like spreadsheets, like here, but actual databases.

128
00:12:32,690 --> 00:12:37,300
We're using those same kinds of data structures, you lay things out in an interesting way in memory.

129
00:12:37,300 --> 00:12:42,010
Thereafter, we'll transition to a very familiar environment that you and I use every day, the web.

130
00:12:42,010 --> 00:12:49,690
Like the web has become rather the User Interface, or UI, that we use everywhere, on the laptops, desktops, and even mobile devices, nowadays.

131
00:12:49,690 --> 00:12:52,360
Well, pictured here is a language called HTML.

132
00:12:52,360 --> 00:12:53,693
It's not a programming language.

133
00:12:53,693 --> 00:12:57,550
It's a markup language, and some of you might have made home pages or portfolios in the past.

134
00:12:57,550 --> 00:13:08,930
But you'll understand what's going on here, but more powerfully, you'll understand how the computer sees that same kind of code, builds up a hierarchical family tree-type structure in memory.

135
00:13:08,930 --> 00:13:16,150
And then you can manipulate that tree with code to actually add more and more information, chat messages, anything on the screen that you like.

136
00:13:16,150 --> 00:13:27,140
And finally, we'll tie all of this together by introducing what are called frameworks and libraries, third-party code that makes it a lot easier to solve problems of interest to you.

137
00:13:27,140 --> 00:13:33,820
And so in particular, here, this is the very first web app that I myself made back in like 1997.

138
00:13:33,820 --> 00:13:41,380
I was part of the first-year intramural sports program, not as an athlete but as the programmer, and I was teaching myself how to build web applications.

139
00:13:41,380 --> 00:13:44,410
I only knew C and maybe a little bit of something else at the time.

140
00:13:44,410 --> 00:13:53,290
But this became, for Harvard at least, the very first website for the first-year intramural sports program, and it wasn't just a static website with links and images and the like.

141
00:13:53,290 --> 00:13:55,570
It was interactive. You could register for sports.

142
00:13:55,570 --> 00:14:01,340
We could input exactly who was in a tournament bracket or the like, and it could actually automatically keep track of this data.

143
00:14:01,340 --> 00:14:07,687
So there too, after just three months of a class like this, you'll go from writing quite simply this week and next Hello, World

144
00:14:07,687 --> 00:14:13,822
to building things like this for whether it's web, mobile, or other platforms as well, if you so choose.

145
00:14:13,822 --> 00:14:17,030
But we'll get you off of the course's infrastructure, by the end of the term.

146
00:14:17,030 --> 00:14:19,570
You won't be using any toy environments along the way.

147
00:14:19,570 --> 00:14:29,980
We'll empower you, ultimately, to write code after CS50, especially if this is the only CS class you ever take, on your own Mac or PC, using the same software, but not the cloud-based version thereof.

148
00:14:29,980 --> 00:14:37,010
But all of this software is itself free and can be used by you powerfully after the course's own end.

149
00:14:37,010 --> 00:14:46,210
But along the way, as you may know, there is this tradition within the class, particularly in healthy times, of a number of events that really brings people get together,

150
00:14:46,210 --> 00:14:52,120
not just collaboratively and academically, but to just solve problems and generally engage with each other as well.

151
00:14:52,120 --> 00:15:00,460
Coming up first, CS50 Puzzle Day, which is meant to be not jigsaw puzzles but logic puzzles that require no prior experience with computer science or programming.

152
00:15:00,460 --> 00:15:07,270
But it's just an opportunity to quietly work on a packet of puzzles with some number of friends for prizes and more.

153
00:15:07,270 --> 00:15:15,910
Later in the semester, once you tackle your final projects, the capstone of the course, where we don't give you a homework to write, you yourself come up with something to build.

154
00:15:15,910 --> 00:15:23,260
We'll get together generally around 7:00 PM in the evening, wrap up around 7:00 AM, if you so choose.

155
00:15:23,260 --> 00:15:33,340
And it's an evening, a 12-hour opportunity to collaborate with classmates on your very own final project, in a large space on campus, that ends-- if you're awake with us-- at 5:00 AM.

156
00:15:33,340 --> 00:15:38,710
We can hop on some CS50 shuttles and go down the road for some pancakes at IHOP around 6:00.

157
00:15:38,710 --> 00:15:43,396
Of course-- of course, this is 6:00, 7:00 AM at that point

158
00:15:43,396 --> 00:15:52,300
but it's an opportunity finally to lead into what's called the CS50 fair, which is an end of semester celebration, an exhibition, of everything that you'll accomplish over the coming months.

159
00:15:52,300 --> 00:15:56,200
And in fact, pictured here are some of your predecessors in healthy times.

160
00:15:56,200 --> 00:16:03,729
The CS50 fair allows you to come with your laptop or phone and exhibits of students, faculty, and staff across campus put together something in person

161
00:16:03,729 --> 00:16:10,150
and on video that people can delight in seeing, as you exhibit what it is you created and what you learned over the course of the several weeks.

162
00:16:10,150 --> 00:16:14,880
And ultimately, a chance to just share and inspire others as well.

163
00:16:14,880 --> 00:16:20,820
And you'll all walk home, ultimately, with your own I took CS50 T-shirts saying as much as well.

164
00:16:20,820 --> 00:16:23,820
So with that high level overview of the course,

165
00:16:23,820 --> 00:16:32,780
I propose that we begin to take a look at what computer science itself is and what it is we're going to be doing over the next several weeks at this lower level too.

166
00:16:32,780 --> 00:16:34,130
So what is computer science?

167
00:16:34,130 --> 00:16:34,630
Right?

168
00:16:34,630 --> 00:16:40,310
If you're maybe like me or new people like my friends in high school, you probably assume that it means programming.

169
00:16:40,310 --> 00:16:48,110
And that's absolutely a big part of it for a lot of people, because with code, you can write, you can express ideas, and solve actual problems, especially involving data.

170
00:16:48,110 --> 00:16:52,100
But computer science itself is really the study of information, if you will.

171
00:16:52,100 --> 00:16:55,170
How do you represent it, and how do you actually process it?

172
00:16:55,170 --> 00:17:04,604
And in that sense, computational thinking is just the application of ideas from computer science, a course like this, to problems of interest to you

173
00:17:04,604 --> 00:17:09,089
again, in the arts, humanities, sciences, social sciences, whatever the domain of interest is to you.

174
00:17:09,089 --> 00:17:16,770
So with that, if computer science is all about information and with it the solving of problems, well, what does it actually mean to solve a problem?

175
00:17:16,770 --> 00:17:21,950
Let's see if we can't propose a model into which all of the lessons learned will ultimately follow.

176
00:17:21,950 --> 00:17:29,070
And I'd propose that this is problem solving. You've got some input, which is like the problem you want to solve. The goal is to solve it.

177
00:17:29,070 --> 00:17:36,233
So that's the so-called output, and then somewhere in here, the proverbial black box, is some kind of secret sauce that gets the work done.

178
00:17:36,233 --> 00:17:42,440
And in the coming months, we'll have to decide, well, how are we going to represent these inputs and outputs, and really, how do we code up?

179
00:17:42,440 --> 00:17:47,310
How do we write solutions for what it is that's solving the problem of interest to us?

180
00:17:47,310 --> 00:17:51,560
So when it comes to representation of information, like there's a lot of ways we can do this.

181
00:17:51,560 --> 00:17:59,340
And for instance, if the problem at hand quite simply is to take attendance at the beginning of class, on the first day of school, well, how could we go about doing this?

182
00:17:59,340 --> 00:18:03,420
Well, we could actually use a system called unary. Well, what is that?

183
00:18:03,420 --> 00:18:08,300
Well, that's a fancy way of saying 1, 2, 3, 4, 5, maybe 6, 7, 8, 9, 10.

184
00:18:08,300 --> 00:18:13,298
And I can use my digits-- pun intended-- on my fingers to actually count everyone up.

185
00:18:13,298 --> 00:18:16,340
And eventually, you need toes and whatnots, if you have to count so high.

186
00:18:16,340 --> 00:18:24,830
But unary is a very simple system of using a single symbol, a human finger in this case, to just solve some problem, like counting the number of people in the room.

187
00:18:24,830 --> 00:18:27,950
Let's make this slightly more technical for a moment, a little more mathy.

188
00:18:27,950 --> 00:18:36,920
That's just called base-1, where the base under which you're operating has one digit in it, like literally a human finger, and maybe multiple such fingers, if you need to count higher.

189
00:18:36,920 --> 00:18:47,180
But of course, most of you, if not all of you, generally, vaguely know that computers use something other than unary-- and even you and I probably don't use this that often-- 

190
00:18:47,180 --> 00:18:50,430
they use what language or alphabet instead.

191
00:18:50,430 --> 00:18:50,930
Yeah.

192
00:18:50,930 --> 00:18:55,980
So binary, so binary is indeed the system that computers somehow use.

193
00:18:55,980 --> 00:19:01,760
So in this case, bi implying two, and so computers have two digits, it turns out, at their disposal.

194
00:19:01,760 --> 00:19:07,490
And in fact, if you've ever heard the technical term bit, which is like a smaller version of a byte-- more on that soon.

195
00:19:07,490 --> 00:19:15,965
Well, a binary digit is the origin of that term "Bit," because if you get rid of some of the letters, and are left from binary digit with just B-I-T, thus is a bit.

196
00:19:15,965 --> 00:19:17,990
A bit is just a 0 and 1.

197
00:19:17,990 --> 00:19:23,030
It's two more digits than you might have on your own finger, and of course, it's fewer though than you and I have.

198
00:19:23,030 --> 00:19:25,820
You and I typically use, as humans, the decimal system.

199
00:19:25,820 --> 00:19:29,390
Dec meaning 10, because you and I generally use 0 through 9.

200
00:19:29,390 --> 00:19:32,930
So on the one hand-- another pun intended-- you've got unary.

201
00:19:32,930 --> 00:19:37,760
Computers use binary. We humans generally think and talk in terms of decimal.

202
00:19:37,760 --> 00:19:44,090
But at the end of the day, these are fundamentally going to be the same thing, which is to say that it's all pretty accessible to us.

203
00:19:44,090 --> 00:19:47,610
Even if you're not a computer person, I daresay you're about to be.

204
00:19:47,610 --> 00:19:53,570
So what is a bit? Well, a bit then is a 0 or a 1. That is a so-called binary digit.

205
00:19:53,570 --> 00:19:56,090
But how do computers only speak in binary?

206
00:19:56,090 --> 00:19:59,360
How do they solve problems, represent information, using only binary?

207
00:19:59,360 --> 00:20:05,300
Well, at the end of the day, if they want to represent 0 and 1, we need to do so physically somehow.

208
00:20:05,300 --> 00:20:11,310
And I daresay that maybe the simplest way to think about a bit, a 0 or a 1, is like a light bulb.

209
00:20:11,310 --> 00:20:20,030
And so by human convention, let's just assume that if you were a computer, be it a laptop, desktop, phone, or the like, and you want to represent the number 0

210
00:20:20,030 --> 00:20:22,770
you know what, you just keep the light switch off.

211
00:20:22,770 --> 00:20:24,290
You keep a light bulb off.

212
00:20:24,290 --> 00:20:30,990
If by contrast, you're that same computer, and you want to represent the number 1, you take that same switch, that same light bulb, and just turn it on.

213
00:20:30,990 --> 00:20:35,840
So a light bulb that's on represents a 1, and a light bulb that's off represents a 0.

214
00:20:35,840 --> 00:20:37,928
So why is this relevant to computers?

215
00:20:37,928 --> 00:20:41,340
Well, at the end of the day, you and I are charging our laptops or phones at night.

216
00:20:41,340 --> 00:20:46,020
So there's some physical resource being replenished there, whether you're on battery or some power cord.

217
00:20:46,020 --> 00:20:51,433
And so inside of a computer are just thousands, millions of tiny little switches, nowadays.

218
00:20:51,433 --> 00:20:55,430
You can think of them metaphorically as light bulbs, but they don't actually shine light.

219
00:20:55,430 --> 00:21:01,430
But there are tiny, tiny little switches, and those switches, if you've ever heard the term, are just called transistors.

220
00:21:01,430 --> 00:21:08,390
So like computers have millions of transistors that can either be flipped on to represent 1's or flipped off to represent 0's.

221
00:21:08,390 --> 00:21:15,110
And from that very simple mechanism, electricity is there, or it's not, a 1 or a 0.

222
00:21:15,110 --> 00:21:23,160
Computers can actually count, obviously, from 0 to 1, but it turns out, even higher, if they use a little more electricity as well.

223
00:21:23,160 --> 00:21:24,420
So how might I do this?

224
00:21:24,420 --> 00:21:28,500
Well, let me go ahead and propose that I just grab one of our own light bulbs here on stage.

225
00:21:28,500 --> 00:21:29,210
This one is off.

226
00:21:29,210 --> 00:21:35,850
So for instance, if this were miniaturized inside of your Mac, PC, or phone, this would be a transistor, and indeed, here's the little switch on the bottom.

227
00:21:35,850 --> 00:21:40,910
And if your computer wants to represent a 0, it just leaves the switch off, and the light is not shining.

228
00:21:40,910 --> 00:21:45,193
If you want to represent a 1, well now, I've counted as high as 1, because the switch is now on.

229
00:21:45,193 --> 00:21:46,610
I've grabbed a little electricity.

230
00:21:46,610 --> 00:21:50,598
I'm holding on to it inside of the computer, and so now I see that this is a 1.

231
00:21:50,598 --> 00:21:53,390
All right, but unfortunately, with just one switch, one light bulb,

232
00:21:53,390 --> 00:21:56,630
I can only count from 0 to 1.

233
00:21:56,630 --> 00:21:59,475
How do I count out higher, might you think, intuitively?

234
00:21:59,475 --> 00:22:00,350
AUDIENCE: [INAUDIBLE]

235
00:22:00,350 --> 00:22:01,070
DAVID J. MALAN: Say it again.

236
00:22:01,070 --> 00:22:01,430
AUDIENCE: More lightbulbs.

237
00:22:01,430 --> 00:22:02,900
DAVID J. MALAN: Yeah, so more light bulbs.

238
00:22:02,900 --> 00:22:03,650
So let me do this.

239
00:22:03,650 --> 00:22:08,270
Let me just grab something to put these on, so I can use a few of them at a time.

240
00:22:08,270 --> 00:22:14,150
And let me propose that here, instead of having just one light bulb, let me give myself maybe three in total.

241
00:22:14,150 --> 00:22:20,540
So all of them are initially off, and if you think of this in miniature form, in your mind's eye, this is like a computer with three transistors.

242
00:22:20,540 --> 00:22:24,860
Three switches representing now the number you and I know as 0.

243
00:22:24,860 --> 00:22:27,150
Why? They're just all off.

244
00:22:27,150 --> 00:22:30,450
So how does a computer go about representing the number 1?

245
00:22:30,450 --> 00:22:33,230
Well, it turns on one of these light bulbs.

246
00:22:33,230 --> 00:22:35,600
And how does the computer represent the number 2?

247
00:22:35,600 --> 00:22:39,900
Well, you might think, if I may, you just turn on a second light bulb.

248
00:22:39,900 --> 00:22:42,290
And if you might think, how does a computer represent 3?

249
00:22:42,290 --> 00:22:44,250
You just turn on the third light bulb.

250
00:22:44,250 --> 00:22:51,020
And so as such, with three bits, a computer would seem to be able to count from 0 on up to 1, 2, 3.

251
00:22:51,020 --> 00:22:53,480
But it turns out, if I'm a little smarter here,

252
00:22:53,480 --> 00:22:55,760
I can actually count higher than that.

253
00:22:55,760 --> 00:22:59,060
Why? Well, I'm just considering the combination of bulbs being on here.

254
00:22:59,060 --> 00:23:00,435
What if I do something like this?

255
00:23:00,435 --> 00:23:08,840
This is still 0, I will claim, but what if I propose now that this will be how a computer represents 1-- on, off, off.

256
00:23:08,840 --> 00:23:12,680
This, though, will be how the computer represents 2.

257
00:23:12,680 --> 00:23:14,360
Notice, I didn't turn on the same two.

258
00:23:14,360 --> 00:23:16,430
I'm just turning on the one in the middle.

259
00:23:16,430 --> 00:23:19,820
This I now claim will be how a computer represents 3.

260
00:23:19,820 --> 00:23:28,550
This is going to be-- in just a second-- how a computer represents the number we know as 4, and yet, I'm still only using three bulbs.

261
00:23:28,550 --> 00:23:32,600
This is going to be the number the computer represents as 5.

262
00:23:32,600 --> 00:23:42,380
This is going to be how the computer represents the number 6, and then lastly, it turns out, with three light bulbs, if you're smart about it, you can count it seems as high as 7.

263
00:23:42,380 --> 00:23:46,220
Now, even if you lost track of what I was turning on and why,

264
00:23:46,220 --> 00:23:50,470
I claim there were eight different patterns, from all of them off to all of them on.

265
00:23:50,470 --> 00:23:52,220
But notice that I started to permute them.

266
00:23:52,220 --> 00:23:55,220
I took into account which ones were on and which ones were off.

267
00:23:55,220 --> 00:23:59,600
Why, though, do these represent the numbers we know as 0 through 7?

268
00:23:59,600 --> 00:24:02,503
Well, let me go ahead, and maybe let's do this.

269
00:24:02,503 --> 00:24:09,650
Instead of just considering there to be light bulbs, let's assign some special significance to each of them, based on where it is.

270
00:24:09,650 --> 00:24:15,350
And maybe for this, could we get maybe three volunteers, three volunteer?

271
00:24:15,350 --> 00:24:17,480
OK. You're being volunteered.

272
00:24:17,480 --> 00:24:18,210
OK. Come on up.

273
00:24:18,210 --> 00:24:19,610
If you want to go over to the stage there.

274
00:24:19,610 --> 00:24:22,350
Yeah. You want to come on up as well, and over here as well.

275
00:24:22,350 --> 00:24:24,530
So there are some stairs on either end.

276
00:24:24,530 --> 00:24:27,440
Maybe a round of applause for our first volunteers of term.

277
00:24:27,440 --> 00:24:30,842
[APPLAUSE]

278
00:24:34,050 --> 00:24:38,633
All right. So you want to be our number 1, and if you want to go ahead and stand roughly right here.

279
00:24:38,633 --> 00:24:40,175
How about do you want to be number 2?

280
00:24:40,175 --> 00:24:41,330
AUDIENCE: Yeah.

281
00:24:41,330 --> 00:24:46,090
DAVID J. MALAN: Come on over right to the right of here, and you'll be number 4, it turns out.

282
00:24:46,090 --> 00:24:53,120
If you want to come over here, on this end, let's give you all a moment to introduce yourselves briefly to your classmates, if you'd like.

283
00:24:53,120 --> 00:24:53,662
AUDIENCE: Hi.

284
00:24:53,662 --> 00:24:54,350
I'm Ellie.

285
00:24:54,350 --> 00:24:56,120
I'm a senior.

286
00:24:56,120 --> 00:24:57,440
DAVID J. MALAN: Nice to meet.

287
00:24:57,440 --> 00:24:59,840
AUDIENCE: I'm [? Rayhanna, ?] and I'm a first year.

288
00:24:59,840 --> 00:25:00,978
DAVID J. MALAN: Welcome.

289
00:25:00,978 --> 00:25:03,850
AUDIENCE: Hi. I'm Joseph, and I am a first year.

290
00:25:03,850 --> 00:25:04,850
DAVID J. MALAN: Welcome.

291
00:25:04,850 --> 00:25:07,940
All right. So so glad to have all three of you up here. Thank you.

292
00:25:07,940 --> 00:25:10,940
[APPLAUSE]

293
00:25:10,940 --> 00:25:16,480
Let me propose now that we'd like you three to represent how about the number 0.

294
00:25:16,480 --> 00:25:21,790
And I claim now that if each of you now represents a switch, you have fancier light bulbs now.

295
00:25:21,790 --> 00:25:27,340
One is a 1. One is a 2. One is a 4, but each of you is still just has a switch on the bottom, in fact, of your plastic devices.

296
00:25:27,340 --> 00:25:30,520
I claim these three volunteers are representing the number 0.

297
00:25:30,520 --> 00:25:34,240
Let me ask you all now, how might you represent the number 1?

298
00:25:34,240 --> 00:25:36,240
How should you cooperate here?

299
00:25:36,240 --> 00:25:43,087
OK. So we would have on, off, off, which I think matches what I did with my three light bulbs as well, if you want to go and turn yours off.

300
00:25:43,087 --> 00:25:46,910
How might you three represent the number 2?

301
00:25:46,910 --> 00:25:50,420
OK, so off, on, off now, from right to left.

302
00:25:50,420 --> 00:25:54,020
How would you three represent the number 3?

303
00:25:54,020 --> 00:25:57,043
Ah, so that's why my two light bulbs went on at the end.

304
00:25:57,043 --> 00:25:58,835
How would you three represent the number 4?

305
00:26:02,620 --> 00:26:10,357
Perfect. Number 5, number 6, and number 7?

306
00:26:10,357 --> 00:26:11,690
All right, and give us one more.

307
00:26:11,690 --> 00:26:14,184
How would you represent 8?

308
00:26:14,184 --> 00:26:15,000
AUDIENCE: We can't.

309
00:26:15,000 --> 00:26:16,190
DAVID J. MALAN: OK. You can't.

310
00:26:16,190 --> 00:26:20,250
How about then one more volunteer, one more volunteer?

311
00:26:20,250 --> 00:26:21,470
OK. Come on up.

312
00:26:25,350 --> 00:26:26,617
All right. What's your name?

313
00:26:26,617 --> 00:26:27,950
AUDIENCE: My name is [? Moin. ?]

314
00:26:27,950 --> 00:26:28,610
DAVID J. MALAN: If you want to say it into there.

315
00:26:28,610 --> 00:26:29,390
AUDIENCE: My name is [? Moin. ?]

316
00:26:29,390 --> 00:26:40,150
DAVID J. MALAN: All right, [? and Moin, ?] you're going to be number 8, and if now you all-- actually, let's make this how would you represent number 8, all collectively, as 4 bits or for switches?

317
00:26:40,150 --> 00:26:42,340
OK, 8, and now lastly, give me 15.

318
00:26:46,380 --> 00:26:49,835
Everyone's awkwardly doing arithmetic in their head, oh, using unary.

319
00:26:52,940 --> 00:26:53,440
Yeah.

320
00:26:53,440 --> 00:26:55,150
Is that everyone--

321
00:26:55,150 --> 00:26:55,720
Yes.

322
00:26:55,720 --> 00:26:56,290
OK.

323
00:26:56,290 --> 00:26:57,670
Round of applause.

324
00:26:57,670 --> 00:26:58,180
OK.

325
00:26:58,180 --> 00:27:00,610
Thank you all.

326
00:27:00,610 --> 00:27:07,107
If you want to leave your numbers over here, we have a CS50 stress ball for you, but thank you for volunteering.

327
00:27:07,107 --> 00:27:09,440
You can turn those numbers off and leave them over here.

328
00:27:09,440 --> 00:27:11,500
So thank you.

329
00:27:11,500 --> 00:27:19,160
So how do we go about-- how do we go from there to creating these patterns?

330
00:27:19,160 --> 00:27:28,720
Well, even though we still had three bits, initially, and three switches, later four bits and four switches, ultimately, we still

331
00:27:28,720 --> 00:27:32,860
used the same approach fundamentally to actually representing information.

332
00:27:32,860 --> 00:27:38,150
And now why were they those patterns, and why did I very deliberately have our volunteers line up in that way?

333
00:27:38,150 --> 00:27:44,140
Well, I wanted them using base-2, a.k.a. binary, but with binary there comes certain rules.

334
00:27:44,140 --> 00:27:53,021
And even if you're not familiar with binary beyond that it exists and relates somehow to computers, it's actually pretty much identical to the system you and I use every day

335
00:27:53,021 --> 00:27:55,520
known as base 10, a.k.a. decimal.

336
00:27:55,520 --> 00:28:00,370
So let's consider, if you will, by rewinding to primary school for just a moment, like how decimal works.

337
00:28:00,370 --> 00:28:03,820
And you'll see that even if you're not a computer person, you actually are.

338
00:28:03,820 --> 00:28:06,410
You just have to tweak your mental model ever so slightly.

339
00:28:06,410 --> 00:28:11,510
So here is the number that you're probably viewing as 123, but why is that?

340
00:28:11,510 --> 00:28:13,240
Well, it's not really 123.

341
00:28:13,240 --> 00:28:23,967
This is just a pattern of three symbols on the screen, 1, 2, 3, and your mind is rapidly assigning mathematical meaning to them, 123, but why is that?

342
00:28:23,967 --> 00:28:32,800
Well, if you're like me, you probably learned back in the day, when you have a three-digit number like, this the rightmost number is in the 1's place, the middle digit is the 10's place,

343
00:28:32,800 --> 00:28:35,870
the leftmost digit is in the 100's place, and why is that relevant?

344
00:28:35,870 --> 00:28:40,271
Well, if you then quickly do some mental math, as you and I just do instantly nowadays

345
00:28:40,271 --> 00:28:50,500
that just means 100 times 1 plus 10 times 2 plus 1 times 3, of course, 100 plus 20 plus 3 gives us the number you and I know as 123.

346
00:28:50,500 --> 00:28:56,900
But beyond that, how do we get to just two digits instead of as many as 9 in the decimal system?

347
00:28:56,900 --> 00:28:58,150
Well, let's generalize this.

348
00:28:58,150 --> 00:29:05,920
In the decimal system, you and I know, if we've got three digits represented by these hashes here, yes, it's the 1's place, 10's place, 100's place,

349
00:29:05,920 --> 00:29:09,860
and if we keep going 1,000's, 10,000's, and so forth, but why is that?

350
00:29:09,860 --> 00:29:12,580
Well, base terminology is now a little more germane.

351
00:29:12,580 --> 00:29:17,420
That's technically the 10 to the 0th column, the 10 to the 1, 10 to the 2.

352
00:29:17,420 --> 00:29:20,650
So these are powers of 10, where 10 is your base.

353
00:29:20,650 --> 00:29:27,520
Computers just simplify things a little bit, because computers, at the end of the day, only have access to electricity, on or off.

354
00:29:27,520 --> 00:29:32,780
They don't have access to 10 different types of electricity, just 2, on or off, if you will.

355
00:29:32,780 --> 00:29:34,640
Well, they just use a different base.

356
00:29:34,640 --> 00:29:37,900
And the rightmost digit would be in the so-called 2 to the 0ths.

357
00:29:37,900 --> 00:29:39,850
Then the middle digit is 2 to the 1.

358
00:29:39,850 --> 00:29:41,830
The left most is 2 to the 2, a.k.a.

359
00:29:41,830 --> 00:29:51,920
1's place, 2's place, 4's place, and as we kept going, 8, and if we keep going, 16, 32, 64, 128, and so forth, but the idea is fundamentally the same.

360
00:29:51,920 --> 00:29:56,770
So why is this how the computer represents the number you and I know is 0?

361
00:29:56,770 --> 00:30:02,750
Well, off, off, off, from right to left or in this case left to right, is just 0.

362
00:30:02,750 --> 00:30:08,320
Why? Because that's 4 times 0 plus 2 times 0 plus 1 times 0 is, of course, 0.

363
00:30:08,320 --> 00:30:12,400
This is why 001 represents 1.

364
00:30:12,400 --> 00:30:20,320
This is why 010 represents 2 and 3 and 4 and 5 and 6 and 7 on up.

365
00:30:20,320 --> 00:30:23,500
And why did we need a 4th bit to represent 8?

366
00:30:23,500 --> 00:30:29,740
Well, we kind of needed to carry the 1, so to speak, using our familiar human terminology.

367
00:30:29,740 --> 00:30:34,630
But for that we need a 4th bit, another transistor, and this now represents the number 8.

368
00:30:34,630 --> 00:30:39,070
And that's why we ended with on-- from left to right-- off, off, off.

369
00:30:39,070 --> 00:30:45,310
So I keep saying on and off, or the light bulb is on or off, but really, I just mean 1 or 0.

370
00:30:45,310 --> 00:30:52,860
And so computers and we humans think of things digitally as just being 0's and 1's, but mechanically, you can think of it indeed is these light bulbs.

371
00:30:52,860 --> 00:30:56,300
Now, a bit is not very useful. Even 3 bits, 4 bits, not that useful.

372
00:30:56,300 --> 00:31:01,240
You can count to 7 or 15, generally speaking, bytes are a more useful unit of measure.

373
00:31:01,240 --> 00:31:04,190
And anyone familiar how many bits is in a byte?

374
00:31:04,190 --> 00:31:08,557
Yeah. So 8 bits are in a byte. You can think of it as an octet equivalently.

375
00:31:08,557 --> 00:31:14,200
In some contexts, there are nuances there, but think of a byte as just being 8 bits, and that's just a more useful measure.

376
00:31:14,200 --> 00:31:15,890
So what does this mean in real terms?

377
00:31:15,890 --> 00:31:22,990
So if you've ever downloaded like a music file or a photograph or a video, those are measured in bytes.

378
00:31:22,990 --> 00:31:32,290
Probably not small numbers of bytes, probably kilobytes for thousands of bytes, megabytes for millions of bytes, gigabytes for billions of bytes, especially for video.

379
00:31:32,290 --> 00:31:39,670
That just means you have a lot of patterns of 8 bits, some combination of 0's and 1's on your computer's hard drive.

380
00:31:39,670 --> 00:31:46,330
Here then, with a byte of bits, 8 bits, is how a computer would typically represent the number 0.

381
00:31:46,330 --> 00:31:58,247
And if that same computer uses all 8 of its bits, its full byte, to change it to 1-- anyone who's quick with math or have seen this before, how high can a computer count with 8 bits or 1?

382
00:31:58,247 --> 00:31:59,080
[INTERPOSING VOICES]

383
00:31:59,080 --> 00:32:00,902
Yeah, 255. Why is that?

384
00:32:00,902 --> 00:32:03,610
Well, we're not going to turn this into a constant math exercise.

385
00:32:03,610 --> 00:32:08,230
Indeed, after today, we're not really going to think about or talk about bits at this low level.

386
00:32:08,230 --> 00:32:19,520
But this is the 1's place, 2's, 4's, 8s, 16, 32, 64, 128, and if I do all of that math from left to right, that indeed gives me 255.

387
00:32:19,520 --> 00:32:24,160
It ignores how we might represent negative numbers, but perhaps more on those some other day.

388
00:32:24,160 --> 00:32:28,810
But computers, of course, do so much more than numbers and math and all this low level stuff.

389
00:32:28,810 --> 00:32:32,150
We send text messages, write documents, emails, and the like.

390
00:32:32,150 --> 00:32:36,220
So how might a computer represent something like the letter A?

391
00:32:36,220 --> 00:32:46,210
I claim, at the end of the day, your Mac, your PC, your phone just has lots of transistors, lots of switches that it can use in units of 8, in units of bytes.

392
00:32:46,210 --> 00:32:58,440
How, though, if it's already using those patterns of 0's and 1's apparently to represent numbers from 0 on up, how do you go about representing letters of the alphabet, might you think?

393
00:32:58,440 --> 00:32:59,230
Yeah?

394
00:32:59,230 --> 00:32:59,730
OK.

395
00:32:59,730 --> 00:33:01,800
So we could assign a number to every letter.

396
00:33:01,800 --> 00:33:01,920
OK.

397
00:33:01,920 --> 00:33:08,760
So let me just conjecture, well, let's just call A 0, for simplicity, B 1, C 2, and now let me play devil's advocate.

398
00:33:08,760 --> 00:33:13,500
OK, how do I now represent 0 or 1 or 2?

399
00:33:13,500 --> 00:33:19,050
Well, we've maybe created a problem for ourselves, if now we have to steal some numbers to represent letters.

400
00:33:19,050 --> 00:33:21,870
We kind of have to pick a lane, but there's a solution to that too that we'll see.

401
00:33:21,870 --> 00:33:25,710
And it turns out the world is not quite as simple as A being 0.

402
00:33:25,710 --> 00:33:32,640
A typically is represented, by computers everywhere, phones everywhere, with the number 65, the decimal number 65.

403
00:33:32,640 --> 00:33:41,220
Using 8 bits, if we turn some of the 0's to 1's, let me just stipulate, you can represent the letter A using 8 bits, by turning certain ones on

404
00:33:41,220 --> 00:33:46,000
and certain ones off, but we will try not to focus on that binary level too much.

405
00:33:46,000 --> 00:33:54,060
So if A is 65, it turns out that B is going to be 66, and C is going to be 67, and so forth, and so where does that get us?

406
00:33:54,060 --> 00:33:59,130
Well, it turns out there's a whole system that maps numbers to letters.

407
00:33:59,130 --> 00:34:05,130
And here, as I alluded to verbally a moment ago, is the pattern of 0's and 1's via which you'd represent 65.

408
00:34:05,130 --> 00:34:13,770
And just quick check here, we won't constantly do math 1's place, that's easy, 2's, 4's, 8's, 16's, 32's, 64's place.

409
00:34:13,770 --> 00:34:17,969
So 64 plus 1 gives us 65.

410
00:34:17,969 --> 00:34:21,540
So once I do that, how do I get to all of the others?

411
00:34:21,540 --> 00:34:25,020
Well, it turns out a bunch of Americans years ago came up with this

412
00:34:25,020 --> 00:34:28,889
ASCII, the American Standard Code for Information Interchange.

413
00:34:28,889 --> 00:34:30,344
Now, what does that mean?

414
00:34:30,344 --> 00:34:37,620
Well, it's just an acronym describing what really you proposed, a mapping between numbers and letters, not quite as simple as 0, 1, 2.

415
00:34:37,620 --> 00:34:45,610
Starts at 65, 66, 67 for capital letters, but here are most of the letters in use today, at least with this system.

416
00:34:45,610 --> 00:34:52,800
So this is just a big chart from online, and you'll see in the middle of this chart, here, here's my 65, A. Here's my 66,

417
00:34:52,800 --> 00:34:58,750
B, C, and let's see, 72 is H, 73 is I, and so forth.

418
00:34:58,750 --> 00:35:03,160
So there's a mapping, at least for English, between all of these numbers and all of these letters.

419
00:35:03,160 --> 00:35:07,080
And if we focus here, those are the beginning of our uppercase alphabet.

420
00:35:07,080 --> 00:35:15,630
So suppose then that today, tomorrow, you receive a text message from someone, and underneath the hood, now that you're a computer person,

421
00:35:15,630 --> 00:35:19,110
you figure out a way to see what pattern of 0's and 1's was sent.

422
00:35:19,110 --> 00:35:23,147
In this case, it's wireless as opposed to wired, but it's still some pattern of 0's and 1's.

423
00:35:23,147 --> 00:35:27,900
And your phone is turning some switches of its own on and off to represent that message from a friend.

424
00:35:27,900 --> 00:35:35,430
Suppose that the three patterns you received were these three bytes, from left to right, spelling out a three-letter word.

425
00:35:35,430 --> 00:35:40,060
Well, if we do out the math, 1's place, 2's place, and so forth-- I'll spoil it for you.

426
00:35:40,060 --> 00:35:49,410
Suppose that you received a text message that doesn't literally say 72, 73, 33, but you've received a pattern of 8 plus 8 plus 8, 24 bits

427
00:35:49,410 --> 00:35:54,510
that if you do out the math represent the decimal number 72, 73, 33.

428
00:35:54,510 --> 00:35:58,980
Anyone recall what message you might have received from the green and white charts?

429
00:35:58,980 --> 00:35:59,970
Yeah?

430
00:35:59,970 --> 00:36:00,930
AUDIENCE: Hi.

431
00:36:00,930 --> 00:36:02,010
DAVID J. MALAN: Hi.

432
00:36:02,010 --> 00:36:08,370
Yes, hi is the message, but 72, 73 gives us H and I. What's 33?

433
00:36:08,370 --> 00:36:10,560
Any guesses to 33?

434
00:36:10,560 --> 00:36:12,100
Yeah, over here.

435
00:36:12,100 --> 00:36:12,600
Yeah.

436
00:36:12,600 --> 00:36:13,770
So it's an exclamation point.

437
00:36:13,770 --> 00:36:14,650
How would you know that?

438
00:36:14,650 --> 00:36:17,025
Well, you really do need some kind of cheat sheet, a.k.a.

439
00:36:17,025 --> 00:36:18,010
ASCII in this case.

440
00:36:18,010 --> 00:36:24,490
And if we look elsewhere-- let me highlight the left of the chart-- you can see that next to 33 in decimal is indeed the exclamation point.

441
00:36:24,490 --> 00:36:31,396
So back in the day, a bunch of humans got in a room, decided that, hey, when we start building PCs and later Macs and phones

442
00:36:31,396 --> 00:36:38,110
we all just have to agree on this form of representation of letters of the English alphabet, in this case.

443
00:36:38,110 --> 00:36:39,810
We just need to agree on this mapping.

444
00:36:39,810 --> 00:36:42,910
But somewhat curiously, notice this.

445
00:36:42,910 --> 00:36:54,660
It turns out that, once you paint yourself into this corner and start using 65 for A, 66 for B, well, how do you represent 65 the number and 66 the number,

446
00:36:54,660 --> 00:36:57,690
if you want to do math or use Excel or something like that?

447
00:36:57,690 --> 00:37:01,380
Does anyone see the solution, perhaps?

448
00:37:01,380 --> 00:37:06,070
How do you represent the number 1 in ASCII?

449
00:37:06,070 --> 00:37:07,528
Yeah, in the middle?

450
00:37:07,528 --> 00:37:09,065
AUDIENCE: [INAUDIBLE].

451
00:37:09,065 --> 00:37:09,940
DAVID J. MALAN: Yeah.

452
00:37:09,940 --> 00:37:15,080
So this is getting a little maybe inception or something, but you could represent numbers with other numbers.

453
00:37:15,080 --> 00:37:23,230
And so if you want to represent the number you and I know as 1, like when you type it on your keyboard, turns out the computer stores that as the decimal number 49.

454
00:37:23,230 --> 00:37:27,070
If you hit 2 on your keyboard, the computer is not storing 2, per se.

455
00:37:27,070 --> 00:37:29,230
It's storing the decimal number 50.

456
00:37:29,230 --> 00:37:33,940
Now, thankfully, the paradox stops there.

457
00:37:33,940 --> 00:37:36,340
We just have a mapping now of numbers to numbers.

458
00:37:36,340 --> 00:37:43,720
But really, at the end of the day-- and you're going to learn this when we start writing code in that other language, C, next week-- it's just context-dependent, at the end of the day.

459
00:37:43,720 --> 00:37:49,720
Inside of your Mac, PC, and phone, there's just all of these permutations of bits, all of these patterns of 0's and 1's.

460
00:37:49,720 --> 00:37:55,252
And generally speaking, when you open up a text message that you've received from someone, it's 0's and 1's.

461
00:37:55,252 --> 00:38:04,862
But obviously, if it's a text message, the whole point of text messages is to send text, and so those patterns of 0's and 1's, by default, will typically be interpreted as letters of the alphabet.

462
00:38:04,862 --> 00:38:06,070
So you won't see 0's and 1's.

463
00:38:06,070 --> 00:38:07,320
You won't see decimal numbers.

464
00:38:07,320 --> 00:38:10,090
You'll see the English message that your friend intended.

465
00:38:10,090 --> 00:38:19,660
By contrast, if you open up something like Excel, that same pattern 0's zeros and 1's might indeed work out to be 72, 73, 33.

466
00:38:19,660 --> 00:38:23,530
You might see cells in your spreadsheet with literally those three numbers.

467
00:38:23,530 --> 00:38:24,040
Why?

468
00:38:24,040 --> 00:38:28,210
Because spreadsheets are all about numbers and number crunching and math, in many cases.

469
00:38:28,210 --> 00:38:36,820
If by contrast, you open up Photoshop and try to look at that same pattern of 0's and 1's, it's not going to be 72, 73, 33.

470
00:38:36,820 --> 00:38:38,530
It's not going to be 0's and 1's.

471
00:38:38,530 --> 00:38:39,670
It's not going to be hi.

472
00:38:39,670 --> 00:38:42,100
It's going to be some color of the rainbow.

473
00:38:42,100 --> 00:38:46,810
You're going to use those patterns of 0's and 1's, it turns out too, to represent colors.

474
00:38:46,810 --> 00:38:56,560
And indeed, so long as you and I just agree, as humans long have, what these patterns are going to be, all of our systems, many of our systems nowadays are indeed interoperable.

475
00:38:56,560 --> 00:39:01,330
But I'm being very biased here, and indeed, the A and ASCII is very American-centric.

476
00:39:01,330 --> 00:39:03,940
What do you not see in this chart?

477
00:39:03,940 --> 00:39:11,620
If you speak any other language than English, odds are, you're not seeing characters you know and love and need every day to type or send messages.

478
00:39:11,620 --> 00:39:17,170
Well, there's a huge character set that's not supported here, whether it's accented characters and a lot of Asian alphabets.

479
00:39:17,170 --> 00:39:20,420
You have many more symbols than can fit even on this screen here.

480
00:39:20,420 --> 00:39:24,010
And so humans kind of painted themselves into a corner, early on, or really,

481
00:39:24,010 --> 00:39:24,970
Americans did.

482
00:39:24,970 --> 00:39:33,880
But on a typical keyboard, US English keyboard, yeah, you have A's and B's and C's, uppercase and lowercase, but you also have accented characters here.

483
00:39:33,880 --> 00:39:41,090
And nowadays, not sure if this is maybe necessary, but nowadays, you have other characters on your keyboard, like these.

484
00:39:41,090 --> 00:39:45,730
And these are a playful incarnation of what's actually a technical solution to this problem.

485
00:39:45,730 --> 00:39:52,480
If I claim for the moment that ASCII historically used 7 bits to represent letters-- and let's just round that up to a byte--

486
00:39:52,480 --> 00:40:00,520
8 bits to represent letters, ASCII can represent as many as 255, or really 256, total characters.

487
00:40:00,520 --> 00:40:01,550
Why 256?

488
00:40:01,550 --> 00:40:04,840
Well, if you have them all 0, that's 0, and the highest number

489
00:40:04,840 --> 00:40:07,070
I claimed a moment ago was 255.

490
00:40:07,070 --> 00:40:09,160
So that's 256 total possibilities.

491
00:40:09,160 --> 00:40:10,360
That's not many letters.

492
00:40:10,360 --> 00:40:13,730
It's fine for English, but not a lot of human languages.

493
00:40:13,730 --> 00:40:25,360
So what might the intuitive solution be, if you want to represent accented characters, Asian characters, emoji, even like these, which are just keys on a keyboard nowadays?

494
00:40:25,360 --> 00:40:28,610
What's the intuitive solution, if a byte's too few?

495
00:40:28,610 --> 00:40:29,110
Yeah?

496
00:40:29,110 --> 00:40:30,320
AUDIENCE: Add another digit.

497
00:40:30,320 --> 00:40:30,710
DAVID J. MALAN: Yeah.

498
00:40:30,710 --> 00:40:31,610
So add another digit.

499
00:40:31,610 --> 00:40:37,640
Just like we had a 4th volunteer come on up to give us a 4th bid, let's just throw hardware at the problem and use a few more bits.

500
00:40:37,640 --> 00:40:41,925
So maybe instead of 1 byte, let's use 2, or heck, let's use 3 or 4 bytes.

501
00:40:41,925 --> 00:40:49,047
Even though it's getting a little expensive-- we're going from 8 to 16 to 24 or 32 bits-- that's how computers do things, these days.

502
00:40:49,047 --> 00:40:54,710
And thankfully, we have so much memory inside of our computers and phones, we can certainly spare a few to represent these things.

503
00:40:54,710 --> 00:40:58,400
And the solution then to ASCII is what we'll call Unicode.

504
00:40:58,400 --> 00:41:06,380
So Unicode is also just a mapping of numbers to letters but in many different languages.

505
00:41:06,380 --> 00:41:16,610
And indeed, the Unicode Consortium is a bunch of people from all different companies-- a lot of different companies and countries and cultures whose mission,

506
00:41:16,610 --> 00:41:23,070
as an organization, is to capture digitally all forms of human language in this case.

507
00:41:23,070 --> 00:41:32,600
And to ensure that especially smaller demographics of humans speaking lesser-known languages are nonetheless represented and preserved digitally using some mapping of these 0's and 1's.

508
00:41:32,600 --> 00:41:42,830
It turns out, though, if you start using 32 bits, as many as 32 bits, to represent characters on a keyboard, that's 4 billion possible permutations of 0's and 1's.

509
00:41:42,830 --> 00:41:45,538
That's way more than we need for most human languages.

510
00:41:45,538 --> 00:41:49,850
So there's a little bit of room in there for some of those more playful things, like those emoji.

511
00:41:49,850 --> 00:41:55,040
So for instance, suppose you got a text message with this pattern of 0's and 1's.

512
00:41:55,040 --> 00:42:03,080
Or if we do out the math, suppose you receive a text message that, if you do out the math in decimal, is 4,036,991,106.

513
00:42:03,080 --> 00:42:07,110
Anyone know what emoji you're looking at?

514
00:42:07,110 --> 00:42:11,033
It would be weird if you do, but what is this?

515
00:42:11,033 --> 00:42:16,990
Well, it turns out that, as of this past year, this is the most popular emoji to be sent by many measures,

516
00:42:16,990 --> 00:42:18,970
Face with Tears of Joy.

517
00:42:18,970 --> 00:42:24,070
So that is the pattern that a bunch of humans in the Unicode Consortium decided would represent this.

518
00:42:24,070 --> 00:42:31,810
But you'll notice, many of you might have iPhones, some of you might have Android devices too, and sometimes, these don't actually look quite the same.

519
00:42:31,810 --> 00:42:36,850
This happens to be the current version of Face with Tears of Joy on iOS.

520
00:42:36,850 --> 00:42:42,550
On Android, it tends to look a little something more like this, and here is kind of a curiosity.

521
00:42:42,550 --> 00:42:46,840
Even though you and I look at these things and they look like images, they're not images.

522
00:42:46,840 --> 00:42:50,470
They're characters, at least as we've defined them now in Unicode.

523
00:42:50,470 --> 00:42:59,325
And iOS and Android and Windows and Facebook and other companies and apps, nowadays, really just have different fonts, if you will.

524
00:42:59,325 --> 00:43:09,250
So just like fonts with English and other languages can give you different characters with serifs or not, emoji are themselves, yes, drawings that someone made, but they're really just a font.

525
00:43:09,250 --> 00:43:14,830
And so that same pattern of 0's and 1's might just render slightly differently on someone's phone or another.

526
00:43:14,830 --> 00:43:22,771
If you've ever gotten like an icon on your phone that's broken, and you've been sent an emoji, but it's like a square or something arbitrary and not sensible

527
00:43:22,771 --> 00:43:29,710
it might just mean that you have not updated to the latest version of iOS or Android, which just updates the font of supported emoji.

528
00:43:29,710 --> 00:43:36,838
Because those folks at Unicode, pretty much every year nowadays, are adding more and more emoji to that particular character set.

529
00:43:36,838 --> 00:43:41,710
Now, I went down the rabbit hole of figuring out the other day just which are the most popular emoji these days.

530
00:43:41,710 --> 00:43:49,390
On Twitter specifically, this past year, the most popular emoji, by contrast, was Loudly Crying Face.

531
00:43:49,390 --> 00:43:55,780
I don't know if that says more about 2021 or about Twitter, but you'll see different trends, certainly, in how these are used.

532
00:43:55,780 --> 00:44:03,790
But even humans themselves didn't necessarily think two steps ahead, and now a lot of the emoji are the default yellow color.

533
00:44:03,790 --> 00:44:10,690
But there's a lot of emoji that aren't these cartoon characters, but they're meant to represent humans in various professions or gestures or the like.

534
00:44:10,690 --> 00:44:18,190
And nowadays too, you've probably noticed on your phone and Macs and PCs, there are different skin tones that you can assign to certain emojis.

535
00:44:18,190 --> 00:44:27,483
If it's supported by the company and by Unicode, you can actually touch and hold on a certain emoji, and then you can choose the appropriate skin tone to represent yourself or someone else.

536
00:44:27,483 --> 00:44:29,440
And that then modifies the display.

537
00:44:29,440 --> 00:44:38,650
Well, let's just think for a moment here, how did Apple and Google and Microsoft and others go about implementing support for emoji with different skin tones?

538
00:44:38,650 --> 00:44:41,000
How could you do this?

539
00:44:41,000 --> 00:44:47,230
If you want to represent some smiling emoji but in five, in this case, different skin tones, you could come up with what?

540
00:44:47,230 --> 00:44:53,950
Five different patterns that are identical, structurally, except for the skin tone used in places in that image.

541
00:44:53,950 --> 00:45:00,890
But that's a little inefficient to just do copy, paste, paste, paste, paste, and change the color in Photoshop, if you will.

542
00:45:00,890 --> 00:45:05,020
That's going to use more bits, more information than you might need to.

543
00:45:05,020 --> 00:45:12,271
How else, if you now start to think a little bit more like a computer scientist, if at the end of the day, all you have are 0's and 1's

544
00:45:12,271 --> 00:45:14,180
how else could you implement skin tones, might you think?

545
00:45:14,180 --> 00:45:14,680
Yeah?

546
00:45:14,680 --> 00:45:15,298
AUDIENCE: RGB.

547
00:45:15,298 --> 00:45:16,090
DAVID J. MALAN: OK.

548
00:45:16,090 --> 00:45:18,190
So RGB, we'll come to that in just a moment.

549
00:45:18,190 --> 00:45:20,590
That stands for Red, Green, Blue. That's one way.

550
00:45:20,590 --> 00:45:29,720
In this case, though, I'm seeking an alternative to just using five different patterns of 0's and 1's to represent the same emoji but different skin tones.

551
00:45:29,720 --> 00:45:30,620
So not quite RGB.

552
00:45:30,620 --> 00:45:31,120
Yeah?

553
00:45:31,120 --> 00:45:32,278
AUDIENCE: [INAUDIBLE]

554
00:45:32,278 --> 00:45:33,070
DAVID J. MALAN: OK.

555
00:45:33,070 --> 00:45:39,410
So store one copy of the emoji and then store different variants of the color that you want to assign to that emoji.

556
00:45:39,410 --> 00:45:39,910
Yeah.

557
00:45:39,910 --> 00:45:42,452
So this is actually an example of-- do you want to elaborate?

558
00:45:42,452 --> 00:45:43,858
AUDIENCE: You could use a loop.

559
00:45:43,858 --> 00:45:44,650
DAVID J. MALAN: OK.

560
00:45:44,650 --> 00:45:46,900
So you can use a loop to actually output these things.

561
00:45:46,900 --> 00:45:47,942
More on that in a moment.

562
00:45:47,942 --> 00:45:49,990
Let me go down this road for just a moment.

563
00:45:49,990 --> 00:45:54,335
This would be in some sense a better design, if you will, but why?

564
00:45:54,335 --> 00:45:54,835
Yeah?

565
00:45:54,835 --> 00:45:55,798
AUDIENCE: A filter?

566
00:45:55,798 --> 00:45:56,590
DAVID J. MALAN: OK.

567
00:45:56,590 --> 00:45:58,780
So filter, if we think of in the Instagram sense.

568
00:45:58,780 --> 00:46:01,885
You can change the color of something, and that could be related here too.

569
00:46:01,885 --> 00:46:03,967
AUDIENCE: Could it be another font [INAUDIBLE]

570
00:46:03,967 --> 00:46:05,300
DAVID J. MALAN: Oh, interesting.

571
00:46:05,300 --> 00:46:07,410
So maybe it could be just a completely different font.

572
00:46:07,410 --> 00:46:12,800
And you have five different fonts that are almost identical, except for the various interpretations of skin tone for those same emoji.

573
00:46:12,800 --> 00:46:13,550
Let me spoil.

574
00:46:13,550 --> 00:46:20,104
I think if we go down this one particular road, the way the Unicode folks decided to do this some years ago

575
00:46:20,104 --> 00:46:29,060
where the first byte or bytes that you receive via text or email just represent like the structure of the emoji, the default yellow version, thereof.

576
00:46:29,060 --> 00:46:37,187
But if it's immediately followed by a certain pattern of bits that these humans standardize to represent each of these different shades of skin tone

577
00:46:37,187 --> 00:46:45,290
then the phone, the Mac, the PC will change that default color, yellow in most cases, to whatever the more apt human tone is.

578
00:46:45,290 --> 00:46:49,970
So you just use twice as many bits, but you don't use five times as many bits.

579
00:46:49,970 --> 00:46:50,720
So what do I mean?

580
00:46:50,720 --> 00:46:54,890
You don't have five completely distinct patterns, per se.

581
00:46:54,890 --> 00:47:07,920
For each of these possible variants, you have a representation of just the emoji itself, structurally, and then reusable patterns for those five skin tones.

582
00:47:07,920 --> 00:47:16,100
Unfortunately, that wasn't quite versatile enough for other features that were in the pipeline, and nowadays too, and there's a double meaning now to representation.

583
00:47:16,100 --> 00:47:24,150
Emojis intended to focus on certain professions, and early on too, were certain professions associated with certain genders and vice versa.

584
00:47:24,150 --> 00:47:28,070
And you couldn't necessarily be one gender or another, in a certain profession or another.

585
00:47:28,070 --> 00:47:30,230
There were these combinatorics that just weren't possible.

586
00:47:30,230 --> 00:47:37,700
But nowadays, as you might have seen, you can have couples in love for instance that actually look a little more like three emojis, but just kind of combined into one.

587
00:47:37,700 --> 00:47:45,390
And indeed, this is just one key press on your phone, and you can combine different emoji on the left and then the right with the emoji in the middle.

588
00:47:45,390 --> 00:47:54,920
And so it turns out how computers nowadays represent these patterns are one set of bits for the character on the left, one set of bits for a character on the right,

589
00:47:54,920 --> 00:47:58,080
one set of bits for whatever emoji you want in the middle.

590
00:47:58,080 --> 00:48:06,350
And then you assemble more complicated compositions of emoji by just reusing those same patterns and bits and bits.

591
00:48:06,350 --> 00:48:12,620
The Unicode folks don't have to come up with a whole new representation for some very specific incarnation.

592
00:48:12,620 --> 00:48:21,390
They can create one for person, for male, for, female for other characters that you might want to display, and reuse those same patterns of 0's and 1's.

593
00:48:21,390 --> 00:48:30,500
And so here, you see the imperfection, of or lack of foresight, of humans for building a system early on that was entirely American-centric, no characters, emoji, or the like, that's evolved too.

594
00:48:30,500 --> 00:48:33,800
And so that's an important detail in computing, nowadays.

595
00:48:33,800 --> 00:48:39,780
It too is evolving, and the languages you're about to learn in the coming days, those too are evolving as well.

596
00:48:39,780 --> 00:48:43,942
And new features are getting added, and even programming languages have version numbers.

597
00:48:43,942 --> 00:48:46,400
You might have a different version of an app on your phone.

598
00:48:46,400 --> 00:48:49,770
Programming languages too have different versions as well.

599
00:48:49,770 --> 00:48:56,900
Questions then thus far on how information is represented using ASCII or Unicode or anything in between?

600
00:48:56,900 --> 00:48:57,440
Yeah?

601
00:48:57,440 --> 00:48:59,383
AUDIENCE: [INAUDIBLE]

602
00:48:59,383 --> 00:49:00,800
DAVID J. MALAN: Oh, good question.

603
00:49:00,800 --> 00:49:12,396
So to recap, why can't you just-- well, let me summarize that as why can't you similarly use different patterns to change the context of what these patterns of bits represent, whether it's

604
00:49:12,396 --> 00:49:14,950
whether it's a number or a letter or a graphic?

605
00:49:14,950 --> 00:49:17,920
In actuality, that's kind of what's happening underneath the hood.

606
00:49:17,920 --> 00:49:24,670
It's not standardized in quite the same way, but starting next week, when we transition from scratch to C, you'll learn about types, data types.

607
00:49:24,670 --> 00:49:35,642
Where the onus initially is going to be on you, the programmer, to tell the program whether or not this pattern of bits should be interpreted as a number or as a letter or as a color or something else.

608
00:49:35,642 --> 00:49:41,170
Nowadays, though, and toward the end of the semester, you'll use languages, like Python, where the computer just figures it out

609
00:49:41,170 --> 00:49:45,950
for you by context, which makes it even easier and faster to program as well.

610
00:49:45,950 --> 00:49:50,580
Other questions on Unicode, ASCII or the like?

611
00:49:50,580 --> 00:49:53,330
All right. Well, how about just a few other forms of information?

612
00:49:53,330 --> 00:49:55,250
RGB was called out earlier, Red, Green, Blue.

613
00:49:55,250 --> 00:49:57,410
How do images get represented in computers?

614
00:49:57,410 --> 00:50:04,340
Well, in fact, it's typically an assembly of some amount of red, some amount of green, some amount of blue, but there are other representations.

615
00:50:04,340 --> 00:50:08,000
If you're a graphic designer, you might know them, but RGB is still pretty common.

616
00:50:08,000 --> 00:50:08,970
What does this mean?

617
00:50:08,970 --> 00:50:18,395
This means to represent every dot on your phone or every dot on your TV or your laptop or desktop, there is a number representing how much red that dot should show,

618
00:50:18,395 --> 00:50:24,690
a number representing how much green, and a number representing how much blue it should show, red, green, blue, respectively.

619
00:50:24,690 --> 00:50:37,250
So for instance, if a dot on your screen were using these three numbers, these three values or bytes, 72, 73, 33, in a text message or email, that would be interpreted as I claimed "High."

620
00:50:37,250 --> 00:50:47,840
But in Photoshop or in some graphical program, that same pattern would be interpreted as let's call it a medium amount of red, a medium amount of green, and a little bit of blue.

621
00:50:47,840 --> 00:50:49,250
And why medium and little?

622
00:50:49,250 --> 00:50:54,110
Turns out, each of these are bytes, the smallest value you can have in a byte we said is 0.

623
00:50:54,110 --> 00:50:58,100
The largest value you can have a byte is 255, so I'm just kind of spitballing here.

624
00:50:58,100 --> 00:51:02,660
This is like medium, medium, and a low amount of red, green, blue, specifically.

625
00:51:02,660 --> 00:51:12,890
Those three colors, like wavelengths of light, are combined in such a way that you would have this dot on the screen, a sort of murky shade of yellow or brown.

626
00:51:12,890 --> 00:51:18,470
That is how a computer would store precisely that color, and in fact, we've seen this color.

627
00:51:18,470 --> 00:51:23,930
When you type in Face with Tears of Joy, generally, on your screen, it looks like this, typically much smaller.

628
00:51:23,930 --> 00:51:27,980
But let's zoom in, or let's Zoom in a little more.

629
00:51:27,980 --> 00:51:30,212
What are you starting to see, if you know the term?

630
00:51:30,212 --> 00:51:30,920
AUDIENCE: Pixels.

631
00:51:30,920 --> 00:51:33,212
DAVID J. MALAN: So pixels, it's getting very pixelated.

632
00:51:33,212 --> 00:51:40,354
A pixel is just a dot on the screen, and if you really zoom in on it, you can literally see all of the dots that compose an emoji

633
00:51:40,354 --> 00:51:45,750
in this case on iOS, in the font that Apple is using to represent this particular pattern of 0's and 0's.

634
00:51:45,750 --> 00:51:53,780
So one of those yellow dots-- and there's many of them all kind of blend together here-- each dot on the screen I claim is 3 bytes.

635
00:51:53,780 --> 00:51:55,700
How much red, green, blue for this dot?

636
00:51:55,700 --> 00:51:58,700
How much red green blue for this dot?

637
00:51:58,700 --> 00:52:02,720
And you'll notice too, that when it gets to be sort of brownish here, the dots really stand out.

638
00:52:02,720 --> 00:52:08,160
The 3 values, the 3 bytes, a.k.a. 24 bits, are just slightly different.

639
00:52:08,160 --> 00:52:19,850
And so underneath the hood, this is why images, photographs that you take or gif that you download, get so darn big, potentially, because you have a number representing every dot on the screen.

640
00:52:19,850 --> 00:52:29,630
Well, if this I claim is indeed how images are typically represented, using pattern of bits that are assigned to some amount of red, green, or blue, how do you get video?

641
00:52:29,630 --> 00:52:34,820
What is a video, if at the end of the day, all we have are 0's and 1's?

642
00:52:34,820 --> 00:52:36,500
What's a video, perhaps?

643
00:52:36,500 --> 00:52:37,610
Yeah?

644
00:52:37,610 --> 00:52:39,420
Let's go here, way in back.

645
00:52:39,420 --> 00:52:44,780
Yeah. Pixels really changing values over time. and do you want to confirm or deny, the hand that went up here?

646
00:52:44,780 --> 00:52:45,380
AUDIENCE: [INAUDIBLE]

647
00:52:45,380 --> 00:52:49,828
DAVID J. MALAN: Yeah, or equivalently, a sequence of images that, over time, are changing on the screen.

648
00:52:49,828 --> 00:52:59,191
So both of those are valid interpretations, and just for fun, if you grew up with these picture books, you might remember a little something like this. if we could dim the lights?

649
00:52:59,191 --> 00:53:02,628
[MUSIC PLAYING]

650
00:53:19,925 --> 00:53:31,250
So that's the old school analog way to implement a video, in the sense that that artist wrote out like hundreds of pieces of paper, with almost identical images, but where the ink from their pencil

651
00:53:31,250 --> 00:53:33,015
or pen was slightly moving.

652
00:53:33,015 --> 00:53:41,220
And if you digitize that, such that each of those strokes are represented with dots instead, that's really what you're seeing is a sequence of all of these images flying across the screen.

653
00:53:41,220 --> 00:53:48,320
And if we dive into the real world, if you've ever watched a film, a Hollywood movie is typically 24 FPS, Frames Per Second.

654
00:53:48,320 --> 00:53:55,370
That really means you're seeing 24 images per second, or on TV or in soap operas, it's often 30 frames per second.

655
00:53:55,370 --> 00:53:57,210
That makes things look a little more smooth.

656
00:53:57,210 --> 00:53:59,750
So it's not actual motion picture, if you will.

657
00:53:59,750 --> 00:54:07,985
It's sequences of pictures, and your brain and mind are interpolating that, oh, this is smooth movement, even though we're just seeing a lot of pictures really fast.

658
00:54:07,985 --> 00:54:15,200
Now, that gets really big, and we'll talk later in the semester how you can compress information, so that you're not using way more bits than you actually need to.

659
00:54:15,200 --> 00:54:21,590
And there's fancy algorithms that folks have developed, but at the end of the day, that's really all a video might be is a sequence of images.

660
00:54:21,590 --> 00:54:30,978
Conversely, if you want to represent the music that accompanies that or something else, if any of you play an instrument and can read sheet music, how could you digitize this?

661
00:54:30,978 --> 00:54:31,520
[PIANO MUSIC]

662
00:54:31,520 --> 00:54:35,330
Like how could you represent musical notes in a computer?

663
00:54:35,330 --> 00:54:41,210
You and I hear them when we play files, but what's really going on underneath the hood?

664
00:54:41,210 --> 00:54:44,760
Any musicians, piano players?

665
00:54:44,760 --> 00:54:45,260
Anyone?

666
00:54:45,260 --> 00:54:45,760
Yeah?

667
00:54:45,760 --> 00:54:47,150
AUDIENCE: Hertz value?

668
00:54:47,150 --> 00:54:49,590
DAVID J. MALAN: OK, so Hertz value, so some frequency.

669
00:54:49,590 --> 00:54:52,528
So sound is some frequency, and it's kind of hitting your eardrum.

670
00:54:52,528 --> 00:54:55,320
And that's what makes it sound low or high or somewhere in between.

671
00:54:55,320 --> 00:55:00,771
So maybe we could assign, just like there's letters A through G here, maybe we could assign specific frequency values, which are just going to be numbers measured in something

672
00:55:00,771 --> 00:55:04,010
which are just going to be numbers measured in something called Hertz, something per second.

673
00:55:04,010 --> 00:55:08,780
And maybe we could have a few other numbers for each of these notes, not just the note or the frequency.

674
00:55:08,780 --> 00:55:14,900
Maybe, we could represent the loudness of it, like how hard or how softly a human might equivalently press it.

675
00:55:14,900 --> 00:55:19,380
Maybe a third number, like duration, like how long is there finger on the keyboard?

676
00:55:19,380 --> 00:55:29,450
So you can imagine quantifying something like music that in the real world is perfectly continuous as something more discrete, by representing each note over time as just some sequence of values.

677
00:55:29,450 --> 00:55:34,680
And there's so many different ways to do this, MIDI, if you've heard, mp3's, AAC.

678
00:55:34,680 --> 00:55:45,290
Almost all of the file extensions you see on your Mac or PC, if you see them at all, ultimately just mean there's a different form of representation for, in this case, something like sound.

679
00:55:45,290 --> 00:55:53,300
So let me just stipulate, there are these and many more ways to represent inputs and outputs, and thankfully, humans have standardized a lot of this.

680
00:55:53,300 --> 00:56:02,100
They don't always agree, and this is why we have different file formats for Apple numbers and Microsoft Excel and Google Spreadsheets and stupid incompatibilities like that.

681
00:56:02,100 --> 00:56:07,670
But generally speaking, humans have standardized how we represent the inputs and outputs to and from problems.

682
00:56:07,670 --> 00:56:12,590
But let's now focus on this Black box, so to speak, in the middle, this abstraction.

683
00:56:12,590 --> 00:56:18,695
So abstraction is technically a term that you'll see all over the place in computer science, and really, problem solving

684
00:56:18,695 --> 00:56:25,310
that just refers to the simplification of something, so that you don't focus on the lower level implementation details.

685
00:56:25,310 --> 00:56:29,880
You really just focus on the high level goals or the process itself.

686
00:56:29,880 --> 00:56:36,830
Therefore, your car, if you have a license and have driven or have been in a car, a car, so far as you're concerned, is probably an abstraction.

687
00:56:36,830 --> 00:56:42,290
Most of us, if you're like me, probably don't really know or care how the engine works and all the parts that are moving.

688
00:56:42,290 --> 00:56:50,510
To you, it's just a way of getting from point A to point B. It's an abstraction, but someone, hopefully the mechanic, does know those lower level implementation details.

689
00:56:50,510 --> 00:56:56,700
If you had to understand how a car works every time you want to go to school or to the store, it's probably going to be a pretty slow process.

690
00:56:56,700 --> 00:57:04,350
You just want to think and operate at this higher level of abstraction, and we're going to do this all the time when writing code and solving problems.

691
00:57:04,350 --> 00:57:07,940
So what then is in this black box, this abstraction at the moment?

692
00:57:07,940 --> 00:57:14,180
Well, generally, it's what a computer scientist would call an algorithm, step-by-step instructions for solving some problem.

693
00:57:14,180 --> 00:57:24,230
Now, let's consider the implementation details, that is to say how you might solve certain problems, and let's take a old school example but in modern form.

694
00:57:24,230 --> 00:57:27,970
This icon, if you have an iPhone, is, of course for your contacts application.

695
00:57:27,970 --> 00:57:36,800
And if you've got a whole bunch of family members or friends or colleagues in your phonebook, you have some kind of contacts pictured here, and it's alphabetized typically by first name and last name.

696
00:57:36,800 --> 00:57:42,950
And odds are, you and I are in the habit, if they're not already a favorite, of like clicking on Search and then using autocomplete.

697
00:57:42,950 --> 00:57:45,140
And what happens when you start typing autocomplete?

698
00:57:45,140 --> 00:57:48,710
Well if you type in the letter H, you'll see only, presumably,

699
00:57:48,710 --> 00:57:50,640
Hagrid, Harry, Hermione, and so forth.

700
00:57:50,640 --> 00:57:56,280
If you type in H-A that shows you only Hagrid and Harry, and it all happens super fast.

701
00:57:56,280 --> 00:57:57,720
So how is that happening?

702
00:57:57,720 --> 00:58:07,490
Well, typically, you could just start at the top and look to the bottom, searching for all of the H's or all of the H-A's, but for larger data sets that's going to get slow.

703
00:58:07,490 --> 00:58:10,130
For the Googles of the world, that's going to get really slow.

704
00:58:10,130 --> 00:58:18,300
And even on our phones when you have hundreds, thousands of contacts, eventually, even that kind of approach, that algorithm step by step it might be slow.

705
00:58:18,300 --> 00:58:24,230
So how might we go about searching for someone in a phonebook like this, like say John Harvard?

706
00:58:24,230 --> 00:58:30,910
Well, here's an old school incarnation of this, and odds are, you might not have had occasion to even physically use this thing, nowadays.

707
00:58:30,910 --> 00:58:36,950
And in fact, this is a bit of a white lie, because this is the yellow pages, which means this is a book of companies not people.

708
00:58:36,950 --> 00:58:40,370
But this is all you can find, and at that, it's even hard to find this.

709
00:58:40,370 --> 00:58:43,770
But this is the same thing in analog form, physical form.

710
00:58:43,770 --> 00:58:47,310
So if I wanted to search for someone like John Harvard, how could I do that?

711
00:58:47,310 --> 00:58:55,345
Well, I could start on page 1, and I could start searching for page 2, page 3, page 4, page 5.

712
00:58:55,345 --> 00:58:59,345
A little hard to do physically, especially since no one's used this phone book in a lot of years.

713
00:58:59,345 --> 00:59:06,260
But is this algorithm correct, turning page by page, very inelegantly?

714
00:59:06,260 --> 00:59:06,980
Is this correct?

715
00:59:06,980 --> 00:59:09,690
Will I find John Harvard, if he's in here?

716
00:59:09,690 --> 00:59:10,190
All right.

717
00:59:10,190 --> 00:59:11,030
So yes.

718
00:59:11,030 --> 00:59:16,870
This is a little stupidly tedious, because if there's like 1,000 pages, he might be a few hundred pages into this, but it's correct.

719
00:59:16,870 --> 00:59:20,120
At some point, I will find him, and if he's on the page, I'll be able to call.

720
00:59:20,120 --> 00:59:20,620
Why?

721
00:59:20,620 --> 00:59:24,608
Because presumably, the names are alphabetized in here, and there's no cheat sheet on the edge.

722
00:59:24,608 --> 00:59:29,150
So I have to search for John Harvard from left to right, searching for H, if it's alphabetized by last name.

723
00:59:29,150 --> 00:59:30,740
Well, what would be marginally better?

724
00:59:30,740 --> 00:59:32,240
Well, how about two pages at a time?

725
00:59:32,240 --> 00:59:41,150
It's hard to do with a 20-year-old phone book, where the pages are grown together, but 2, 4, 6, 8, 10, 12.

726
00:59:41,150 --> 00:59:42,605
This algorithm, is this correct?

727
00:59:42,605 --> 00:59:43,465
AUDIENCE: No.

728
00:59:43,465 --> 00:59:44,150
DAVID J. MALAN: All right, so no.

729
00:59:44,150 --> 00:59:44,780
Why?

730
00:59:44,780 --> 00:59:46,280
AUDIENCE: You're skipping pages.

731
00:59:46,280 --> 00:59:46,610
DAVID J. MALAN: Yeah.

732
00:59:46,610 --> 00:59:48,060
So I'm skipping every other page.

733
00:59:48,060 --> 00:59:56,120
So if I don't consider that, and I find myself in like the I section or the J section, well, I might accidentally conclude,

734
00:59:56,120 --> 01:00:01,130
nope, I haven't found John Harvard yet, just because I skipped him, because it was sandwiched between two pages.

735
01:00:01,130 --> 01:00:08,100
Now, I can fix this, I think, if I do hit the I section, well, let me just double back one page, just in case he was in that last page.

736
01:00:08,100 --> 01:00:12,277
So it's recoverable, but it's almost twice as fast, minus that hiccup there.

737
01:00:12,277 --> 01:00:18,020
But what most of us would do, and what your phones are doing, albeit digitally, is they open up roughly to the middle of the phonebook.

738
01:00:18,020 --> 01:00:21,747
And they look down, and they say, oh, I'm in roughly the M section.

739
01:00:21,747 --> 01:00:24,080
So I'm roughly halfway through the 1,000-page phonebook.

740
01:00:24,080 --> 01:00:26,510
But what do I now know about John Harvard?

741
01:00:26,510 --> 01:00:29,820
Where is he, to my left or to my right?

742
01:00:29,820 --> 01:00:30,320
All right.

743
01:00:30,320 --> 01:00:39,950
So alphabetically, he's presumably to my left, and so here I can, both metaphorically and physically, tear the problem in half.

744
01:00:39,950 --> 01:00:41,330
You don't need to be impressed.

745
01:00:41,330 --> 01:00:46,460
It's really easy down the spine that way, but I know that John Harvard is to the left here.

746
01:00:46,460 --> 01:00:53,810
But now I can throw, unnecessarily dramatically, half and page one out of the way, and what do I now know?

747
01:00:53,810 --> 01:00:55,910
I've gone from 1,000 pages to like 500.

748
01:00:55,910 --> 01:00:57,602
I can repeat roughly the same algorithm.

749
01:00:57,602 --> 01:01:00,560
Go to the half of this, and so this time, I went back a little too far.

750
01:01:00,560 --> 01:01:03,150
I'm in now the E section.

751
01:01:03,150 --> 01:01:04,040
So what do I know?

752
01:01:04,040 --> 01:01:07,490
Is John Harvard to my left or to my right?

753
01:01:07,490 --> 01:01:09,950
To my right, so I can, again, tear the problem in half.

754
01:01:09,950 --> 01:01:12,800
Throw this half away, and now I'm really flying.

755
01:01:12,800 --> 01:01:18,380
I'm doing it verbally slowly, but that went from 1,000 pages to 500 to now 250.

756
01:01:18,380 --> 01:01:20,960
And now I can do it again, 125.

757
01:01:20,960 --> 01:01:32,210
I do it again, roughly like 67, and keep doing it again and again and again, until I get left with, hopefully, just one single page or in this case an ad for, ironically, a mechanic.

758
01:01:32,210 --> 01:01:36,620
OK, so what is the implication for our performance?

759
01:01:36,620 --> 01:01:44,340
Well, let's just do this sort of in the abstract, if you will, if that first algorithm were to be plotted just quickly on a chart without even numbers.

760
01:01:44,340 --> 01:01:47,340
Here's my x-axis, size of problem on the x-axis.

761
01:01:47,340 --> 01:01:49,760
So the bigger the problem, the farther out that way.

762
01:01:49,760 --> 01:01:51,200
Time to solve the problem.

763
01:01:51,200 --> 01:01:55,530
The higher you go up on the y-axis, the more time you're taking to solve it.

764
01:01:55,530 --> 01:01:59,850
How would we draw the running time, the amount of time taken to run that first algorithm?

765
01:01:59,850 --> 01:02:01,010
Well, it's going to be a straight line.

766
01:02:01,010 --> 01:02:01,520
Why?

767
01:02:01,520 --> 01:02:09,790
Because if you add one more page next year because more people move to Cambridge, you're going to add one more page turn potentially, so one more second, one more unit of time.

768
01:02:09,790 --> 01:02:10,790
So it's a straight line.

769
01:02:10,790 --> 01:02:12,207
And we'll abstract it away as "n."

770
01:02:12,207 --> 01:02:16,640
If there's n pages in the phone book, the slope of this line is essentially n.

771
01:02:16,640 --> 01:02:22,970
The second algorithm, wherein I was doing two pages at a time, was twice as fast, but it's still a straight line.

772
01:02:22,970 --> 01:02:25,190
And in fact, let me just draw some dotted lines here.

773
01:02:25,190 --> 01:02:32,990
If the phone book is this big, with my first algorithm, it might take this many units of time, this many steps, this many page turns.

774
01:02:32,990 --> 01:02:39,260
But with that second algorithm, notice that the intersection is much lower on the yellow line than on the red.

775
01:02:39,260 --> 01:02:43,517
So n over 2 means there's half as many pages here, if n is the number of pages.

776
01:02:43,517 --> 01:02:49,530
So indeed, that algorithm-- the second one-- is twice as fast minus the little hiccup that I have to double back one page.

777
01:02:49,530 --> 01:02:53,000
But that's not a big deal if I'm still doing things twice as fast.

778
01:02:53,000 --> 01:02:55,340
But the third algorithm looks fundamentally different.

779
01:02:55,340 --> 01:02:56,300
It looks like this.

780
01:02:56,300 --> 01:03:00,320
Logarithms, if you recall from high school or prior-- if you don't, that's fine too.

781
01:03:00,320 --> 01:03:03,900
It's just a fundamentally different function, a different shape.

782
01:03:03,900 --> 01:03:11,720
And notice that the green line is going up and up and up but a much slower rate of increase, which means crazy things are possible.

783
01:03:11,720 --> 01:03:20,890
If two towns in Massachusetts, like Cambridge and Allston, across the river, merge next year, for instance, in terms of their phone book, they're phone book just got twice as big.

784
01:03:20,890 --> 01:03:24,550
For the first algorithm, that's going to take me twice as many steps to go through.

785
01:03:24,550 --> 01:03:29,780
The second algorithm, almost it's going to take me 50% more steps to go through, two at a time.

786
01:03:29,780 --> 01:03:38,650
But the third algorithm, that I ended with, tearing things again and again, dividing and conquering, if you will, in half and in half and in half, how many more steps will my third algorithm

787
01:03:38,650 --> 01:03:42,965
take if Cambridge and Allston merge into a phone book that's twice as big?

788
01:03:42,965 --> 01:03:43,840
AUDIENCE: Four steps.

789
01:03:43,840 --> 01:03:45,590
DAVID J. MALAN: Just one more step, right?

790
01:03:45,590 --> 01:03:46,160
No big deal.

791
01:03:46,160 --> 01:03:50,960
You just take a really big bite out of the problem once you decide if John Harvard is to the left or to the right.

792
01:03:50,960 --> 01:03:53,470
And so you've made much faster progress.

793
01:03:53,470 --> 01:04:04,090
And so this, in essence, is what your computer, your phone is probably doing underneath the hood when searching for Harry or Hermione or Hagrid or anyone else because it's that much faster,

794
01:04:04,090 --> 01:04:05,590
especially when you have large data.

795
01:04:05,590 --> 01:04:13,360
If you don't have that many contacts, it probably doesn't matter if you search from top to bottom or more in the form of this divide-and-conquer algorithm.

796
01:04:13,360 --> 01:04:18,920
But if you're the Googles of the world or you're analyzing large data sets, indeed, this is going to add up quite quickly.

797
01:04:18,920 --> 01:04:20,420
So where do we go with this?

798
01:04:20,420 --> 01:04:23,140
Well, we're going to introduce next something called pseudocode.

799
01:04:23,140 --> 01:04:27,673
How can I translate what I did verbally there, sort of intuitively, to actual code?

800
01:04:27,673 --> 01:04:28,840
Well, this won't be Scratch.

801
01:04:28,840 --> 01:04:30,830
This won't be C or Python just yet.

802
01:04:30,830 --> 01:04:32,840
It's just going to be an English-like syntax.

803
01:04:32,840 --> 01:04:35,530
And this is how many programmers would start solving a problem.

804
01:04:35,530 --> 01:04:38,763
They don't start typing out code in C or Python or the like.

805
01:04:38,763 --> 01:04:43,210
They use English or whatever their human language is to jot down an outline for their ideas.

806
01:04:43,210 --> 01:04:45,700
My first step, really, was picking up the phone book.

807
01:04:45,700 --> 01:04:48,790
My second step was opening to the middle of the phone book.

808
01:04:48,790 --> 01:04:52,570
My third step was somewhat different-- look at the page, because why?

809
01:04:52,570 --> 01:04:57,670
My fourth step was if person I'm looking for is on the page, I then do what?

810
01:04:57,670 --> 01:05:00,820
It never happened in my example, but I call the person.

811
01:05:00,820 --> 01:05:01,960
So I'm done.

812
01:05:01,960 --> 01:05:08,830
Else if the person is earlier in the book alphabetically, as John Harvard was in the case of my H, then

813
01:05:08,830 --> 01:05:12,460
I should search to the middle of the left of the phone book.

814
01:05:12,460 --> 01:05:15,800
And then I should go back to step three.

815
01:05:15,800 --> 01:05:19,540
Step 3 is look at the page, thereby repeating the same process again and again.

816
01:05:19,540 --> 01:05:29,050
Step 9, though, might be else if the person is later in the book, then let's go ahead and open to the middle of the right half of the book and then go back to line 3.

817
01:05:29,050 --> 01:05:37,750
Else there's a fourth scenario we should probably consider, lest my search process freeze or crash or give me one of those spinning beach balls with a bug.

818
01:05:37,750 --> 01:05:38,470
Yeah--

819
01:05:38,470 --> 01:05:39,580
AUDIENCE: [INAUDIBLE]

820
01:05:39,580 --> 01:05:41,620
DAVID J. MALAN: Yeah, what if John Harvard isn't in the phone book?

821
01:05:41,620 --> 01:05:44,438
I'd prefer that my algorithm, my phone not just reboot or freeze.

822
01:05:44,438 --> 01:05:46,480
I should handle that with some kind of catch all.

823
01:05:46,480 --> 01:05:49,420
Else, so to speak, let's just quit the program.

824
01:05:49,420 --> 01:05:54,340
So there's well-defined behavior for every possible scenario of the four.

825
01:05:54,340 --> 01:05:56,470
Now, let's call out a few of these salient terms.

826
01:05:56,470 --> 01:06:00,620
It turns out, if I highlight in yellow here, there's a pattern to what I've been doing here.

827
01:06:00,620 --> 01:06:02,050
These are all of my English verbs.

828
01:06:02,050 --> 01:06:05,410
And in a moment, we're going to start calling those verbs "functions."

829
01:06:05,410 --> 01:06:14,020
When you program or write code and you want the program or the computer to do something for you, some action or verb, we're going to refer to those actions or verbs

830
01:06:14,020 --> 01:06:16,510
as these things called "functions," like those here.

831
01:06:16,510 --> 01:06:20,950
By contrast, I've just highlighted, instead, my "if," my "else if," my "else if," and "else."

832
01:06:20,950 --> 01:06:29,860
This is going to represent what we're going to start calling a "conditional," a proverbial fork in the road where you can either go this way or that way, do this thing or this other thing.

833
01:06:29,860 --> 01:06:38,230
And you're going to decide which of those things to do based on what I've now highlighted here, which are going to be called "Boolean expressions"--

834
01:06:38,230 --> 01:06:41,260
Boole, referring to a mathematician, last name Boole.

835
01:06:41,260 --> 01:06:47,980
A Boolean expression is just a question with a yes/no, a true/false, a 1 or a 0 answer, if you will.

836
01:06:47,980 --> 01:06:51,790
And it governs whether you do this thing or this thing or this thing or that.

837
01:06:51,790 --> 01:06:54,440
The indentation, in this case, is important.

838
01:06:54,440 --> 01:07:06,410
The fact that I've indented line 5 implies, by convention in programming, that I should only do line 5 if the answer to line 4 is a yes or a true, and same for these other indented lines as well.

839
01:07:06,410 --> 01:07:09,492
And the last characteristic here is this here.

840
01:07:09,492 --> 01:07:11,200
Someone called this out earlier, in fact.

841
01:07:11,200 --> 01:07:15,580
These lines, 8 and 11, are now highlighted and represent what?

842
01:07:15,580 --> 01:07:24,820
What might we call these in code if you've done-- yeah, so these are loops, some kind of cycles that result in my doing the same thing again and again,

843
01:07:24,820 --> 01:07:28,240
but there's a key detail with this algorithm in pseudocode.

844
01:07:28,240 --> 01:07:34,750
Even though it's telling me to go back to line 3, why is this algorithm eventually going to stop?

845
01:07:34,750 --> 01:07:43,010
Why do I not constantly keep looking for John Harvard forever by nature of these loops telling me to keep going back to line 3?

846
01:07:43,010 --> 01:07:43,580
Good.

847
01:07:43,580 --> 01:07:51,260
Eventually, he'll be on the page or, to your point earlier, he won't be at all and we're out of pages, and so we just quit.

848
01:07:51,260 --> 01:07:54,050
And that's the key about going to the left half or the right half.

849
01:07:54,050 --> 01:07:56,430
It doesn't matter if you do the same thing again and again.

850
01:07:56,430 --> 01:08:03,890
You're not going to get stuck in a so-called infinite loop so long as you keep dividing the problem and shrinking it into something smaller, smaller, smaller.

851
01:08:03,890 --> 01:08:06,570
Eventually, there's going to be no problem left to solve.

852
01:08:06,570 --> 01:08:11,479
So even if you don't think of yourself as a computer person, even if you've never written code

853
01:08:11,479 --> 01:08:18,080
what you'll find in the coming days is that these ideas that we've just kind of harnessed from real life are at your fingertips already.

854
01:08:18,080 --> 01:08:25,880
And a lot of the process of learning to code is just going to be some bumps in the road because you can't quite see the new syntax in a familiar way.

855
01:08:25,880 --> 01:08:30,380
But you'll find that the ideas, in fact, are going to be more familiar than you might otherwise think.

856
01:08:30,380 --> 01:08:38,240
And so we'll see in a bit-- and we'll take a break in a moment to take a breather-- that you will see these same ideas in a moment in the context of Scratch,

857
01:08:38,240 --> 01:08:42,743
an actual programming language via which we'll drag and drop puzzle pieces to make actual code work.

858
01:08:42,743 --> 01:08:47,040
We'll see some variants of these ideas, things called "arguments" and "return values" and "variables."

859
01:08:47,040 --> 01:08:50,660
But we'll ultimately convert it into this somehow.

860
01:08:50,660 --> 01:08:56,810
Anyone want to wager what this program will do if fed to your Mac or PC or phone?

861
01:08:56,810 --> 01:08:59,975
Here's just a massive pattern of zeros and ones.

862
01:08:59,975 --> 01:09:01,199
AUDIENCE: [INAUDIBLE]

863
01:09:01,200 --> 01:09:05,370
DAVID J. MALAN: It will indeed say, rather disappointingly, apparently, just, "Hello, world."

864
01:09:05,370 --> 01:09:15,750
And indeed, baked into all of these 0's and 1's are not just the H-E-L-L-O, but also the verbs, the action of printing something to the screen.

865
01:09:15,750 --> 01:09:23,870
And there's other stuff too so that the program knows how to start and how to stop, a lot of stuff that we won't have to worry about, that whoever designed the computer or the language did.

866
01:09:23,870 --> 01:09:31,319
But at the end of the day, you're never going to be writing the 0's and 1's yourselves, though our ancestors, once upon a time, did in some form.

867
01:09:31,319 --> 01:09:39,189
We'll be using a much higher-level language, like this in C, or better yet, in just a moment, like in Scratch, like this.

868
01:09:39,189 --> 01:09:45,812
And indeed, this is why today we focus on and begin with Scratch, this graphical programming language

869
01:09:45,812 --> 01:09:49,937
so we have a way of expressing ourselves with functions, conditionals, loops, and more

870
01:09:49,937 --> 01:09:57,720
but in a way that doesn't have stupid parentheses and curly braces and all of these visual distractions in the way and will translate that thereafter to this lower-level language.

871
01:09:57,720 --> 01:09:59,027
But for now, that was a lot.

872
01:09:59,027 --> 01:10:03,365
That was definitely a fire hose. Let's go ahead and take a 10-minute break. Feel free to get up or stay here.

873
01:10:03,365 --> 01:10:06,755
And we'll resume in a bit with some actual code.

874
01:10:06,755 --> 01:10:07,422
[VIDEO PLAYBACK]

875
01:10:07,422 --> 01:10:11,374
[MUSIC - THE WEATHER GIRLS, "IT'S RAINING MEN"] [MUSIC PLAYING]

876
01:10:11,374 --> 01:10:13,844
[THUNDER RUMBLING]

877
01:10:35,505 --> 01:10:36,130
- (SINGING) Hi.

878
01:10:36,130 --> 01:10:37,000
Hi.

879
01:10:37,000 --> 01:10:41,491
We're your Weather Girls, and have we got news for you.

880
01:10:41,491 --> 01:10:42,485
You better listen.

881
01:10:42,485 --> 01:10:45,540
Get ready, all you lonely girls.

882
01:10:45,540 --> 01:10:47,940
And leave those umbrellas at home.

883
01:10:47,940 --> 01:10:49,217
All right.

884
01:10:49,217 --> 01:10:51,140
Humidity is rising.

885
01:10:51,140 --> 01:10:52,912
Hmm, rising.

886
01:10:52,912 --> 01:10:54,460
Barometer's getting low.

887
01:10:54,460 --> 01:10:56,034
How low, girl?

888
01:10:56,034 --> 01:11:01,600
According to all sources-- what sources, now-- the street's the place to go.

889
01:11:01,600 --> 01:11:02,880
We better hurry up.

890
01:11:02,880 --> 01:11:18,100
'Cause tonight, for the first time, just about half-past 10:00-- half-past 10:00-- for the first time in history, it's going to start raining men-- start raining men!

891
01:11:18,100 --> 01:11:21,650
It's raining men, hallelujah!

892
01:11:21,650 --> 01:11:25,780
It's raining men, amen!

893
01:11:25,780 --> 01:11:27,505
I'm going to go out.

894
01:11:27,505 --> 01:11:33,920
I'm going to let myself get absolutely soaking wet!

895
01:11:33,920 --> 01:11:37,045
It's raining men, hallelujah!

896
01:11:37,045 --> 01:11:38,795
DAVID J. MALAN: [CHUCKLES] All right, so--

897
01:11:38,795 --> 01:11:39,378
[END PLAYBACK]

898
01:11:39,378 --> 01:11:41,400
[APPLAUSE]

899
01:11:43,720 --> 01:11:49,312
So this then is Scratch, a graphical programming language from our friends down the road at MIT's Media Lab

900
01:11:49,312 --> 01:11:58,630
that indeed some of you might have used in grade school or the like, for playing and writing code and the like, but you maybe didn't necessarily think about how some of these primitives ultimately worked.

901
01:11:58,630 --> 01:12:07,120
And in fact, everything you've done-- if you've used Scratch before-- and everything you'll see today is going to apply to all of the weeks to come, as we explore these things called "functions"

902
01:12:07,120 --> 01:12:09,820
and "loops" and "conditionals," "Boolean expressions" and more.

903
01:12:09,820 --> 01:12:17,860
With Scratch, because it's so graphical and animated-congruent, can you create animations, like this one, interactive art, and software more generally.

904
01:12:17,860 --> 01:12:23,990
But you'll do so by dragging and dropping puzzle pieces that only lock together if it makes logical sense to do so.

905
01:12:23,990 --> 01:12:33,460
And you won't have to deal with, in this first week of class, is curly braces, parentheses, all of the weird symbology that you might recall seeing, when we just wanted to say, "Hello, world."

906
01:12:33,460 --> 01:12:41,860
Now, this particular program, "Raining Men," was written by a former CS50 teaching fellow, Andrew Berry, who's actually now the general manager of the Cleveland

907
01:12:41,860 --> 01:12:43,730
Browns, the American football team.

908
01:12:43,730 --> 01:12:48,400
And so these are just some of the programs that some of your predecessors in the class have created.

909
01:12:48,400 --> 01:12:56,170
And you'll see, in the remainder of class here, a couple of others as well, and more in the course's first assignment, namely, problem set zero.

910
01:12:56,170 --> 01:12:57,470
So how do we get there?

911
01:12:57,470 --> 01:13:00,040
Well, first a quick tour of what it is we're going to do.

912
01:13:00,040 --> 01:13:03,523
This, in Scratch, is perhaps the simplest program you can write.

913
01:13:03,523 --> 01:13:09,970
And even if you've never seen Scratch or any programming language before, you can probably guess that this just says, on the screen somehow,

914
01:13:09,970 --> 01:13:10,940
"Hello, World."

915
01:13:10,940 --> 01:13:16,720
But what you don't have to do is type esoteric commands and weird syntax, those curly braces and parentheses I keep alluding to.

916
01:13:16,720 --> 01:13:18,970
You just drag this yellow puzzle piece.

917
01:13:18,970 --> 01:13:20,530
You drag this purple puzzle piece.

918
01:13:20,530 --> 01:13:22,810
Let them magnetically lock together, so to speak.

919
01:13:22,810 --> 01:13:24,430
Click a button and boom.

920
01:13:24,430 --> 01:13:31,010
With those same building blocks and several others, can you make exactly the sorts of things that Andrew brought to life as well.

921
01:13:31,010 --> 01:13:32,740
So here's what we're about to see.

922
01:13:32,740 --> 01:13:38,500
At Scratch.MIT.edu is a cloud-based programming environment on MIT servers.

923
01:13:38,500 --> 01:13:41,380
You can also download it offline on your own Mac or PC.

924
01:13:41,380 --> 01:13:43,870
And it gives you an interface like this.

925
01:13:43,870 --> 01:13:47,770
On the left-hand side of the screen, you'll see a blocks palette.

926
01:13:47,770 --> 01:13:52,540
These puzzle pieces, a.k.a. blocks, come in different colors which rather categorize them.

927
01:13:52,540 --> 01:13:57,040
So pictured here, for instance, in blue, are a whole bunch of motion-related blocks.

928
01:13:57,040 --> 01:14:05,110
So Andrew used a whole bunch of those to have the singer and the men moving around on the screen in synchronicity with the song that was playing in the background.

929
01:14:05,110 --> 01:14:09,310
Meanwhile, in the middle of this interface is going to be the code area.

930
01:14:09,310 --> 01:14:14,729
And this is where Andrew, and soon you, will drag and drop some of those puzzle pieces and other colors as well

931
01:14:14,729 --> 01:14:20,110
and lock them together to get your character-- soon to be invented-- to do something on the screen.

932
01:14:20,110 --> 01:14:29,650
Indeed, at the bottom right here, will you see, ultimately, a sprite area, where a sprite is a technical term for like a character in a video game or a programming environment like this.

933
01:14:29,650 --> 01:14:36,020
By default, historically, Scratch is the cat, the mascot, if you will, for this programming environment.

934
01:14:36,020 --> 01:14:42,490
And so here we see, by default, just one sprite selected because on the top right of the screen is the stage for that sprite.

935
01:14:42,490 --> 01:14:45,310
And you can click and zoom in to make it full screen.

936
01:14:45,310 --> 01:14:49,120
But this is the world in which Scratch-- by default, the cat-- will live.

937
01:14:49,120 --> 01:14:55,854
But you can change Scratch's costume so that it looks like a singer or the man falling from the sky or the like or anything else

938
01:14:55,854 --> 01:15:00,260
either creating the art yourself or importing some of the things that come with it or elsewhere online.

939
01:15:00,260 --> 01:15:03,640
So what is this world that Scratch rather lives in?

940
01:15:03,640 --> 01:15:08,646
Well, generally speaking, we won't have to care too much about numbers because we'll be able to ask questions

941
01:15:08,646 --> 01:15:15,520
like interactive ones, like is Scratch the cat, or any character otherwise, touching the edge of the screen, touching something else?

942
01:15:15,520 --> 01:15:21,080
But Scratch does exist in this two-dimensional coordinate-system world.

943
01:15:21,080 --> 01:15:27,700
So when the cat or any character is dead center in the middle, that would be xy location 0,0, if you will.

944
01:15:27,700 --> 01:15:32,990
Meanwhile, over here is 240 pixels, or dots, all the way to the right.

945
01:15:32,990 --> 01:15:37,700
So this would be 240,0, where y is 0 because it's right on that midline.

946
01:15:37,700 --> 01:15:39,460
So it's neither up or below.

947
01:15:39,460 --> 01:15:43,330
Over here to the left, of course, would be -240 and 0.

948
01:15:43,330 --> 01:15:48,880
Above the cat would be x equals 0, because it's right on that vertical midline, and 180.

949
01:15:48,880 --> 01:15:52,152
And then down here, as you might guess, would be 0, negative 180.

950
01:15:52,152 --> 01:15:55,733
Generally speaking, we don't have to care about those precise pixel coordinates.

951
01:15:55,733 --> 01:15:59,400
But it's helpful, ultimately, if you do want the cat to move up, down, left, or right.

952
01:15:59,400 --> 01:16:06,010
Having some sense of direction according to the x-axis and y-axis as well can help you express your ideas, ultimately.

953
01:16:06,010 --> 01:16:08,680
So what might some of those ideas be?

954
01:16:08,680 --> 01:16:09,950
Well, let's do this.

955
01:16:09,950 --> 01:16:18,293
I'm going to go ahead and create, on Scratch.MIT.edu, just an empty screen like this one here.

956
01:16:18,293 --> 01:16:19,960
And so this is the exact same interface.

957
01:16:19,960 --> 01:16:24,490
But now I'm in my browser, full screen, so that I can start writing some code.

958
01:16:24,490 --> 01:16:27,222
And let's get that cat to say something actually on the screen.

959
01:16:27,222 --> 01:16:28,930
Now, this takes a little bit of practice.

960
01:16:28,930 --> 01:16:36,538
But honestly, just by scrolling through these puzzle pieces can you quickly get a sense of what's possible, not just categorically, but specifically.

961
01:16:36,538 --> 01:16:39,163
And I'll jump around because I've done this, of course, before.

962
01:16:39,163 --> 01:16:41,410
But I'm going to go to events, in yellow, first.

963
01:16:41,410 --> 01:16:45,475
And I'm going to drag and drop this first block, called when Green Flag clicked.

964
01:16:45,475 --> 01:16:48,100
And I've zoomed in there just to make it a little more legible.

965
01:16:48,100 --> 01:16:57,070
And notice that the shape of this Green Flag just so happens to mirror this Green Flag here at top, next to this red Stop Sign, of sorts.

966
01:16:57,070 --> 01:17:02,320
And the Green Flag is going to mean go and the red Stop Sign is going to mean stop, to start or stop our program.

967
01:17:02,320 --> 01:17:06,560
Next week, you're going to be writing a textual command at your keyboard to do the exact same idea.

968
01:17:06,560 --> 01:17:07,790
But for now, it's a button.

969
01:17:07,790 --> 01:17:10,667
So when Green Flag clicked, what do I want Scratch to do?

970
01:17:10,667 --> 01:17:18,790
Well, how about we have Scratch just initially say something like, "Hello, world," which indeed, historically, is the first program that most any programmer might write.

971
01:17:18,790 --> 01:17:24,490
So anything related to what the cat looks like it's doing is actually going to be under looks, here in purple.

972
01:17:24,490 --> 01:17:27,100
So I'm going to drag over Say "hello."

973
01:17:27,100 --> 01:17:30,820
And you'll notice something curious and different about this purple block.

974
01:17:30,820 --> 01:17:33,400
It says, of course, "Say" in purple.

975
01:17:33,400 --> 01:17:40,810
But then there's this white oval and some text that, by default, is "hello" because MIT just decided that, by default, the placeholder will be "hello."

976
01:17:40,810 --> 01:17:48,790
But anytime you see this white oval, it's an opportunity to provide an input into the function called Say.

977
01:17:48,790 --> 01:17:50,980
And so here I'm borrowing terminology from before.

978
01:17:50,980 --> 01:17:54,280
Problem solving, again, is all about inputs producing outputs.

979
01:17:54,280 --> 01:17:56,045
And in between there is some algorithm.

980
01:17:56,045 --> 01:18:00,470
In a moment, we're going to start referring to algorithms quite frequently as "functions."

981
01:18:00,470 --> 01:18:00,970
Why?

982
01:18:00,970 --> 01:18:03,350
Because it's the implementation of some algorithm.

983
01:18:03,350 --> 01:18:06,640
So let me override the default with, "Hello, world."

984
01:18:06,640 --> 01:18:07,690
I'll zoom out.

985
01:18:07,690 --> 01:18:15,310
And now if I go to the top right of the screen and click the Green Flag, we'll see, hopefully, my very first program in code.

986
01:18:15,310 --> 01:18:17,190
Now, it wasn't a huge lift, right?

987
01:18:17,190 --> 01:18:19,690
It only was a matter of dragging and dropping puzzle pieces.

988
01:18:19,690 --> 01:18:21,070
But what has now happened?

989
01:18:21,070 --> 01:18:23,530
Well, it turns out that two things have happened.

990
01:18:23,530 --> 01:18:26,710
When I, the human, clicked on that Green Flag,

991
01:18:26,710 --> 01:18:29,570
I triggered, what we're going to start calling now, an "event."

992
01:18:29,570 --> 01:18:34,580
An event is generally something graphical or interactive that just happens in a computer program.

993
01:18:34,580 --> 01:18:37,600
You and I trigger events on our phones all day long.

994
01:18:37,600 --> 01:18:45,460
Whenever you tap or drag or long press or pinch or any of those gestures in vogue nowadays on phones, you are triggering events.

995
01:18:45,460 --> 01:18:52,880
And people at Apple and Google and elsewhere have written code that listen for those events and do something when that event happens.

996
01:18:52,880 --> 01:18:54,010
That's what I just did.

997
01:18:54,010 --> 01:19:01,150
When Green Flag is clicked, I want something to happen, namely, I want this purple function, this verb, this action called

998
01:19:01,150 --> 01:19:02,910
Say, to do something.

999
01:19:02,910 --> 01:19:03,910
What do I want it to do?

1000
01:19:03,910 --> 01:19:05,590
I want it to say what this input is.

1001
01:19:05,590 --> 01:19:07,900
And I'm going to introduce another vocabulary term.

1002
01:19:07,900 --> 01:19:11,350
The white ovals here are, yes, inputs, very generically.

1003
01:19:11,350 --> 01:19:16,080
But in a programmer's terminology, they're called "arguments," otherwise known as "parameters."

1004
01:19:16,080 --> 01:19:20,050
And that just means an input to a function that modifies its behavior in some way.

1005
01:19:20,050 --> 01:19:22,253
When I click Stop, that's just another event.

1006
01:19:22,253 --> 01:19:23,920
And that one is just built into Scratch.

1007
01:19:23,920 --> 01:19:28,490
Scratch knows that when you click the green Stop Sign, everything should just stop automatically.

1008
01:19:28,490 --> 01:19:30,950
I don't have to write code to support that feature.

1009
01:19:30,950 --> 01:19:33,470
So that's all fine and good, "Hello, world."

1010
01:19:33,470 --> 01:19:39,130
But if I keep doing stop and start and stop and start, it's going to do the same thing again and again.

1011
01:19:39,130 --> 01:19:45,350
And it's really not that interesting, at the end of the day, maybe gratifying once, but it'd be nice if this were a little more interactive.

1012
01:19:45,350 --> 01:19:48,140
So it turns out that we can do that too.

1013
01:19:48,140 --> 01:19:50,450
But we need a different mental model instead.

1014
01:19:50,450 --> 01:19:53,740
So in this case here, when we think about this function,

1015
01:19:53,740 --> 01:20:01,870
Say, in this input, "Hello, world," this actually maps pretty cleanly to this model earlier, that I propose is problem solving, is computer science, if you will.

1016
01:20:01,870 --> 01:20:05,770
The input to the current problem is going to be in white here,

1017
01:20:05,770 --> 01:20:06,760
"Hello, world."

1018
01:20:06,760 --> 01:20:10,300
The algorithm is the "say" algorithm.

1019
01:20:10,300 --> 01:20:14,330
Now, I don't know how MIT got it to print out the little, pretty speech bubble on the screen.

1020
01:20:14,330 --> 01:20:17,770
But they wrote those underlying low-level implementation details.

1021
01:20:17,770 --> 01:20:22,630
And they gave me and you a purple function, called Say, that just does that for you.

1022
01:20:22,630 --> 01:20:24,670
You and I don't have to reinvent that wheel.

1023
01:20:24,670 --> 01:20:28,580
The output of Say is another technical term, now, called a "side effect."

1024
01:20:28,580 --> 01:20:34,008
A side effect is usually something visual that happens, like as a side effect of you calling a function.

1025
01:20:34,008 --> 01:20:39,800
And so the side effect here is that the cat has this speech bubble magically appear, inside of which is "Hello, world."

1026
01:20:39,800 --> 01:20:41,200
So we have an input.

1027
01:20:41,200 --> 01:20:42,370
We have an output.

1028
01:20:42,370 --> 01:20:43,540
We have an algorithm.

1029
01:20:43,540 --> 01:20:46,910
But now we're talking about these ideas in the context of programming.

1030
01:20:46,910 --> 01:20:49,420
So now the input is an "argument."

1031
01:20:49,420 --> 01:20:51,400
The algorithm is a "function."

1032
01:20:51,400 --> 01:20:55,840
And the output, in this case, is a "side effect"-- terminology that you'll just hear more and more.

1033
01:20:55,840 --> 01:21:00,800
And it'll eventually sink in, but not to worry if the terminology doesn't come naturally early on.

1034
01:21:00,800 --> 01:21:03,890
So what more might I do with this?

1035
01:21:03,890 --> 01:21:09,910
Let me go back to Scratch here and make this maybe perhaps more interactive and actually get the cat to say something a little more dynamically.

1036
01:21:09,910 --> 01:21:15,050
So instead of "Hello, world," why don't we get him to say hello to me or to you or anyone else?

1037
01:21:15,050 --> 01:21:16,010
So let me do this.

1038
01:21:16,010 --> 01:21:20,200
Let me go under, say-- let me get rid of this first.

1039
01:21:20,200 --> 01:21:22,090
And you'll notice this neat trick.

1040
01:21:22,090 --> 01:21:28,480
As soon as you start dragging on a block, if it gets close to it, it kind of goes gray, and it can be magnetically snapped together.

1041
01:21:28,480 --> 01:21:30,220
You don't have to do it very precisely.

1042
01:21:30,220 --> 01:21:32,345
Conversely, if I want to get rid of a puzzle piece,

1043
01:21:32,345 --> 01:21:35,800
I can just drag it anywhere on the left, let go, and that deletes it.

1044
01:21:35,800 --> 01:21:39,902
Or you can Right-click or Control-click and a little menu will let you delete it as well.

1045
01:21:39,902 --> 01:21:41,110
Well, let me do this instead.

1046
01:21:41,110 --> 01:21:50,700
Under Sensing, which I know is there because I've done this before, are a whole bunch of things related to Sensing, whereby the cat can kind of feel out its world, in some sense.

1047
01:21:50,700 --> 01:21:55,620
It can do things like ask this question, "Am I touching the mouse pointer?"-- like the user's cursor.

1048
01:21:55,620 --> 01:21:59,010
"Am I touching a specific color that you can override to be anything you want?"

1049
01:21:59,010 --> 01:22:02,500
"Is the distance to the mouse pointer some specific value?"

1050
01:22:02,500 --> 01:22:12,030
But for now, I'm going to focus on this, this blue puzzle piece that asks a question, which itself is this white oval that I can apparently change, and then it's going to wait for a response.

1051
01:22:12,030 --> 01:22:14,443
But this puzzle piece is a little different.

1052
01:22:14,443 --> 01:22:15,360
It's a little special.

1053
01:22:15,360 --> 01:22:16,590
It comes with a freebie.

1054
01:22:16,590 --> 01:22:19,690
It comes with what we're going to call, technically, a "return value."

1055
01:22:19,690 --> 01:22:22,590
So some functions don't just do something on the screen.

1056
01:22:22,590 --> 01:22:27,570
They hand you back, so to speak, a value that you can do anything that you want with.

1057
01:22:27,570 --> 01:22:31,750
Nothing happens immediately unless you do something with that so-called return value.

1058
01:22:31,750 --> 01:22:35,633
So let me go ahead and drag this thing over here, ask, "What's your name?"

1059
01:22:35,633 --> 01:22:37,050
And I'll use the default question.

1060
01:22:37,050 --> 01:22:38,675
That seems a reasonable place to start.

1061
01:22:38,675 --> 01:22:41,970
I'm not going to override that default. And now let me go ahead and zoom out.

1062
01:22:41,970 --> 01:22:43,890
Let me go back to Looks.

1063
01:22:43,890 --> 01:22:46,320
Let me go to Say.

1064
01:22:46,320 --> 01:22:48,850
And let me just form the English sentence I want.

1065
01:22:48,850 --> 01:22:53,730
So let me zoom in here and type in "hello," maybe comma, space.

1066
01:22:53,730 --> 01:23:00,270
I could do "David," but that's obviously not right because I'm asking for a name, and then I'm like, in advance, hard-coding my name.

1067
01:23:00,270 --> 01:23:01,228
That's not what I want.

1068
01:23:01,228 --> 01:23:02,610
I just want, "hello," comma.

1069
01:23:02,610 --> 01:23:06,180
And now let me zoom out and grab one more Say block.

1070
01:23:06,180 --> 01:23:07,500
Let me maybe Say here.

1071
01:23:07,500 --> 01:23:09,180
OK, I don't want to say, "Hello, hello."

1072
01:23:09,180 --> 01:23:14,230
I don't want to just type in my own name because, again, then what's the point of asking the user for their name?

1073
01:23:14,230 --> 01:23:15,300
But notice this.

1074
01:23:15,300 --> 01:23:22,080
If I go back to the sensing block, this is where that oval that's blue, called Answer, is useful.

1075
01:23:22,080 --> 01:23:25,280
This will be the so-called "return value" of that function.

1076
01:23:25,280 --> 01:23:27,780
So I'm just going to go ahead and do this and drag and drop.

1077
01:23:27,780 --> 01:23:30,600
Even though it's not the right size, it is the right shape.

1078
01:23:30,600 --> 01:23:34,620
And so Scratch will be smart about it and grow to fill that puzzle piece for you.

1079
01:23:34,620 --> 01:23:35,820
Let me zoom out now.

1080
01:23:35,820 --> 01:23:37,607
And now let me click the Green Flag.

1081
01:23:37,607 --> 01:23:40,440
You'll see that Scratch is indeed prompting me with a speech bubble,

1082
01:23:40,440 --> 01:23:41,232
"What's your name?"

1083
01:23:41,232 --> 01:23:44,320
Notice the little text box below the cat is asking, what's your name?

1084
01:23:44,320 --> 01:23:46,590
So I'm going to type in D-A-V-I-D and hit Enter.

1085
01:23:46,590 --> 01:23:48,120
Or I can click the blue check.

1086
01:23:48,120 --> 01:23:50,310
Enter.

1087
01:23:50,310 --> 01:23:51,802
OK, it's a little weird.

1088
01:23:51,802 --> 01:23:53,760
I wanted him to say, "hello," not just my name.

1089
01:23:53,760 --> 01:23:55,020
So let me Stop.

1090
01:23:55,020 --> 01:23:56,190
Let me start it again.

1091
01:23:56,190 --> 01:23:57,648
All right, hello, what's your name?

1092
01:23:57,648 --> 01:24:00,230
D-A-V-I-D. Enter.

1093
01:24:00,230 --> 01:24:02,490
Huh-- kind of rude.

1094
01:24:02,490 --> 01:24:04,890
Why is there this bug?

1095
01:24:04,890 --> 01:24:07,920
Like, I wanted to say, "Hello, David," not just "David."

1096
01:24:07,920 --> 01:24:11,550
And yet twice it has failed to do so.

1097
01:24:11,550 --> 01:24:12,560
Yeah--

1098
01:24:12,560 --> 01:24:13,577
AUDIENCE: [INAUDIBLE]

1099
01:24:13,577 --> 01:24:17,658
DAVID J. MALAN: Yeah, the computer's processing my directions, my actions, really quickly.

1100
01:24:17,658 --> 01:24:18,950
And so it actually is doing it.

1101
01:24:18,950 --> 01:24:23,220
It's just, you and I, in the room, are just way too slow to notice that it said-- (QUICKLY) "Hello, David."

1102
01:24:23,220 --> 01:24:25,470
It just seems to have just said, "David."

1103
01:24:25,470 --> 01:24:26,910
So all right, how can I fix this?

1104
01:24:26,910 --> 01:24:29,940
Well, here's where you start to poke around and think about how you might solve this.

1105
01:24:29,940 --> 01:24:31,100
Let me go back under Looks.

1106
01:24:31,100 --> 01:24:33,330
Maybe there's a smarter way to do this.

1107
01:24:33,330 --> 01:24:34,520
Maybe I could do--

1108
01:24:34,520 --> 01:24:35,540
OK, I could do this.

1109
01:24:35,540 --> 01:24:42,150
How about instead of just Say "hello," there's apparently another puzzle piece where I can time it so I can maybe slow things down a little bit.

1110
01:24:42,150 --> 01:24:43,110
So let me do this.

1111
01:24:43,110 --> 01:24:45,810
Let me throw away all of this.

1112
01:24:45,810 --> 01:24:49,140
Let me drag a Say "hello" for 2 seconds.

1113
01:24:49,140 --> 01:24:51,870
Let me drag another Say "hello" for 2 seconds.

1114
01:24:51,870 --> 01:24:54,500
Let me change the first one to, indeed, "hello" comma.

1115
01:24:54,500 --> 01:24:57,530
And then let me go back to Sensing.

1116
01:24:57,530 --> 01:25:01,460
Let me grab that same answer because I threw it away a second ago, and I'll just change it.

1117
01:25:01,460 --> 01:25:02,960
I don't even have to delete "hello."

1118
01:25:02,960 --> 01:25:04,740
I can just overwrite it like this.

1119
01:25:04,740 --> 01:25:08,360
So now I think we'll kind of pump the brakes and see things more slowly.

1120
01:25:08,360 --> 01:25:09,620
Let me Stop.

1121
01:25:09,620 --> 01:25:10,550
Let me start.

1122
01:25:10,550 --> 01:25:12,050
D-A-V-I-D, Enter.

1123
01:25:12,050 --> 01:25:14,600
Hello, David.

1124
01:25:14,600 --> 01:25:18,120
OK, so it's better, like it seems to be working.

1125
01:25:18,120 --> 01:25:21,255
I think your hypothesis was right, just looks kind of stupid, right?

1126
01:25:21,255 --> 01:25:22,880
Like, the fact that it's saying Hello--

1127
01:25:22,880 --> 01:25:24,170
[PAUSE]

1128
01:25:24,170 --> 01:25:25,640
--David, like we can do better.

1129
01:25:25,640 --> 01:25:29,930
And like, literally every piece of software on your phone or Mac or PC is better than that.

1130
01:25:29,930 --> 01:25:33,750
It adds words together in the user interfaces you and I are familiar with.

1131
01:25:33,750 --> 01:25:35,480
So let's go a little more fishing here.

1132
01:25:35,480 --> 01:25:36,950
Let me throw away these.

1133
01:25:36,950 --> 01:25:39,860
Let me go back to Looks and just get the simpler Say.

1134
01:25:39,860 --> 01:25:45,720
I want this to say, "Hello" comma name, where name comes from that Answer return value.

1135
01:25:45,720 --> 01:25:46,740
So how can I do this?

1136
01:25:46,740 --> 01:25:49,440
Well, let me go under Operations, which we haven't been before.

1137
01:25:49,440 --> 01:25:50,732
There's a lot of stuff in here.

1138
01:25:50,732 --> 01:25:53,720
Some of it's mathematically related, adding, subtracting, and so forth.

1139
01:25:53,720 --> 01:25:56,280
You can generate random numbers which might be useful.

1140
01:25:56,280 --> 01:25:59,810
And if I keep scrolling down, there's this Join "apple" and "banana."

1141
01:25:59,810 --> 01:26:01,280
But that's just placeholder text.

1142
01:26:01,280 --> 01:26:06,170
You can join one piece of text with another piece of text, by default "apple" and "banana."

1143
01:26:06,170 --> 01:26:08,480
But let's change it to "hello" and my name.

1144
01:26:08,480 --> 01:26:11,120
So this, too, wrong size but right shape.

1145
01:26:11,120 --> 01:26:13,190
So let me let it snap into place.

1146
01:26:13,190 --> 01:26:15,920
Let me go ahead now and do "hello" comma.

1147
01:26:15,920 --> 01:26:20,840
And now I think I just want to go grab that Answer return value.

1148
01:26:20,840 --> 01:26:25,280
Let me drag the same oval as before, clobber-- that is, overwrite-- banana.

1149
01:26:25,280 --> 01:26:28,430
So now I'm kind of composing functions.

1150
01:26:28,430 --> 01:26:33,972
The output of one function, Join, is going to be the input of another function, Say.

1151
01:26:33,972 --> 01:26:38,660
So let's see what happens now that they're kind of stacked on top of each other or nested, so to speak.

1152
01:26:38,660 --> 01:26:42,440
Click the Green Flag, D-A-V-I-D. Enter.

1153
01:26:42,440 --> 01:26:43,357
"Hello, David."

1154
01:26:43,357 --> 01:26:44,690
All right, that was pretty fast.

1155
01:26:44,690 --> 01:26:45,680
Let's just do it once more.

1156
01:26:45,680 --> 01:26:46,310
Stop.

1157
01:26:46,310 --> 01:26:47,270
Start.

1158
01:26:47,270 --> 01:26:49,545
Here we go, D-A-V-I-D. Enter.

1159
01:26:49,545 --> 01:26:50,045
OK.

1160
01:26:50,045 --> 01:26:52,650
All right, it's not the most exciting program in the world.

1161
01:26:52,650 --> 01:26:53,750
But it's more correct.

1162
01:26:53,750 --> 01:26:57,062
It's better designed just because that's what you would kind of expect the software to do

1163
01:26:57,062 --> 01:27:03,962
and not be some kind of lame user interface that's just inserting random delays to just make it kind of work, like that's a workaround, a hack, if you will.

1164
01:27:03,962 --> 01:27:06,170
But there's some cool things you can do with Scratch.

1165
01:27:06,170 --> 01:27:10,940
And we won't really go down the rabbit hole of all of the fun and family-friendly features that it has.

1166
01:27:10,940 --> 01:27:12,810
But there is one that's kind of cool here.

1167
01:27:12,810 --> 01:27:16,550
Let me go into the Extensions button at the bottom left of my screen.

1168
01:27:16,550 --> 01:27:17,720
And this one's kind of cool.

1169
01:27:17,720 --> 01:27:19,575
Let me go to Text to Speech.

1170
01:27:19,575 --> 01:27:22,700
And you'll notice that this one requires internet because it's cloud based.

1171
01:27:22,700 --> 01:27:27,715
But this just gave me some new puzzle pieces in a new category,

1172
01:27:27,715 --> 01:27:28,340
Text to Speech.

1173
01:27:28,340 --> 01:27:30,710
And these green ones do exactly what they say.

1174
01:27:30,710 --> 01:27:31,860
So let me do this.

1175
01:27:31,860 --> 01:27:33,120
Let me zoom out again.

1176
01:27:33,120 --> 01:27:34,543
Let me keep the Join block.

1177
01:27:34,543 --> 01:27:36,710
And I'm just going to temporarily toss it over here.

1178
01:27:36,710 --> 01:27:40,070
It's not going to delete itself because I didn't drag it over to the other side.

1179
01:27:40,070 --> 01:27:42,800
But I'm going to get rid of the Say block, in purple.

1180
01:27:42,800 --> 01:27:47,570
I'm going to do the Speak block here, in green, and let it snap into place.

1181
01:27:47,570 --> 01:27:50,990
And then I'm going to drag and drop this onto the input to Speak.

1182
01:27:50,990 --> 01:27:54,290
And now, perhaps a little more adorably, let's try this.

1183
01:27:54,290 --> 01:27:56,270
Green Flag, what's your name?

1184
01:27:56,270 --> 01:27:57,710
D-A-V-I-D. Enter.

1185
01:27:57,710 --> 01:27:58,460
And--

1186
01:27:58,460 --> 01:28:00,578
COMPUTER: Hello, David.

1187
01:28:00,578 --> 01:28:01,370
DAVID J. MALAN: OK.

1188
01:28:01,370 --> 01:28:02,370
[LAUGHTER]

1189
01:28:02,370 --> 01:28:03,890
It's a little robotic.

1190
01:28:03,890 --> 01:28:05,917
But at least now it has synthesized speech.

1191
01:28:05,917 --> 01:28:13,550
And I've kind of got my own, like, Siri or Google Assistant or Alexa thing going on here now, where it's now recognized whatever text it is, and it's played it.

1192
01:28:13,550 --> 01:28:17,480
Well, let's make this an actual cat that doesn't talk in that weird human voice.

1193
01:28:17,480 --> 01:28:19,610
Let me go ahead and get rid of most of this stuff.

1194
01:28:19,610 --> 01:28:22,730
And let's get the cat to actually meow, like a cat tends to.

1195
01:28:22,730 --> 01:28:24,650
And let me go under the Sounds block.

1196
01:28:24,650 --> 01:28:33,080
Now MIT gives you a few sounds for free because it's designed around a cat, by default. And I'm going to go ahead and grab this one, Play Sound Meow until done.

1197
01:28:33,080 --> 01:28:36,860
And now-- and we heard a teaser for this earlier in the crowd--

1198
01:28:36,860 --> 01:28:38,982
[MEOW]

1199
01:28:38,982 --> 01:28:40,440
It's a little piercing, admittedly.

1200
01:28:40,440 --> 01:28:42,460
Maybe we can lower the volume a little bit there.

1201
01:28:42,460 --> 01:28:45,710
But notice, if I want the cat to meow a second time, I'll just click it again.

1202
01:28:45,710 --> 01:28:46,905
[MEOW]

1203
01:28:46,905 --> 01:28:48,690
OK, and over there, too, I hear--

1204
01:28:48,690 --> 01:28:50,320
[MEOW]

1205
01:28:50,320 --> 01:28:50,820
OK.

1206
01:28:50,820 --> 01:28:51,320
[MEOW]

1207
01:28:51,320 --> 01:28:53,500
All right, so it's kind of cute now, right?

1208
01:28:53,500 --> 01:28:54,960
So it's just meow--

1209
01:28:54,960 --> 01:28:56,610
OK, yes, echo, echo.

1210
01:28:56,610 --> 01:28:59,767
So it's meowing now every time I hit the Green Flag.

1211
01:28:59,767 --> 01:29:02,100
Now, that's great, but even a kid is probably going to--

1212
01:29:02,100 --> 01:29:02,730
[MEOW]

1213
01:29:02,730 --> 01:29:03,780
--like would prefer that it--

1214
01:29:03,780 --> 01:29:03,840
[MEOW]

1215
01:29:03,840 --> 01:29:06,790
--just meow, perhaps, like again and again, without having to keep--

1216
01:29:06,790 --> 01:29:07,290
[MEOW]

1217
01:29:07,290 --> 01:29:08,165
--hitting the button.

1218
01:29:08,165 --> 01:29:09,880
So how might we do this?

1219
01:29:09,880 --> 01:29:16,570
All right, well, if I want it to meow multiple times, why don't I just, like, grab it another time and another time?

1220
01:29:16,570 --> 01:29:21,725
Alternatively, you can Right-click or Control-click a puzzle piece and just duplicate it from a little menu that drops down.

1221
01:29:21,725 --> 01:29:22,920
So here we go, three meows.

1222
01:29:22,920 --> 01:29:25,090
[MEOWING]

1223
01:29:25,960 --> 01:29:27,730
All right, that's not really a happy cat.

1224
01:29:27,730 --> 01:29:29,200
It sounds maybe hungry.

1225
01:29:29,200 --> 01:29:31,240
So can we slow that down?

1226
01:29:31,240 --> 01:29:32,380
Well, maybe.

1227
01:29:32,380 --> 01:29:34,630
In fact, if I poke around, let me go under Control.

1228
01:29:34,630 --> 01:29:36,850
It looks like there's a Wait block.

1229
01:29:36,850 --> 01:29:40,630
Wait 1 Second, by default. And notice, Scratch will be pretty accommodating.

1230
01:29:40,630 --> 01:29:44,410
If you just hover in between blocks, it will grow to fill that too.

1231
01:29:44,410 --> 01:29:47,095
So I could change it to 1 or 2 or anything, seconds.

1232
01:29:47,095 --> 01:29:48,970
I'll just leave it at the default for now, 1.

1233
01:29:48,970 --> 01:29:50,680
And now I'll go ahead and do this.

1234
01:29:50,680 --> 01:29:52,838
[MEOWING]

1235
01:29:55,580 --> 01:29:58,790
OK, so cuter and less hungry and just more friendly.

1236
01:29:58,790 --> 01:30:00,740
But this isn't the best design.

1237
01:30:00,740 --> 01:30:01,460
It is correct.

1238
01:30:01,460 --> 01:30:02,960
And let's use that as a term of art.

1239
01:30:02,960 --> 01:30:05,720
Correct means the code does what you want it to do.

1240
01:30:05,720 --> 01:30:08,090
I want the cat to meow three times slowly.

1241
01:30:08,090 --> 01:30:08,720
And it did.

1242
01:30:08,720 --> 01:30:10,370
So I'd wager this is correct.

1243
01:30:10,370 --> 01:30:12,380
But it's not the best design.

1244
01:30:12,380 --> 01:30:14,810
And this is where things get more subjective, right?

1245
01:30:14,810 --> 01:30:20,663
Like, you could write accurate sentences in an essay for an English class, but otherwise, it's just completely a mess.

1246
01:30:20,663 --> 01:30:24,830
Like, your arguments here and there, and you don't say anything wrong, but you don't say it well.

1247
01:30:24,830 --> 01:30:28,110
In the context of code, we can do better than this.

1248
01:30:28,110 --> 01:30:32,340
And Copy/Paste or repeating yourself again and again tends to be bad practice.

1249
01:30:32,340 --> 01:30:32,840
Why?

1250
01:30:32,840 --> 01:30:37,188
Suppose that you want to change the Wait to 2 seconds instead of 1.

1251
01:30:37,188 --> 01:30:38,480
It's admittedly not a big deal.

1252
01:30:38,480 --> 01:30:40,400
Fine, I click there, I change it to 2.

1253
01:30:40,400 --> 01:30:41,990
I click there, I change it to 2.

1254
01:30:41,990 --> 01:30:43,820
But what if you meow 5 times, 10 times?

1255
01:30:43,820 --> 01:30:46,858
Now I have to change the Wait, like, in 5, 10 different places.

1256
01:30:46,858 --> 01:30:47,900
Like, that's just stupid.

1257
01:30:47,900 --> 01:30:53,270
It's taking unnecessary human time, and you're going to screw up eventually, especially if your program is getting longer.

1258
01:30:53,270 --> 01:30:54,740
You're going to miss one of the inputs.

1259
01:30:54,740 --> 01:30:56,365
You're going to leave the number wrong.

1260
01:30:56,365 --> 01:30:57,080
And that's a bug.

1261
01:30:57,080 --> 01:31:04,050
So just based on what you've seen already or if you've program before, which a few of you have, what's the term of art here that will solve this?

1262
01:31:04,050 --> 01:31:06,095
How can we design this better?

1263
01:31:06,095 --> 01:31:07,230
AUDIENCE: [INAUDIBLE]

1264
01:31:07,230 --> 01:31:08,563
DAVID J. MALAN: I heard it here.

1265
01:31:08,563 --> 01:31:12,110
Yeah, so a loop-- a loop, some kind of cycle that says, do that again.

1266
01:31:12,110 --> 01:31:16,430
Do that again-- not infinitely many times, necessarily, but some finite number.

1267
01:31:16,430 --> 01:31:18,740
Well, you can perhaps see a spoiler on the screen.

1268
01:31:18,740 --> 01:31:22,760
Under the same orange Control category is a Repeat block.

1269
01:31:22,760 --> 01:31:24,320
And by default, it's proposing 10.

1270
01:31:24,320 --> 01:31:25,440
But we can change that.

1271
01:31:25,440 --> 01:31:26,280
So let me do this.

1272
01:31:26,280 --> 01:31:29,930
I'm going to throw away most of this Copy/Paste as redundant.

1273
01:31:29,930 --> 01:31:33,470
I'm going to detach this temporarily just to make room for something else.

1274
01:31:33,470 --> 01:31:37,590
And I'm going to drag a Repeat block over here and let that snap into place.

1275
01:31:37,590 --> 01:31:40,340
And I'm going to change it for now, just to be 3, for consistency.

1276
01:31:40,340 --> 01:31:44,660
And this is the correct shape even though it's too small, but Scratch will accommodate that for us.

1277
01:31:44,660 --> 01:31:50,370
And now-- same output but arguably better designed.

1278
01:31:50,370 --> 01:31:50,870
Why?

1279
01:31:50,870 --> 01:31:55,040
Because if I want to change the number of meows, I change it in one place, no Copy/Paste messiness.

1280
01:31:55,040 --> 01:31:56,867
If I want to change the waiting, one place.

1281
01:31:56,867 --> 01:31:59,450
I don't have to change it in multiple places and not screw up.

1282
01:31:59,450 --> 01:32:00,920
So let me hit the Green Flag.

1283
01:32:00,920 --> 01:32:03,405
[MEOWING]

1284
01:32:05,890 --> 01:32:06,940
All right, so-- nice.

1285
01:32:06,940 --> 01:32:12,970
Now, it would have been nice if MIT had just given us a meow block that just automates all of this for us.

1286
01:32:12,970 --> 01:32:15,910
Let me wager, they gave us the low-level implementation details.

1287
01:32:15,910 --> 01:32:18,400
They gave us the Play Sound Meow.

1288
01:32:18,400 --> 01:32:23,120
But I had to implement a decent number of blocks just to get a cat to meow again and again.

1289
01:32:23,120 --> 01:32:26,350
I feel like we should have gotten that for free from MIT.

1290
01:32:26,350 --> 01:32:30,100
Well, they don't have to be the only ones that invent blocks for us to use.

1291
01:32:30,100 --> 01:32:33,920
You can write your own functions, your own verbs or actions.

1292
01:32:33,920 --> 01:32:35,180
So how can we do this?

1293
01:32:35,180 --> 01:32:42,650
Let's make our own puzzle piece, called Meow, that uses this code but creates it in such a way that it's reusable elsewhere.

1294
01:32:42,650 --> 01:32:43,420
So let me do this.

1295
01:32:43,420 --> 01:32:48,310
Under my blocks in pink here, I'm going to go ahead and click, literally, Make a Block.

1296
01:32:48,310 --> 01:32:51,100
Now, here's an interface by which I can give the block a name.

1297
01:32:51,100 --> 01:32:53,410
M-E-O-W will be the name of this block.

1298
01:32:53,410 --> 01:32:55,810
And I'm just going to go ahead and quickly click OK.

1299
01:32:55,810 --> 01:33:06,717
That just gives me a very generic, pink puzzle piece that starts with the word Define because scratch is asking me to define, that is, implement or create, this new puzzle piece for me.

1300
01:33:06,717 --> 01:33:08,050
Well, what does it mean to Meow?

1301
01:33:08,050 --> 01:33:14,890
I'm going to claim that it means to do these two steps, to play the sound meow and then just wait for 1 second.

1302
01:33:14,890 --> 01:33:18,520
But what's powerful about this idea is look at this up top.

1303
01:33:18,520 --> 01:33:21,970
Now that I've made a block, it exists in Scratch.

1304
01:33:21,970 --> 01:33:23,710
MIT didn't need to create this for me.

1305
01:33:23,710 --> 01:33:27,190
I created it for myself and even you, if we end up sharing code.

1306
01:33:27,190 --> 01:33:30,320
So I can now drag Meow up in here.

1307
01:33:30,320 --> 01:33:35,680
And what's nice about Meow is that itself is, yes, a function, but it's also an abstraction.

1308
01:33:35,680 --> 01:33:42,340
Like, never again do I or even you need to worry or care about what it means to meow or implement it.

1309
01:33:42,340 --> 01:33:43,930
I can sort of drag it out of the way.

1310
01:33:43,930 --> 01:33:45,790
I didn't delete it-- drag it out of the way.

1311
01:33:45,790 --> 01:33:46,970
Out of sight, out of mind.

1312
01:33:46,970 --> 01:33:47,470
Why?

1313
01:33:47,470 --> 01:33:51,070
Because my code is now even better designed, in some sense, because it's more readable.

1314
01:33:51,070 --> 01:33:51,910
What is it doing?

1315
01:33:51,910 --> 01:33:55,000
When the Green Flag is clicked, repeat 3 times Meow.

1316
01:33:55,000 --> 01:33:56,305
It just says what it means.

1317
01:33:56,305 --> 01:34:03,040
And so it's a lot easier to read it, and it's a lot easier to think about it, especially if you're using Meow in other projects too.

1318
01:34:03,040 --> 01:34:05,380
Now, let me go ahead and click Play.

1319
01:34:05,380 --> 01:34:06,280
[MEOW]

1320
01:34:06,280 --> 01:34:07,200
Same thing.

1321
01:34:07,200 --> 01:34:07,700
[MEOW]

1322
01:34:07,700 --> 01:34:09,282
So it's not really fundamentally any different.

1323
01:34:09,282 --> 01:34:09,830
[MEOW]

1324
01:34:09,830 --> 01:34:15,010
But I can make this custom puzzle piece, this own function of mine, Meow, even more powerful.

1325
01:34:15,010 --> 01:34:18,520
Let me kind of rewind a bit and go to my Meow puzzle piece.

1326
01:34:18,520 --> 01:34:21,658
And I am going to Control-click or Right-click on my pink puzzle piece.

1327
01:34:21,658 --> 01:34:22,700
And I'm going to edit it.

1328
01:34:22,700 --> 01:34:25,210
So I kind of regret making Meow so simple.

1329
01:34:25,210 --> 01:34:31,960
Wouldn't it be nice if Meow took an input, a.k.a. an argument, that tells Meow how many times to meow.

1330
01:34:31,960 --> 01:34:34,300
Then I can get rid of that loop and just tell

1331
01:34:34,300 --> 01:34:36,530
Meow how many meows I actually want.

1332
01:34:36,530 --> 01:34:40,390
So I'm going to click on another button here called, literally, Add an Input.

1333
01:34:40,390 --> 01:34:42,085
And it's going to have placeholder here.

1334
01:34:42,085 --> 01:34:43,960
So I'm just going to put a placeholder there.

1335
01:34:43,960 --> 01:34:47,880
I keep using "n" for number, which is a go to in computer scientist terms.

1336
01:34:47,880 --> 01:34:52,030
And I'm going to add some descriptive text just so that it's a little more self-explanatory.

1337
01:34:52,030 --> 01:34:54,070
I'm just going to say Meow n Times.

1338
01:34:54,070 --> 01:34:55,510
But there's only one oval.

1339
01:34:55,510 --> 01:34:57,700
Times is just going to be explanatory text.

1340
01:34:57,700 --> 01:34:59,290
And now notice what has happened.

1341
01:34:59,290 --> 01:35:06,580
Now my puzzle piece takes an input, a.k.a. an argument, that will tell that function to meow some number of times.

1342
01:35:06,580 --> 01:35:08,440
But it's not just going to work magically.

1343
01:35:08,440 --> 01:35:11,110
I need to implement that lower level detail.

1344
01:35:11,110 --> 01:35:12,700
So let me zoom out.

1345
01:35:12,700 --> 01:35:14,918
I have to remind myself what this function was.

1346
01:35:14,918 --> 01:35:18,550
So I'm going to drag it higher up just so they're on the screen at the same time.

1347
01:35:18,550 --> 01:35:22,090
I'm going to go ahead now and temporarily move this over here.

1348
01:35:22,090 --> 01:35:24,190
I'm going to temporarily detach this over here.

1349
01:35:24,190 --> 01:35:24,700
Why?

1350
01:35:24,700 --> 01:35:33,760
Because what I thing I want to do is move my loop into the function itself, move the Play and the Wait into the loop.

1351
01:35:33,760 --> 01:35:35,470
But I don't want a hardcode 3.

1352
01:35:35,470 --> 01:35:41,390
Notice that n here is its own oval I can drag a copy of n and just let it go there.

1353
01:35:41,390 --> 01:35:48,170
So now I have a new version of Meow that takes an argument, n, that tells Meow how many times to meow.

1354
01:35:48,170 --> 01:35:52,750
And now let me, again, drag this out of sight, out of mind, because who cares how I implemented it?

1355
01:35:52,750 --> 01:35:54,880
Once it's implemented, it's sort of done.

1356
01:35:54,880 --> 01:35:58,070
Now my program is even better designed, in some sense.

1357
01:35:58,070 --> 01:35:58,570
Why?

1358
01:35:58,570 --> 01:36:01,120
Because now it really just says what it means.

1359
01:36:01,120 --> 01:36:01,840
There's no loop.

1360
01:36:01,840 --> 01:36:04,360
There's no repeat, no implementation details.

1361
01:36:04,360 --> 01:36:07,060
When Green Flag Clicked, Meow 3 Times.

1362
01:36:07,060 --> 01:36:13,070
And so functions indeed let you implement algorithms, like they're just code that do something for you.

1363
01:36:13,070 --> 01:36:14,930
But they're also themselves abstractions.

1364
01:36:14,930 --> 01:36:15,430
Why?

1365
01:36:15,430 --> 01:36:17,660
Because once a function exists, it has a name.

1366
01:36:17,660 --> 01:36:19,580
And you can think about it in that term.

1367
01:36:19,580 --> 01:36:21,610
And you can use it by its name.

1368
01:36:21,610 --> 01:36:27,730
You don't have to care or remember how the function itself was built, whether it's by you or even MIT.

1369
01:36:27,730 --> 01:36:29,480
So again, here I'll click the Green Flag.

1370
01:36:29,480 --> 01:36:30,313
It's the same thing.

1371
01:36:30,313 --> 01:36:32,292
[MEOWING]

1372
01:36:35,130 --> 01:36:38,250
So still correct, but better and better designed.

1373
01:36:38,250 --> 01:36:42,271
And so any time, here and out, with Scratch, or soon C, and eventually Python

1374
01:36:42,271 --> 01:36:49,370
when you find yourself doing anything resembling Copy/Paste or again and again grabbing the same code, probably an opportunity to say, wait a minute.

1375
01:36:49,370 --> 01:36:59,580
Let me refactor this, so to speak, that is, rip out the code that seems to be repeated again and again and put it in its own function so you can give it a descriptive name and use and reuse it.

1376
01:36:59,580 --> 01:37:06,590
Any questions just yet on now saying or these loops or these functions that we're using?

1377
01:37:06,590 --> 01:37:07,130
Yeah--

1378
01:37:07,130 --> 01:37:09,883
AUDIENCE: [INAUDIBLE]

1379
01:37:09,883 --> 01:37:12,300
DAVID J. MALAN: How did I make it so it meows three times?

1380
01:37:12,300 --> 01:37:15,060
So I originally only had a puzzle piece called Meow.

1381
01:37:15,060 --> 01:37:16,770
And I decided to improve it.

1382
01:37:16,770 --> 01:37:22,070
So I held down Control and I Right-clicked or Control-clicked on the pink puzzle piece at top left.

1383
01:37:22,070 --> 01:37:23,120
And I clicked Edit.

1384
01:37:23,120 --> 01:37:28,790
And that brought back the original interface that lets me add some arguments to the puzzle piece itself.

1385
01:37:28,790 --> 01:37:31,250
And I clicked Add an Input on the left here.

1386
01:37:31,250 --> 01:37:34,260
And then I clicked on Add a Label over here.

1387
01:37:34,260 --> 01:37:36,960
So that just lets you customize it even further.

1388
01:37:36,960 --> 01:37:38,490
All right, so we've done this.

1389
01:37:38,490 --> 01:37:41,900
Let's add one of those other primitives too to do something optionally.

1390
01:37:41,900 --> 01:37:50,540
So how about we make the cat meow only if it's being petted by a human, as by moving the mouse to hover over the cat, like a human would pet a cat?

1391
01:37:50,540 --> 01:37:55,110
Well, let me go ahead and throw away the meowing for now.

1392
01:37:55,110 --> 01:37:57,083
And let me simplify it by just using a sound.

1393
01:37:57,083 --> 01:37:58,500
I'm going to go ahead and do this.

1394
01:37:58,500 --> 01:38:08,930
I'm going to go ahead and have a Control block that says If, because I want to implement the idea of if the cursor is touching the cat, then play sound meow.

1395
01:38:08,930 --> 01:38:10,710
Or I could use my same pink puzzle piece.

1396
01:38:10,710 --> 01:38:14,150
But I'm going to throw that away and focus only now on the sounds.

1397
01:38:14,150 --> 01:38:15,840
And I'm going to do this.

1398
01:38:15,840 --> 01:38:19,598
If touching mouse pointer-- so I need to sense something about the world.

1399
01:38:19,598 --> 01:38:22,500
And we saw this earlier-- so If Touching Mouse Pointer.

1400
01:38:22,500 --> 01:38:24,810
So notice this shape here, way too big.

1401
01:38:24,810 --> 01:38:25,920
But it is the right shape.

1402
01:38:25,920 --> 01:38:29,210
So if I hover just right, it'll snap into place.

1403
01:38:29,210 --> 01:38:34,850
And this now, in blue, is my Boolean expression, a yes/no question, true false.

1404
01:38:34,850 --> 01:38:36,860
"If" is a conditional.

1405
01:38:36,860 --> 01:38:38,100
And what do I want to do?

1406
01:38:38,100 --> 01:38:42,290
Well, if the cat is touching the mouse pointer,

1407
01:38:42,290 --> 01:38:44,970
I want to go ahead and play sound meow until done.

1408
01:38:44,970 --> 01:38:46,080
So let's do this.

1409
01:38:46,080 --> 01:38:48,808
I'm going to hit Green Flag, click.

1410
01:38:48,808 --> 01:38:51,350
Now nothing's happened yet because it's a conditional, right?

1411
01:38:51,350 --> 01:38:53,808
It's only supposed to do something if I'm touching the cat.

1412
01:38:53,808 --> 01:38:55,550
Let me move the cursor over to the cat.

1413
01:38:55,550 --> 01:38:59,365
And-- wait for it.

1414
01:38:59,365 --> 01:39:02,330
Hmm-- another bug.

1415
01:39:02,330 --> 01:39:09,020
Why is the cat not meowing even though I very explicitly said, If Touching Mouse Pointer, Meow?

1416
01:39:09,020 --> 01:39:10,295
Yeah, in the middle--

1417
01:39:10,295 --> 01:39:11,893
AUDIENCE: [INAUDIBLE]

1418
01:39:11,893 --> 01:39:15,440
DAVID J. MALAN: Yeah, this is-- again, my computer's just so darn fast, like yours.

1419
01:39:15,440 --> 01:39:18,650
I click the Green Flag, it asks the question, am I touching the mouse pointer?

1420
01:39:18,650 --> 01:39:21,350
Well, no, because my cursor was up there, not touching the cat.

1421
01:39:21,350 --> 01:39:22,370
It's too late.

1422
01:39:22,370 --> 01:39:23,570
The cat's out of the bag.

1423
01:39:23,570 --> 01:39:28,490
And so we have to instead solve this by some other means.

1424
01:39:28,490 --> 01:39:29,940
How can we fix this?

1425
01:39:29,940 --> 01:39:31,470
How do we fix that sort of race?

1426
01:39:31,470 --> 01:39:31,970
Yeah--

1427
01:39:31,970 --> 01:39:32,690
AUDIENCE: [INAUDIBLE]

1428
01:39:32,690 --> 01:39:38,570
DAVID J. MALAN: Yeah, so why don't we just keep asking the question until I eventually am or am not actually petting the cat?

1429
01:39:38,570 --> 01:39:40,610
So let me detach this temporarily.

1430
01:39:40,610 --> 01:39:42,050
Let me go under Control.

1431
01:39:42,050 --> 01:39:46,140
Let me go under-- instead of repeat some finite number of times, let's just do it forever.

1432
01:39:46,140 --> 01:39:49,070
So sometimes loops that do work forever are a good thing.

1433
01:39:49,070 --> 01:39:54,720
The clock on your phone, that's in a loop forever because you want it to always tell time and not stop at the end of the day.

1434
01:39:54,720 --> 01:39:58,913
So sometimes you do want code to loop forever, as in this case.

1435
01:39:58,913 --> 01:40:00,830
So let me go ahead and drag and drop it there.

1436
01:40:00,830 --> 01:40:02,750
Let me, again, click the Green Flag.

1437
01:40:02,750 --> 01:40:03,900
Nothing's happening yet.

1438
01:40:03,900 --> 01:40:06,300
But notice, the program is still running.

1439
01:40:06,300 --> 01:40:10,700
And so if I move my cursor, move my cursor, move my cursor, and--

1440
01:40:10,700 --> 01:40:12,880
[MEOWING]

1441
01:40:12,880 --> 01:40:14,550
OK, so maybe we could add some Waiting.

1442
01:40:14,550 --> 01:40:17,750
But the cat does not want to be pet, in this case.

1443
01:40:17,750 --> 01:40:20,220
But it's indeed conditional.

1444
01:40:20,220 --> 01:40:24,290
So there we have an incarnation in Scratch of doing something conditionally.

1445
01:40:24,290 --> 01:40:26,790
Now, we can make this really cool, really fast, if you will.

1446
01:40:26,790 --> 01:40:28,440
Let me stop this version.

1447
01:40:28,440 --> 01:40:31,270
Let me go ahead and do this.

1448
01:40:31,270 --> 01:40:33,270
Let me go ahead and throw all of this away.

1449
01:40:33,270 --> 01:40:36,210
Let me go into my little Extensions bucket over here.

1450
01:40:36,210 --> 01:40:40,620
And let me do Video Sensing, since most laptops or phones these days have cameras.

1451
01:40:40,620 --> 01:40:44,190
And there, indeed, I am, with Sanders behind me.

1452
01:40:44,190 --> 01:40:45,780
And let me do this.

1453
01:40:45,780 --> 01:40:48,900
When Video Motion-- and let me get out of the way.

1454
01:40:48,900 --> 01:40:51,820
When Video Motion is Greater Than some value.

1455
01:40:51,820 --> 01:40:56,670
So 10 is the default. This is just a number that measures how much motion there is or isn't.

1456
01:40:56,670 --> 01:40:58,290
So small number is like no motion.

1457
01:40:58,290 --> 01:40:59,920
Big number is lots of motion.

1458
01:40:59,920 --> 01:41:03,120
So I'm going to choose 50, somewhat arbitrarily here-- so 50.

1459
01:41:03,120 --> 01:41:05,370
This is not normal to program off to the side.

1460
01:41:05,370 --> 01:41:08,130
But I'm now going to say this.

1461
01:41:08,130 --> 01:41:14,460
When Video Motion is 50, go ahead and Play Sound Meow like this.

1462
01:41:14,460 --> 01:41:16,170
So the cat is still in that world.

1463
01:41:16,170 --> 01:41:18,970
I'm going to stop the program and rerun it.

1464
01:41:18,970 --> 01:41:21,090
So here we go, Green Flag.

1465
01:41:21,090 --> 01:41:30,640
And now here comes-- all right, this is a little creepy, the way I'm petting the cat, but-- and-- [SIGH]

1466
01:41:31,600 --> 01:41:32,940
[MEOWING]

1467
01:41:32,940 --> 01:41:33,440
OK.

1468
01:41:33,440 --> 01:41:35,750
[LAUGHTER]

1469
01:41:35,750 --> 01:41:36,290
There we go.

1470
01:41:36,290 --> 01:41:37,910
OK, so 50 was too big of a number.

1471
01:41:37,910 --> 01:41:39,500
I have to pet the cat faster.

1472
01:41:39,500 --> 01:41:41,925
[MEOWING]

1473
01:41:42,900 --> 01:41:44,940
Whereas this, if--

1474
01:41:44,940 --> 01:41:46,410
I don't know--

1475
01:41:46,410 --> 01:41:48,330
[LAUGHTER]

1476
01:41:48,330 --> 01:41:49,924
Yeah, so--

1477
01:41:49,924 --> 01:41:50,710
[MEOW]

1478
01:41:50,710 --> 01:41:55,410
OK, so you can make things even more interactive in this way by just assembling different puzzle pieces.

1479
01:41:55,410 --> 01:41:58,050
And honestly, there are so many different puzzle pieces in here.

1480
01:41:58,050 --> 01:42:00,610
We're not going to even scratch the surface of a lot of them.

1481
01:42:00,610 --> 01:42:02,940
But they generally just do what they say.

1482
01:42:02,940 --> 01:42:12,970
And indeed, when you see on the screen here this pallet of puzzle pieces, really a lot of programming, especially early on, when learning a language, is just trying different things and try and fail.

1483
01:42:12,970 --> 01:42:20,000
And if it doesn't work quite right, look for an alternative solution there too, as even I just had to do a moment ago.

1484
01:42:20,000 --> 01:42:24,720
Well, let's go ahead and use, actually, how about another example of something a predecessor of yours made?

1485
01:42:24,720 --> 01:42:28,830
Let me go ahead and grab a program I opened in advance here called

1486
01:42:28,830 --> 01:42:38,895
Whack-A-Mole Might we get a brave volunteer to come up, who is willing to whack a mole with their head, virtually?

1487
01:42:38,895 --> 01:42:40,770
Maybe-- OK, let's see, how about in way back?

1488
01:42:40,770 --> 01:42:42,300
You want to come on down?

1489
01:42:42,300 --> 01:42:45,327
All right, come on down.

1490
01:42:45,327 --> 01:42:47,160
Sure, a round of applause for our volunteer.

1491
01:42:47,160 --> 01:42:49,382
[APPLAUSE]

1492
01:42:52,130 --> 01:43:01,178
All right, so here we have-- come on down.

1493
01:43:01,178 --> 01:43:01,970
AUDIENCE: Hi there.

1494
01:43:01,970 --> 01:43:02,720
DAVID J. MALAN: What's your name?

1495
01:43:02,720 --> 01:43:03,320
AUDIENCE: I'm Josh.

1496
01:43:03,320 --> 01:43:05,695
DAVID J. MALAN: Oh, actually, say it into the microphone.

1497
01:43:05,695 --> 01:43:06,950
AUDIENCE: Hi, I'm Josh.

1498
01:43:06,950 --> 01:43:07,670
DAVID J. MALAN: OK, nice.

1499
01:43:07,670 --> 01:43:08,240
Welcome, Josh.

1500
01:43:08,240 --> 01:43:08,782
Come on over.

1501
01:43:08,782 --> 01:43:10,850
[APPLAUSE]

1502
01:43:10,850 --> 01:43:12,892
All right, so same idea here--

1503
01:43:12,892 --> 01:43:13,850
I'll take the mic back.

1504
01:43:13,850 --> 01:43:15,230
You'll have to stand in front of the camera.

1505
01:43:15,230 --> 01:43:20,150
In just a moment, you're going to have to position your head in a box that your classmate from yesteryear created.

1506
01:43:20,150 --> 01:43:22,340
[MUSIC PLAYING]

1507
01:43:22,840 --> 01:43:24,490
And we'll start with Beginner.

1508
01:43:24,490 --> 01:43:25,180
AUDIENCE: OK.

1509
01:43:25,180 --> 01:43:28,166
DAVID J. MALAN: So line your head up in the box in a moment.

1510
01:43:28,166 --> 01:43:29,142
AUDIENCE: All right.

1511
01:43:37,438 --> 01:43:39,878
[LAUGHTER]

1512
01:43:43,800 --> 01:43:45,390
DAVID J. MALAN: Nice.

1513
01:43:45,390 --> 01:43:46,155
12 seconds.

1514
01:43:52,500 --> 01:43:53,790
5 seconds.

1515
01:43:53,790 --> 01:43:55,710
Notice the score's up to 18 already.

1516
01:43:55,710 --> 01:43:58,410
Pretty good.

1517
01:43:58,410 --> 01:44:00,990
All right, a round of applause for Josh, if we could.

1518
01:44:00,990 --> 01:44:03,440
[APPLAUSE]

1519
01:44:06,380 --> 01:44:11,330
So notice how using some fairly simple primitives, things do get interesting pretty fast.

1520
01:44:11,330 --> 01:44:12,560
And how was that implemented?

1521
01:44:12,560 --> 01:44:14,560
Well, there were probably at least four sprites.

1522
01:44:14,560 --> 01:44:16,222
So you're not confined to just one cat.

1523
01:44:16,222 --> 01:44:18,930
You can create more and more sprites, change what they look like.

1524
01:44:18,930 --> 01:44:20,930
So they actually look like a mole, in this case.

1525
01:44:20,930 --> 01:44:23,990
There's probably some conditionals in there, some loops for 30 seconds.

1526
01:44:23,990 --> 01:44:31,550
That's checking if Josh's head's movement is exceeding some value over this way or over this way, then increment something called a variable.

1527
01:44:31,550 --> 01:44:32,450
We'll see those too.

1528
01:44:32,450 --> 01:44:42,350
Just like in algebra you might have x and y and z, storing values like numbers, so can computer programs, have variables called x or y or z, or more descriptively called Score,

1529
01:44:42,350 --> 01:44:49,632
as in this case at top right, or another variable called Countdown, typically one word in code, but in this case two words, that just store some value.

1530
01:44:49,632 --> 01:44:54,604
So there's probably some math going on in there whereby the author of this program just is incrementing

1531
01:44:54,604 --> 01:45:00,570
that is, adding 1 and 1 every time it detected that a mole had been whacked, in this case, with movement.

1532
01:45:00,570 --> 01:45:07,562
So back in the day, I, myself, actually implemented my very first program in Scratch when I was a graduate student, actually, at MIT

1533
01:45:07,562 --> 01:45:15,500
cross-registered at MIT, taking a class from MIT's Media Lab, specifically, the lifelong kindergarten group, which is the group that created Scratch, itself.

1534
01:45:15,500 --> 01:45:27,120
And the program I wrote all those years ago and still rather cling to is a little something here called Oscartime, that I thought I'd play just a quick excerpt of myself here.

1535
01:45:27,120 --> 01:45:38,060
So in this case, consider, as the music starts playing, how this program, which is much more sophisticated, certainly, than the earliest "Say hello" examples we just did might also be implemented.

1536
01:45:38,060 --> 01:45:40,745
Let me go ahead now and click the Green Flag.

1537
01:45:40,745 --> 01:45:44,950
[MUSIC - OSCAR THE GROUCH, "I LOVE TRASH"]

1538
01:45:44,950 --> 01:45:46,973
OSCAR THE GROUCH: (SINGING) Oh, I love trash.

1539
01:45:46,973 --> 01:45:51,970
DAVID J. MALAN: OK, so some trash is moving, presumably in some kind of loop from the top.

1540
01:45:51,970 --> 01:45:56,440
If I'm touching the mouse cursor, it follows me.

1541
01:45:56,440 --> 01:45:59,920
If I hover over the trash can, it responds.

1542
01:45:59,920 --> 01:46:06,910
If I let go, in some kind of loop, Oscar pops out, creates a variable with the current score.

1543
01:46:06,910 --> 01:46:07,900
And it happens again.

1544
01:46:07,900 --> 01:46:09,983
OSCAR THE GROUCH: (SINGING) It's awful, the holes.

1545
01:46:09,983 --> 01:46:11,950
And the laces are torn.

1546
01:46:11,950 --> 01:46:16,030
A gift from my mother the day I was born.

1547
01:46:16,030 --> 01:46:20,050
I love it because it's trash.

1548
01:46:20,050 --> 01:46:21,070
Oh, I--

1549
01:46:21,070 --> 01:46:24,050
DAVID J. MALAN: It's pretty easy at first but--

1550
01:46:24,050 --> 01:46:26,410
OSCAR THE GROUCH: (SINGING) --anything dirty or dingy--

1551
01:46:26,410 --> 01:46:30,230
DAVID J. MALAN: So I don't need to keep playing this up on stage in front of everyone.

1552
01:46:30,230 --> 01:46:32,950
So my score is already now up to some 6 or so.

1553
01:46:32,950 --> 01:46:35,900
But in a moment, too, you'll see that it's going to escalate.

1554
01:46:35,900 --> 01:46:38,080
So I'm taking into account some time apparently.

1555
01:46:38,080 --> 01:46:38,980
So now--

1556
01:46:38,980 --> 01:46:42,343
OSCAR THE GROUCH: (SINGING) I have here some newspaper, 13 months old.

1557
01:46:42,343 --> 01:46:45,010
DAVID J. MALAN: So more and more sprites are suddenly appearing.

1558
01:46:45,010 --> 01:46:48,040
And notice, that each time they're appearing from a different part of the screen.

1559
01:46:48,040 --> 01:46:52,270
That's an illusion, perhaps, too, that-- pick a random number between x and y.

1560
01:46:52,270 --> 01:46:56,032
So you can actually pick some range of values to have the game constantly changing.

1561
01:46:56,032 --> 01:47:00,860
And indeed, I'm going to go ahead and click Stop, since I spent like eight hours plus, years ago, making this.

1562
01:47:00,860 --> 01:47:04,810
And I can never listen to the song again, not that I should be anyway at this point in my life.

1563
01:47:04,810 --> 01:47:09,670
But this song is synchronized then with a lot of the actions that's happening.

1564
01:47:09,670 --> 01:47:12,130
And ultimately, there's just a lot of building blocks.

1565
01:47:12,130 --> 01:47:15,610
But I didn't sit down and implement Oscartime, as I called it, all at once.

1566
01:47:15,610 --> 01:47:17,500
I really did take baby steps, so to speak.

1567
01:47:17,500 --> 01:47:24,220
And I figured out, well, how could I decompose this vision I had at the time to create this game ultimately?

1568
01:47:24,220 --> 01:47:26,470
And how do I bite off maybe the easiest parts first?

1569
01:47:26,470 --> 01:47:31,120
And honestly, the first thing I did was I found this image, and I just dragged and dropped it into Scratch--

1570
01:47:31,120 --> 01:47:33,580
OK, done-- like, lamppost is installed.

1571
01:47:33,580 --> 01:47:34,575
It doesn't do anything.

1572
01:47:34,575 --> 01:47:35,450
It's not interactive.

1573
01:47:35,450 --> 01:47:37,995
But I at least set the stage, so to speak, for the program.

1574
01:47:37,995 --> 01:47:39,370
Then what else might I have done?

1575
01:47:39,370 --> 01:47:40,640
Well, let me do this.

1576
01:47:40,640 --> 01:47:48,980
Let me go ahead and open up in another editor here an early incarnation of Oscartime by doing this.

1577
01:47:48,980 --> 01:47:51,220
Let me go into Oscartime here.

1578
01:47:51,220 --> 01:47:52,510
Let me full screen this.

1579
01:47:52,510 --> 01:47:59,687
And here you have-- let me hide the trash for just a moment-- is what I might call the second version of my program

1580
01:47:59,687 --> 01:48:06,267
wherein, at the top right of the stage here, I had the lamppost, which I just dragged and dropped and got going, but then I added an actual sprite.

1581
01:48:06,267 --> 01:48:09,100
And it has to be a sprite if you want it to do things interactively.

1582
01:48:09,100 --> 01:48:10,420
The lamppost-- not a sprite.

1583
01:48:10,420 --> 01:48:14,680
It's just an image a costume, if you will, for the whole stage itself, a backdrop.

1584
01:48:14,680 --> 01:48:20,240
But this thing is indeed a sprite because it needs to respond to code and events, like dragging and dropping.

1585
01:48:20,240 --> 01:48:23,960
So what might I have done early on with that code?

1586
01:48:23,960 --> 01:48:32,170
Well, maybe the first version would have been something like this, whereby my very first version of Oscartime might have said something like, oh, this.

1587
01:48:32,170 --> 01:48:35,500
How about, let me control the program as before-- or, rather, events.

1588
01:48:35,500 --> 01:48:38,630
When the Green Flag is clicked, what do I want to do?

1589
01:48:38,630 --> 01:48:43,600
Well, I want to go ahead and forever do something like this.

1590
01:48:43,600 --> 01:48:46,687
Forever-- so I want the lid to open up if I touch it.

1591
01:48:46,687 --> 01:48:49,270
So if the cursor gets near the lid, I want the lid to open up.

1592
01:48:49,270 --> 01:48:51,340
And then if I move away, I want it to close.

1593
01:48:51,340 --> 01:48:52,640
So how can I do that?

1594
01:48:52,640 --> 01:48:59,200
I want an If, but I just don't want one question, I really want two, a fork in the road that goes left or right, so to speak.

1595
01:48:59,200 --> 01:49:02,830
And let me grab this puzzle piece here, as I did long ago.

1596
01:49:02,830 --> 01:49:04,690
So notice, it grows to fill.

1597
01:49:04,690 --> 01:49:06,430
What's the question I want to ask?

1598
01:49:06,430 --> 01:49:13,863
Well, under Sensing, I'm going to go ahead here and say If this trashcan is Touching the Mouse Pointer-- what do I want to do?

1599
01:49:13,863 --> 01:49:16,030
Well, I want to change what the trashcan looks like.

1600
01:49:16,030 --> 01:49:17,740
And this part, I did in advance of class.

1601
01:49:17,740 --> 01:49:21,040
If you go up here to Costumes, this is where all the graphical stuff happens.

1602
01:49:21,040 --> 01:49:31,423
And you'll see that I imported a whole bunch of different costumes that effectively, much like a video, when you play them quickly, creates the illusion of movement, some animation.

1603
01:49:31,423 --> 01:49:35,320
But it's really just dot, dot, dot, dot, dot-- different images showing on the screen.

1604
01:49:35,320 --> 01:49:39,250
Well, some of these costumes are called like Oscar1, Oscar2.

1605
01:49:39,250 --> 01:49:40,810
Oscar1 is closed.

1606
01:49:40,810 --> 01:49:42,070
Oscar2 is open.

1607
01:49:42,070 --> 01:49:43,730
So let's just deal with those first.

1608
01:49:43,730 --> 01:49:48,100
So if I'm touching the mouse pointer, let me go under-- how about Looks?

1609
01:49:48,100 --> 01:49:50,680
And we didn't use this before, but there's this block,

1610
01:49:50,680 --> 01:49:52,870
Switch Costume to Something Else.

1611
01:49:52,870 --> 01:49:55,150
I'm going to drag and drop this inside of the If.

1612
01:49:55,150 --> 01:49:57,070
And notice it's a little bit indented.

1613
01:49:57,070 --> 01:50:00,730
I'm going to change it not to Oscar8, but Oscar2.

1614
01:50:00,730 --> 01:50:10,840
Otherwise, If Not Touching the Mouse Pointer-- this is the other direction in the fork in the road-- let's go ahead and switch the costume back to what I described as Oscar1.

1615
01:50:10,840 --> 01:50:12,400
So let me run this program.

1616
01:50:12,400 --> 01:50:14,900
And not much of interest is happening yet.

1617
01:50:14,900 --> 01:50:20,030
But notice, if I move the cursor up, down-- but how is that working?

1618
01:50:20,030 --> 01:50:22,940
It's just changing the costume that's being overlaid on the sprite.

1619
01:50:22,940 --> 01:50:25,998
So it looks like interactivity, but you are really just changing the aesthetics.

1620
01:50:25,998 --> 01:50:29,135
And we humans are just kind of assuming, oh, it's opening up.

1621
01:50:29,135 --> 01:50:30,760
Well, no, it's just changing a costume.

1622
01:50:30,760 --> 01:50:31,802
So here's the difference.

1623
01:50:31,802 --> 01:50:34,210
The high-level abstraction-- trashcan opening.

1624
01:50:34,210 --> 01:50:38,500
The lower-level implementation detail-- costume changing, creating that illusion.

1625
01:50:38,500 --> 01:50:46,130
And if I want it to look prettier, I could just have many other costumes and go boom, boom, boom, boom, boom to create more frames per second, if you will.

1626
01:50:46,130 --> 01:50:48,820
So I need to do one other thing.

1627
01:50:48,820 --> 01:50:52,750
Maybe if I accidentally leave the trashcan open, let me make one change here.

1628
01:50:52,750 --> 01:50:54,730
Let me make sure that the very first thing

1629
01:50:54,730 --> 01:51:01,810
I do when the Green Flag is clicked, is always start with the trashcan closed because otherwise, you might accidentally leave it open.

1630
01:51:01,810 --> 01:51:03,590
So this gets me into some default state.

1631
01:51:03,590 --> 01:51:08,133
So now it's always closed until I manually hover over it instead.

1632
01:51:08,133 --> 01:51:09,550
Well, what might I have done next?

1633
01:51:09,550 --> 01:51:13,587
Well, if I wanted to introduce something like the trash, I need a second sprite.

1634
01:51:13,587 --> 01:51:15,670
And here, in advance, I grabbed the image already.

1635
01:51:15,670 --> 01:51:18,310
Let me pretend that this never happened.

1636
01:51:18,310 --> 01:51:20,260
Let me drag this away here.

1637
01:51:20,260 --> 01:51:24,033
And now I have nothing in my code area for this piece of trash.

1638
01:51:24,033 --> 01:51:25,200
But it is the second sprite.

1639
01:51:25,200 --> 01:51:29,190
And all I did was I clicked on the little cat plus icon here, created a second sprite.

1640
01:51:29,190 --> 01:51:30,330
I named it trash.

1641
01:51:30,330 --> 01:51:32,250
I added a costume for it.

1642
01:51:32,250 --> 01:51:34,170
Sort of the aesthetic stuff, I did in advance.

1643
01:51:34,170 --> 01:51:36,360
But here I'll do now the code.

1644
01:51:36,360 --> 01:51:37,720
How do I want to do this?

1645
01:51:37,720 --> 01:51:42,160
Well, how about when the Green Flag is clicked, for the trash can,

1646
01:51:42,160 --> 01:51:45,090
I want the trash can in parallel to do--

1647
01:51:45,090 --> 01:51:48,190
I want the trash, the piece of trash, to do its own thing.

1648
01:51:48,190 --> 01:51:52,500
So what I want it to do is maybe let's do Motion, how about?

1649
01:51:52,500 --> 01:51:54,240
And let's go to a specific coordinate.

1650
01:51:54,240 --> 01:51:55,750
Now, there's a lot of options here.

1651
01:51:55,750 --> 01:52:01,740
There's Turning, Go to a Random Position, Go to x,y, Glide, more elegantly.

1652
01:52:01,740 --> 01:52:03,990
There's a lot of different ways to implement movement.

1653
01:52:03,990 --> 01:52:06,310
I just want it to go to a very specific location first.

1654
01:52:06,310 --> 01:52:09,000
So I'm just going to go to x,y first.

1655
01:52:09,000 --> 01:52:14,470
And I'm going to say x, how about, will be-- let's not hardcode this.

1656
01:52:14,470 --> 01:52:18,120
Let's just have it be-- well, let's do it at 0, initially, and then 240.

1657
01:52:18,120 --> 01:52:23,410
So-- whoops-- let's do 0,240 so that this piece of trash always starts at the top middle of the screen.

1658
01:52:23,410 --> 01:52:26,160
If you think back to that coordinate system, 0,0 is in the middle.

1659
01:52:26,160 --> 01:52:28,230
240 is straight above it.

1660
01:52:28,230 --> 01:52:31,150
All right, now, after I do that, what do I want to do?

1661
01:52:31,150 --> 01:52:34,980
Well, how about I control this thing by forever falling.

1662
01:52:34,980 --> 01:52:36,427
Now, how do I make the trash move?

1663
01:52:36,427 --> 01:52:38,010
We haven't seen this puzzle piece yet.

1664
01:52:38,010 --> 01:52:42,390
But under Motion, the very first thing is called Move Some Number of Steps.

1665
01:52:42,390 --> 01:52:43,380
By default, it's 10.

1666
01:52:43,380 --> 01:52:44,880
But we'll do it more simply.

1667
01:52:44,880 --> 01:52:48,660
Let me go ahead and move-- oh, sorry.

1668
01:52:48,660 --> 01:52:52,350
Move is going to move it in whatever direction it's facing.

1669
01:52:52,350 --> 01:52:53,753
I only want it to move down.

1670
01:52:53,753 --> 01:52:57,540
So here, even I'm getting confused as to how many different ways there are to do things.

1671
01:52:57,540 --> 01:52:59,680
What I thing I want to do is this.

1672
01:52:59,680 --> 01:53:03,670
Let me only change my y-axis as follows.

1673
01:53:03,670 --> 01:53:06,060
So here's another puzzle piece called Change y.

1674
01:53:06,060 --> 01:53:07,680
So again, y is the vertical.

1675
01:53:07,680 --> 01:53:14,170
So let me just change y by one pixel downward at a time, so -1 one pixel at a time.

1676
01:53:14,170 --> 01:53:15,540
So it's kind of slow.

1677
01:53:15,540 --> 01:53:17,010
And I think now--

1678
01:53:17,010 --> 01:53:17,890
I think that's it.

1679
01:53:17,890 --> 01:53:18,990
Let me hit Stop.

1680
01:53:18,990 --> 01:53:21,700
Notice that my trashcan is still going to be interactive.

1681
01:53:21,700 --> 01:53:23,370
I haven't changed or deleted that code.

1682
01:53:23,370 --> 01:53:26,850
I've just added now code for my piece of trash.

1683
01:53:26,850 --> 01:53:32,920
If I click the Green Flag, notice that-- after I enable it-- let me start that again.

1684
01:53:32,920 --> 01:53:34,320
I had it hidden for before class.

1685
01:53:34,320 --> 01:53:35,403
But let me enable it now--

1686
01:53:35,403 --> 01:53:42,750
Green Flag, notice it starts dead center, at x equals 0, y equals 240, and it's dropping one pixel at a time.

1687
01:53:42,750 --> 01:53:47,530
If that seems a little boring, we can change it to -10 pixels at a time and, boom, it's done.

1688
01:53:47,530 --> 01:53:49,780
So that's how you might change the speed of a program.

1689
01:53:49,780 --> 01:53:51,750
But I'm going to leave it more simply as -1.

1690
01:53:51,750 --> 01:53:54,708
And honestly, it would be nice if it doesn't always start from the top.

1691
01:53:54,708 --> 01:53:57,083
Otherwise, this game is not going to be very interactive.

1692
01:53:57,083 --> 01:54:00,580
I'm literally going to be grabbing the trash from the same place every time.

1693
01:54:00,580 --> 01:54:03,250
So why don't I, instead, Stop this.

1694
01:54:03,250 --> 01:54:06,550
Let me go under Operators, and let's pick a random number.

1695
01:54:06,550 --> 01:54:12,437
So let me change the hardcoded-- the manually inputted-- 0, and let's make x be somewhere between 0

1696
01:54:12,437 --> 01:54:20,970
so in the middle and all the way over to-- what was it-- oh, I got my numbers wrong-- 240 and my y will be 180.

1697
01:54:20,970 --> 01:54:23,560
Sorry, I got my x and my y confused.

1698
01:54:23,560 --> 01:54:25,420
So let me play this again.

1699
01:54:25,420 --> 01:54:30,978
And now we have a game that's more like games you might have played growing up or even now, like there's some randomness to it.

1700
01:54:30,978 --> 01:54:33,660
So the CPU, so to speak, is doing something more interesting.

1701
01:54:33,660 --> 01:54:34,570
Let me run it again.

1702
01:54:34,570 --> 01:54:35,820
Now it's a little to the left.

1703
01:54:35,820 --> 01:54:36,600
Let me run it again.

1704
01:54:36,600 --> 01:54:38,058
Now it's a little more to the left.

1705
01:54:38,058 --> 01:54:39,630
Again-- now it's back to the right.

1706
01:54:39,630 --> 01:54:41,640
So randomness just makes games more interesting.

1707
01:54:41,640 --> 01:54:46,172
And this is why when you play any video game, if different things are happening, there's probably just some randomness.

1708
01:54:46,172 --> 01:54:48,360
And it's quantized as just a simple number.

1709
01:54:48,360 --> 01:54:52,050
Now, I think I just need one final flourish here, if I may.

1710
01:54:52,050 --> 01:54:54,060
Let me go ahead and add this.

1711
01:54:54,060 --> 01:54:58,380
How about Events-- or rather-- yes, Events.

1712
01:54:58,380 --> 01:55:02,700
When Green Flag is clicked, I can do multiple things within the same sprite.

1713
01:55:02,700 --> 01:55:05,190
They don't all have to be attached to the same one.

1714
01:55:05,190 --> 01:55:10,110
Let me go ahead and forever go ahead and do something else.

1715
01:55:10,110 --> 01:55:20,850
How about, Whenever the Trash is-- how about-- Touching the Trash Can-- so Forever If-- let's see, I need a Sensing block.

1716
01:55:20,850 --> 01:55:28,530
So how about, Is Touching-- not the Mouse Pointer, this time, but Touching Oscar himself there.

1717
01:55:28,530 --> 01:55:30,810
Now let's see what happens.

1718
01:55:30,810 --> 01:55:33,750
All right, so let's go ahead and click the Green Flag.

1719
01:55:33,750 --> 01:55:37,560
Now I go down over here and let go.

1720
01:55:37,560 --> 01:55:41,340
OK, I kind of want it to go into the trash can.

1721
01:55:41,340 --> 01:55:43,620
How do I make it go into the trash can?

1722
01:55:43,620 --> 01:55:49,950
How can we take this high-level idea, put trash into the trash can, and make it seem to disappear?

1723
01:55:49,950 --> 01:55:51,520
Logically, what could we do?

1724
01:55:51,520 --> 01:55:52,370
Yeah--

1725
01:55:52,370 --> 01:55:53,245
AUDIENCE: [INAUDIBLE]

1726
01:55:53,245 --> 01:55:56,037
DAVID J. MALAN: OK, so when it touches it, let's have it disappear.

1727
01:55:56,037 --> 01:55:56,910
So I could hide it.

1728
01:55:56,910 --> 01:56:04,380
Or honestly, if the game is going to be ongoing, like it was, letting me drop more and more trash, let me just have it go ahead and pick a new random location.

1729
01:56:04,380 --> 01:56:05,560
So let me do this.

1730
01:56:05,560 --> 01:56:09,073
Let me go ahead and Copy this puzzle piece up here and Duplicate.

1731
01:56:09,073 --> 01:56:10,740
And I don't want the whole thing, sorry.

1732
01:56:10,740 --> 01:56:12,400
Let me get rid of this.

1733
01:56:12,400 --> 01:56:13,540
Let me just do this.

1734
01:56:13,540 --> 01:56:16,720
Let me go back to some random location at the top.

1735
01:56:16,720 --> 01:56:17,940
So now notice what happens.

1736
01:56:17,940 --> 01:56:26,318
If I click and drag on it-- here it goes-- and I let go, it looks like it's going into the trash can because it snaps back up to some random location.

1737
01:56:26,318 --> 01:56:29,610
Now, the only thing I'm not doing really is keeping track of any kind of score.

1738
01:56:29,610 --> 01:56:33,940
And it turns out, if I full screen this, it's not going to be draggable, by default.

1739
01:56:33,940 --> 01:56:45,960
So just as a corner case, so to speak, something that you might trip over otherwise, let me go ahead and under, let's see, Sensing, it turns out I also need this for the piece of trash.

1740
01:56:45,960 --> 01:56:51,540
There's this way of setting, in Scratch, a sprite to be draggable or not draggable.

1741
01:56:51,540 --> 01:57:00,240
I need to explicitly make it draggable so that when I do full screen this thing now, it still remains draggable and someone like myself can play it again and again.

1742
01:57:00,240 --> 01:57:03,120
Well, how about we supplement this with one final flourish?

1743
01:57:03,120 --> 01:57:06,010
Why don't we keep track now of the user score?

1744
01:57:06,010 --> 01:57:16,590
So how about, when the user actually drags the piece of trash to the trash can, let me go under Variables here, where, in advance, I've already made myself a variable called Score.

1745
01:57:16,590 --> 01:57:20,100
I could have called it x or y or z or ABC, but that's not very descriptive.

1746
01:57:20,100 --> 01:57:24,450
In programming, you typically give things a more descriptive English, or some other language, name.

1747
01:57:24,450 --> 01:57:26,200
So I called this one Score.

1748
01:57:26,200 --> 01:57:28,710
So how do I want to do this in my Score?

1749
01:57:28,710 --> 01:57:37,470
Well, let me go ahead and initially set this game score to 0 at the very top of one of these scripts-- one of these programs up here.

1750
01:57:37,470 --> 01:57:42,570
And then any time my piece of trash is touching

1751
01:57:42,570 --> 01:57:49,630
Oscar, let's not just jump to the top, let's change the score by 1 up here.

1752
01:57:49,630 --> 01:57:52,680
So now notice, If Touching Oscar, Change the Score-- that is,

1753
01:57:52,680 --> 01:57:55,920
Add 1 to the Score-- and then Pick a new Random location.

1754
01:57:55,920 --> 01:57:59,520
And now Green Flag-- let's do this slowly.

1755
01:57:59,520 --> 01:58:00,540
Here it goes.

1756
01:58:00,540 --> 01:58:01,590
The trashcan opens.

1757
01:58:01,590 --> 01:58:02,520
I let go.

1758
01:58:02,520 --> 01:58:06,660
And now notice, at the top left of my program, notice the score is now 2.

1759
01:58:06,660 --> 01:58:10,140
Notice the score, if I do this again, is about to become 3.

1760
01:58:10,140 --> 01:58:15,910
And so here we have building blocks, literally, of making this program better and better and better.

1761
01:58:15,910 --> 01:58:22,530
And so, indeed, that's how you generally approach solving any problem with code, be it in Scratch or C or Python or some other.

1762
01:58:22,530 --> 01:58:31,530
You take this vision you might have or some vision you've been assigned in a homework assignment and try to break it down into these constituent parts and just pluck off the easy ones first.

1763
01:58:31,530 --> 01:58:34,980
Put the lamp post there first, and at least feel like you're making some progress.

1764
01:58:34,980 --> 01:58:38,457
Then pluck off something like the trash can, and just make it do a little thing.

1765
01:58:38,457 --> 01:58:40,540
And it doesn't have to be in some same order here.

1766
01:58:40,540 --> 01:58:42,750
I could have done this in a million different ways.

1767
01:58:42,750 --> 01:58:52,380
But figure out what the small pieces are that, ultimately, like a few of the problems we've solved today, assemble into a greater solution there too.

1768
01:58:52,380 --> 01:58:58,470
So that you have now a mental model for these types of blocks and others, let's return for a moment to this.

1769
01:58:58,470 --> 01:59:06,670
We saw a moment ago that when I started saying, "Hello, David," and nesting those puzzle pieces, we had a whole different paradigm altogether.

1770
01:59:06,670 --> 01:59:15,000
My input for that second version of, "Hello, world," was to now pass in, for instance, "What's Your Name?" into my function, called Ask.

1771
01:59:15,000 --> 01:59:21,690
That gave me not a side effect, but what I called, again, a return value, called Answer, by default, in Scratch.

1772
01:59:21,690 --> 01:59:31,260
And now notice and recall, when I had that same output become the input to my next block, it looked a little something like this--

1773
01:59:31,260 --> 01:59:32,100
Say.

1774
01:59:32,100 --> 01:59:37,710
So how does this type of block and this nesting, this stacking of blocks, fit into the same mental model?

1775
01:59:37,710 --> 01:59:47,190
Well, same idea-- my input for that part of the story is now taking in not one input but two-- two arguments-- "hello" and the answer from before.

1776
01:59:47,190 --> 01:59:50,010
The function, in this case, is that new block called Join.

1777
01:59:50,010 --> 02:00:00,840
The output thereof is, "Hello, David," which itself became-- if we sort of animate this-- the input to my final function, which indeed was still Say.

1778
02:00:00,840 --> 02:00:06,729
And this is only to say-- no pun intended-- that almost everything that you do with these puzzle pieces

1779
02:00:06,729 --> 02:00:16,320
be it in the context of Oscartime or the mole whacking or even just something simple like, "Hello, world," will ultimately fit into that relatively simple mental model there.

1780
02:00:16,320 --> 02:00:20,220
Now, I thought we'd end by taking a look at just a couple of final examples.

1781
02:00:20,220 --> 02:00:22,950
These ones, too, made by some of your predecessors.

1782
02:00:22,950 --> 02:00:27,760
And for this, I thought we would not write code together, but read it instead.

1783
02:00:27,760 --> 02:00:36,720
And so allow me to open up one other example here that will show us a few different versions of a program that a predecessor made.

1784
02:00:36,720 --> 02:00:38,340
Give me just a moment here.

1785
02:00:38,340 --> 02:00:42,960
And we'll see how we might build up to something even more interactive.

1786
02:00:42,960 --> 02:00:51,090
And in just a moment, we'll see something they called Ivy's Hardest Game, focused here on these particular mechanics.

1787
02:00:51,090 --> 02:00:58,560
So here is version 0, so to speak, of this program, wherein the goal was to create a game where you have to get out of some kind of maze.

1788
02:00:58,560 --> 02:01:01,800
And you have to get out, in this case, the Harvard crest from this maze.

1789
02:01:01,800 --> 02:01:08,040
Let me go ahead and just hit Play on this Green Flag so you can see what the first building block for this program might have been.

1790
02:01:08,040 --> 02:01:12,990
Notice that my hand here is actually on the Arrow keys on my keyboard.

1791
02:01:12,990 --> 02:01:20,432
And it seems that by moving up, down, left, or right, this little crest on the screen responds in exactly that way.

1792
02:01:20,432 --> 02:01:22,140
Now, let's hypothesize for just a moment.

1793
02:01:22,140 --> 02:01:27,260
Even though we've not done anything quite like this before, how might this code be implemented?

1794
02:01:27,260 --> 02:01:34,220
How do you get a sprite, be it a cat or a crest, to respond to keys on a keyboard-- might you think intuitively?

1795
02:01:34,220 --> 02:01:34,730
Yeah--

1796
02:01:34,730 --> 02:01:36,983
AUDIENCE: [INAUDIBLE]

1797
02:01:36,983 --> 02:01:40,410
DAVID J. MALAN: Yeah, there could be something sensing what key you're pressing on.

1798
02:01:40,410 --> 02:01:44,600
And if you do it again in forever a loop, you'll just constantly be listening for keystrokes.

1799
02:01:44,600 --> 02:01:47,240
And this is how, like, every piece of software nowadays works.

1800
02:01:47,240 --> 02:01:51,690
It's constantly waiting for your phone to be tapped or something to be typed on the screen.

1801
02:01:51,690 --> 02:01:55,400
So let me go ahead and look inside of this existing program here.

1802
02:01:55,400 --> 02:01:59,730
And there's more going on, but we'll take a quick glance what's actually going on.

1803
02:01:59,730 --> 02:02:04,850
Well, up here at top left, notice, we just have Go To x Equals 0 and y Equals 0.

1804
02:02:04,850 --> 02:02:07,850
That means put the Harvard crest dead center in the middle of the stage.

1805
02:02:07,850 --> 02:02:13,130
Then we have Forever two functions that we made in advance as custom functions--

1806
02:02:13,130 --> 02:02:15,500
Listen for Keyboard, Feel for Walls.

1807
02:02:15,500 --> 02:02:17,190
So it's doing two things at once.

1808
02:02:17,190 --> 02:02:23,278
It's forever listening for the keyboard-- up, down, left, right-- and feeling for the walls, in the sense that if I get too far to the left,

1809
02:02:23,278 --> 02:02:26,010
I don't want it to keep moving past that black wall.

1810
02:02:26,010 --> 02:02:29,060
And if it moves too far to the right, I don't want it to blow through that wall either.

1811
02:02:29,060 --> 02:02:34,250
So it's going to do two things constantly, listening for keyboard and feeling for walls, so to speak.

1812
02:02:34,250 --> 02:02:35,870
And how are those implemented?

1813
02:02:35,870 --> 02:02:37,190
Well, this one's a bit long.

1814
02:02:37,190 --> 02:02:40,080
But on the left here is Listen for Keyboard.

1815
02:02:40,080 --> 02:02:47,420
So this pink puzzle piece, Listen for Keyboard, first checks If the Key Up Arrow is Pressed, question mark,

1816
02:02:47,420 --> 02:02:50,570
Boolean expression in a conditional, Change y By 1.

1817
02:02:50,570 --> 02:02:52,040
That means, move it up 1.

1818
02:02:52,040 --> 02:02:59,540
Else If the Key Down Arrow is Pressed, then Change y by -1, and similar for Left Arrow, similar for Right Arrow.

1819
02:02:59,540 --> 02:03:04,310
And even though there's not a loop in this pink function, there is where I'm using it.

1820
02:03:04,310 --> 02:03:06,860
So it's constantly being asked again and again.

1821
02:03:06,860 --> 02:03:08,420
How about feeling for walls?

1822
02:03:08,420 --> 02:03:13,970
Well, over here to the right-- it's a little cut off-- but here you have, If Touching Left Wall,

1823
02:03:13,970 --> 02:03:15,260
Change x by 1.

1824
02:03:15,260 --> 02:03:17,200
So if you hit the wall, it's too late.

1825
02:03:17,200 --> 02:03:18,950
You're kind of blowing through it already.

1826
02:03:18,950 --> 02:03:23,000
So I want to move it back one pixel so it's no longer touching that wall.

1827
02:03:23,000 --> 02:03:28,220
Similarly, if it's touching the right wall, I want to back it up one pixel so it's no longer touching that wall.

1828
02:03:28,220 --> 02:03:33,110
So it's kind of like bouncing off ever so slightly so that it doesn't slip through that actual wall.

1829
02:03:33,110 --> 02:03:34,340
And what are those walls?

1830
02:03:34,340 --> 02:03:41,790
Well, notice down here, it's just a simple sprite with a black line that I've oriented vertically instead of horizontally.

1831
02:03:41,790 --> 02:03:45,230
And that's just so that I can ask questions of these other two sprites.

1832
02:03:45,230 --> 02:03:47,570
Now, that gives me that form of interactivity.

1833
02:03:47,570 --> 02:03:49,200
What more can I now do?

1834
02:03:49,200 --> 02:03:52,410
Well, what if we make things a little more interactive here?

1835
02:03:52,410 --> 02:03:55,640
Let me go ahead and see inside version 1 our second.

1836
02:03:55,640 --> 02:03:58,860
And let me propose what's going to happen here.

1837
02:03:58,860 --> 02:04:02,600
Well, how might we add a little something like Yale into the mix?

1838
02:04:02,600 --> 02:04:07,460
Well, what's Yale going to do when I hit the Green Flag now based on this code?

1839
02:04:07,460 --> 02:04:09,920
Any hunches?

1840
02:04:09,920 --> 02:04:13,250
Here is the code for my Yale sprite.

1841
02:04:13,250 --> 02:04:13,820
Yeah--

1842
02:04:13,820 --> 02:04:14,570
AUDIENCE: [INAUDIBLE]

1843
02:04:14,570 --> 02:04:19,370
DAVID J. MALAN: Yeah, it's kind of going to be an adversarially by blocking my path, theoretically, if I keep writing more code.

1844
02:04:19,370 --> 02:04:20,030
So why?

1845
02:04:20,030 --> 02:04:22,160
It too goes to the middle of the screen.

1846
02:04:22,160 --> 02:04:23,940
It points in direction 90 degrees.

1847
02:04:23,940 --> 02:04:26,520
So similarly, there's a whole degree system as well.

1848
02:04:26,520 --> 02:04:27,710
And it forever asks this.

1849
02:04:27,710 --> 02:04:30,920
If Touching the Left Wall Or-- notice the green block--

1850
02:04:30,920 --> 02:04:33,900
Touching the Right Wall, then just Turn around 180 Degrees.

1851
02:04:33,900 --> 02:04:42,860
And indeed, if you think this through logically, that just means you're bouncing this way and this way by just flipping yourself around 180 degrees for just this Yale sprite.

1852
02:04:42,860 --> 02:04:46,550
So if I go ahead and zoom in on this and click the Green Flag,

1853
02:04:46,550 --> 02:04:48,350
I can still move up and down.

1854
02:04:48,350 --> 02:04:53,490
But Yale is just kind of doing this all day long, back and forth and back and forth, forever.

1855
02:04:53,490 --> 02:04:55,710
Nothing bad happens if I try to go through it.

1856
02:04:55,710 --> 02:04:58,010
But we could add that, certainly, to the mix.

1857
02:04:58,010 --> 02:05:01,760
In fact, let's add one final feature before we play this particular game.

1858
02:05:01,760 --> 02:05:08,640
And let me go ahead and open up the final version of these building blocks that adds MIT to the mix.

1859
02:05:08,640 --> 02:05:10,940
So here is MIT.

1860
02:05:10,940 --> 02:05:13,182
Someone want to explain what this code does?

1861
02:05:13,182 --> 02:05:14,390
And this is what we're doing.

1862
02:05:14,390 --> 02:05:15,470
This itself is a skill.

1863
02:05:15,470 --> 02:05:20,640
Reading someone else's code and understanding it is half of the part of programming besides writing.

1864
02:05:20,640 --> 02:05:21,140
Yeah--

1865
02:05:21,140 --> 02:05:22,015
AUDIENCE: [INAUDIBLE]

1866
02:05:22,015 --> 02:05:24,960
DAVID J. MALAN: Yeah, it's chasing down the Harvard logo outline.

1867
02:05:24,960 --> 02:05:30,050
So this is apparently the name of the costume that this student made, Harvard logo outline.

1868
02:05:30,050 --> 02:05:32,600
And apparently, it goes to a random position first.

1869
02:05:32,600 --> 02:05:34,700
But then it forever points to Harvard.

1870
02:05:34,700 --> 02:05:40,830
So no matter where I'm moving it, up, down, left, or right, MIT is being a little more strategic than Yale, bouncing back and forth like this.

1871
02:05:40,830 --> 02:05:43,440
So let's go ahead and play this one in full screen.

1872
02:05:43,440 --> 02:05:45,540
And here we have a Green Flag.

1873
02:05:45,540 --> 02:05:53,210
So if I move up, MIT, rather strategically, is following me no matter where I go.

1874
02:05:53,210 --> 02:05:55,190
All right, so still, nothing bad happens.

1875
02:05:55,190 --> 02:05:56,940
But now it's struggling, right?

1876
02:05:56,940 --> 02:05:58,190
It's going up, down, up, down.

1877
02:05:58,190 --> 02:06:00,950
It's trying to follow me even though I'm not moving.

1878
02:06:00,950 --> 02:06:02,630
So we need some final flourishes.

1879
02:06:02,630 --> 02:06:06,740
And so I think, for this, we need perhaps one final volunteer.

1880
02:06:06,740 --> 02:06:11,990
After this, cake awaits for everyone outside, as is an end of first lecture CS50 tradition.

1881
02:06:11,990 --> 02:06:14,840
Would you like to come up and be our volunteer?

1882
02:06:14,840 --> 02:06:17,230
[APPLAUSE]

1883
02:06:23,450 --> 02:06:24,040
All right.

1884
02:06:24,040 --> 02:06:30,040
And so this will be the actual version but written by one of your predecessors that I'll full screen here.

1885
02:06:30,040 --> 02:06:35,562
It's going to stitch together all of these same primitives and more, but add the notion of scores and lives

1886
02:06:35,562 --> 02:06:44,650
so that there's actually a goal, which in this case is to move the Harvard crest to constantly pursue the character on the right-hand side so that your sprite touches that one.

1887
02:06:44,650 --> 02:06:46,533
Would you like to introduce yourself?

1888
02:06:46,533 --> 02:06:47,950
AUDIENCE: Hi, my name is Mohammed.

1889
02:06:47,950 --> 02:06:49,000
DAVID J. MALAN: All right, wonderful.

1890
02:06:49,000 --> 02:06:49,630
Welcome aboard.

1891
02:06:49,630 --> 02:06:56,048
And here we come with some instructions and final flourish if we want to keep the lights up but perhaps increase the music.

1892
02:06:56,048 --> 02:06:58,236
[MUSIC PLAYING]

1893
02:06:58,736 --> 02:07:00,486
[MUSIC - MC HAMMER, "U CAN'T TOUCH THIS"]

1894
02:07:00,486 --> 02:07:02,150
MC HAMMER: (SINGING) You can't this.

1895
02:07:02,150 --> 02:07:03,025
You can't touch this.

1896
02:07:03,025 --> 02:07:05,567
DAVID J. MALAN: Notice he is using the up, down, left, right.

1897
02:07:05,567 --> 02:07:07,320
But there's many more walls now.

1898
02:07:07,320 --> 02:07:08,730
First level's pretty easy.

1899
02:07:08,730 --> 02:07:13,560
But now Yale's in the mix, bouncing back and forth.

1900
02:07:13,560 --> 02:07:15,420
Again, pretty easy.

1901
02:07:15,420 --> 02:07:22,290
Now there's two Yale's at slightly different positions.

1902
02:07:22,290 --> 02:07:23,730
MIT is coming soon.

1903
02:07:23,730 --> 02:07:25,432
But first, we have three Yales.

1904
02:07:25,432 --> 02:07:26,640
MC HAMMER: (SINGING) As such.

1905
02:07:26,640 --> 02:07:28,542
And this is a beat, uh, you can't touch.

1906
02:07:28,542 --> 02:07:29,625
DAVID J. MALAN: Very nice.

1907
02:07:29,625 --> 02:07:30,125
[APPLAUSE]

1908
02:07:30,125 --> 02:07:33,100
MC HAMMER: (SINGING) I told you, homeboy, you can't touch this.

1909
02:07:33,100 --> 02:07:36,820
Yeah, that's how it look when you know you can't touch this.

1910
02:07:36,820 --> 02:07:40,798
Look at my eyes, man, you can't touch this.

1911
02:07:40,798 --> 02:07:43,090
Yo, let me bust the funky lyrics. you can't touch this.

1912
02:07:43,090 --> 02:07:45,171
Fresh new kicks and pants, you got to like that.

1913
02:07:45,171 --> 02:07:46,504
Now, you know you want to dance.

1914
02:07:46,504 --> 02:07:48,570
So move out of your seat and get a fly--

1915
02:07:48,570 --> 02:07:49,290
DAVID J. MALAN: You got to go quick.

1916
02:07:49,290 --> 02:07:51,623
MC HAMMER: (SINGING) Catch this beat while it's rolling.

1917
02:07:51,623 --> 02:07:52,130
Hold on.

1918
02:07:52,130 --> 02:07:55,490
Pump a little bit, and let them know what's going on, like that, like that.

1919
02:07:55,490 --> 02:07:57,056
Cold on a mission, so fall on back.

1920
02:07:57,056 --> 02:08:02,800
Let them know that you're too much and this a beat, uh, they can't touch.

1921
02:08:02,800 --> 02:08:03,627
Yo, I told you.

1922
02:08:03,627 --> 02:08:04,502
You can't touch this.

1923
02:08:04,502 --> 02:08:06,882
[APPLAUSE]

1924
02:08:08,790 --> 02:08:09,810
Yo, sound the bell.

1925
02:08:09,810 --> 02:08:10,975
School's in, sucker.

1926
02:08:10,975 --> 02:08:11,850
You can't touch this.

1927
02:08:11,850 --> 02:08:13,432
Give me a song, a rhythm.

1928
02:08:13,432 --> 02:08:15,390
Making them sweat, that's what I'm giving them.

1929
02:08:15,390 --> 02:08:20,810
Now they know, you talk about the Hammer, you talking about a show that's hyped and tight.

1930
02:08:20,810 --> 02:08:24,018
Singers are sweating, so pass them a wipe or a tape to learn.

1931
02:08:24,018 --> 02:08:25,060
What's it going to take--

1932
02:08:25,060 --> 02:08:27,040
DAVID J. MALAN: Second-to-last level.

1933
02:08:27,040 --> 02:08:28,165
MC HAMMER: (SINGING) Legit.

1934
02:08:28,165 --> 02:08:30,065
Either work hard or you might as well quit.

1935
02:08:30,065 --> 02:08:31,410
That's word because you know--

1936
02:08:31,410 --> 02:08:32,535
DAVID J. MALAN: Last level.

1937
02:08:32,535 --> 02:08:35,652
MC HAMMER: (SINGING) You can't touch this.

1938
02:08:35,652 --> 02:08:37,124
DAVID J. MALAN: Hey!

1939
02:08:37,124 --> 02:08:37,624
[LAUGHS]

1940
02:08:37,624 --> 02:08:39,710
[APPLAUSE]

1941
02:08:39,710 --> 02:08:40,210
Congrats.

1942
02:08:45,170 --> 02:08:47,570
All right, that's it for CS50.

1943
02:08:47,570 --> 02:08:48,410
Welcome.

1944
02:08:48,410 --> 02:08:49,820
Cake is now served.

1945
02:08:49,820 --> 02:08:51,950
We'll see you next time.

1946
02:08:51,950 --> 02:08:53,450
[PROJECTOR CLICKING]

1947
02:08:53,450 --> 02:08:56,800
[MUSIC PLAYING]

1949
00:01:13,310 --> 00:01:15,260
戴维-J-马兰：好的。

1950
00:01:15,260 --> 00:01:22,940
这里是 CS50，哈佛大学计算机科学和编程艺术的入门课程。

1951
00:01:22,940 --> 00:01:27,660
我叫大卫-马兰（David Malan），实际上，早在 1996 年，我就亲自上过这门课。

1952
00:01:27,660 --> 00:01:29,382
当时我上大二。

1953
00:01:29,382 --> 00:01:40,200
实际上，我的专业是政府学，因为在一年前，作为一年级学生，我进入哈佛时认为自己喜欢历史和宪法，以及高中时的类似课程。

1954
00:01:40,200 --> 00:01:44,180
因此，当我来到这里时，我更倾向于熟悉的事物。

1955
00:01:44,180 --> 00:01:50,300
我想，如果我在高中时喜欢并擅长那门学科，那么我在这里就应该是这样的人。

1956
00:01:50,300 --> 00:01:57,680
但直到大二，我才鼓起勇气踏进 CS50 教室，即便如此，也只是出于好奇。

1957
00:01:57,680 --> 00:02:03,170
就像我刚进校园时，根本没打算学习计算机科学，甚至连 CS50 都没选。

1958
00:02:03,170 --> 00:02:07,400
但人们对此议论纷纷，纷纷提防。

1959
00:02:07,400 --> 00:02:12,560
而且，这也许只是为初学者准备的，我最终也不知道计算机科学到底是什么。

1960
00:02:12,560 --> 00:02:15,800
但对我来说，灯泡熄灭了。

1961
00:02:15,800 --> 00:02:24,830
我发现，与我在高中看到的情况相反，我看到我的朋友们在计算机实验室里低头编程，反社会地做着他们正在做的事情、

1962
00:02:24,830 --> 00:02:29,280
一旦我上了这个特殊的班级，到了这个特殊的地方，就真的不是那么回事了。

1963
00:02:29,280 --> 00:02:34,852
它更多地是关于解决问题，以及学习如何用代码和不同的语言表达自己。

1964
00:02:34,852 --> 00:02:37,310
这样，你才能真正解决自己感兴趣的问题。

1965
00:02:37,310 --> 00:02:47,280
即使你无意成为一名计算机科学家或工程师，只是希望能够在艺术、人文和社会科学领域解决问题、分析数据、做有趣的事情、

1966
00:02:47,280 --> 00:02:49,710
物理科学，或任何其他领域。

1967
00:02:49,710 --> 00:02:56,090
事实上，这条特殊的道路将我引向了计算机科学，但 CS50 更普遍的希望是，你能

1968
00:02:56,090 --> 00:03:02,370
只要找到自己的方法，将未来几个月学到的原则应用到自己感兴趣的领域就可以了。

1969
00:03:02,370 --> 00:03:07,500
尽管如此，这对我来说绝对是一项艰巨的工作，而且并非没有挫折。

1970
00:03:07,500 --> 00:03:15,630
但是，没有什么比用脑袋撞墙，花上几个小时甚至几天，试图修复代码中的一个错误更美妙的了。

1971
00:03:15,630 --> 00:03:23,600
然后，我的天啊，当你终于解决了某个一直压在你心头的难题时，那种成就感、自豪感、疲惫感一涌而上。

1972
00:03:23,600 --> 00:03:26,570
这让我感到无比欣慰，同时也增强了我的能力。

1973
00:03:26,570 --> 00:03:31,200
因为与很多领域不同，计算机科学是由人类自己建立起来的。

1974
00:03:31,200 --> 00:03:35,460
因此，如果人类建造了这个，那么你，另一个人类，肯定也能理解它。

1975
00:03:35,460 --> 00:03:42,440
因此，尽管一路上会有一些干扰，但如果你以前从未做过编程，你就会看到一些看起来令人难以置信的东西。

1976
00:03:42,440 --> 00:03:46,402
随着时间的推移和实践的积累，一切都会变得更有意义。

1977
00:03:46,402 --> 00:03:49,950
随着时间的推移和实践的积累，你会在这一领域越做越好。

1978
00:03:49,950 --> 00:03:55,530
事实上，编程成功的关键在于给自己留出足够的时间。

1979
00:03:55,530 --> 00:04:00,950
因此，至少值得庆幸的是，我很快就养成了在一周内尽早开始工作的习惯，比如在编写实际代码时。

1980
00:04:00,950 --> 00:04:03,200
为什么？因为你会碰壁。

1981
00:04:03,200 --> 00:04:04,460
你不会看到什么虫子。

1982
00:04:04,460 --> 00:04:06,470
有些东西不会让你眼前一亮，没关系。

1983
00:04:06,470 --> 00:04:11,030
这时，你就可以收工了，休息一下，干点别的，然后再回来干。

1984
00:04:11,030 --> 00:04:16,310
这也是我保持编程乐趣的原因，即使在多年以后，无论是教学还是实际应用，都是如此。

1985
00:04:16,310 --> 00:04:22,170
但是，在这条路上，有一段麻省理工学院黑客的历史，昔日的麻省理工学院看起来有点像这样。

1986
00:04:22,170 --> 00:04:25,280
麻省理工学院的学生们在做这个黑客的时候，还发出了一点感叹。

1987
00:04:25,280 --> 00:04:33,890
墙上写着：从麻省理工学院接受教育就像从消防水龙头里喝水一样，而他们确实把消防水龙头连接到了本应只是一个饮水机的地方。

1988
00:04:33,890 --> 00:04:39,560
有时候，不光是计算机科学本身，就是一个陌生的领域，也会有这种感觉。

1989
00:04:39,560 --> 00:04:42,740
如果你不是来自 STEM，不是来自 CS，那也没关系。

1990
00:04:42,740 --> 00:04:49,430
但是，很多东西最终都会被你吸收，并在学期结束时在你的掌握之中。

1991
00:04:49,430 --> 00:04:57,440
因此，请记住，这就是我们的初衷，但你会对自己在三个月左右的时间里所创造的成果感到惊讶。

1992
00:04:57,440 --> 00:05:03,140
事实上，你们当中有三分之二的人从未上过 CS 课程，这与你们可能认为的情况恰恰相反。

1993
00:05:03,140 --> 00:05:07,550
所以，绝对不是说左边或右边的人肯定比你懂得多。

1994
00:05:07,550 --> 00:05:09,462
事实上，情况恰恰相反。

1995
00:05:09,462 --> 00:05:17,450
在接下来的几周里，当你编写自己的代码、解决自己的问题时，你就会发现，在这门课程中，最终重要的并不是你与你的同学们的排名

1996
00:05:17,450 --> 00:05:20,783
而是相对于你开始时的自己而言，你的终点在哪里。

1997
00:05:20,783 --> 00:05:27,380
不管你有没有编程，只要能从这样的课程中有所收获，这就是真正的 "三角洲"。

1998
00:05:27,380 --> 00:05:34,520
如果这确实需要时间，如果你确实感受到了挫折，但你同时也最终感受到了成就感，那只能说明这一切都很有效。

1999
00:05:34,520 --> 00:05:39,712
事实上，希望最终能因此而更有价值、更令人欣慰。

2000
00:05:39,712 --> 00:05:41,670
那么，未来几周我们该做些什么呢？

2001
00:05:41,670 --> 00:05:43,550
现在是第零周。

2002
00:05:43,550 --> 00:05:47,480
我们很快就会明白，为什么计算机和计算机科学家要从 0 开始计数。

2003
00:05:47,480 --> 00:05:54,860
但第 0 周，我们将探索计算思维，像计算机一样思考，并开始清理你的思维过程。

2004
00:05:54,860 --> 00:05:59,360
让你思考，更有条理地解决问题，并最终将其转化为代码。

2005
00:05:59,360 --> 00:06:04,520
有些人可能认识这个环境，又名 Scratch，巧合的是，它也来自麻省理工学院。

2006
00:06:04,520 --> 00:06:06,350
你可能在小学时用过。

2007
00:06:06,350 --> 00:06:11,760
我们将在今天和本周末的课程第一次家庭作业或问题集中使用它。

2008
00:06:11,760 --> 00:06:18,990
但这并不是为了让你像过去那样玩游戏，而是为了探索计算机科学和编程的理念。

2009
00:06:18,990 --> 00:06:22,650
我们以后每周都会使用和重复使用。

2010
00:06:22,650 --> 00:06:26,800
此后，我们将在下周过渡到第一周，可以这么说。

2011
00:06:26,800 --> 00:06:31,979
在此，我们将向您介绍一种更传统的语言，一种低级语言，一种叫做 C 语言的更古老的语言。

2012
00:06:31,979 --> 00:06:39,030
在 C 语言中，你需要使用键盘，而不是鼠标，但你要编写的代码很快就会像这样。

2013
00:06:39,030 --> 00:06:42,120
如果你以前编过程序，大概就能明白这要做什么。

2014
00:06:42,120 --> 00:06:47,560
如果你以前从未学过编程（大多数人都是这种情况），这也会很快变得有意义。

2015
00:06:47,560 --> 00:06:51,120
但这是大多数程序员编写的最经典的程序

2016
00:06:51,120 --> 00:06:59,430
事实上，这句话以及它上下的所有语法很快就会变得更有意义。

2017
00:06:59,430 --> 00:07:02,250
可以说，您将学会如何使用行业标准工具。

2018
00:07:02,250 --> 00:07:04,980
图中所示的是 Visual Studio 代码，简称 VS 代码。

2019
00:07:04,980 --> 00:07:10,678
您最初将使用基于云的版本，因此您不必担心任何技术问题或类似的头痛问题。

2020
00:07:10,678 --> 00:07:18,840
这只是一开始的工作，但我们最终会利用它来探索计算机科学中的想法，以及你可以应用的原理。

2021
00:07:18,840 --> 00:07:27,210
我们将从电脑的引擎盖下看一看内存或 RAM（随机存取存储器），所有数据最终都将存储在这里。

2022
00:07:27,210 --> 00:07:31,470
此后，我们还将看看程序错误。错误就是程序中的错误。

2023
00:07:31,470 --> 00:07:41,040
这是昔日真实电脑中的一个真实错误，但我们会教你如何调试程序、发现自己的错误、发现别人的错误，并改进代码。

2024
00:07:41,040 --> 00:07:47,340
然后，我们将过渡到算法，即解决一些问题的分步指导，我们今天也会涉及到这一点。

2025
00:07:47,340 --> 00:07:51,120
如果你想象一下，这其实是一个很有代表性的问题。

2026
00:07:51,120 --> 00:07:55,510
您很可能没有遇到过类似的情况，但这是有代表性的排序方式。

2027
00:07:55,510 --> 00:08:00,810
如果把这些小条中的每一条都看作是一个小数，那么大条中的每一条就是一个大数、

2028
00:08:00,810 --> 00:08:08,478
你可能会想，作为一个人，你怎么能把所有这些条形图分类，比如把所有的短条形图放在这里，把所有的大条形图放在那里？

2029
00:08:08,478 --> 00:08:16,533
好吧，如果你像我一样，你可能会用眼睛看一下，如果你可以用身体互动，你可能会先抓取最小的元素，把它们放在左边。

2030
00:08:16,533 --> 00:08:20,880
也许可以抓住最大的元素，把它们放在右边。但你的算法是什么？

2031
00:08:20,880 --> 00:08:24,930
比如，你如何教一个比你年轻、从未做过这种事的人如何做？

2032
00:08:24,930 --> 00:08:28,740
你如何强迫你的 Mac、PC 或手机做这样的事情？

2033
00:08:28,740 --> 00:08:32,572
你不能只是挥挥手，然后说，哦，想办法吧。把东西搬来搬去。

2034
00:08:32,572 --> 00:08:36,815
你必须更有条理地表达自己。因此，即使是这样的想法，我们也要将其转化为代码。

2035
00:08:36,815 --> 00:08:42,780
而这正是谷歌和世界上其他公司在不断做的事情，因为它们要对世界上的信息进行分类和整理。

2036
00:08:42,780 --> 00:08:45,490
如果有帮助的话，我们可以用比喻来说明。

2037
00:08:45,490 --> 00:08:48,990
我们把电脑内存比作一个邮政地址。

2038
00:08:48,990 --> 00:08:57,560
就像世界上的每个邮箱都有某种形式的邮政地址，街道、城市、州、国家等等，而事实证明，你的 Mac、PC 和手机也是这样工作的。

2039
00:08:57,560 --> 00:09:02,730
你有一大堆内存，就像之前的图片一样，但你可以把它看作是一个个独立的邮箱。

2040
00:09:02,730 --> 00:09:08,725
你可以在这些邮箱中放置任何你想要的东西，你也可以进入邮箱获取其中的信息。

2041
00:09:08,725 --> 00:09:12,490
所以说到底，这就是电脑处理信息的全部工作。

2042
00:09:12,490 --> 00:09:18,870
它只是在整理信息，而不是将信息整理到邮箱中，比如你可能知道的 "字节"。

2043
00:09:18,870 --> 00:09:22,560
我们来谈谈现在也会出现的问题。

2044
00:09:22,560 --> 00:09:32,520
事实上，你们中的大多数人都熟悉 Mac、PC 甚至手机有时会自发重启、死机、出现恼人的旋转沙滩球或沙漏图标的情况。

2045
00:09:32,520 --> 00:09:33,790
这到底是怎么回事？

2046
00:09:33,790 --> 00:09:40,110
这些只是苹果、谷歌、微软等公司的人类程序中的漏洞，他们搞砸了，写出了漏洞百出的代码。

2047
00:09:40,110 --> 00:09:44,290
而你的电脑在遇到这些错误时，不知道该怎么办。

2048
00:09:44,290 --> 00:09:50,110
因此，可以说十有八九会出现死机或冻结之类的情况，但这种情况会更有意义。

2049
00:09:50,110 --> 00:09:55,350
因此，即使是现实世界也会有意义，图中是我们最终会在学期中接触到的一些低级术语。

2050
00:09:55,350 --> 00:10:02,440
但一般来说，当事情像这个箭头一样朝这个方向发展，而事情又像这个箭头一样朝这个方向发展时，结局就不会太好。

2051
00:10:02,440 --> 00:10:05,250
这往往就是电脑崩溃时发生的情况。

2052
00:10:05,250 --> 00:10:11,470
有人在上面使用记忆，但也有人在下面使用记忆，这样就不是真正意义上的左手和右手了。

2053
00:10:11,470 --> 00:10:17,010
因此，这只是我们会遇到的一些问题的高度概括，但我们最终会把重点放在数据上。

2054
00:10:17,010 --> 00:10:20,530
因此，这里展示的是一种相当技术性的东西，叫做哈希表。

2055
00:10:20,530 --> 00:10:25,110
它是一个我们即将称之为数组的东西和一个我们称之为链接列表的东西的混合体。

2056
00:10:25,110 --> 00:10:34,440
这些都是花哨的术语，用来描述如何比将单个值放入邮箱更灵活地组织信息。

2057
00:10:34,440 --> 00:10:40,510
比如，你如何构建结构，比如可以说是实际的数据结构，二维结构？

2058
00:10:40,510 --> 00:10:48,040
因此，你们在这里看到的是哈利-波特宇宙中的一些名字，有些人可能已经认出来了，但它们是按字母顺序排列的。

2059
00:10:48,040 --> 00:10:58,440
请注意，任何时候都有多个名字以 H 开头的人，比如赫敏、哈利和海格，如果左边的每个方格都是同一个邮箱，那么他们就不可能都装进邮箱。

2060
00:10:58,440 --> 00:11:02,490
因此，你必须将它们串联起来。你将在代码中学习如何做到这一点。

2061
00:11:02,490 --> 00:11:07,440
这样，即使你获得的数据比你预期的要多，如果你的业务正在蓬勃发展，而且你是一些基于网络的企业、

2062
00:11:07,440 --> 00:11:12,790
您是如何在软件中不断添加信息，从而真正跟上它的步伐的？

2063
00:11:12,790 --> 00:11:16,480
但这也是代码很快就会出现的情况，最快下周就会出现、

2064
00:11:16,480 --> 00:11:25,190
但几周后，我们将过渡到一种更现代、更高级的语言，可以说是 Python。

2065
00:11:25,190 --> 00:11:33,520
事实上，在我的时代和现在，这门课程非常有意地首先向你介绍 C 语言，有趣的是，很多人并不倾向于每天都用 C 语言编程。

2066
00:11:33,520 --> 00:11:40,540
我一般在 9 月、10 月、11 月和 12 月教授 CS50 时使用 C 语言。尽管如此，它还是无处不在。

2067
00:11:40,540 --> 00:11:52,360
事实上，即使是今天你可能熟悉的其他语言，如 Python 和 Java，以及其他语言，你也能在引擎盖下看到同样的原始语言，因为它实在是太快了。

2068
00:11:52,360 --> 00:11:59,180
在接下来的几周里，你将了解到，它真的能让你接触和理解这里的概念。

2069
00:11:59,180 --> 00:12:05,180
这样，在 CS50 之后，当你编写代码时，你就可以从一个非常高的层面来思考实际发生了什么。

2070
00:12:05,180 --> 00:12:11,170
因此，事实上，再过几周，在 C 语言中看起来是这样的，在 Python 中就会变成这样。

2071
00:12:11,170 --> 00:12:16,521
您将更好地了解引擎盖下发生的事情，而且很有可能在这堂课之后，您会去学习一门语言。

2072
00:12:16,521 --> 00:12:22,750
与 C 语言相比，Python 的使用频率更高，但你会从这种自下而上的理解中受益匪浅。

2073
00:12:22,750 --> 00:12:28,630
此后，在学期结束前，我们将向您介绍一些其他想法，比如您该把大量数据放在哪里？

2074
00:12:28,630 --> 00:12:32,690
数据库不是电子表格，而是真正的数据库。

2075
00:12:32,690 --> 00:12:37,300
我们使用的也是这种数据结构，你可以在内存中以有趣的方式布局。

2076
00:12:37,300 --> 00:12:42,010
之后，我们将过渡到一个你我每天都在使用的非常熟悉的环境--网络。

2077
00:12:42,010 --> 00:12:49,690
如今，网络已成为我们在笔记本电脑、台式机甚至移动设备上随处使用的用户界面。

2078
00:12:49,690 --> 00:12:52,360
这里展示的是一种名为 HTML 的语言。

2079
00:12:52,360 --> 00:12:53,693
它不是一种编程语言。

2080
00:12:53,693 --> 00:12:57,550
这是一种标记语言，有些人过去可能制作过主页或作品集。

2081
00:12:57,550 --> 00:13:08,930
但你会明白这里发生了什么，而且更重要的是，你会明白计算机是如何看到同样的代码，并在内存中建立起层次分明的家族树状结构的。

2082
00:13:08,930 --> 00:13:16,150
然后，你就可以用代码操作这棵树，在屏幕上添加越来越多的信息、聊天信息等任何你喜欢的内容。

2083
00:13:16,150 --> 00:13:27,140
最后，我们将通过介绍所谓的框架和库，将所有这一切联系在一起，这些第三方代码能让你更轻松地解决感兴趣的问题。

2084
00:13:27,140 --> 00:13:33,820
尤其是这里，这是我自己在 1997 年制作的第一个网络应用程序。

2085
00:13:33,820 --> 00:13:41,380
我参加了一年级的校内体育项目，但不是作为运动员，而是作为程序员，自学如何构建网络应用程序。

2086
00:13:41,380 --> 00:13:44,410
当时我只知道 C，也许还知道一点别的。

2087
00:13:44,410 --> 00:13:53,290
但至少对哈佛大学来说，这成了一年级校内体育项目的第一个网站，而且它不仅仅是一个带有链接和图片等的静态网站。

2088
00:13:53,290 --> 00:13:55,570
它是互动的。你可以报名参加体育运动。

2089
00:13:55,570 --> 00:14:01,340
我们可以准确地输入谁进入了锦标赛或类似的比赛，它实际上可以自动跟踪这些数据。

2090
00:14:01,340 --> 00:14:07,687
因此，在短短三个月这样的课程之后，你也会从简单地写这周和下周的 Hello, World

2091
00:14:07,687 --> 00:14:13,822
如果您愿意，也可以在网络、手机或其他平台上构建类似的功能。

2092
00:14:13,822 --> 00:14:17,030
但在学期结束前，我们会让你离开课程的基础设施。

2093
00:14:17,030 --> 00:14:19,570
沿途不会使用任何玩具环境。

2094
00:14:19,570 --> 00:14:29,980
最终，我们将赋予你在 CS50 之后编写代码的能力，尤其是如果这是你唯一的一门 CS 课程，你可以在自己的 Mac 或 PC 上使用相同的软件，但不是基于云的版本。

2095
00:14:29,980 --> 00:14:37,010
但所有这些软件本身都是免费的，在课程结束后，您还可以继续使用。

2096
00:14:37,010 --> 00:14:46,210
但一路走来，大家可能都知道，班级里有这样一个传统，尤其是在健康时期，有很多活动能让大家真正聚在一起、

2097
00:14:46,210 --> 00:14:52,120
不仅是合作和学术上的，而且还包括解决问题和一般的相互交流。

2098
00:14:52,120 --> 00:15:00,460
首先是 "CS50 拼图日"，这不是拼图游戏，而是不需要任何计算机科学或编程经验的逻辑谜题。

2099
00:15:00,460 --> 00:15:07,270
但这只是一个机会，可以和一些朋友一起静静地做一包谜题，获得奖品等。

2100
00:15:07,270 --> 00:15:15,910
在本学期晚些时候，一旦你完成了期末项目，也就是课程的巅峰之作，我们不给你写作业，而是你自己想出一些东西来构建。

2101
00:15:15,910 --> 00:15:23,260
我们一般会在晚上 7:00 左右聚在一起，如果你愿意，可以在早上 7:00 左右结束。

2102
00:15:23,260 --> 00:15:33,340
这是一个晚上，一个与同学合作完成自己的毕业设计的 12 个小时的机会，地点就在校园的一个大空间里，如果你和我们一样醒着的话，结束时间是凌晨 5:00。

2103
00:15:33,340 --> 00:15:38,710
我们可以跳上 CS50 穿梭巴士，6:00 左右去路上的 IHOP 吃煎饼。

2104
00:15:38,710 --> 00:15:43,396
当然--当然，这时候是早上六、七点钟

2105
00:15:43,396 --> 00:15:52,300
这是一个学期末的庆祝活动，也是一个展览，展示了你们在未来几个月里所取得的成就。

2106
00:15:52,300 --> 00:15:56,200
事实上，图中是您在健康时代的一些前辈。

2107
00:15:56,200 --> 00:16:03,729
在 CS50 展览会上，您可以携带笔记本电脑或手机，与全校学生、教职员工一起亲自参加展览。

2108
00:16:03,729 --> 00:16:10,150
在这几周的时间里，你将展示自己的创作成果和所学到的知识，并通过视频让人们欣喜地看到。

2109
00:16:10,150 --> 00:16:14,880
最终，这也是一个分享和激励他人的机会。

2110
00:16:14,880 --> 00:16:20,820
最终，你们都将带着自己的 "我参加了 CS50 "T恤衫回家。

2111
00:16:20,820 --> 00:16:23,820
以上就是本课程的概况、

2112
00:16:23,820 --> 00:16:32,780
我建议，我们也开始看看计算机科学本身是什么，以及在接下来的几周里，我们要在这个较低的层次上做些什么。

2113
00:16:32,780 --> 00:16:34,130
那么，什么是计算机科学？

2115
00:16:34,630 --> 00:16:40,310
如果你和我一样，或者是像我高中同学一样的新朋友，你可能会认为这意味着编程。

2116
00:16:40,310 --> 00:16:48,110
对很多人来说，这绝对是重要的一部分，因为有了代码，你就可以写作，可以表达想法，解决实际问题，尤其是涉及数据的问题。

2117
00:16:48,110 --> 00:16:52,100
但计算机科学本身其实就是一门研究信息的学科。

2118
00:16:52,100 --> 00:16:55,170
你如何表现它，又如何实际处理它？

2119
00:16:55,170 --> 00:17:04,604
从这个意义上说，计算思维就是将计算机科学的思想，像这样的课程，应用到你感兴趣的问题中去。

2120
00:17:04,604 --> 00:17:09,089
同样，艺术、人文、科学、社会科学，无论你感兴趣的领域是什么。

2121
00:17:09,089 --> 00:17:16,770
那么，如果说计算机科学的核心是信息，并以此来解决问题，那么，解决问题究竟意味着什么呢？

2122
00:17:16,770 --> 00:17:21,950
让我们看看，我们是否能提出一个模式，让所有的经验教训最终都能融入其中。

2123
00:17:21,950 --> 00:17:29,070
我认为这就是解决问题。你已经有了一些输入，这就像是你想要解决的问题。目标就是解决问题。

2124
00:17:29,070 --> 00:17:36,233
因此，这就是所谓的输出，然后在这里的某个地方，也就是众所周知的黑盒子里，有某种能完成工作的秘方。

2125
00:17:36,233 --> 00:17:42,440
在接下来的几个月里，我们必须决定，我们该如何表示这些输入和输出，以及我们该如何编码？

2126
00:17:42,440 --> 00:17:47,310
我们怎样才能写出解决我们感兴趣的问题的方案？

2127
00:17:47,310 --> 00:17:51,560
因此，说到信息的表现形式，我们有很多方法可以做到这一点。

2128
00:17:51,560 --> 00:17:59,340
举例来说，如果当前的问题很简单，就是在开学第一天上课时进行考勤，那么，我们该如何去做呢？

2129
00:17:59,340 --> 00:18:03,420
实际上，我们可以使用一种叫做 "一元 "的系统。那是什么呢？

2130
00:18:03,420 --> 00:18:08,300
嗯，那是 1、2、3、4、5，也许还有 6、7、8、9、10 的花哨说法。

2131
00:18:08,300 --> 00:18:13,298
我还能用我的手指--双关语--数出每个人的人数。

2132
00:18:13,298 --> 00:18:16,340
最后，你还需要脚趾什么的，如果你非要数到这么高的话。

2133
00:18:16,340 --> 00:18:24,830
但是，一元数是一个非常简单的系统，它使用一个符号（这里指的是人的手指）来解决一些问题，比如计算房间里的人数。

2134
00:18:24,830 --> 00:18:27,950
让我们把这个问题稍微技术化一点，数学化一点。

2135
00:18:27,950 --> 00:18:36,920
这就是所谓的基数-1，你所操作的基数中只有一位数，就像人的手指一样，如果你需要数得更高，可能还有多个这样的手指。

2136
00:18:36,920 --> 00:18:47,180
当然，你们中的大多数人（如果不是所有人的话）一般都隐约知道计算机使用的不是一元数组，甚至你和我可能也不经常使用一元数组。

2137
00:18:47,180 --> 00:18:50,430
他们用什么语言或字母来代替。

2139
00:18:50,930 --> 00:18:55,980
所以二进制，所以二进制确实是计算机以某种方式使用的系统。

2140
00:18:55,980 --> 00:19:01,760
因此，在这种情况下，"bi "意味着 "2"，所以计算机有两位数可以使用。

2141
00:19:01,760 --> 00:19:07,490
事实上，如果你听说过技术术语比特（bit），它就像是字节（byte）的缩小版--很快会有更多的介绍。

2142
00:19:07,490 --> 00:19:15,965
二进制位是 "比特 "一词的由来，因为如果去掉一些字母，二进制位只剩下 B-I-T，这就是比特。

2143
00:19:15,965 --> 00:19:17,990
比特就是 0 和 1。

2144
00:19:17,990 --> 00:19:23,030
这比你自己手指上的数字还多两个，当然，也比你我的数字少。

2145
00:19:23,030 --> 00:19:25,820
作为人类，你我通常使用十进制。

2146
00:19:25,820 --> 00:19:29,390
Dec 表示 10，因为你我一般使用 0 到 9。

2147
00:19:29,390 --> 00:19:32,930
因此，一方面--又是一个双关语--你有了单韵母。

2148
00:19:32,930 --> 00:19:37,760
计算机使用二进制。我们人类通常用十进制思考和交谈。

2149
00:19:37,760 --> 00:19:44,090
但归根结底，这些东西从根本上说都是一样的，也就是说，我们都可以很容易地接触到它们。

2150
00:19:44,090 --> 00:19:47,610
即使你不是电脑达人，我敢说你也即将成为电脑达人。

2151
00:19:47,610 --> 00:19:53,570
那么什么是比特呢？那么，一个比特就是一个 0 或一个 1，也就是所谓的二进制位。

2152
00:19:53,570 --> 00:19:56,090
但电脑怎么只能用二进制说话呢？

2153
00:19:56,090 --> 00:19:59,360
他们如何仅用二进制解决问题、表示信息？

2154
00:19:59,360 --> 00:20:05,300
好吧，说到底，如果他们想表示 0 和 1，我们就需要通过某种物理方式来实现。

2155
00:20:05,300 --> 00:20:11,310
我敢说，也许最简单的方法就是把比特、0 或 1 想象成灯泡。

2156
00:20:11,310 --> 00:20:20,030
按照人类的习惯，我们假设你是一台电脑，无论是笔记本电脑、台式机、手机，还是其他类似设备，你想表示的数字是 0

2157
00:20:20,030 --> 00:20:22,770
你知道吗，你只要把电灯开关关上就行了。

2158
00:20:22,770 --> 00:20:24,290
你把灯泡关掉。

2159
00:20:24,290 --> 00:20:30,990
相比之下，如果你是那台电脑，你想表示数字 1，你就可以打开同样的开关，同样的灯泡，然后把它打开。

2160
00:20:30,990 --> 00:20:35,840
因此，亮着的灯泡代表 "1"，熄灭的灯泡代表 "0"。

2161
00:20:35,840 --> 00:20:37,928
为什么这与计算机有关？

2162
00:20:37,928 --> 00:20:41,340
说到底，你我都是在晚上给笔记本电脑或手机充电。

2163
00:20:41,340 --> 00:20:46,020
因此，无论你使用的是电池还是电源线，都会有一些物理资源得到补充。

2164
00:20:46,020 --> 00:20:51,433
如今，电脑内部有成千上万个小开关。

2165
00:20:51,433 --> 00:20:55,430
你可以把它们比喻成灯泡，但实际上它们并不发光。

2166
00:20:55,430 --> 00:21:01,430
但是，还有一些很小很小的开关，这些开关，如果你听说过这个词，就是所谓的晶体管。

2167
00:21:01,430 --> 00:21:08,390
因此，就像计算机拥有数百万个晶体管一样，这些晶体管可以打开表示 1，也可以关闭表示 0。

2168
00:21:08,390 --> 00:21:15,110
从这个非常简单的机制中，电存在或不存在，一个 1 或一个 0。

2169
00:21:15,110 --> 00:21:23,160
显然，计算机可以从 0 数到 1，但事实证明，如果多用一点电，还可以数得更高。

2170
00:21:23,160 --> 00:21:24,420
那么，我该怎么做呢？

2171
00:21:24,420 --> 00:21:28,500
好吧，让我来提议，我在台上拿一个我们自己的灯泡。

2172
00:21:28,500 --> 00:21:29,210
这个关了。

2173
00:21:29,210 --> 00:21:35,850
因此，举例来说，如果把它微型化，装在 Mac、PC 或手机里，这就是一个晶体管，事实上，这是底部的小开关。

2174
00:21:35,850 --> 00:21:40,910
如果你的电脑想表示 0，它就会把开关关掉，灯也不会亮。

2175
00:21:40,910 --> 00:21:45,193
如果你想表示 1，那么现在，我已经数到了 1，因为开关现在打开了。

2176
00:21:45,193 --> 00:21:46,610
我抓住了一点电。

2177
00:21:46,610 --> 00:21:50,598
我把它放在电脑里，所以现在我看到这是一个 1。

2178
00:21:50,598 --> 00:21:53,390
好吧，但不幸的是，只有一个开关，一个灯泡、

2179
00:21:53,390 --> 00:21:56,630
我只能从 0 数到 1。

2180
00:21:56,630 --> 00:21:59,475
你可能会直觉地想，我怎么才能算得更高呢？

2182
00:22:00,350 --> 00:22:01,070
大卫-J-马兰：再说一遍。

2183
00:22:01,070 --> 00:22:01,430
听众：更多灯泡

2184
00:22:01,430 --> 00:22:02,900
是啊，所以要多装灯泡。

2185
00:22:02,900 --> 00:22:03,650
那就让我来吧。

2186
00:22:03,650 --> 00:22:08,270
让我先拿点东西把它们放上去，这样我就可以一次用几个了。

2187
00:22:08,270 --> 00:22:14,150
让我在此提议，与其只有一个灯泡，不如让我给自己一共装上三个灯泡。

2188
00:22:14,150 --> 00:22:20,540
因此，所有的晶体管最初都是关闭的，如果你把它想象成微缩形式，在你的脑海中，这就像一台有三个晶体管的计算机。

2189
00:22:20,540 --> 00:22:24,860
三个开关现在代表你我都知道的数字 0。

2190
00:22:24,860 --> 00:22:27,150
为什么？他们都不在状态。

2191
00:22:27,150 --> 00:22:30,450
那么，计算机如何表示数字 1 呢？

2192
00:22:30,450 --> 00:22:33,230
嗯，它打开了其中一个灯泡。

2193
00:22:33,230 --> 00:22:35,600
电脑又是如何表示数字 2 的？

2194
00:22:35,600 --> 00:22:39,900
好吧，你可能会想，如果可以的话，你只需打开第二个灯泡。

2195
00:22:39,900 --> 00:22:42,290
如果你想，计算机如何表示 3？

2196
00:22:42,290 --> 00:22:44,250
你只需打开第三个灯泡。

2197
00:22:44,250 --> 00:22:51,020
因此，有了三个比特，计算机似乎就能从 0 开始数到 1、2、3。

2198
00:22:51,020 --> 00:22:53,480
但事实证明，如果我稍微聪明一点的话、

2199
00:22:53,480 --> 00:22:55,760
其实我数的比这还多。

2200
00:22:55,760 --> 00:22:59,060
为什么？我只是在考虑灯泡在这里的组合。

2201
00:22:59,060 --> 00:23:00,435
如果我这样做呢？

2202
00:23:00,435 --> 00:23:08,840
但如果我现在提出，这将是计算机表示 1 的方式呢？

2203
00:23:08,840 --> 00:23:12,680
不过，这将是计算机表示 2 的方式。

2204
00:23:12,680 --> 00:23:14,360
请注意，我没有打开同样的两个。

2205
00:23:14,360 --> 00:23:16,430
我正在打开中间那个。

2206
00:23:16,430 --> 00:23:19,820
我现在声称，这将是计算机表示 3 的方式。

2207
00:23:19,820 --> 00:23:28,550
这将会是 -- 马上就会是 -- 电脑是如何表示我们所知道的 4 这个数字的，但我仍然只用了三个灯泡。

2208
00:23:28,550 --> 00:23:32,600
这将是计算机表示为 5 的数字。

2209
00:23:32,600 --> 00:23:42,380
这将是电脑如何表示数字 6 的过程，最后，事实证明，如果你聪明的话，用三个灯泡就能把数字数到 7。

2210
00:23:42,380 --> 00:23:46,220
现在，即使你不知道我打开了什么以及为什么打开、

2211
00:23:46,220 --> 00:23:50,470
我声称有八种不同的模式，从全部关闭到全部打开。

2212
00:23:50,470 --> 00:23:52,220
但请注意，我开始对它们进行烫发处理。

2213
00:23:52,220 --> 00:23:55,220
我考虑了哪些是打开的，哪些是关闭的。

2214
00:23:55,220 --> 00:23:59,600
为什么这些数字代表我们所熟知的 0 到 7 呢？

2215
00:23:59,600 --> 00:24:02,503
好吧，让我继续，也许我们可以这样做。

2216
00:24:02,503 --> 00:24:09,650
让我们根据灯泡所在的位置，为每一个灯泡赋予一些特殊的意义，而不是仅仅考虑灯泡的存在。

2217
00:24:09,650 --> 00:24:15,350
也许我们可以找三名志愿者，三名志愿者？

2218
00:24:15,350 --> 00:24:17,480
好的你是自愿的

2219
00:24:17,480 --> 00:24:18,210
好的上来吧

2220
00:24:18,210 --> 00:24:19,610
如果你想去那边的舞台。

2221
00:24:19,610 --> 00:24:22,350
你也上来吧你也上来吧 也到这边来

2222
00:24:22,350 --> 00:24:24,530
因此，两端都有一些楼梯。

2223
00:24:24,530 --> 00:24:27,440
也许我们应该为本学期的第一批志愿者鼓掌。

2225
00:24:34,050 --> 00:24:38,633
好的所以你想成为我们的1号，如果你想继续前进，大致站在这里。

2226
00:24:38,633 --> 00:24:40,175
你想成为第二名吗？

2227
00:24:40,175 --> 00:24:41,330
是的Yeah.

2228
00:24:41,330 --> 00:24:46,090
请到右边来，你是4号。

2229
00:24:46,090 --> 00:24:53,120
如果你们愿意，可以到这边来，让我们给你们一点时间，向同学们简单介绍一下自己。

2230
00:24:53,120 --> 00:24:53,662
你好

2232
00:24:54,350 --> 00:24:56,120
我是高年级学生。

2233
00:24:56,120 --> 00:24:57,440
很高兴见到你。

2234
00:24:57,440 --> 00:24:59,840
听众：我叫[? Rayhanna, ?]，是一年级学生。

2235
00:24:59,840 --> 00:25:00,978
欢迎。

2236
00:25:00,978 --> 00:25:03,850
我叫约瑟夫，是一年级学生。

2237
00:25:03,850 --> 00:25:04,850
欢迎。

2238
00:25:04,850 --> 00:25:07,940
好的很高兴你们三位都来了。谢谢你们

2240
00:25:10,940 --> 00:25:16,480
现在我提议，请你们三位代表数字 0。

2241
00:25:16,480 --> 00:25:21,790
我现在宣布，如果你们每个人现在都代表一个开关，那么你们现在就有了更高级的灯泡。

2242
00:25:21,790 --> 00:25:27,340
一个是 1，一个是 2，一个是 4，但事实上，你们每个人的塑料设备底部都有一个开关。

2243
00:25:27,340 --> 00:25:30,520
我声称这三位志愿者代表的是数字 0。

2244
00:25:30,520 --> 00:25:34,240
现在让我来问问大家，你们如何表示数字 1？

2245
00:25:34,240 --> 00:25:36,240
你们应该如何合作？

2246
00:25:36,240 --> 00:25:43,087
好的。所以，我们会有开、关、关，我想这和我的三个灯泡也是一样的，如果你想去关掉你的灯泡的话。

2247
00:25:43,087 --> 00:25:46,910
你们三个如何表示数字 2？

2248
00:25:46,910 --> 00:25:50,420
好了，现在从右到左，关、开、关。

2249
00:25:50,420 --> 00:25:54,020
你们三个如何表示数字 3？

2250
00:25:54,020 --> 00:25:57,043
啊，这就是为什么我的两个灯泡最后都亮了。

2251
00:25:57,043 --> 00:25:58,835
你们三个如何表示数字 4？

2252
00:26:02,620 --> 00:26:10,357
完美。5号、6号和7号？

2253
00:26:10,357 --> 00:26:11,690
好吧，再给我们一个。

2254
00:26:11,690 --> 00:26:14,184
你如何代表 8？

2255
00:26:14,184 --> 00:26:15,000
我们不能We can't.

2256
00:26:15,000 --> 00:26:16,190
好吧，你不能。

2257
00:26:16,190 --> 00:26:20,250
那就再来一名志愿者，一名志愿者，怎么样？

2258
00:26:20,250 --> 00:26:21,470
好的上来吧

2259
00:26:25,350 --> 00:26:26,617
好吧 你叫什么名字 All right.你叫什么名字？

2260
00:26:26,617 --> 00:26:27,950
我叫穆因我叫穆因

2261
00:26:27,950 --> 00:26:28,610
戴维-J-马兰：如果你想说的话。

2262
00:26:28,610 --> 00:26:29,390
我叫穆因我叫穆因

2263
00:26:29,390 --> 00:26:40,150
好吧，[和穆因，]你们将是第 8 号，如果现在你们都-- 实际上，让我们来做个假设，你们将如何集体表示第 8 号，是 4 比特还是交换机？

2264
00:26:40,150 --> 00:26:42,340
好，8，最后，给我 15。

2265
00:26:46,380 --> 00:26:49,835
每个人都在脑子里笨拙地做算术题，哦，用单项式。

2267
00:26:53,440 --> 00:26:55,150
是每个人

2270
00:26:56,290 --> 00:26:57,670
掌声欢迎。

2272
00:26:58,180 --> 00:27:00,610
谢谢大家。

2273
00:27:00,610 --> 00:27:07,107
如果您想在这里留下您的号码，我们为您准备了一个 CS50 压力球，但还是要感谢您的志愿服务。

2274
00:27:07,107 --> 00:27:09,440
你可以把这些数字关掉，放在这里。

2275
00:27:09,440 --> 00:27:11,500
谢谢你。

2276
00:27:11,500 --> 00:27:19,160
那么，我们该如何--如何从那里去创造这些模式呢？

2277
00:27:19,160 --> 00:27:28,720
尽管我们最初仍有三个比特和三个开关，后来又有四个比特和四个开关，但最终，我们还是

2278
00:27:28,720 --> 00:27:32,860
从根本上说，它使用了同样的方法来实际表示信息。

2279
00:27:32,860 --> 00:27:38,150
我为什么要故意让志愿者们这样排队？

2280
00:27:38,150 --> 00:27:44,140
我想让它们使用 2 进制，也就是二进制，但二进制也有一定的规则。

2281
00:27:44,140 --> 00:27:53,021
即使你对二进制并不熟悉，只知道它的存在并与计算机有某种联系，但它实际上与你我每天使用的系统基本相同

2282
00:27:53,021 --> 00:27:55,520
称为基数 10，又称十进制。

2283
00:27:55,520 --> 00:28:00,370
因此，让我们把时间倒回小学，考虑一下十进制是如何工作的。

2284
00:28:00,370 --> 00:28:03,820
你会发现，即使你不是电脑达人，其实你也是。

2285
00:28:03,820 --> 00:28:06,410
你只需稍微调整一下你的心智模式。

2286
00:28:06,410 --> 00:28:11,510
所以，这里的数字你可能会认为是 123，但这是为什么呢？

2287
00:28:11,510 --> 00:28:13,240
其实也不是 123。

2288
00:28:13,240 --> 00:28:23,967
这只是屏幕上三个符号的图案，1、2、3，你的大脑正在迅速赋予它们数学意义，123，但这是为什么呢？

2289
00:28:23,967 --> 00:28:32,800
好吧，如果你和我一样，可能在以前就学过，当你有一个三位数时，比如，最右边的数字是 1 的位数，中间的数字是 10 的位数、

2290
00:28:32,800 --> 00:28:35,870
最左边的数字是 100，这有什么关系？

2291
00:28:35,870 --> 00:28:40,271
好吧，如果你快速做一些心算，就像你我如今即时做的那样

2292
00:28:40,271 --> 00:28:50,500
这意味着 100 乘以 1 再乘以 10 乘以 2 再乘以 1 乘以 3，当然，100 乘以 20 再乘以 3 就得到了你我都知道的 123。

2293
00:28:50,500 --> 00:28:56,900
但除此之外，我们如何才能在十进制系统中只用两位数而不是多达 9 位数呢？

2294
00:28:56,900 --> 00:28:58,150
好吧，我们来归纳一下。

2295
00:28:58,150 --> 00:29:05,920
在十进制系统中，你我都知道，如果我们这里的哈希值代表三位数，没错，就是 1 位、10 位、100 位、

2296
00:29:05,920 --> 00:29:09,860
如果我们不断地进行 1,000 次、10,000 次等，但为什么会这样呢？

2297
00:29:09,860 --> 00:29:12,580
好了，基础术语现在更贴切了。

2298
00:29:12,580 --> 00:29:17,420
从技术上讲，就是 10 到第 0 列，10 到 1，10 到 2。

2299
00:29:17,420 --> 00:29:20,650
因此，这些都是 10 的幂，其中 10 是基数。

2300
00:29:20,650 --> 00:29:27,520
计算机只是把事情简化了一点，因为计算机最终只能使用电力，无论开机还是关机。

2301
00:29:27,520 --> 00:29:32,780
他们无法使用 10 种不同类型的电力，只有 2 种，即开即关。

2302
00:29:32,780 --> 00:29:34,640
他们只是使用了不同的底座。

2303
00:29:34,640 --> 00:29:37,900
而最右边的数字就是所谓的 2 到 0。

2304
00:29:37,900 --> 00:29:39,850
那么中间的数字就是 2 到 1。

2305
00:29:39,850 --> 00:29:41,830
最左边是 2 到 2，又名

2306
00:29:41,830 --> 00:29:51,920
1 的位置、2 的位置、4 的位置，继续下去就是 8，再继续下去就是 16、32、64、128，等等，但基本思路是一样的。

2307
00:29:51,920 --> 00:29:56,770
那么，为什么你我都知道的数字 "0 "会被电脑这样表示呢？

2308
00:29:56,770 --> 00:30:02,750
那么，从右到左，从左到右，就是 0。

2309
00:30:02,750 --> 00:30:08,320
为什么呢？因为 4 乘以 0 再加上 2 乘以 0 再加上 1 乘以 0 当然就是 0。

2310
00:30:08,320 --> 00:30:12,400
这就是为什么 001 代表 1。

2311
00:30:12,400 --> 00:30:20,320
这就是为什么 010 代表 2、3、4、5、6 和 7。

2312
00:30:20,320 --> 00:30:23,500
为什么我们需要第 4 位来表示 8 呢？

2313
00:30:23,500 --> 00:30:29,740
可以说，我们需要用我们熟悉的人类术语来表达 "1"。

2314
00:30:29,740 --> 00:30:34,630
但为此我们需要第 4 位，即另一个晶体管，它现在代表数字 8。

2315
00:30:34,630 --> 00:30:39,070
这就是为什么我们以 "开 "结束 -- 从左到右 -- "关"、"关"、"关"。

2316
00:30:39,070 --> 00:30:45,310
所以我一直在说 "开 "和 "关"，或者灯泡 "开 "或 "关"，但实际上，我的意思只是 "1 "或 "0"。

2317
00:30:45,310 --> 00:30:52,860
因此，计算机和我们人类认为的数字事物只是 0 和 1，但从机械角度来看，你可以把它看作是这些灯泡。

2318
00:30:52,860 --> 00:30:56,300
现在，一个比特用处不大。即使是 3 位、4 位，也没多大用。

2319
00:30:56,300 --> 00:31:01,240
你可以数到 7 或 15，但一般来说，字节是更有用的计量单位。

2320
00:31:01,240 --> 00:31:04,190
有谁知道一个字节有多少位？

2321
00:31:04,190 --> 00:31:08,557
是的一个字节有 8 个比特。你可以把它看成一个八位组。

2322
00:31:08,557 --> 00:31:14,200
在某些情况下，会有一些细微差别，但把一个字节看作是 8 位，这只是一个更有用的衡量标准。

2323
00:31:14,200 --> 00:31:15,890
那么，这意味着什么呢？

2324
00:31:15,890 --> 00:31:22,990
因此，如果你下载过音乐文件、照片或视频，这些都是以字节为单位的。

2325
00:31:22,990 --> 00:31:32,290
可能不是小数字节，可能是千字节的千字节、百万字节的兆字节、亿字节的千兆字节，尤其是视频。

2326
00:31:32,290 --> 00:31:39,670
这意味着你的计算机硬盘上有很多 8 位的模式，一些 0 和 1 的组合。

2327
00:31:39,670 --> 00:31:46,330
在这里，计算机通常用 8 位字节来表示数字 0。

2328
00:31:46,330 --> 00:31:58,247
如果同一台计算机使用全部 8 个比特（即全部字节）将其变为 1 -- 任何数学思维敏捷或见过这种情况的人都知道，一台计算机用 8 个比特或 1 能数多高？

2330
00:31:59,080 --> 00:32:00,902
是的，255。为什么是255？

2331
00:32:00,902 --> 00:32:03,610
好吧，我们不打算把这变成一成不变的数学练习。

2332
00:32:03,610 --> 00:32:08,230
事实上，过了今天，我们就不会再考虑或谈论这么低级的比特了。

2333
00:32:08,230 --> 00:32:19,520
但这是 1 的位置，2，4，8，16，32，64，128，如果我从左往右算，确实是 255。

2334
00:32:19,520 --> 00:32:24,160
它忽略了我们如何表示负数，但也许改天会有更多关于负数的内容。

2335
00:32:24,160 --> 00:32:28,810
当然，计算机能做的远不止数字、数学和这些低层次的东西。

2336
00:32:28,810 --> 00:32:32,150
我们发送短信、撰写文件和电子邮件等等。

2337
00:32:32,150 --> 00:32:36,220
那么，计算机该如何表示字母 A 呢？

2338
00:32:36,220 --> 00:32:46,210
我认为，归根结底，你的 Mac、PC 和手机只是拥有大量的晶体管和开关，可以以 8 或字节为单位使用。

2339
00:32:46,210 --> 00:32:58,440
不过，如果它已经使用这些 0 和 1 的模式来表示从 0 开始的数字，那么你认为该如何表示字母表中的字母呢？

2342
00:32:59,730 --> 00:33:01,800
因此，我们可以给每个字母分配一个数字。

2344
00:33:01,920 --> 00:33:08,760
让我来猜想一下，为了简单起见，我们把 A 称为 0，B 称为 1，C 称为 2。

2345
00:33:08,760 --> 00:33:13,500
好了，我现在该如何表示 0、1 或 2 呢？

2346
00:33:13,500 --> 00:33:19,050
好吧，如果现在我们不得不偷用一些数字来表示字母，那我们可能会给自己带来麻烦。

2347
00:33:19,050 --> 00:33:21,870
我们必须选择一条车道，但也有解决办法，我们会看到的。

2348
00:33:21,870 --> 00:33:25,710
事实证明，世界并不像 A 为 0 那么简单。

2349
00:33:25,710 --> 00:33:32,640
一个典型的例子是，各地的电脑和电话都用数字 65（十进制数字 65）来表示。

2350
00:33:32,640 --> 00:33:41,220
使用 8 个比特，如果我们将某些 0 变为 1，那么让我来规定一下，你可以使用 8 个比特，通过打开某些比特来表示字母 A

2351
00:33:41,220 --> 00:33:46,000
但我们将尽量不过多地关注二进制层面。

2352
00:33:46,000 --> 00:33:54,060
因此，如果 A 是 65，那么 B 将是 66，C 将是 67，以此类推，我们会得到什么呢？

2353
00:33:54,060 --> 00:33:59,130
原来，有一整套系统可以将数字映射到字母。

2354
00:33:59,130 --> 00:34:05,130
正如我刚才口头提到的，这里是 0 和 1 的模式，你可以通过它来表示 65。

2355
00:34:05,130 --> 00:34:13,770
这里只需快速检查一下，我们不会经常做 1 位的数学运算，这很简单，2、4、8、16、32、64 位都可以。

2356
00:34:13,770 --> 00:34:17,969
所以 64 加 1 等于 65。

2357
00:34:17,969 --> 00:34:21,540
那么，一旦我做到了这一点，我怎样才能获得所有其他的信息呢？

2358
00:34:21,540 --> 00:34:25,020
原来，几年前一群美国人想出了这个办法

2359
00:34:25,020 --> 00:34:28,889
ASCII，美国信息交换标准码。

2360
00:34:28,889 --> 00:34:30,344
现在，这是什么意思？

2361
00:34:30,344 --> 00:34:37,620
嗯，这只是一个缩写，描述的是你真正提出的，数字和字母之间的映射，不像 0、1、2 那么简单。

2362
00:34:37,620 --> 00:34:45,610
大写字母从 65、66、67 开始，但这里是目前使用的大多数字母，至少在这一系统中是这样。

2363
00:34:45,610 --> 00:34:52,800
这是网上的一个大图表，你会在图表中间看到，这里是我的65分，A，这里是我的66分、

2364
00:34:52,800 --> 00:34:58,750
B、C，让我们看看，72 是 H，73 是 I，以此类推。

2365
00:34:58,750 --> 00:35:03,160
因此，至少在英语中，所有这些数字和字母之间都有一个映射关系。

2366
00:35:03,160 --> 00:35:07,080
如果我们把注意力集中在这里，这些就是大写字母的开头。

2367
00:35:07,080 --> 00:35:15,630
那么假设今天、明天，你收到了某人发来的短信，而你是个电脑高手、

2368
00:35:15,630 --> 00:35:19,110
你要想办法查看发送的是什么 0 和 1 的模式。

2369
00:35:19,110 --> 00:35:23,147
在这种情况下，它是无线的，而不是有线的，但它仍然是一些 0 和 1 的模式。

2370
00:35:23,147 --> 00:35:27,900
而你的手机正在打开和关闭自己的一些开关，以表示朋友发来的信息。

2371
00:35:27,900 --> 00:35:35,430
假设您收到的三个图案是这三个字节，从左到右，拼成一个三个字母的单词。

2372
00:35:35,430 --> 00:35:40,060
好吧，如果我们算出 1 的位置、2 的位置等等 -- 我就不告诉你了。

2373
00:35:40,060 --> 00:35:49,410
假设您收到的短信并不是字面上的 72、73、33，而是 8 加 8 加 8，24 比特的模式

2374
00:35:49,410 --> 00:35:54,510
如果用数学运算，则表示十进制数 72、73、33。

2375
00:35:54,510 --> 00:35:58,980
有谁还记得你可能从绿色和白色图表中收到了什么信息？

2377
00:35:59,970 --> 00:36:00,930
你好

2378
00:36:00,930 --> 00:36:02,010
你好。

2379
00:36:02,010 --> 00:36:08,370
是的，"嗨 "是信息，但 72、73 给了我们 H 和 I。

2380
00:36:08,370 --> 00:36:10,560
猜到 33 吗？

2381
00:36:10,560 --> 00:36:12,100
是啊，在这里。

2383
00:36:12,600 --> 00:36:13,770
所以这是一个感叹号。

2384
00:36:13,770 --> 00:36:14,650
你怎么知道？

2385
00:36:14,650 --> 00:36:17,025
好吧，你确实需要一些小抄，又名......

2386
00:36:17,025 --> 00:36:18,010
这里是 ASCII 编码。

2387
00:36:18,010 --> 00:36:24,490
如果我们再看看其他地方--让我突出显示图表的左边--你就会发现，在小数点后 33 位的旁边确实有一个感叹号。

2388
00:36:24,490 --> 00:36:31,396
所以，在过去，一群人在一个房间里决定，嘿，当我们开始制造 PC，后来又制造 Mac 和手机时

2389
00:36:31,396 --> 00:36:38,110
在这种情况下，我们只需就英文字母的这种表现形式达成一致。

2390
00:36:38,110 --> 00:36:39,810
我们只需就这一映射达成一致。

2391
00:36:39,810 --> 00:36:42,910
但有点奇怪的是，请注意这一点。

2392
00:36:42,910 --> 00:36:54,660
事实证明，一旦你把自己逼到这个角落，开始用 65 表示 A，66 表示 B，那么，你该如何表示 65 这个数字和 66 这个数字呢？

2393
00:36:54,660 --> 00:36:57,690
如果你想做数学题或使用 Excel 或类似的东西？

2394
00:36:57,690 --> 00:37:01,380
有谁能找到解决办法吗？

2395
00:37:01,380 --> 00:37:06,070
如何用 ASCII 码表示数字 1？

2396
00:37:06,070 --> 00:37:07,528
是啊，在中间？

2398
00:37:09,065 --> 00:37:09,940
是的。

2399
00:37:09,940 --> 00:37:15,080
这可能有点 "萌"，但你可以用其他数字来表示数字。

2400
00:37:15,080 --> 00:37:23,230
因此，如果你想把你我都知道的数字表示为 1，比如你在键盘上输入 1，结果计算机会把它存储为十进制数字 49。

2401
00:37:23,230 --> 00:37:27,070
如果您在键盘上敲击 2，计算机本身并没有存储 2。

2402
00:37:27,070 --> 00:37:29,230
它存储的是十进制数 50。

2403
00:37:29,230 --> 00:37:33,940
现在，值得庆幸的是，悖论到此为止。

2404
00:37:33,940 --> 00:37:36,340
我们现在只需将数字与数字进行映射。

2405
00:37:36,340 --> 00:37:43,720
但实际上，归根结底--下周我们开始用另一种语言 C 编写代码时，你就会学到这一点--归根结底，这只是取决于上下文。

2406
00:37:43,720 --> 00:37:49,720
在你的 Mac、PC 和手机里，有所有这些比特的排列组合，所有这些 0 和 1 的模式。

2407
00:37:49,720 --> 00:37:55,252
一般来说，当你打开收到的短信时，里面都是 0 和 1。

2408
00:37:55,252 --> 00:38:04,862
但很明显，如果是文字信息，文字信息的全部意义就在于发送文字，因此这些 0 和 1 的模式，默认情况下通常会被解释为字母表中的字母。

2409
00:38:04,862 --> 00:38:06,070
因此，你不会看到 0 和 1。

2410
00:38:06,070 --> 00:38:07,320
您不会看到小数点后的数字。

2411
00:38:07,320 --> 00:38:10,090
您将看到您朋友想要的英文信息。

2412
00:38:10,090 --> 00:38:19,660
相比之下，如果你打开 Excel 等软件，同样的 0 和 1 的模式可能确实是 72、73、33。

2413
00:38:19,660 --> 00:38:23,530
您可能会在电子表格中看到写有这三个数字的单元格。

2415
00:38:24,040 --> 00:38:28,210
因为电子表格在很多情况下都是关于数字、数字运算和数学的。

2416
00:38:28,210 --> 00:38:36,820
相比之下，如果打开 Photoshop，尝试查看同样的 0 和 1 图案，就不会是 72、73、33 了。

2417
00:38:36,820 --> 00:38:38,530
它不会是 0 和 1。

2418
00:38:38,530 --> 00:38:39,670
它不会是喜。

2419
00:38:39,670 --> 00:38:42,100
它将是彩虹中的某种颜色。

2420
00:38:42,100 --> 00:38:46,810
原来，你也要用这些 0 和 1 的图案来表示颜色。

2421
00:38:46,810 --> 00:38:56,560
事实上，只要你我同意，就像人类一直以来同意的那样，这些模式将会是什么，我们所有的系统，我们如今的许多系统确实都是可互操作的。

2422
00:38:56,560 --> 00:39:01,330
但我在这里很有偏见，事实上，A 和 ASCII 非常以美国为中心。

2423
00:39:01,330 --> 00:39:03,940
你在这张图表中看不到什么？

2424
00:39:03,940 --> 00:39:11,620
如果你说的是英语以外的其他语言，那么你很可能看不到你熟悉和喜爱的、每天都需要用来输入或发送信息的字符。

2425
00:39:11,620 --> 00:39:17,170
这里不支持大量字符集，包括重音字符和大量亚洲字母。

2426
00:39:17,170 --> 00:39:20,420
你有很多符号，甚至在这个屏幕上都放不下。

2427
00:39:20,420 --> 00:39:24,010
因此，人类很早就把自己逼入了绝境、

2428
00:39:24,010 --> 00:39:24,970
美国人做到了。

2429
00:39:24,970 --> 00:39:33,880
但在典型的键盘上，即美国英语键盘上，有 A、B、C、大写和小写字母，但也有重音字符。

2430
00:39:33,880 --> 00:39:41,090
如今，不知道是否有必要这样做，但现在键盘上还有其他字符，比如这些。

2431
00:39:41,090 --> 00:39:45,730
这些都是这一问题的技术解决方案的有趣化身。

2432
00:39:45,730 --> 00:39:52,480
如果我暂时声称 ASCII 码历史上用 7 位来表示字母--让我们把它四舍五入为一个字节--那么

2433
00:39:52,480 --> 00:40:00,520
用 8 位来表示字母，ASCII 可以表示多达 255 个字符，实际上是 256 个字符。

2435
00:40:01,550 --> 00:40:04,840
如果都是 0，那就是 0，最高的数字是

2436
00:40:04,840 --> 00:40:07,070
我刚才说的是 255。

2437
00:40:07,070 --> 00:40:09,160
因此，总共有 256 种可能性。

2438
00:40:09,160 --> 00:40:10,360
这可不是几个字母。

2439
00:40:10,360 --> 00:40:13,730
这对英语还行，但对很多人类语言就不行了。

2440
00:40:13,730 --> 00:40:25,360
那么，如果要表示重音字符、亚洲字符、表情符号，甚至像这些如今只是键盘上的按键的字符，直观的解决方案可能是什么呢？

2441
00:40:25,360 --> 00:40:28,610
如果一个字节太少，直观的解决方案是什么？

2443
00:40:29,110 --> 00:40:30,320
听众：再加一位数

2444
00:40:30,320 --> 00:40:30,710
是的。

2445
00:40:30,710 --> 00:40:31,610
所以再加一位数。

2446
00:40:31,610 --> 00:40:37,640
就像我们让第 4 个志愿者上来给我们出第 4 个价一样，让我们把硬件扔到问题上，多用几个位子。

2447
00:40:37,640 --> 00:40:41,925
因此，也许可以用 2 个字节代替 1 个字节，或者干脆用 3 或 4 个字节。

2448
00:40:41,925 --> 00:40:49,047
尽管它变得有点昂贵--我们正在从 8 位变为 16 位，再变为 24 位或 32 位--但这就是如今计算机的工作方式。

2449
00:40:49,047 --> 00:40:54,710
值得庆幸的是，我们的电脑和手机内存如此之大，我们当然可以腾出一些内存来表现这些东西。

2450
00:40:54,710 --> 00:40:58,400
解决 ASCII 码的办法就是我们所说的统一码。

2451
00:40:58,400 --> 00:41:06,380
因此，Unicode 也只是数字到字母的映射，但使用的语言多种多样。

2452
00:41:06,380 --> 00:41:16,610
事实上，Unicode 协会是由一群来自不同公司、不同国家和不同文化背景的人组成的、

2453
00:41:16,610 --> 00:41:23,070
在这种情况下，作为一个组织，就是要以数字方式捕捉人类语言的所有形式。

2454
00:41:23,070 --> 00:41:32,600
此外，还要确保使用鲜为人知的语言的人类，尤其是较小的人口群体，能够通过这些 0 和 1 的映射，以数字方式得到表达和保存。

2455
00:41:32,600 --> 00:41:42,830
但事实证明，如果开始使用 32 位（多达 32 位）来表示键盘上的字符，那么就有 40 亿种 0 和 1 的可能排列组合。

2456
00:41:42,830 --> 00:41:45,538
这远远超出了我们对大多数人类语言的需求。

2457
00:41:45,538 --> 00:41:49,850
因此，还有一点空间可以容纳一些更好玩的东西，比如那些表情符号。

2458
00:41:49,850 --> 00:41:55,040
举个例子，假设你收到一条短信，短信内容是 0 和 1 的组合。

2459
00:41:55,040 --> 00:42:03,080
或者，如果我们计算一下，假设你收到一条短信，如果按十进制计算，就是 4,036,991,106 条。

2460
00:42:03,080 --> 00:42:07,110
有人知道你在看什么表情符号吗？

2461
00:42:07,110 --> 00:42:11,033
如果你这样做就太奇怪了，但这是什么？

2462
00:42:11,033 --> 00:42:16,990
事实证明，截至去年，这个表情符号是最受欢迎的表情符号、

2463
00:42:16,990 --> 00:42:18,970
喜极而泣的脸庞

2464
00:42:18,970 --> 00:42:24,070
这就是统一码联盟中的一群人所决定的表示模式。

2465
00:42:24,070 --> 00:42:31,810
但你会发现，你们中的许多人可能有 iPhone，有些人可能也有安卓设备，有时，这些设备实际上看起来不太一样。

2466
00:42:31,810 --> 00:42:36,850
这恰好是 iOS 上的 "喜极而泣 "当前版本。

2467
00:42:36,850 --> 00:42:42,550
在安卓系统上，它往往看起来更像这样一些，而这里就有点奇怪了。

2468
00:42:42,550 --> 00:42:46,840
尽管你我看到的这些东西看起来像图像，但它们并不是图像。

2469
00:42:46,840 --> 00:42:50,470
它们是字符，至少是我们现在在 Unicode 中定义的字符。

2470
00:42:50,470 --> 00:42:59,325
如今，iOS、Android、Windows、Facebook 以及其他公司和应用程序的字体都不尽相同。

2471
00:42:59,325 --> 00:43:09,250
因此，就像英文字体和其他语言的字体可以给你提供有衬线或无衬线的不同字符一样，emoji 本身也是有人画的图画，但它们实际上只是一种字体。

2472
00:43:09,250 --> 00:43:14,830
因此，同样是 0 和 1 的模式，在某人的手机上呈现的效果可能会略有不同。

2473
00:43:14,830 --> 00:43:22,771
如果你的手机上有一个图标坏了，你收到了一个表情符号，但它就像一个正方形或其他任意的、不合理的东西。

2474
00:43:22,771 --> 00:43:29,710
这可能只是意味着你还没有更新到 iOS 或 Android 的最新版本，而最新版本只会更新支持的表情符号字体。

2475
00:43:29,710 --> 00:43:36,838
因为如今，Unicode 的工作人员几乎每年都会在特定字符集中添加越来越多的表情符号。

2476
00:43:36,838 --> 00:43:41,710
前几天，我在兔子洞里找出了最近最流行的表情符号。

2477
00:43:41,710 --> 00:43:49,390
相比之下，去年 Twitter 上最流行的表情符号是 "大声哭泣的脸"。

2478
00:43:49,390 --> 00:43:55,780
我不知道这更能说明 2021 年的情况，还是 Twitter 的情况，但你肯定会看到使用这些工具的不同趋势。

2479
00:43:55,780 --> 00:44:03,790
但是，即使是人类自己也不一定会提前两步思考，现在很多表情符号都是默认的黄色。

2480
00:44:03,790 --> 00:44:10,690
但有很多表情符号并不是这些卡通人物，而是代表人类的各种职业或手势等。

2481
00:44:10,690 --> 00:44:18,190
如今，你可能也注意到了，在你的手机、Mac 和 PC 上，你可以为某些表情符号指定不同的肤色。

2482
00:44:18,190 --> 00:44:27,483
如果得到公司和 Unicode 的支持，你就可以触摸并按住某个表情符号，然后选择合适的肤色来代表自己或他人。

2483
00:44:27,483 --> 00:44:29,440
然后修改显示屏。

2484
00:44:29,440 --> 00:44:38,650
我们不妨想一想，苹果、谷歌和微软等公司是如何实现对不同肤色表情符号的支持的？

2485
00:44:38,650 --> 00:44:41,000
你怎么能这样做？

2486
00:44:41,000 --> 00:44:47,230
如果你想用五个不同肤色的表情符号来表示一些微笑的表情符号，你能想到什么？

2487
00:44:47,230 --> 00:44:53,950
五种不同的图案在结构上完全相同，只是在该图像的某些地方使用了肤色。

2488
00:44:53,950 --> 00:45:00,890
但如果只是复制、粘贴、粘贴、粘贴、粘贴，然后在 Photoshop 中更改颜色，效率就有点低了。

2489
00:45:00,890 --> 00:45:05,020
这将使用比你可能需要的更多比特、更多信息。

2490
00:45:05,020 --> 00:45:12,271
如果你现在开始像计算机科学家那样思考问题，如果一天结束时，你所拥有的只是 0 和 1，那还能怎样呢？

2491
00:45:12,271 --> 00:45:14,180
你认为还能如何实现肤色？

2493
00:45:14,680 --> 00:45:15,298
观众：RGB.

2494
00:45:15,298 --> 00:45:16,090
大卫-J-马兰：好的。

2495
00:45:16,090 --> 00:45:18,190
所以，RGB，我们稍后再谈。

2496
00:45:18,190 --> 00:45:20,590
这代表红、绿、蓝。这是一种方法。

2497
00:45:20,590 --> 00:45:29,720
不过，在这种情况下，我正在寻找一种替代方法，而不仅仅是用五个不同的 0 和 1 图案来表示相同的表情符号，但却代表不同的肤色。

2498
00:45:29,720 --> 00:45:30,620
因此不完全是 RGB。

2501
00:45:32,278 --> 00:45:33,070
大卫-J-马兰：好的。

2502
00:45:33,070 --> 00:45:39,410
因此，先存储一个表情符号的副本，然后存储您想为该表情符号指定的颜色的不同变体。

2504
00:45:39,910 --> 00:45:42,452
所以这实际上是一个例子 -- 你想详细说明一下吗？

2505
00:45:42,452 --> 00:45:43,858
听众：你可以用一个循环。

2506
00:45:43,858 --> 00:45:44,650
大卫-J-马兰：好的。

2507
00:45:44,650 --> 00:45:46,900
因此，你可以使用循环来实际输出这些内容。

2508
00:45:46,900 --> 00:45:47,942
稍后再详述。

2509
00:45:47,942 --> 00:45:49,990
让我沿着这条路走下去。

2510
00:45:49,990 --> 00:45:54,335
如果你愿意，这在某种意义上是一种更好的设计，但为什么呢？

2512
00:45:54,835 --> 00:45:55,798
听众：过滤器？

2513
00:45:55,798 --> 00:45:56,590
大卫-J-马兰：好的。

2514
00:45:56,590 --> 00:45:58,780
所以，如果我们从 Instagram 的角度来考虑，滤镜也是如此。

2515
00:45:58,780 --> 00:46:01,885
你可以改变某些东西的颜色，这也可能与此有关。

2516
00:46:01,885 --> 00:46:03,967
会不会是另一种字体？会不会是另一种字体？

2517
00:46:03,967 --> 00:46:05,300
大卫-J-马兰：哦，有意思。

2518
00:46:05,300 --> 00:46:07,410
所以，也许只是一种完全不同的字体。

2519
00:46:07,410 --> 00:46:12,800
除了对相同表情符号的肤色有不同的解释外，你有五种几乎完全相同的不同字体。

2520
00:46:12,800 --> 00:46:13,550
让我来破坏。

2521
00:46:13,550 --> 00:46:20,104
我认为，如果我们沿着这条特殊的道路走下去，Unicode 工作人员几年前决定这样做的方式是

2522
00:46:20,104 --> 00:46:29,060
其中，您通过短信或电子邮件收到的第一个或多个字节就像表情符号的结构，即默认的黄色版本。

2523
00:46:29,060 --> 00:46:37,187
但是，如果紧随其后的是这些人类标准化的、代表每种不同色调肤色的特定比特模式

2524
00:46:37,187 --> 00:46:45,290
然后，手机、Mac 和 PC 就会将默认颜色（大多数情况下是黄色）更改为更适合人类的颜色。

2525
00:46:45,290 --> 00:46:49,970
因此，你只需使用两倍的比特，但不会使用五倍的比特。

2526
00:46:49,970 --> 00:46:50,720
那我是什么意思？

2527
00:46:50,720 --> 00:46:54,890
你本身并没有五种完全不同的模式。

2528
00:46:54,890 --> 00:47:07,920
对于每种可能的变体，你都有一个表情符号本身的结构表示，然后是这五种肤色的可重复使用的图案。

2529
00:47:07,920 --> 00:47:16,100
遗憾的是，这对于正在开发的其他功能来说还不够全面，如今也是如此。

2530
00:47:16,100 --> 00:47:24,150
表情符号旨在关注某些职业，早期也是如此，某些职业与某些性别相关，反之亦然。

2531
00:47:24,150 --> 00:47:28,070
你不一定是某一性别或另一性别，从事某一职业或另一职业。

2532
00:47:28,070 --> 00:47:30,230
这些组合是不可能实现的。

2533
00:47:30,230 --> 00:47:37,700
但如今，正如你可能已经看到的那样，比如说，你可以看到一对热恋中的情侣，他们实际上看起来更像三个表情符号，只是有点像合二为一。

2534
00:47:37,700 --> 00:47:45,390
事实上，这只需在手机上按一下键，就能将左边和右边的不同表情符号与中间的表情符号组合在一起。

2535
00:47:45,390 --> 00:47:54,920
因此，现在的计算机在表示这些模式时，左边的字符用一组比特表示，右边的字符用一组比特表示、

2536
00:47:54,920 --> 00:47:58,080
一组比特用于中间的任何表情符号。

2537
00:47:58,080 --> 00:48:06,350
然后，你只需重复使用这些相同的图案和零碎的部分，就能组合出更复杂的表情符号。

2538
00:48:06,350 --> 00:48:12,620
Unicode 人员不必为某些非常特殊的化身设计全新的表示法。

2539
00:48:12,620 --> 00:48:21,390
他们可以为您要显示的其他字符创建一个人形、男形、女形，并重复使用这些相同的 0 和 1 模式。

2540
00:48:21,390 --> 00:48:30,500
在这里，你可以看到人类的不完美，或者说缺乏远见，因为人类在早期建立了一个完全以美国为中心的系统，没有字符、表情符号或类似的东西，但现在也发展了。

2541
00:48:30,500 --> 00:48:33,800
因此，这是当今计算领域的一个重要细节。

2542
00:48:33,800 --> 00:48:39,780
它也在不断发展，而你们在接下来的日子里将要学习的语言，也同样在不断发展。

2543
00:48:39,780 --> 00:48:43,942
新功能不断增加，甚至编程语言也有版本号。

2544
00:48:43,942 --> 00:48:46,400
您的手机上可能有不同版本的应用程序。

2545
00:48:46,400 --> 00:48:49,770
编程语言也有不同的版本。

2546
00:48:49,770 --> 00:48:56,900
那么，迄今为止关于如何使用 ASCII 或 Unicode 或两者之间的任何编码来表示信息的问题是什么？

2549
00:48:59,383 --> 00:49:00,800
大卫-J-马兰：哦，问得好。

2550
00:49:00,800 --> 00:49:12,396
所以，概括地说，你为什么不能--嗯，让我总结一下，你为什么不能同样使用不同的模式来改变这些比特模式所代表的背景，无论是

2551
00:49:12,396 --> 00:49:14,950
无论是数字、字母还是图形？

2552
00:49:14,950 --> 00:49:17,920
实际上，这就是引擎盖下发生的事情。

2553
00:49:17,920 --> 00:49:24,670
但从下周开始，当我们从零开始过渡到 C 语言时，你将学习类型、数据类型。

2554
00:49:24,670 --> 00:49:35,642
最初的责任在于程序员，告诉程序是否应该将这种比特模式解释为数字、字母、颜色或其他东西。

2555
00:49:35,642 --> 00:49:41,170
不过现在，在学期末，你会使用 Python 等语言，计算机会自动计算出结果

2556
00:49:41,170 --> 00:49:45,950
通过上下文为您提供，这也让编程变得更加简单快捷。

2557
00:49:45,950 --> 00:49:50,580
有关 Unicode、ASCII 或类似的其他问题？

2558
00:49:50,580 --> 00:49:53,330
好吧那么，其他形式的信息呢？

2559
00:49:53,330 --> 00:49:55,250
前面提到了 RGB，即红、绿、蓝。

2560
00:49:55,250 --> 00:49:57,410
计算机如何处理图像？

2561
00:49:57,410 --> 00:50:04,340
事实上，它通常是由一定量的红色、绿色和蓝色组合而成，但也有其他表现形式。

2562
00:50:04,340 --> 00:50:08,000
如果你是平面设计师，你可能知道它们，但 RGB 还是很常见的。

2563
00:50:08,000 --> 00:50:08,970
这意味着什么？

2564
00:50:08,970 --> 00:50:18,395
这意味着，手机上的每一个点、电视上的每一个点、笔记本电脑或台式机上的每一个点，都有一个代表该点应显示多少红色的数字、

2565
00:50:18,395 --> 00:50:24,690
一个数字代表多少绿色，一个数字代表多少蓝色，分别为红、绿、蓝。

2566
00:50:24,690 --> 00:50:37,250
因此，举例来说，如果你屏幕上的一个点在短信或电子邮件中使用了这三个数字，这三个值或字节，72、73、33，那就会被解释为我声称 "高"。

2567
00:50:37,250 --> 00:50:47,840
但在 Photoshop 或其他图形程序中，同样的图案会被解释为中等量的红色、中等量的绿色和少量的蓝色。

2568
00:50:47,840 --> 00:50:49,250
为什么是 "中 "和 "小"？

2569
00:50:49,250 --> 00:50:54,110
原来，这些都是字节，我们说的字节中最小的值是 0。

2570
00:50:54,110 --> 00:50:58,100
一个字节的最大值是 255，所以我只是随便说说。

2571
00:50:58,100 --> 00:51:02,660
具体来说，这就像中等、中等和少量的红色、绿色和蓝色。

2572
00:51:02,660 --> 00:51:12,890
这三种颜色，就像光的波长一样，以这样的方式组合在一起，你就会在屏幕上看到这个点，一种黄色或棕色的浑浊色调。

2573
00:51:12,890 --> 00:51:18,470
计算机就是这样精确存储这种颜色的，事实上，我们已经看到了这种颜色。

2574
00:51:18,470 --> 00:51:23,930
一般来说，当您在屏幕上输入 "喜极而泣的脸 "时，它看起来是这样的，但通常要小得多。

2575
00:51:23,930 --> 00:51:27,980
不过，让我们放大一点，或者说再放大一点。

2576
00:51:27,980 --> 00:51:30,212
如果你知道这个词，你开始看到什么？

2577
00:51:30,212 --> 00:51:30,920
观众：像素

2578
00:51:30,920 --> 00:51:33,212
戴维-J-马兰：所以像素，它变得非常像素化。

2579
00:51:33,212 --> 00:51:40,354
像素只是屏幕上的一个小点，如果把它放大，就能看到组成表情符号的所有小点。

2580
00:51:40,354 --> 00:51:45,750
在 iOS 系统中，苹果公司使用的字体就是用来表示这种 0 和 0 的特殊模式的。

2581
00:51:45,750 --> 00:51:53,780
屏幕上的每一个黄点都有 3 个字节。

2582
00:51:53,780 --> 00:51:55,700
这个点需要多少红、绿、蓝？

2583
00:51:55,700 --> 00:51:58,700
这个点需要多少红绿蓝？

2584
00:51:58,700 --> 00:52:02,720
你也会注意到，当它变成褐色时，小点就会非常显眼。

2585
00:52:02,720 --> 00:52:08,160
这 3 个值、3 个字节（又称 24 位）只是略有不同。

2586
00:52:08,160 --> 00:52:19,850
这就是为什么你拍摄的图片或下载的 gif 会变得如此之大的原因，因为屏幕上的每一个点都代表着一个数字。

2587
00:52:19,850 --> 00:52:29,630
那么，如果这就是我所说的图像的典型表示方法，即使用比特模式分配一定量的红色、绿色或蓝色，那么视频又是如何产生的呢？

2588
00:52:29,630 --> 00:52:34,820
如果一天结束时，我们所拥有的只是 0 和 1，那么视频又算得了什么呢？

2589
00:52:34,820 --> 00:52:36,500
视频是什么？

2591
00:52:37,610 --> 00:52:39,420
让我们去这里，在后面的路。

2592
00:52:39,420 --> 00:52:44,780
是的像素的数值真的会随着时间的推移而变化。你想确认还是否认这只手的举动吗？

2594
00:52:45,380 --> 00:52:49,828
戴维-J-马兰：是的，或者说，一连串的图像，随着时间的推移，在屏幕上不断变化。

2595
00:52:49,828 --> 00:52:59,191
因此，这两种解释都是有道理的，只是为了好玩，如果你是在这些图画书的陪伴下长大的，你可能会记得这样一个小故事：如果我们能把灯光调暗？

2597
00:53:19,925 --> 00:53:31,250
因此，这是一种老式的模拟方式来实现视频，从这个意义上说，艺术家写出了数百张纸，上面的图像几乎一模一样，但他们铅笔上的墨水

2598
00:53:31,250 --> 00:53:33,015
或者笔在轻微移动。

2599
00:53:33,015 --> 00:53:41,220
如果将其数字化，让每一个笔画都用点来表示，那么你看到的就是一连串在屏幕上飞舞的图像。

2600
00:53:41,220 --> 00:53:48,320
如果我们深入现实世界，如果你看过电影，好莱坞电影通常是 24 FPS（每秒帧数）。

2601
00:53:48,320 --> 00:53:55,370
这实际上意味着你看到的是每秒 24 幅图像，而在电视或肥皂剧中，通常是每秒 30 幅图像。

2602
00:53:55,370 --> 00:53:57,210
这让事情看起来更顺利一些。

2603
00:53:57,210 --> 00:53:59,750
因此，如果你愿意的话，这并不是一部真正的电影。

2604
00:53:59,750 --> 00:54:07,985
这是一连串的图片，而你的大脑和思维会插值到：哦，这是流畅的运动，尽管我们看到的只是非常快速的大量图片。

2605
00:54:07,985 --> 00:54:15,200
现在，信息量变得非常大，我们将在本学期晚些时候讨论如何压缩信息，从而避免使用比实际需要更多的比特。

2606
00:54:15,200 --> 00:54:21,590
虽然人们开发出了各种花哨的算法，但归根结底，视频可能只是一连串的图像而已。

2607
00:54:21,590 --> 00:54:30,978
反过来说，如果你想表现伴奏音乐或其他东西，如果你们中有人会演奏乐器并能读懂乐谱，你如何将其数字化？

2609
00:54:31,520 --> 00:54:35,330
比如，如何在计算机中表现音符？

2610
00:54:35,330 --> 00:54:41,210
你和我在播放文件时都能听到它们的声音，但引擎盖下到底发生了什么？

2611
00:54:41,210 --> 00:54:44,760
有音乐家、钢琴演奏家吗？

2614
00:54:45,760 --> 00:54:47,150
听众：赫兹值？

2615
00:54:47,150 --> 00:54:49,590
大卫-J-马兰：好的，那么赫兹值，即某种频率。

2616
00:54:49,590 --> 00:54:52,528
因此，声音是一种频率，它会撞击你的耳膜。

2617
00:54:52,528 --> 00:54:55,320
这就是声音低沉、高亢或介于两者之间的原因。

2618
00:54:55,320 --> 00:55:00,771
因此，也许我们可以分配，就像这里的字母 A 到 G 一样，也许我们可以分配特定的频率值，这些频率值将是以某种方式测量的数字

2619
00:55:00,771 --> 00:55:04,010
这些都是以赫兹为单位的数字，即每秒。

2620
00:55:04,010 --> 00:55:08,780
也许我们还可以为每个音符添加一些其他数字，而不仅仅是音符或频率。

2621
00:55:08,780 --> 00:55:14,900
也许，我们可以表示它的响度，比如人类按压它的力度或轻重。

2622
00:55:14,900 --> 00:55:19,380
也许第三个数字，比如持续时间，比如手指在键盘上停留了多久？

2623
00:55:19,380 --> 00:55:29,450
因此，你可以想象把音乐这种在现实世界中完全连续的东西量化为更离散的东西，把每个音符在一段时间内表示为一些数值序列。

2624
00:55:29,450 --> 00:55:34,680
有很多不同的方式可以做到这一点，MIDI、mp3、AAC。

2625
00:55:34,680 --> 00:55:45,290
你在 Mac 或 PC 上看到的几乎所有文件扩展名（如果你看到它们的话），归根结底只是表示一种不同的表示形式，在这种情况下，就像声音一样。

2626
00:55:45,290 --> 00:55:53,300
因此，我只想说，有这些方法，还有更多的方法来表示输入和输出，值得庆幸的是，人类已经在很多方面实现了标准化。

2627
00:55:53,300 --> 00:56:02,100
它们并不总是一致的，这就是为什么苹果数字、微软 Excel 和谷歌电子表格有不同的文件格式，以及不兼容的原因。

2628
00:56:02,100 --> 00:56:07,670
但总的来说，人类已经将如何表示问题的输入和输出标准化了。

2629
00:56:07,670 --> 00:56:12,590
但是，现在让我们把注意力集中在中间的这个黑盒子上，也就是这个抽象的东西。

2630
00:56:12,590 --> 00:56:18,695
因此，从技术上讲，抽象是一个在计算机科学中随处可见的术语，而实际上，问题解决也是如此。

2631
00:56:18,695 --> 00:56:25,310
这只是指简化某些东西，使你不必关注低层次的实现细节。

2632
00:56:25,310 --> 00:56:29,880
你只需关注高层次目标或过程本身。

2633
00:56:29,880 --> 00:56:36,830
因此，如果你有驾照、开过车或坐过车，那么你的车，就你而言，很可能是一个抽象概念。

2634
00:56:36,830 --> 00:56:42,290
如果你和我一样，大多数人可能并不真正了解或关心发动机的工作原理和所有运动部件。

2635
00:56:42,290 --> 00:56:50,510
对你来说，它只是一种从 A 点到 B 点的方式。它是一种抽象概念，但有人（希望是机械师）确实知道这些低层次的实现细节。

2636
00:56:50,510 --> 00:56:56,700
如果你每次上学或去商店都要了解汽车的工作原理，那可能会是一个相当缓慢的过程。

2637
00:56:56,700 --> 00:57:04,350
我们只是想在更高的抽象层次上进行思考和操作，而在编写代码和解决问题时，我们会一直这样做。

2638
00:57:04,350 --> 00:57:07,940
那么，在这个黑盒子里，在这个抽象的概念里，究竟有什么呢？

2639
00:57:07,940 --> 00:57:14,180
一般来说，计算机科学家会称之为算法，即解决某个问题的分步指令。

2640
00:57:14,180 --> 00:57:24,230
现在，让我们来考虑实施细节，也就是如何解决某些问题，让我们举一个老式但现代的例子。

2641
00:57:24,230 --> 00:57:27,970
如果你有 iPhone，这个图标当然就是通讯录应用程序。

2642
00:57:27,970 --> 00:57:36,800
如果你的电话簿里有一大堆家人、朋友或同事，你就会在这里看到一些联系人的照片，这些照片通常按名字和姓氏的字母顺序排列。

2643
00:57:36,800 --> 00:57:42,950
你我都有点击 "搜索 "然后使用自动完成的习惯，如果它们还不是你的最爱的话。

2644
00:57:42,950 --> 00:57:45,140
当你开始输入自动完成时会发生什么？

2645
00:57:45,140 --> 00:57:48,710
嗯，如果你输入字母 H，你会看到只有，大概是这样、

2646
00:57:48,710 --> 00:57:50,640
海格、哈利、赫敏等等。

2647
00:57:50,640 --> 00:57:56,280
如果输入 H-A，则只显示海格和哈利，而且速度超快。

2648
00:57:56,280 --> 00:57:57,720
这是怎么回事呢？

2649
00:57:57,720 --> 00:58:07,490
通常情况下，你可以从顶部开始，一直到底部，搜索所有的 H 或所有的 H-A，但对于较大的数据集来说，这样做会很慢。

2650
00:58:07,490 --> 00:58:10,130
对于世界上的谷歌来说，这将变得非常缓慢。

2651
00:58:10,130 --> 00:58:18,300
即使在我们的手机上，当你有成百上千个联系人时，最终，即使是这种方法，这种算法一步一步来，也可能会很慢。

2652
00:58:18,300 --> 00:58:24,230
那么，我们该如何在这样的电话簿中搜索某个人，比如约翰-哈佛？

2653
00:58:24,230 --> 00:58:30,910
这就是它的老式化身，而如今，你可能连实际使用它的机会都没有了。

2654
00:58:30,910 --> 00:58:36,950
事实上，这有点像是在撒一个弥天大谎，因为这是黄页，这意味着这是一本关于公司而不是人的书。

2655
00:58:36,950 --> 00:58:40,370
但你只能找到这些，甚至连这些都很难找到。

2656
00:58:40,370 --> 00:58:43,770
但这与模拟形式、物理形式是一样的。

2657
00:58:43,770 --> 00:58:47,310
那么，如果我想搜索像约翰-哈佛这样的人，该怎么做呢？

2658
00:58:47,310 --> 00:58:55,345
好吧，我可以从第 1 页开始，然后开始搜索第 2 页、第 3 页、第 4 页、第 5 页。

2659
00:58:55,345 --> 00:58:59,345
要做到这一点有点困难，尤其是这本电话簿已经很多年没人用了。

2660
00:58:59,345 --> 00:59:06,260
但是，这种算法是否正确，一页一页地翻，非常不优雅？

2661
00:59:06,260 --> 00:59:06,980
这样做对吗？

2662
00:59:06,980 --> 00:59:09,690
如果约翰-哈佛在这里，我能找到他吗？

2665
00:59:11,030 --> 00:59:16,870
这有点愚蠢地乏味，因为如果有 1000 页的话，他可能只读了几百页，但这是正确的。

2666
00:59:16,870 --> 00:59:20,120
总有一天，我会找到他，如果他在页面上，我就能打电话给他。

2668
00:59:20,620 --> 00:59:24,608
因为据推测，这里的名字都是按字母顺序排列的，边上也没有小抄。

2669
00:59:24,608 --> 00:59:29,150
因此，如果按姓氏字母顺序排列，我必须从左到右搜索约翰-哈佛，搜索 H。

2670
00:59:29,150 --> 00:59:30,740
那么，什么会稍微好一点呢？

2671
00:59:30,740 --> 00:59:32,240
那么，一次翻两页如何？

2672
00:59:32,240 --> 00:59:41,150
一本有 20 年历史的电话簿很难做到这一点，因为电话簿的每一页都是长在一起的，但 2、4、6、8、10、12 页都有。

2673
00:59:41,150 --> 00:59:42,605
这种算法，对吗？

2674
00:59:42,605 --> 00:59:43,465
AUDIENCE：No.

2675
00:59:43,465 --> 00:59:44,150
戴维-J-马兰：好吧，所以没有。

2677
00:59:44,780 --> 00:59:46,280
你在跳页你在跳页

2678
00:59:46,280 --> 00:59:46,610
是的。

2679
00:59:46,610 --> 00:59:48,060
所以我每隔一页都会跳过。

2680
00:59:48,060 --> 00:59:56,120
因此，如果我不考虑这一点，而我发现自己在 I 区或 J 区，那么我可能会意外地得出结论、

2681
00:59:56,120 --> 01:00:01,130
不，我还没有找到约翰-哈佛，只是因为我跳过了他，因为它夹在两页纸中间。

2682
01:00:01,130 --> 01:00:08,100
现在，我可以解决这个问题，我想，如果我点击了 I 部分，好吧，让我再往回翻一页，以防他在最后一页。

2683
01:00:08,100 --> 01:00:12,277
因此，它是可以恢复的，但除去刚才的小插曲，速度几乎快了一倍。

2684
01:00:12,277 --> 01:00:18,020
但我们大多数人都会这么做，而你们的手机也是这么做的，尽管是以数字方式，但它们会大致打开电话簿的中间部分。

2685
01:00:18,020 --> 01:00:21,747
他们低头一看，说，哦，我大概在 M 区。

2686
01:00:21,747 --> 01:00:24,080
因此，1000 页的电话簿我大概看了一半。

2687
01:00:24,080 --> 01:00:26,510
但我现在对约翰-哈佛了解多少呢？

2688
01:00:26,510 --> 01:00:29,820
他在哪里，在我左边还是右边？

2690
01:00:30,320 --> 01:00:39,950
因此，按字母顺序，他应该在我的左边，所以在这里，我可以用比喻和实际的方式，把问题撕成两半。

2691
01:00:39,950 --> 01:00:41,330
你不需要留下深刻印象。

2692
01:00:41,330 --> 01:00:46,460
沿着脊柱往下走很容易，但我知道约翰-哈佛就在左边。

2693
01:00:46,460 --> 01:00:53,810
但现在，我可以不必要地戏剧性地把第一页的一半扔掉，我现在知道了什么？

2694
01:00:53,810 --> 01:00:55,910
我已经从 1000 页减少到 500 页左右。

2695
01:00:55,910 --> 01:00:57,602
我可以重复大致相同的算法。

2696
01:00:57,602 --> 01:01:00,560
所以这次，我回得有点远了。

2697
01:01:00,560 --> 01:01:03,150
我现在在 E 区。

2698
01:01:03,150 --> 01:01:04,040
我知道什么？

2699
01:01:04,040 --> 01:01:07,490
约翰-哈佛在我左边还是右边？

2700
01:01:07,490 --> 01:01:09,950
在我的右边，这样我又可以把问题分成两半。

2701
01:01:09,950 --> 01:01:12,800
扔掉这一半，现在我真的要飞了。

2702
01:01:12,800 --> 01:01:18,380
我正在慢慢地口述，但从 1000 页到 500 页，再到现在的 250 页。

2703
01:01:18,380 --> 01:01:20,960
现在，我又可以这样做了，125。

2704
01:01:20,960 --> 01:01:32,210
我再做一次，大概像 67 次一样，不断重复，直到我希望只剩下一页纸，或者在这种情况下，具有讽刺意味的是，只剩下一个机械师的广告。

2705
01:01:32,210 --> 01:01:36,620
那么，这对我们的业绩有什么影响呢？

2706
01:01:36,620 --> 01:01:44,340
好吧，让我们抽象一下，如果第一种算法是快速绘制在一张没有偶数的图表上。

2707
01:01:44,340 --> 01:01:47,340
这是我的 X 轴，问题的大小在 X 轴上。

2708
01:01:47,340 --> 01:01:49,760
因此，问题越大，就越往那边走。

2709
01:01:49,760 --> 01:01:51,200
是时候解决问题了。

2710
01:01:51,200 --> 01:01:55,530
在 y 轴上越往上，解决问题所需的时间就越长。

2711
01:01:55,530 --> 01:01:59,850
我们如何得出运行时间，即运行第一个算法所需的时间？

2712
01:01:59,850 --> 01:02:01,010
嗯，这将是一条直线。

2714
01:02:01,520 --> 01:02:09,790
因为如果明年因为更多的人搬到剑桥而增加一个页面，你就可能增加一个页面的翻转，所以就多了一秒钟，多了一个时间单位。

2715
01:02:09,790 --> 01:02:10,790
所以这是一条直线。

2716
01:02:10,790 --> 01:02:12,207
我们将其抽象为 "n"。

2717
01:02:12,207 --> 01:02:16,640
如果电话簿有 n 页，那么这条直线的斜率基本上就是 n。

2718
01:02:16,640 --> 01:02:22,970
第二种算法，我一次做两页，速度快了一倍，但仍然是直线。

2719
01:02:22,970 --> 01:02:25,190
事实上，让我在这里画一些虚线。

2720
01:02:25,190 --> 01:02:32,990
如果电话簿有这么大，按照我的第一种算法，可能需要这么多时间单位、这么多步骤、这么多翻页。

2721
01:02:32,990 --> 01:02:39,260
但使用第二种算法时，请注意黄线上的交叉点比红线上的交叉点要低得多。

2722
01:02:39,260 --> 01:02:43,517
如果 n 是页数，那么 n 大于 2 就意味着这里有一半的页数。

2723
01:02:43,517 --> 01:02:49,530
因此，事实上，第二种算法的速度是前者的两倍，只是少了一个小插曲，那就是我必须向后翻两页。

2724
01:02:49,530 --> 01:02:53,000
不过，如果我做事情的速度仍然比别人快一倍，那也没什么大不了的。

2725
01:02:53,000 --> 01:02:55,340
但是，第三种算法看起来根本不同。

2726
01:02:55,340 --> 01:02:56,300
看起来是这样的

2727
01:02:56,300 --> 01:03:00,320
对数，如果你还记得高中或高中以前的内容--如果你不记得，也没关系。

2728
01:03:00,320 --> 01:03:03,900
只是功能和形状从根本上不同而已。

2729
01:03:03,900 --> 01:03:11,720
请注意，绿线在不断上升，但上升速度要慢得多，这意味着疯狂的事情是有可能发生的。

2730
01:03:11,720 --> 01:03:20,890
如果马萨诸塞州的两个小镇，比如河对岸的剑桥和阿尔斯顿明年合并，那么就电话簿而言，它们的电话簿就变大了一倍。

2731
01:03:20,890 --> 01:03:24,550
对于第一种算法，我需要花两倍的时间来完成。

2732
01:03:24,550 --> 01:03:29,780
第二种算法，差不多要多花 50%的步骤，一次两步。

2733
01:03:29,780 --> 01:03:38,650
但第三种算法，也就是我最后的算法，一次又一次地撕裂事物，一次又一次地分割和征服，如果你愿意，一半又一半，一半又一半，我的第三种算法还要走多少步呢

2734
01:03:38,650 --> 01:03:42,965
如果剑桥和阿尔斯顿合并成一个两倍大的电话簿，会怎么样？

2735
01:03:42,965 --> 01:03:43,840
听众：四个步骤

2736
01:03:43,840 --> 01:03:45,590
就差一步了，对吧？

2737
01:03:45,590 --> 01:03:46,160
没什么大不了的。

2738
01:03:46,160 --> 01:03:50,960
一旦你决定约翰-哈佛是在左边还是右边，你就会在这个问题上大做文章。

2739
01:03:50,960 --> 01:03:53,470
这样，你的进步就更快了。

2740
01:03:53,470 --> 01:04:04,090
因此，从本质上讲，这就是你的电脑、手机在搜索哈利、赫敏、海格或其他任何人时，在引擎盖下所做的事情，因为它快得多、

2741
01:04:04,090 --> 01:04:05,590
尤其是在数据量较大的情况下。

2742
01:04:05,590 --> 01:04:13,360
如果你没有那么多联系人，那么采用这种分而治之的算法，从上到下搜索或更多地搜索可能并不重要。

2743
01:04:13,360 --> 01:04:18,920
但是，如果你是世界上的谷歌公司，或者你正在分析大型数据集，那么这些数据的确会很快增加。

2744
01:04:18,920 --> 01:04:20,420
我们该何去何从？

2745
01:04:20,420 --> 01:04:23,140
接下来，我们要介绍一种叫做伪代码的东西。

2746
01:04:23,140 --> 01:04:27,673
我怎样才能将口头上的直觉转化为实际代码？

2747
01:04:27,673 --> 01:04:28,840
好吧，这不会是 "划痕"。

2748
01:04:28,840 --> 01:04:30,830
这还不是 C 语言或 Python 语言。

2749
01:04:30,830 --> 01:04:32,840
这只是一种类似英语的语法。

2750
01:04:32,840 --> 01:04:35,530
许多程序员就是这样开始解决问题的。

2751
01:04:35,530 --> 01:04:38,763
他们不会开始用 C、Python 或类似的语言输入代码。

2752
01:04:38,763 --> 01:04:43,210
他们用英语或其他人类语言记下自己的想法大纲。

2753
01:04:43,210 --> 01:04:45,700
其实，我的第一步就是拿起电话簿。

2754
01:04:45,700 --> 01:04:48,790
我的第二步是打开电话簿的中间部分。

2755
01:04:48,790 --> 01:04:52,570
我的第三步有些不同--看页面，因为为什么？

2756
01:04:52,570 --> 01:04:57,670
我的第四步是，如果我要找的人出现在页面上，我应该怎么做？

2757
01:04:57,670 --> 01:05:00,820
在我的例子中，这种情况从未发生过，但我还是给对方打了电话。

2758
01:05:00,820 --> 01:05:01,960
所以我不干了。

2759
01:05:01,960 --> 01:05:08,830
否则，如果该人在书中按字母顺序排列较前，如我的 H 是约翰-哈佛，那么

2760
01:05:08,830 --> 01:05:12,460
我应该在电话簿左边中间的位置搜索。

2761
01:05:12,460 --> 01:05:15,800
然后我应该回到第三步。

2762
01:05:15,800 --> 01:05:19,540
第三步是查看页面，从而不断重复相同的过程。

2763
01:05:19,540 --> 01:05:29,050
不过，第 9 步可能是别的，如果这个人在书的后半部分，那么让我们继续翻到书的右半部分中间，然后回到第 3 行。

2764
01:05:29,050 --> 01:05:37,750
除此之外，我们或许还应该考虑第四种情况，以免我的搜索过程冻结或崩溃，或者给我一个带着错误的旋转沙滩球。

2767
01:05:39,580 --> 01:05:41,620
如果电话簿上没有约翰-哈佛呢？

2768
01:05:41,620 --> 01:05:44,438
我希望我的算法、我的手机不会重启或冻结。

2769
01:05:44,438 --> 01:05:46,480
我应该用某种一网打尽的方法来处理这个问题。

2770
01:05:46,480 --> 01:05:49,420
否则，可以说，我们就退出这个项目吧。

2771
01:05:49,420 --> 01:05:54,340
因此，这四种可能出现的情况都有明确定义的行为。

2772
01:05:54,340 --> 01:05:56,470
现在，让我们来指出其中几个突出的术语。

2773
01:05:56,470 --> 01:06:00,620
事实证明，如果我在这里用黄色高亮显示，我在这里所做的事情是有规律可循的。

2774
01:06:00,620 --> 01:06:02,050
这些是我所有的英语动词。

2775
01:06:02,050 --> 01:06:05,410
稍后，我们将开始把这些动词称为 "功能"。

2776
01:06:05,410 --> 01:06:14,020
当你编程或写代码时，你希望程序或计算机为你做一些事情，一些动作或动词，我们将提及这些动作或动词

2777
01:06:14,020 --> 01:06:16,510
就像这里所说的 "功能 "一样。

2778
01:06:16,510 --> 01:06:20,950
相比之下，我只是突出了我的 "如果"、"其他如果"、"其他如果 "和 "其他"。

2779
01:06:20,950 --> 01:06:29,860
这将代表我们开始称之为 "条件 "的东西，也就是俗话说的岔路口，在这里你要么走这条路，要么走那条路，要么做这件事，要么做另一件事。

2780
01:06:29,860 --> 01:06:38,230
你要根据我现在强调的内容来决定做哪些事情，这些内容将被称为 "布尔表达式"。

2781
01:06:38,230 --> 01:06:41,260
布尔，指一位数学家，姓布尔。

2782
01:06:41,260 --> 01:06:47,980
布尔表达式只是一个问题，有 "是"/"否"、"真"/"假"、"1 "或 "0 "等答案。

2783
01:06:47,980 --> 01:06:51,790
它决定着你是做这件事，还是做这件事，还是做这件事，还是做那件事。

2784
01:06:51,790 --> 01:06:54,440
在这种情况下，缩进是很重要的。

2785
01:06:54,440 --> 01:07:06,410
我缩进第 5 行这一事实意味着，按照程序设计的惯例，只有当第 4 行的答案是 "是 "或 "true "时，我才应该执行第 5 行，其他缩进的行也是如此。

2786
01:07:06,410 --> 01:07:09,492
最后一个特点就是这里。

2787
01:07:09,492 --> 01:07:11,200
事实上，早些时候就有人指出了这一点。

2788
01:07:11,200 --> 01:07:15,580
现在突出显示这两行，即第 8 行和第 11 行，它们代表什么？

2789
01:07:15,580 --> 01:07:24,820
如果你已经做了--是的，这些是循环，是我反复做同样事情的某种循环、

2790
01:07:24,820 --> 01:07:28,240
但在伪代码中，这种算法有一个关键细节。

2791
01:07:28,240 --> 01:07:34,750
虽然它告诉我回到第 3 行，但为什么这种算法最终会停止呢？

2792
01:07:34,750 --> 01:07:43,010
为什么我不会因为这些循环告诉我继续回到第 3 行而永远不停地寻找约翰-哈佛呢？

2794
01:07:43,580 --> 01:07:51,260
最后，他会出现在页面上，或者，就像你刚才说的，他根本不会出现，我们就没有页面了，所以我们就放弃了。

2795
01:07:51,260 --> 01:07:54,050
这就是去左半边还是右半边的关键所在。

2796
01:07:54,050 --> 01:07:56,430
重复做同样的事情并不重要。

2797
01:07:56,430 --> 01:08:03,890
只要你不断分割问题，把它缩小、缩小、再缩小，你就不会陷入所谓的无限循环。

2798
01:08:03,890 --> 01:08:06,570
最终，就没有问题可以解决了。

2799
01:08:06,570 --> 01:08:11,479
因此，即使你不认为自己是计算机人才，即使你从未编写过代码

2800
01:08:11,479 --> 01:08:18,080
在接下来的日子里，你会发现我们从现实生活中汲取的这些想法已经触手可及。

2801
01:08:18,080 --> 01:08:25,880
在学习代码的过程中，很多时候都会遇到一些磕磕绊绊，因为你无法以熟悉的方式来看待新语法。

2802
01:08:25,880 --> 01:08:30,380
但你会发现，这些想法其实比你想象的要熟悉得多。

2803
01:08:30,380 --> 01:08:38,240
稍后我们将看到--稍后我们将休息片刻，喘口气--你将在 Scratch 的背景下看到这些相同的想法、

2804
01:08:38,240 --> 01:08:42,743
这是一种实际的编程语言，我们可以通过拖放拼图来编写实际的代码。

2805
01:08:42,743 --> 01:08:47,040
我们会看到这些想法的一些变体，即所谓的 "参数"、"返回值 "和 "变量"。

2806
01:08:47,040 --> 01:08:50,660
但我们最终会以某种方式将其转换成这个。

2807
01:08:50,660 --> 01:08:56,810
有人想打赌，如果把这个程序输入到 Mac、PC 或手机中，它能做什么吗？

2808
01:08:56,810 --> 01:08:59,975
这里只有大量的 0 和 1。

2810
01:09:01,200 --> 01:09:05,370
它确实会说 "你好，世界"，但显然令人失望。

2811
01:09:05,370 --> 01:09:15,750
事实上，在所有这些 0 和 1 中，不仅有 H-E-L-L-O，还有动词，即把东西打印到屏幕上的动作。

2812
01:09:15,750 --> 01:09:23,870
还有其他一些东西，让程序知道如何启动，如何停止，很多东西我们都不用担心，这些都是设计计算机或语言的人做的。

2813
01:09:23,870 --> 01:09:31,319
但归根结底，你们永远不会自己写 0 和 1，尽管我们的祖先曾经以某种形式写过。

2814
01:09:31,319 --> 01:09:39,189
我们将使用更高级的语言，就像这样用 C 语言，或者更好的是，一会儿就用 Scratch，就像这样。

2815
01:09:39,189 --> 01:09:45,812
事实上，这也是我们今天关注并开始学习 Scratch 这种图形编程语言的原因。

2816
01:09:45,812 --> 01:09:49,937
因此，我们可以用函数、条件式、循环等方法来表达自己的意思

2817
01:09:49,937 --> 01:09:57,720
但这种方式没有愚蠢的括号和大括号，也没有这些视觉干扰，因此可以将其翻译成这种低级语言。

2818
01:09:57,720 --> 01:09:59,027
但现在，这已经够多了。

2819
01:09:59,027 --> 01:10:03,365
那绝对是消防水龙头我们先休息十分钟。请随意起身或留在这里。

2820
01:10:03,365 --> 01:10:06,755
稍后我们将继续学习一些实际代码。

2824
01:10:35,505 --> 01:10:36,130
- 嗨

2826
01:10:37,000 --> 01:10:41,491
我们是 "天气女郎"，有消息要告诉你。

2827
01:10:41,491 --> 01:10:42,485
你最好听着

2828
01:10:42,485 --> 01:10:45,540
准备好了，所有寂寞的姑娘们。

2829
01:10:45,540 --> 01:10:47,940
把雨伞留在家里。

2831
01:10:49,217 --> 01:10:51,140
湿度正在上升。

2832
01:10:51,140 --> 01:10:52,912
嗯，上升。

2833
01:10:52,912 --> 01:10:54,460
气压越来越低了

2834
01:10:54,460 --> 01:10:56,034
有多低？

2835
01:10:56,034 --> 01:11:01,600
根据所有的消息来源 -- 什么消息来源, 现在 -- 街道才是该去的地方。

2836
01:11:01,600 --> 01:11:02,880
我们最好快点。

2837
01:11:02,880 --> 01:11:18,100
今晚十点半左右 历史上第一次 下起了男人雨 下起了男人雨

2838
01:11:18,100 --> 01:11:21,650
下雨了，哈利路亚！

2839
01:11:21,650 --> 01:11:25,780
下雨了，男人们，阿门！

2840
01:11:25,780 --> 01:11:27,505
我要出去了

2841
01:11:27,505 --> 01:11:33,920
我要让自己全身湿透！

2842
01:11:33,920 --> 01:11:37,045
下雨了，哈利路亚！

2843
01:11:37,045 --> 01:11:38,795
好吧，那么 --

2846
01:11:43,720 --> 01:11:49,312
这就是我们麻省理工学院媒体实验室的朋友们推出的图形编程语言 Scratch

2847
01:11:49,312 --> 01:11:58,630
事实上，你们中的一些人可能在小学或类似的学校里用过这些工具，用来玩游戏、写代码等，但你们可能并不一定想过这些原语最终是如何工作的。

2848
01:11:58,630 --> 01:12:07,120
事实上，你所做的一切--如果你以前用过 Scratch--以及你今天看到的一切，都将适用于接下来的几周，因为我们将探索这些被称为 "函数 "的东西

2849
01:12:07,120 --> 01:12:09,820
循环"、"条件"、"布尔表达式 "等等。

2850
01:12:09,820 --> 01:12:17,860
有了 Scratch，因为它的图形和动画非常协调，你就能制作出像这样的动画、互动艺术和更一般的软件。

2851
01:12:17,860 --> 01:12:23,990
不过，您需要通过拖放拼图块来实现，只有在符合逻辑的情况下，拼图块才能锁定在一起。

2852
01:12:23,990 --> 01:12:33,460
在第一周的课程中，你将不必处理大括号、小括号，以及所有你可能还记得的奇怪符号，而我们只想说 "你好，世界"。

2853
01:12:33,460 --> 01:12:41,860
现在，这个特殊的节目 "下雨的男人 "是由前 CS50 教学研究员安德鲁-贝里（Andrew Berry）撰写的，他现在实际上是克利夫兰的总经理。

2854
01:12:41,860 --> 01:12:43,730
布朗队，美国橄榄球队。

2855
01:12:43,730 --> 01:12:48,400
因此，这些只是你们班上一些前辈创建的一些项目。

2856
01:12:48,400 --> 01:12:56,170
在这堂课的剩余时间里，你还会看到其他几个问题，更多的是在课程的第一个作业，即问题集 0 中。

2857
01:12:56,170 --> 01:12:57,470
那么，我们如何到达那里呢？

2858
01:12:57,470 --> 01:13:00,040
好吧，先简单介绍一下我们要做的事情。

2859
01:13:00,040 --> 01:13:03,523
在 Scratch 中，这也许是你能编写的最简单的程序。

2860
01:13:03,523 --> 01:13:09,970
即使你以前从未见过 Scratch 或任何编程语言，你可能也能猜到这只是在屏幕上以某种方式 "说 "出来的、

2861
01:13:09,970 --> 01:13:10,940
"你好，世界"

2862
01:13:10,940 --> 01:13:16,720
但你不必输入深奥的命令和奇怪的语法，也就是我一直提到的大括号和小括号。

2863
01:13:16,720 --> 01:13:18,970
你只需拖动这块黄色拼图。

2864
01:13:18,970 --> 01:13:20,530
你拖动这块紫色拼图。

2865
01:13:20,530 --> 01:13:22,810
可以说，让它们磁性地锁在一起。

2866
01:13:22,810 --> 01:13:24,430
点击按钮，"砰 "的一声。

2867
01:13:24,430 --> 01:13:31,010
有了这些积木和其他一些积木，你还能做出安德鲁栩栩如生的东西吗？

2868
01:13:31,010 --> 01:13:32,740
下面我们就来看看。

2869
01:13:32,740 --> 01:13:38,500
Scratch.MIT.edu 是麻省理工学院服务器上的云编程环境。

2870
01:13:38,500 --> 01:13:41,380
您还可以在自己的 Mac 或 PC 上离线下载。

2871
01:13:41,380 --> 01:13:43,870
它会给你一个这样的界面。

2872
01:13:43,870 --> 01:13:47,770
在屏幕左侧，你会看到一个区块调色板。

2873
01:13:47,770 --> 01:13:52,540
这些拼图（又称积木）有不同的颜色，这也是对它们的分类。

2874
01:13:52,540 --> 01:13:57,040
例如，图中蓝色部分就是一大堆与运动相关的图块。

2875
01:13:57,040 --> 01:14:05,110
于是，安德鲁用了一大堆这样的道具，让歌手和男主角在屏幕上随着背景音乐同步移动。

2876
01:14:05,110 --> 01:14:09,310
同时，这个界面的中间将是代码区。

2877
01:14:09,310 --> 01:14:14,729
在这里，安德鲁和你将拖放一些拼图块和其他颜色。

2878
01:14:14,729 --> 01:14:20,110
并将它们锁定在一起，让你的角色--即将被发明出来的角色--在屏幕上做一些事情。

2879
01:14:20,110 --> 01:14:29,650
事实上，在右下方，你会看到一个精灵区域，精灵是一个专业术语，指视频游戏或类似编程环境中的角色。

2880
01:14:29,650 --> 01:14:36,020
默认情况下，Scratch 是这个编程环境的吉祥物。

2881
01:14:36,020 --> 01:14:42,490
默认情况下，这里只选择了一个精灵，因为屏幕右上方就是该精灵的舞台。

2882
01:14:42,490 --> 01:14:45,310
您还可以点击并放大，使其全屏显示。

2883
01:14:45,310 --> 01:14:49,120
但这就是 Scratch（默认为猫咪）将要生活的世界。

2884
01:14:49,120 --> 01:14:55,854
但你可以改变斯克雷奇的服装，让它看起来像一个歌手，或者像一个从天而降的人，或者像其他任何东西。

2885
01:14:55,854 --> 01:15:00,260
你可以自己创作，也可以从网上或其他地方引进一些艺术品。

2886
01:15:00,260 --> 01:15:03,640
那么，Scratch 所处的世界究竟是怎样的呢？

2887
01:15:03,640 --> 01:15:08,646
一般来说，我们不必太在意数字，因为我们可以提出问题

2888
01:15:08,646 --> 01:15:15,520
比如交互式的，比如 "抓猫 "或其他任何角色是否触碰到了屏幕边缘，是否触碰到了其他东西？

2889
01:15:15,520 --> 01:15:21,080
但 Scratch 确实存在于这个二维坐标系世界中。

2890
01:15:21,080 --> 01:15:27,700
因此，当猫或任何角色处于中间位置时，就是 xy 位置 0,0。

2891
01:15:27,700 --> 01:15:32,990
同时，这里是 240 像素，也就是点，一直向右。

2892
01:15:32,990 --> 01:15:37,700
因此，这将是 240,0，其中 y 为 0，因为它正好位于中线上。

2893
01:15:37,700 --> 01:15:39,460
因此，它既不是向上的，也不是向下的。

2894
01:15:39,460 --> 01:15:43,330
当然，左边是 -240 和 0。

2895
01:15:43,330 --> 01:15:48,880
在猫的上方，x 等于 0，因为它正好在垂直中线上，然后是 180。

2896
01:15:48,880 --> 01:15:52,152
然后往下，你可能会猜到，这里是 0，负 180。

2897
01:15:52,152 --> 01:15:55,733
一般来说，我们不必在意这些精确的像素坐标。

2898
01:15:55,733 --> 01:15:59,400
不过，如果你真的想让猫向上、向下、向左或向右移动，它最终还是有帮助的。

2899
01:15:59,400 --> 01:16:06,010
根据 x 轴和 y 轴来确定方向，最终也能帮助你表达自己的想法。

2900
01:16:06,010 --> 01:16:08,680
那么，这些想法可能是什么呢？

2901
01:16:08,680 --> 01:16:09,950
好吧，就这么办。

2902
01:16:09,950 --> 01:16:18,293
我要在 Scratch.MIT.edu 上创建一个像这样的空屏幕。

2903
01:16:18,293 --> 01:16:19,960
因此，这是完全相同的界面。

2904
01:16:19,960 --> 01:16:24,490
但现在我在浏览器中，全屏显示，这样我就可以开始写代码了。

2905
01:16:24,490 --> 01:16:27,222
让那只猫在屏幕上说点什么吧。

2906
01:16:27,222 --> 01:16:28,930
现在，这需要一点练习。

2907
01:16:28,930 --> 01:16:36,538
但老实说，只要浏览一下这些拼图，你就能很快了解到什么是可能的，不仅是分类的，而且是具体的。

2908
01:16:36,538 --> 01:16:39,163
我会跳来跳去，因为我以前当然也这么干过。

2909
01:16:39,163 --> 01:16:41,410
但我要先去参加黄色的活动。

2910
01:16:41,410 --> 01:16:45,475
我要拖放第一个图块，名为 "点击绿旗"。

2911
01:16:45,475 --> 01:16:48,100
我放大了那里，只是为了让它更清晰一点。

2912
01:16:48,100 --> 01:16:57,070
请注意，这面绿旗的形状恰好与顶部的绿旗相呼应，旁边是红色的 "停车标志"。

2913
01:16:57,070 --> 01:17:02,320
绿旗表示开始，红色停止标志表示停止，即开始或停止我们的项目。

2914
01:17:02,320 --> 01:17:06,560
下周，你将在键盘上编写一个文本命令来实现完全相同的想法。

2915
01:17:06,560 --> 01:17:07,790
但现在，它只是一个按钮。

2916
01:17:07,790 --> 01:17:10,667
那么，当点击 "绿旗 "时，我想让 Scratch 做什么呢？

2917
01:17:10,667 --> 01:17:18,790
那么，不如让 Scratch 一开始就说 "Hello, world"（你好，世界）这样的话，从历史上看，这的确是大多数程序员可能写的第一个程序。

2918
01:17:18,790 --> 01:17:24,490
因此，任何与猫看起来正在做的事情有关的内容，实际上都会被放在 "看起来 "下面，这里用紫色表示。

2919
01:17:24,490 --> 01:17:27,100
所以我要拖过来 说 "你好"

2920
01:17:27,100 --> 01:17:30,820
你会发现这个紫色块有些奇特和与众不同。

2921
01:17:30,820 --> 01:17:33,400
当然，上面用紫色写着 "说"。

2922
01:17:33,400 --> 01:17:40,810
但是，这里有一个白色椭圆和一些文字，默认情况下是 "hello"，因为 MIT 刚刚决定，默认情况下，占位符将是 "hello"。

2923
01:17:40,810 --> 01:17:48,790
但只要你看到这个白色椭圆，就有机会为 "说 "功能提供输入。

2924
01:17:48,790 --> 01:17:50,980
在这里，我借用了之前的术语。

2925
01:17:50,980 --> 01:17:54,280
同样，解决问题的关键在于投入产出。

2926
01:17:54,280 --> 01:17:56,045
在这两者之间，还有一些算法。

2927
01:17:56,045 --> 01:18:00,470
稍后，我们将开始频繁地把算法称为 "函数"。

2929
01:18:00,970 --> 01:18:03,350
因为它是某种算法的实现。

2930
01:18:03,350 --> 01:18:06,640
因此，让我用 "你好，世界 "覆盖默认设置。

2931
01:18:06,640 --> 01:18:07,690
我会放大。

2932
01:18:07,690 --> 01:18:15,310
现在，如果我转到屏幕右上方，点击 "绿旗"，我们就能看到我的第一个程序代码了。

2933
01:18:15,310 --> 01:18:17,190
现在，这不是一个巨大的提升，对吗？

2934
01:18:17,190 --> 01:18:19,690
只需拖放拼图块即可。

2935
01:18:19,690 --> 01:18:21,070
但现在发生了什么呢？

2936
01:18:21,070 --> 01:18:23,530
事实证明，有两件事发生了。

2937
01:18:23,530 --> 01:18:26,710
当我这个人类点击绿旗时、

2938
01:18:26,710 --> 01:18:29,570
我触发了，我们现在开始称之为 "事件 "的东西。

2939
01:18:29,570 --> 01:18:34,580
事件通常是计算机程序中发生的图形或交互式事件。

2940
01:18:34,580 --> 01:18:37,600
你我整天都在用手机触发事件。

2941
01:18:37,600 --> 01:18:45,460
每当你轻点、拖动、长按或捏住手机或任何时下手机上流行的手势时，都会触发事件。

2942
01:18:45,460 --> 01:18:52,880
苹果、谷歌和其他公司的员工编写的代码可以监听这些事件，并在事件发生时采取相应措施。

2943
01:18:52,880 --> 01:18:54,010
我就是这么做的。

2944
01:18:54,010 --> 01:19:01,150
当点击 "绿旗 "时，我希望发生一些事情，即我希望这个紫色函数、这个动词、这个动作叫做

2945
01:19:01,150 --> 01:19:02,910
说，做某事。

2946
01:19:02,910 --> 01:19:03,910
我想让它做什么？

2947
01:19:03,910 --> 01:19:05,590
我想让它说明这个输入是什么。

2948
01:19:05,590 --> 01:19:07,900
我还要介绍另一个词汇。

2949
01:19:07,900 --> 01:19:11,350
没错，这里的白色椭圆就是输入，非常通用。

2950
01:19:11,350 --> 01:19:16,080
但在程序员的术语中，它们被称为 "参数"，又称 "参数"。

2951
01:19:16,080 --> 01:19:20,050
而这只是指对函数的输入，以某种方式修改函数的行为。

2952
01:19:20,050 --> 01:19:22,253
当我点击 "停止 "时，这只是另一个事件。

2953
01:19:22,253 --> 01:19:23,920
而这个功能就内置在 Scratch 中。

2954
01:19:23,920 --> 01:19:28,490
Scratch 知道，当你点击绿色的 "停止标志 "时，一切都会自动停止。

2955
01:19:28,490 --> 01:19:30,950
我无需编写代码来支持该功能。

2956
01:19:30,950 --> 01:19:33,470
所以这一切都很好，"你好，世界"。

2957
01:19:33,470 --> 01:19:39,130
但如果我不停地停止、启动、停止、启动，它就会一次又一次地做同样的事情。

2958
01:19:39,130 --> 01:19:45,350
说到底，这真的没什么意思，也许有一次会让人感到欣慰，但如果能有更多的互动就更好了。

2959
01:19:45,350 --> 01:19:48,140
原来，我们也可以这样做。

2960
01:19:48,140 --> 01:19:50,450
但我们需要一种不同的思维模式。

2961
01:19:50,450 --> 01:19:53,740
因此，在这种情况下，当我们考虑这个功能时、

2962
01:19:53,740 --> 01:20:01,870
比如说，在这个输入中，"你好，世界"，这实际上非常清晰地映射到了前面的这个模型中，我提出的这个模型就是解决问题，就是计算机科学，如果你愿意的话。

2963
01:20:01,870 --> 01:20:05,770
当前问题的输入将以白色显示、

2964
01:20:05,770 --> 01:20:06,760
"你好，世界"

2965
01:20:06,760 --> 01:20:10,300
这种算法就是 "说 "算法。

2966
01:20:10,300 --> 01:20:14,330
现在，我不知道麻省理工学院是如何让它在屏幕上打印出漂亮的小语泡的。

2967
01:20:14,330 --> 01:20:17,770
但他们编写了这些底层的低级实施细节。

2968
01:20:17,770 --> 01:20:22,630
他们给了我和你一个紫色的功能，叫做 "说"，它可以帮你做到这一点。

2969
01:20:22,630 --> 01:20:24,670
你我不必重新发明轮子。

2970
01:20:24,670 --> 01:20:28,580
Say 的输出是另一个专业术语，现在称为 "副作用"。

2971
01:20:28,580 --> 01:20:34,008
副作用通常是指一些可视化的现象，比如调用一个函数的副作用。

2972
01:20:34,008 --> 01:20:39,800
这样做的副作用是，猫咪神奇地出现了一个语音气泡，里面写着 "你好，世界"。

2973
01:20:39,800 --> 01:20:41,200
所以我们有一个输入。

2974
01:20:41,200 --> 01:20:42,370
我们有一个输出。

2975
01:20:42,370 --> 01:20:43,540
我们有一种算法。

2976
01:20:43,540 --> 01:20:46,910
但现在我们是在编程的背景下讨论这些想法。

2977
01:20:46,910 --> 01:20:49,420
因此，现在的输入是一个 "参数"。

2978
01:20:49,420 --> 01:20:51,400
算法是一种 "函数"。

2979
01:20:51,400 --> 01:20:55,840
在这种情况下，输出是一种 "副作用"--你会听到越来越多这样的术语。

2980
01:20:55,840 --> 01:21:00,800
最终我们会明白这一点，但不用担心，如果这些术语不是很自然地出现在我们的生活中。

2981
01:21:00,800 --> 01:21:03,890
那么，我还能用它做些什么呢？

2982
01:21:03,890 --> 01:21:09,910
让我回到 Scratch，让它更具互动性，让猫咪更生动地说点什么。

2983
01:21:09,910 --> 01:21:15,050
所以，与其说 "你好，世界"，不如让他对我或你或其他人说 "你好"。

2984
01:21:15,050 --> 01:21:16,010
那就让我来吧。

2985
01:21:16,010 --> 01:21:20,200
让我到下面去，说 -- 让我先把这个弄掉。

2986
01:21:20,200 --> 01:21:22,090
你还会发现一个小窍门。

2987
01:21:22,090 --> 01:21:28,480
只要你开始拖动一个块，如果它靠近它，它就会变成灰色，然后就会被磁力吸到一起。

2988
01:21:28,480 --> 01:21:30,220
你不必做得非常精确。

2989
01:21:30,220 --> 01:21:32,345
相反，如果我想去掉一块拼图、

2990
01:21:32,345 --> 01:21:35,800
我可以把它拖到左边的任何位置，然后放手，这样就可以删除它了。

2991
01:21:35,800 --> 01:21:39,902
或者，你也可以右键单击或按住 Control 键单击，一个小菜单也会让你删除它。

2992
01:21:39,902 --> 01:21:41,110
好吧，让我来做这个。

2993
01:21:41,110 --> 01:21:50,700
在 "感知 "下面，我知道有很多与 "感知 "相关的东西，因为我以前也做过这样的工作。

2994
01:21:50,700 --> 01:21:55,620
它能做的事情包括提出这样的问题："我是否触碰到了鼠标指针？"就像用户的光标一样。

2995
01:21:55,620 --> 01:21:59,010
"我触摸的是一种特定的颜色 你可以覆盖成任何你想要的颜色吗？"

2996
01:21:59,010 --> 01:22:02,500
"鼠标指针的距离是某个特定值吗？

2997
01:22:02,500 --> 01:22:12,030
但现在，我要把注意力集中在这块蓝色拼图上，这块拼图会提出一个问题，它本身是一个白色的椭圆形，我显然可以改变它，然后它就会等待回应。

2998
01:22:12,030 --> 01:22:14,443
但这块拼图有点不同。

2999
01:22:14,443 --> 01:22:15,360
它有点特别。

3000
01:22:15,360 --> 01:22:16,590
它还附带赠品。

3001
01:22:16,590 --> 01:22:19,690
技术上，我们称之为 "返回值"。

3002
01:22:19,690 --> 01:22:22,590
因此，有些功能并不只是在屏幕上做一些事情。

3003
01:22:22,590 --> 01:22:27,570
可以说，他们还给你的是一种价值，你可以用它做任何你想做的事。

3004
01:22:27,570 --> 01:22:31,750
除非你对所谓的返回值进行操作，否则什么都不会立即发生。

3005
01:22:31,750 --> 01:22:35,633
让我把这东西拖过来 问 "你叫什么名字？"

3006
01:22:35,633 --> 01:22:37,050
我将使用默认问题。

3007
01:22:37,050 --> 01:22:38,675
这似乎是一个合理的起点。

3008
01:22:38,675 --> 01:22:41,970
我不会覆盖默认值。现在让我继续放大。

3009
01:22:41,970 --> 01:22:43,890
让我回到 "外观"。

3010
01:22:43,890 --> 01:22:46,320
让我去说。

3011
01:22:46,320 --> 01:22:48,850
让我来组一个我想要的英语句子。

3012
01:22:48,850 --> 01:22:53,730
所以，让我放大这里，输入 "你好"，也许是逗号、空格。

3013
01:22:53,730 --> 01:23:00,270
我可以用 "戴维"，但这显然不对，因为我是在询问一个名字，然后我就像是提前硬编码了我的名字。

3014
01:23:00,270 --> 01:23:01,228
这不是我想要的。

3015
01:23:01,228 --> 01:23:02,610
我只想说 "你好"，逗号。

3016
01:23:02,610 --> 01:23:06,180
现在，让我把镜头拉远，再抓一个 Say block。

3017
01:23:06,180 --> 01:23:07,500
让我在这里说一下。

3018
01:23:07,500 --> 01:23:09,180
好吧，我不想说 "你好，你好"

3019
01:23:09,180 --> 01:23:14,230
我不想直接输入自己的名字，因为这样又有什么意义呢？

3020
01:23:14,230 --> 01:23:15,300
但请注意这一点。

3021
01:23:15,300 --> 01:23:22,080
如果我回到传感区块，蓝色椭圆形的 "应答 "就能派上用场。

3022
01:23:22,080 --> 01:23:25,280
这就是该函数的所谓 "返回值"。

3023
01:23:25,280 --> 01:23:27,780
所以，我要继续这样做，然后拖放。

3024
01:23:27,780 --> 01:23:30,600
虽然尺寸不合适，但形状是合适的。

3025
01:23:30,600 --> 01:23:34,620
因此，Scratch 会很聪明地为您填补这块拼图。

3026
01:23:34,620 --> 01:23:35,820
让我现在放大。

3027
01:23:35,820 --> 01:23:37,607
现在让我点击绿旗。

3028
01:23:37,607 --> 01:23:40,440
你会看到 Scratch 确实在用语音气泡提示我、

3029
01:23:40,440 --> 01:23:41,232
"你叫什么名字？"

3030
01:23:41,232 --> 01:23:44,320
注意到猫下面的小文本框在问：你叫什么名字？

3031
01:23:44,320 --> 01:23:46,590
所以我要输入 D-A-V-I-D，然后按回车键。

3032
01:23:46,590 --> 01:23:48,120
或者，我可以点击蓝色复选框。

3034
01:23:50,310 --> 01:23:51,802
好吧，这有点奇怪。

3035
01:23:51,802 --> 01:23:53,760
我想让他说 "你好"，而不仅仅是我的名字。

3036
01:23:53,760 --> 01:23:55,020
让我停下来。

3037
01:23:55,020 --> 01:23:56,190
让我重新开始。

3038
01:23:56,190 --> 01:23:57,648
好吧，你好，你叫什么名字？

3039
01:23:57,648 --> 01:24:00,230
D -A -V进入

3040
01:24:00,230 --> 01:24:02,490
有点粗鲁

3041
01:24:02,490 --> 01:24:04,890
为什么会出现这个错误？

3042
01:24:04,890 --> 01:24:07,920
比如，我想说 "你好，大卫"，而不只是 "大卫"。

3043
01:24:07,920 --> 01:24:11,550
然而，它两次都没有做到这一点。

3046
01:24:13,577 --> 01:24:17,658
是的，电脑正在快速处理我的指令和行动。

3047
01:24:17,658 --> 01:24:18,950
因此，它实际上正在这样做。

3048
01:24:18,950 --> 01:24:23,220
只是，你和我，在房间里，都太迟钝了 没注意到它说 -- "你好，戴维"

3049
01:24:23,220 --> 01:24:25,470
它似乎只说了 "大卫"。

3050
01:24:25,470 --> 01:24:26,910
那么好吧，我该如何解决这个问题呢？

3051
01:24:26,910 --> 01:24:29,940
这时候，你就要开始四处打探，思考如何解决这个问题。

3052
01:24:29,940 --> 01:24:31,100
让我回到 "外观 "下面。

3053
01:24:31,100 --> 01:24:33,330
也许有更聪明的办法。

3054
01:24:33,330 --> 01:24:34,520
也许我可以

3055
01:24:34,520 --> 01:24:35,540
好吧，我可以做到这一点。

3056
01:24:35,540 --> 01:24:42,150
要不，别只说 "你好"，显然还有另一个拼图，我可以给它计时，这样也许能让事情慢一点。

3057
01:24:42,150 --> 01:24:43,110
那就让我来吧。

3058
01:24:43,110 --> 01:24:45,810
让我把这些都扔掉吧。

3059
01:24:45,810 --> 01:24:49,140
让我拖动 2 秒钟，说 "你好"。

3060
01:24:49,140 --> 01:24:51,870
让我再拖一个 说 "你好 "2 秒钟。

3061
01:24:51,870 --> 01:24:54,500
让我把第一个逗号改为 "你好 "逗号。

3062
01:24:54,500 --> 01:24:57,530
然后让我回到 "感应"。

3063
01:24:57,530 --> 01:25:01,460
让我抓住那个同样的答案，因为我刚才把它扔掉了，我就改一下。

3064
01:25:01,460 --> 01:25:02,960
我甚至不用删除 "你好"。

3065
01:25:02,960 --> 01:25:04,740
我可以这样覆盖它。

3066
01:25:04,740 --> 01:25:08,360
所以，我想现在我们应该踩踩刹车，慢慢来。

3067
01:25:08,360 --> 01:25:09,620
让我停下来。

3068
01:25:09,620 --> 01:25:10,550
让我先说。

3069
01:25:10,550 --> 01:25:12,050
D-A-V-I-D，回车

3070
01:25:12,050 --> 01:25:14,600
你好，戴维

3071
01:25:14,600 --> 01:25:18,120
好吧，现在好多了，好像开始起作用了。

3072
01:25:18,120 --> 01:25:21,255
我认为你的假设是对的，只是看起来有点愚蠢，对吗？

3073
01:25:21,255 --> 01:25:22,880
就像它在说 "你好

3075
01:25:24,170 --> 01:25:25,640
--大卫，好像我们能做得更好似的。

3076
01:25:25,640 --> 01:25:29,930
而且，你手机、Mac 或 PC 上的每款软件都比它好。

3077
01:25:29,930 --> 01:25:33,750
它通过你我都熟悉的用户界面将单词加在一起。

3078
01:25:33,750 --> 01:25:35,480
所以，让我们在这里再多钓一会儿。

3079
01:25:35,480 --> 01:25:36,950
让我扔掉这些。

3080
01:25:36,950 --> 01:25:39,860
让我回到 "外观"，说得简单一些。

3081
01:25:39,860 --> 01:25:45,720
我想让它说 "Hello"（你好），逗号为 name，其中 name 来自答案的返回值。

3082
01:25:45,720 --> 01:25:46,740
那么，我该怎么做呢？

3083
01:25:46,740 --> 01:25:49,440
好吧，让我来介绍一下行动处，这是我们以前没有接触过的。

3084
01:25:49,440 --> 01:25:50,732
这里有很多东西。

3085
01:25:50,732 --> 01:25:53,720
其中一些与数学有关，如加法、减法等。

3086
01:25:53,720 --> 01:25:56,280
您可以生成可能有用的随机数。

3087
01:25:56,280 --> 01:25:59,810
如果我继续往下看，就会看到 "苹果 "和 "香蕉"。

3088
01:25:59,810 --> 01:26:01,280
但这只是占位符文字。

3089
01:26:01,280 --> 01:26:06,170
您可以将一段文字与另一段文字连接起来，默认为 "苹果 "和 "香蕉"。

3090
01:26:06,170 --> 01:26:08,480
不过，还是改成 "你好 "和我的名字吧。

3091
01:26:08,480 --> 01:26:11,120
这个也是，尺寸不对，但形状是对的。

3092
01:26:11,120 --> 01:26:13,190
所以，让我先把它说清楚。

3093
01:26:13,190 --> 01:26:15,920
现在让我来做 "你好 "逗号。

3094
01:26:15,920 --> 01:26:20,840
现在，我想我只想抓取答案的返回值。

3095
01:26:20,840 --> 01:26:25,280
让我拖着和以前一样的椭圆形，"掐"--也就是 "覆盖"--香蕉。

3096
01:26:25,280 --> 01:26:28,430
所以，现在我正在构思一些功能。

3097
01:26:28,430 --> 01:26:33,972
一个函数 "Join "的输出将是另一个函数 "Say "的输入。

3098
01:26:33,972 --> 01:26:38,660
现在，我们来看看它们堆叠在一起或嵌套在一起会发生什么。

3099
01:26:38,660 --> 01:26:42,440
点击绿旗，D-A-V-I-D。输入。

3100
01:26:42,440 --> 01:26:43,357
"你好 戴维"

3101
01:26:43,357 --> 01:26:44,690
好吧，这也太快了

3102
01:26:44,690 --> 01:26:45,680
让我们再来一次。

3105
01:26:47,270 --> 01:26:49,545
开始，D -A -V进来

3107
01:26:50,045 --> 01:26:52,650
好吧，这不是世界上最激动人心的节目。

3108
01:26:52,650 --> 01:26:53,750
但这更正确。

3109
01:26:53,750 --> 01:26:57,062
设计得更好，只是因为这是你期望软件做的事

3110
01:26:57,062 --> 01:27:03,962
而不是某种蹩脚的用户界面，只是插入随机延迟，使其勉强工作，就像是一种变通办法，一种黑客手段，如果你愿意的话。

3111
01:27:03,962 --> 01:27:06,170
不过，用 Scratch 也能做一些很酷的事情。

3112
01:27:06,170 --> 01:27:10,940
我们就不一一赘述它所拥有的各种有趣的、适合家庭使用的功能了。

3113
01:27:10,940 --> 01:27:12,810
不过，这里有一个还挺酷的。

3114
01:27:12,810 --> 01:27:16,550
让我进入屏幕左下角的 "扩展 "按钮。

3115
01:27:16,550 --> 01:27:17,720
这个还挺酷的。

3116
01:27:17,720 --> 01:27:19,575
让我转到文本到语音。

3117
01:27:19,575 --> 01:27:22,700
你会注意到，这个软件需要互联网，因为它是基于云计算的。

3118
01:27:22,700 --> 01:27:27,715
但这只是给了我一些新的拼图碎片，属于一个新的类别、

3119
01:27:27,715 --> 01:27:28,340
文本转语音

3120
01:27:28,340 --> 01:27:30,710
而这些绿色的产品也确实如其所言。

3121
01:27:30,710 --> 01:27:31,860
那就让我来吧。

3122
01:27:31,860 --> 01:27:33,120
让我再放大一点。

3123
01:27:33,120 --> 01:27:34,543
让我保留 "加入 "区块。

3124
01:27:34,543 --> 01:27:36,710
我就暂时把它扔在这里。

3125
01:27:36,710 --> 01:27:40,070
它不会因为我没有把它拖到另一边而自动删除。

3126
01:27:40,070 --> 01:27:42,800
但我要去掉紫色的 "说 "字块。

3127
01:27:42,800 --> 01:27:47,570
我要做的是绿色的 "说话 "区块，然后让它就位。

3128
01:27:47,570 --> 01:27:50,990
然后，我要把它拖放到 "说话 "输入框上。

3129
01:27:50,990 --> 01:27:54,290
现在，也许更可爱一点，让我们试试这个。

3130
01:27:54,290 --> 01:27:56,270
绿旗，你叫什么名字？

3131
01:27:56,270 --> 01:27:57,710
D -A -V进入

3133
01:27:58,460 --> 01:28:00,578
你好，戴维

3134
01:28:00,578 --> 01:28:01,370
大卫-J-马兰：好的。

3136
01:28:02,370 --> 01:28:03,890
有点像机器人。

3137
01:28:03,890 --> 01:28:05,917
但至少现在有了合成语音。

3138
01:28:05,917 --> 01:28:13,550
现在我已经有了自己的 Siri 或 Google Assistant 或 Alexa，它可以识别任何文字，并播放出来。

3139
01:28:13,550 --> 01:28:17,480
好吧，让我们把它变成一只真正的猫，它不会用那种奇怪的人类声音说话。

3140
01:28:17,480 --> 01:28:19,610
让我先把这些东西都扔掉吧。

3141
01:28:19,610 --> 01:28:22,730
让这只猫像猫一样喵喵叫吧。

3142
01:28:22,730 --> 01:28:24,650
让我到 "声音 "区下面去。

3143
01:28:24,650 --> 01:28:33,080
现在，麻省理工学院免费为你提供了一些声音，因为它默认是围绕猫设计的。我将继续使用 "Play Sound Meow（播放喵喵的声音）"，直到完成为止。

3144
01:28:33,080 --> 01:28:36,860
现在 -- 我们之前在人群中听到了一段预告 --

3146
01:28:38,982 --> 01:28:40,440
诚然，这有点刺耳。

3147
01:28:40,440 --> 01:28:42,460
也许我们可以把音量调低一点。

3148
01:28:42,460 --> 01:28:45,710
但请注意，如果我想让猫再喵喵叫一次，我只需再点击一次。

3150
01:28:46,905 --> 01:28:48,690
好吧，还有那边，我听说 --

3154
01:28:51,320 --> 01:28:53,500
好了，现在有点可爱了吧？

3155
01:28:53,500 --> 01:28:54,960
所以，它只是喵 -

3156
01:28:54,960 --> 01:28:56,610
好的，是的，回声，回声。

3157
01:28:56,610 --> 01:28:59,767
所以现在每次我打绿旗的时候，它都会喵喵叫。

3158
01:28:59,767 --> 01:29:02,100
现在，这是伟大的， 但即使是一个孩子可能会 -

3160
01:29:02,730 --> 01:29:03,780
--比如希望它--

3162
01:29:03,840 --> 01:29:06,790
--就 "喵喵 "地叫，也许，就像一次又一次，而不必一直--

3164
01:29:07,290 --> 01:29:08,165
--按下按钮

3165
01:29:08,165 --> 01:29:09,880
那么，我们该如何做呢？

3166
01:29:09,880 --> 01:29:16,570
好吧，如果我想让它多次喵喵叫，我为什么不一次又一次地抓住它呢？

3167
01:29:16,570 --> 01:29:21,725
或者，你也可以右键单击或按住 Control 键单击一块拼图，然后从弹出的小菜单中复制它。

3168
01:29:21,725 --> 01:29:22,920
好了，三只喵喵。

3170
01:29:25,960 --> 01:29:27,730
好吧，这可不是一只快乐的猫。

3171
01:29:27,730 --> 01:29:29,200
听起来可能是饿了。

3172
01:29:29,200 --> 01:29:31,240
那么，我们能减缓这种情况吗？

3173
01:29:31,240 --> 01:29:32,380
也许吧

3174
01:29:32,380 --> 01:29:34,630
事实上，如果我四处打探，就让我去控制室吧。

3175
01:29:34,630 --> 01:29:36,850
好像有个 Wait block。

3176
01:29:36,850 --> 01:29:40,630
默认情况下等待 1 秒。请注意，Scratch 会很通情达理。

3177
01:29:40,630 --> 01:29:44,410
如果你只是在块之间悬停，它也会生长到填满该块。

3178
01:29:44,410 --> 01:29:47,095
所以，我可以把它改成 1 或 2，或者任何数秒的时间。

3179
01:29:47,095 --> 01:29:48,970
我暂时将其保留为默认值，即 1.

3180
01:29:48,970 --> 01:29:50,680
现在，我要继续做这件事。

3182
01:29:55,580 --> 01:29:58,790
好了，更可爱、更不饿、更友好了。

3183
01:29:58,790 --> 01:30:00,740
但这并不是最好的设计。

3184
01:30:00,740 --> 01:30:01,460
这是正确的。

3185
01:30:01,460 --> 01:30:02,960
让我们把它作为一个艺术术语。

3186
01:30:02,960 --> 01:30:05,720
正确的意思是代码会按照您的要求运行。

3187
01:30:05,720 --> 01:30:08,090
我想让猫慢慢地喵喵叫三声。

3188
01:30:08,090 --> 01:30:08,720
它确实做到了。

3189
01:30:08,720 --> 01:30:10,370
所以我敢打赌这是正确的。

3190
01:30:10,370 --> 01:30:12,380
但这并不是最好的设计。

3191
01:30:12,380 --> 01:30:14,810
这就是事情变得更加主观的地方，对吗？

3192
01:30:14,810 --> 01:30:20,663
比如，你可以在英语课的作文中写出准确的句子，但除此之外，完全就是一团糟。

3193
01:30:20,663 --> 01:30:24,830
比如，你在这里和那里的争论，你没有说错什么，但你说得不好。

3194
01:30:24,830 --> 01:30:28,110
在代码方面，我们可以做得更好。

3195
01:30:28,110 --> 01:30:32,340
而复制/粘贴或反复重复自己的内容往往是不好的做法。

3197
01:30:32,840 --> 01:30:37,188
假设您想将等待时间从 1 秒改为 2 秒。

3198
01:30:37,188 --> 01:30:38,480
诚然，这不是什么大不了的事。

3199
01:30:38,480 --> 01:30:40,400
好吧，我点击那里，把它改成 2。

3200
01:30:40,400 --> 01:30:41,990
我点击那里，将其改为 2。

3201
01:30:41,990 --> 01:30:43,820
但如果你喵了 5 次、10 次呢？

3202
01:30:43,820 --> 01:30:46,858
现在，我必须在 5 到 10 个不同的地方更改 "等待"。

3203
01:30:46,858 --> 01:30:47,900
这太愚蠢了

3204
01:30:47,900 --> 01:30:53,270
这会占用不必要的人力时间，而且你最终会搞砸，尤其是当你的程序越来越长的时候。

3205
01:30:53,270 --> 01:30:54,740
你会错过其中一个输入。

3206
01:30:54,740 --> 01:30:56,365
你会把号码记错的。

3207
01:30:56,365 --> 01:30:57,080
这是一个错误。

3208
01:30:57,080 --> 01:31:04,050
那么，根据你们已经看到的，或者如果你们以前编制过程序（你们中的一些人已经编制过），有什么术语可以解决这个问题？

3209
01:31:04,050 --> 01:31:06,095
如何才能设计得更好？

3211
01:31:07,230 --> 01:31:08,563
大卫-J-马兰：我在这里听到的。

3212
01:31:08,563 --> 01:31:12,110
是的，所以一个循环 -- 一个循环，某种循环说，再来一次。

3213
01:31:12,110 --> 01:31:16,430
再做一次--不一定是无限次，但一定是有限次。

3214
01:31:16,430 --> 01:31:18,740
好吧，你也许可以在屏幕上看到一个扰流板。

3215
01:31:18,740 --> 01:31:22,760
在同一个橙色控制类别下有一个重复区块。

3216
01:31:22,760 --> 01:31:24,320
默认情况下，建议使用 10。

3217
01:31:24,320 --> 01:31:25,440
但我们可以改变这种状况。

3218
01:31:25,440 --> 01:31:26,280
那就让我来吧。

3219
01:31:26,280 --> 01:31:29,930
我打算把这些复制/粘贴的大部分内容当作多余的东西扔掉。

3220
01:31:29,930 --> 01:31:33,470
我要把这个暂时拆开，以便腾出地方放别的东西。

3221
01:31:33,470 --> 01:31:37,590
我要把一个 Repeat 块拖到这里，让它就位。

3222
01:31:37,590 --> 01:31:40,340
为了统一起见，我暂时把它改成 3。

3223
01:31:40,340 --> 01:31:44,660
这就是正确的形状，尽管它太小了，但 Scratch 会为我们满足这个要求。

3224
01:31:44,660 --> 01:31:50,370
而现在--同样的输出，但可以说设计得更好。

3226
01:31:50,870 --> 01:31:55,040
因为如果我想更改喵星人的数量，只需在一个地方进行更改即可，不会出现复制/粘贴的混乱情况。

3227
01:31:55,040 --> 01:31:56,867
如果我想改变等待时间，只需去一个地方。

3228
01:31:56,867 --> 01:31:59,450
我不必在多个地方进行更改，也不会搞砸。

3229
01:31:59,450 --> 01:32:00,920
所以，让我打绿旗吧。

3231
01:32:05,890 --> 01:32:06,940
好吧 很好

3232
01:32:06,940 --> 01:32:12,970
现在，如果麻省理工学院能给我们一个喵块，让我们自动完成所有这些工作，那该有多好。

3233
01:32:12,970 --> 01:32:15,910
我敢打赌，他们给了我们低层次的实施细节。

3234
01:32:15,910 --> 01:32:18,400
他们给了我们 Play Sound Meow。

3235
01:32:18,400 --> 01:32:23,120
但是，为了让一只猫一次又一次地 "喵喵喵 "叫，我不得不设置相当多的障碍。

3236
01:32:23,120 --> 01:32:26,350
我觉得我们应该从麻省理工学院免费得到这个。

3237
01:32:26,350 --> 01:32:30,100
其实，不一定只有他们发明了积木供我们使用。

3238
01:32:30,100 --> 01:32:33,920
您可以编写自己的函数、动词或动作。

3239
01:32:33,920 --> 01:32:35,180
那么，我们如何才能做到这一点呢？

3240
01:32:35,180 --> 01:32:42,650
让我们自己制作一个名为 "喵喵 "的拼图，它使用了这些代码，但创建的方式使它可以在其他地方重复使用。

3241
01:32:42,650 --> 01:32:43,420
那就让我来吧。

3242
01:32:43,420 --> 01:32:48,310
在粉红色的区块下，我要点击 "制作区块"。

3243
01:32:48,310 --> 01:32:51,100
现在，这里有一个接口，我可以通过它给程序块命名。

3244
01:32:51,100 --> 01:32:53,410
M-E-O-W 将是这个街区的名称。

3245
01:32:53,410 --> 01:32:55,810
我将继续快速点击 "确定"。

3246
01:32:55,810 --> 01:33:06,717
这只是给了我一个非常普通的、以 "定义 "开头的粉色拼图，因为 "划痕 "要求我定义，也就是为我实现或创建这个新拼图。

3247
01:33:06,717 --> 01:33:08,050
那么，这对喵星人来说意味着什么呢？

3248
01:33:08,050 --> 01:33:14,890
我想说的是，这两个步骤的意思是，播放喵喵声，然后等待 1 秒钟。

3249
01:33:14,890 --> 01:33:18,520
但这个想法的强大之处在于，看看上面这个。

3250
01:33:18,520 --> 01:33:21,970
现在我已经制作了一个区块，它就存在于 Scratch 中。

3251
01:33:21,970 --> 01:33:23,710
麻省理工学院不需要为我创造这些。

3252
01:33:23,710 --> 01:33:27,190
我创建它是为了我自己，甚至是你，如果我们最终共享代码的话。

3253
01:33:27,190 --> 01:33:30,320
现在我可以把喵喵拉上来了。

3254
01:33:30,320 --> 01:33:35,680
喵喵的优点在于，它本身是一个功能，但同时也是一个抽象概念。

3255
01:33:35,680 --> 01:33:42,340
比如，我甚至你们再也不需要担心或在意 "喵喵 "的含义，也不需要实施 "喵喵"。

3256
01:33:42,340 --> 01:33:43,930
我可以把它拖出来。

3257
01:33:43,930 --> 01:33:45,790
我没有删除它，而是把它拖走了。

3258
01:33:45,790 --> 01:33:46,970
眼不见，心不烦。

3260
01:33:47,470 --> 01:33:51,070
因为从某种意义上说，我的代码现在设计得更好了，因为它更具可读性。

3261
01:33:51,070 --> 01:33:51,910
它在做什么？

3262
01:33:51,910 --> 01:33:55,000
点击绿旗后，重复 3 次 "喵"。

3263
01:33:55,000 --> 01:33:56,305
它说什么就是什么。

3264
01:33:56,305 --> 01:34:03,040
这样阅读起来就容易多了，思考起来也容易多了，尤其是当你在其他项目中也使用喵星人的时候。

3265
01:34:03,040 --> 01:34:05,380
现在，让我继续点击 "播放"。

3267
01:34:06,280 --> 01:34:07,200
一样的。

3269
01:34:07,700 --> 01:34:09,282
因此，从根本上说并没有什么不同。

3271
01:34:09,830 --> 01:34:15,010
但我可以让这块定制拼图，也就是我自己的功能 "喵喵 "变得更加强大。

3272
01:34:15,010 --> 01:34:18,520
让我来倒带一下，看看我的 "喵喵拼图"。

3273
01:34:18,520 --> 01:34:21,658
我将按住 Control 键或右键单击我的粉色拼图。

3274
01:34:21,658 --> 01:34:22,700
我要编辑它。

3275
01:34:22,700 --> 01:34:25,210
所以我有点后悔把喵喵设计得这么简单。

3276
01:34:25,210 --> 01:34:31,960
如果喵喵能接受一个输入，也就是一个参数，告诉喵喵要喵喵叫多少次，那该有多好。

3277
01:34:31,960 --> 01:34:34,300
然后，我就可以去掉这个循环，直接告诉

3278
01:34:34,300 --> 01:34:36,530
喵喵喵，我到底想要多少喵喵喵。

3279
01:34:36,530 --> 01:34:40,390
因此，我要点击这里的另一个按钮，字面意思是 "添加输入"。

3280
01:34:40,390 --> 01:34:42,085
这里会有占位符。

3281
01:34:42,085 --> 01:34:43,960
所以我就在这里放一个占位符。

3282
01:34:43,960 --> 01:34:47,880
我一直用 "n "表示数字，这是计算机科学家的常用术语。

3283
01:34:47,880 --> 01:34:52,030
我还要添加一些描述性文字，这样就更一目了然了。

3284
01:34:52,030 --> 01:34:54,070
我只想说 Meow n Times。

3285
01:34:54,070 --> 01:34:55,510
但只有一个椭圆形。

3286
01:34:55,510 --> 01:34:57,700
时代》只是解释性文字。

3287
01:34:57,700 --> 01:34:59,290
现在请注意发生了什么。

3288
01:34:59,290 --> 01:35:06,580
现在，我的拼图需要一个输入，也就是一个参数，这个参数会告诉函数 "喵喵 "叫若干次。

3289
01:35:06,580 --> 01:35:08,440
但这并不只是神奇地起作用。

3290
01:35:08,440 --> 01:35:11,110
我需要实现较低级别的细节。

3291
01:35:11,110 --> 01:35:12,700
让我把镜头拉远。

3292
01:35:12,700 --> 01:35:14,918
我必须提醒自己这个功能是什么。

3293
01:35:14,918 --> 01:35:18,550
所以我要把它拖到更高的位置，让它们同时出现在屏幕上。

3294
01:35:18,550 --> 01:35:22,090
我现在要把它暂时移到这里。

3295
01:35:22,090 --> 01:35:24,190
我要把这个暂时拆开。

3297
01:35:24,700 --> 01:35:33,760
因为我想做的是将循环移到函数本身，将播放和等待移到循环中。

3298
01:35:33,760 --> 01:35:35,470
但我不想要硬编码 3。

3299
01:35:35,470 --> 01:35:41,390
注意，这里的 n 是它自己的椭圆形，我可以拖动 n 的副本，让它去那里。

3300
01:35:41,390 --> 01:35:48,170
现在，我有了一个新版本的 Meow，它接受一个参数 n，这个参数告诉 Meow 要喵喵叫多少次。

3301
01:35:48,170 --> 01:35:52,750
现在，让我再一次把这件事抛到脑后，因为谁会在意我是如何实施的呢？

3302
01:35:52,750 --> 01:35:54,880
一旦实施，就等于完成了。

3303
01:35:54,880 --> 01:35:58,070
从某种意义上说，现在我的程序设计得更好了。

3305
01:35:58,570 --> 01:36:01,120
因为现在它真的是言之有物了。

3306
01:36:01,120 --> 01:36:01,840
没有循环。

3307
01:36:01,840 --> 01:36:04,360
没有重复，没有实施细节。

3308
01:36:04,360 --> 01:36:07,060
点击绿旗时，喵喵叫 3 次。

3309
01:36:07,060 --> 01:36:13,070
因此，函数的确可以让你实现算法，就像它们只是为你做一些事情的代码。

3310
01:36:13,070 --> 01:36:14,930
但它们本身也是抽象的。

3312
01:36:15,430 --> 01:36:17,660
因为一旦函数存在，它就有了名字。

3313
01:36:17,660 --> 01:36:19,580
你可以从这个角度来考虑。

3314
01:36:19,580 --> 01:36:21,610
你还可以根据它的名字来使用它。

3315
01:36:21,610 --> 01:36:27,730
你不必关心或记住功能本身是如何建立的，无论它是由你还是麻省理工学院建立的。

3316
01:36:27,730 --> 01:36:29,480
在这里，我要再次点击 "绿旗"。

3317
01:36:29,480 --> 01:36:30,313
都是一样的。

3319
01:36:35,130 --> 01:36:38,250
所以还是正确的，但设计得更好、更完美。

3320
01:36:38,250 --> 01:36:42,271
因此，无论何时何地，都可以使用 Scratch，或者很快使用 C，最终使用 Python

3321
01:36:42,271 --> 01:36:49,370
当你发现自己在做任何类似于复制/粘贴的事情，或者一次又一次地抓取相同的代码时，你可能就有机会说，等一下。

3322
01:36:49,370 --> 01:36:59,580
让我来重构一下，也就是说，把那些看起来重复的代码删掉，把它放在自己的函数中，这样你就可以给它一个描述性的名字，并使用和重复使用它。

3323
01:36:59,580 --> 01:37:06,590
对于我们现在说的这些循环或函数，还有什么问题吗？

3326
01:37:09,883 --> 01:37:12,300
我是怎么让它喵喵叫三声的？

3327
01:37:12,300 --> 01:37:15,060
所以，我最初只有一块拼图，叫做 "喵喵"。

3328
01:37:15,060 --> 01:37:16,770
我决定改进它。

3329
01:37:16,770 --> 01:37:22,070
于是，我按住 Control 键，用鼠标右键或 Control 键点击左上角的粉红色拼图。

3330
01:37:22,070 --> 01:37:23,120
然后我点击了 "编辑"。

3331
01:37:23,120 --> 01:37:28,790
这让我又回到了最初的界面，可以为拼图本身添加一些参数。

3332
01:37:28,790 --> 01:37:31,250
然后我点击左侧的 "添加输入"。

3333
01:37:31,250 --> 01:37:34,260
然后点击这里的添加标签。

3334
01:37:34,260 --> 01:37:36,960
这样，你就可以进一步定制它了。

3335
01:37:36,960 --> 01:37:38,490
好吧，我们已经做到了。

3336
01:37:38,490 --> 01:37:41,900
让我们也添加一个其他的基元，来做一些可选择的事情。

3337
01:37:41,900 --> 01:37:50,540
那么，让猫咪只在人类抚摸它时才喵喵叫，就像人类抚摸猫咪那样移动鼠标悬停在猫咪上方，怎么样？

3338
01:37:50,540 --> 01:37:55,110
好吧，让我先把 "喵喵 "声扔掉吧。

3339
01:37:55,110 --> 01:37:57,083
让我用声音来简化一下。

3340
01:37:57,083 --> 01:37:58,500
我要继续这样做。

3341
01:37:58,500 --> 01:38:08,930
我将继续使用 "如果 "控制块，因为我想实现 "如果光标碰到猫，就播放喵喵声 "的想法。

3342
01:38:08,930 --> 01:38:10,710
或者，我也可以用我的那块粉色拼图。

3343
01:38:10,710 --> 01:38:14,150
但我现在要抛开这些，只关注声音。

3344
01:38:14,150 --> 01:38:15,840
我要这么做

3345
01:38:15,840 --> 01:38:19,598
如果触摸鼠标指针 -- 所以我需要感知世界的某些东西。

3346
01:38:19,598 --> 01:38:22,500
我们在前面已经看到了这一点，所以如果触摸鼠标指针。

3347
01:38:22,500 --> 01:38:24,810
注意这个形状，太大了。

3348
01:38:24,810 --> 01:38:25,920
但它的形状是正确的。

3349
01:38:25,920 --> 01:38:29,210
因此，如果我悬停得恰到好处，它就会卡住。

3350
01:38:29,210 --> 01:38:34,850
现在这个蓝色的是我的布尔表达式，一个是/否的问题，真假。

3351
01:38:34,850 --> 01:38:36,860
"如果 "是一个条件。

3352
01:38:36,860 --> 01:38:38,100
我想做什么？

3353
01:38:38,100 --> 01:38:42,290
如果猫在触摸鼠标指针的话、

3354
01:38:42,290 --> 01:38:44,970
我想继续播放声音喵，直到完成为止。

3355
01:38:44,970 --> 01:38:46,080
那就这么办吧。

3356
01:38:46,080 --> 01:38:48,808
我要点击绿旗，咔嚓。

3357
01:38:48,808 --> 01:38:51,350
现在什么都还没发生，因为这是一个条件，对吗？

3358
01:38:51,350 --> 01:38:53,808
只有在我摸猫的时候，它才会有反应。

3359
01:38:53,808 --> 01:38:55,550
让我把光标移到猫身上。

3360
01:38:55,550 --> 01:38:59,365
等等

3361
01:38:59,365 --> 01:39:02,330
嗯--又一个错误。

3362
01:39:02,330 --> 01:39:09,020
为什么我明明说了 "如果触摸鼠标指针，就喵喵叫"，猫却不喵喵叫呢？

3363
01:39:09,020 --> 01:39:10,295
是啊，在中间 -

3365
01:39:11,893 --> 01:39:15,440
我的电脑和你一样快得要命

3366
01:39:15,440 --> 01:39:18,650
我点击 "绿旗"，它会问我是否触碰到了鼠标指针？

3367
01:39:18,650 --> 01:39:21,350
嗯，没有，因为我的光标在上面，没碰到猫。

3368
01:39:21,350 --> 01:39:22,370
太迟了

3369
01:39:22,370 --> 01:39:23,570
猫已经出来了

3370
01:39:23,570 --> 01:39:28,490
因此，我们必须用其他方法来解决这个问题。

3371
01:39:28,490 --> 01:39:29,940
如何解决这个问题？

3372
01:39:29,940 --> 01:39:31,470
我们该如何解决这种比赛？

3375
01:39:32,690 --> 01:39:38,570
大卫-J-马兰：是啊，那我们为什么不继续问这个问题，直到我最终是否真的在抚摸那只猫呢？

3376
01:39:38,570 --> 01:39:40,610
所以，让我暂时脱离这个问题。

3377
01:39:40,610 --> 01:39:42,050
让我去控制室。

3378
01:39:42,050 --> 01:39:46,140
让我到下面去 -- 与其重复一些有限的次数，不如永远这样做。

3379
01:39:46,140 --> 01:39:49,070
所以，有时循环永远有效是件好事。

3380
01:39:49,070 --> 01:39:54,720
你手机上的时钟，永远在循环，因为你希望它永远显示时间，而不是在一天结束时停止。

3381
01:39:54,720 --> 01:39:58,913
因此，有时你确实希望代码永远循环下去，就像本例中一样。

3382
01:39:58,913 --> 01:40:00,830
所以，让我把它拖放到这里。

3383
01:40:00,830 --> 01:40:02,750
让我再次点击绿旗。

3384
01:40:02,750 --> 01:40:03,900
什么都还没发生。

3385
01:40:03,900 --> 01:40:06,300
但请注意，程序仍在运行。

3386
01:40:06,300 --> 01:40:10,700
因此，如果我移动光标，移动光标，移动光标，然后 --

3388
01:40:12,880 --> 01:40:14,550
好吧，也许我们可以增加一些 "等待"。

3389
01:40:14,550 --> 01:40:17,750
但在这种情况下，猫并不想被人宠爱。

3390
01:40:17,750 --> 01:40:20,220
但这确实是有条件的。

3391
01:40:20,220 --> 01:40:24,290
因此，我们在 Scratch 中看到了有条件地做某事的化身。

3392
01:40:24,290 --> 01:40:26,790
现在，我们可以让它变得非常酷、非常快，如果你愿意的话。

3393
01:40:26,790 --> 01:40:28,440
让我停止这个版本。

3394
01:40:28,440 --> 01:40:31,270
让我来吧。

3395
01:40:31,270 --> 01:40:33,270
让我把这些都扔掉吧。

3396
01:40:33,270 --> 01:40:36,210
让我进入我的小扩展桶。

3397
01:40:36,210 --> 01:40:40,620
让我来做视频感应，因为现在大多数笔记本电脑或手机都有摄像头。

3398
01:40:40,620 --> 01:40:44,190
我确实在那里，桑德斯就在我身后。

3399
01:40:44,190 --> 01:40:45,780
让我来吧

3400
01:40:45,780 --> 01:40:48,900
当 "视频动态"-- 让我闪开。

3401
01:40:48,900 --> 01:40:51,820
当视频动态大于某个值时。

3402
01:40:51,820 --> 01:40:56,670
因此 10 是默认值。这只是一个衡量运动量大小的数字。

3403
01:40:56,670 --> 01:40:58,290
所以，数字小就等于没有运动。

3404
01:40:58,290 --> 01:40:59,920
大数字就是大动作。

3405
01:40:59,920 --> 01:41:03,120
所以我选择 50，有点随意，就 50 吧。

3406
01:41:03,120 --> 01:41:05,370
在一旁编程是不正常的。

3407
01:41:05,370 --> 01:41:08,130
但我现在要说的是

3408
01:41:08,130 --> 01:41:14,460
当 "视频动态 "为 50 时，像这样播放 "声音喵"。

3409
01:41:14,460 --> 01:41:16,170
所以，这只猫还在那个世界里。

3410
01:41:16,170 --> 01:41:18,970
我要停止程序并重新运行。

3411
01:41:18,970 --> 01:41:21,090
我们开始吧，绿旗。

3412
01:41:21,090 --> 01:41:30,640
现在来了 -- 好吧，这有点吓人， 我抚摸猫的方式，但是 -- 而且 -- [叹气]

3416
01:41:35,750 --> 01:41:36,290
好了

3417
01:41:36,290 --> 01:41:37,910
好吧，50 这个数字太大了。

3418
01:41:37,910 --> 01:41:39,500
我得快点抚摸猫咪。

3420
01:41:42,900 --> 01:41:44,940
鉴于此，如果

3421
01:41:44,940 --> 01:41:46,410
我不知道

3425
01:41:50,710 --> 01:41:55,410
好了，只要把不同的拼图拼在一起，就能让事情变得更加互动。

3426
01:41:55,410 --> 01:41:58,050
老实说，这里有很多不同的拼图。

3427
01:41:58,050 --> 01:42:00,610
我们甚至不会对其中的很多内容浅尝辄止。

3428
01:42:00,610 --> 01:42:02,940
但他们一般都是说到做到。

3429
01:42:02,940 --> 01:42:12,970
事实上，当你在屏幕上看到这些拼图时，很多编程工作，尤其是在学习一门语言的初期，都是在尝试不同的东西，不断尝试，不断失败。

3430
01:42:12,970 --> 01:42:20,000
如果效果不佳，也可以寻找其他解决方案，就像我刚才不得不做的那样。

3431
01:42:20,000 --> 01:42:24,720
好吧，让我们继续用，实际上，用你的前任做的另一个例子怎么样？

3432
01:42:24,720 --> 01:42:28,830
让我在这里提前打开一个程序，名为

3433
01:42:28,830 --> 01:42:38,895
捶打鼹鼠 我们能否请一位勇敢的志愿者上台，愿意用头捶打鼹鼠？

3434
01:42:38,895 --> 01:42:40,770
好吧，我想想，在后面怎么样？

3435
01:42:40,770 --> 01:42:42,300
你想下来吗？

3436
01:42:42,300 --> 01:42:45,327
好了，下来吧

3437
01:42:45,327 --> 01:42:47,160
当然，掌声送给我们的志愿者。

3439
01:42:52,130 --> 01:43:01,178
好了 我们到了 下来吧

3440
01:43:01,178 --> 01:43:01,970
大家好

3441
01:43:01,970 --> 01:43:02,720
你叫什么名字？

3442
01:43:02,720 --> 01:43:03,320
我是乔希

3443
01:43:03,320 --> 01:43:05,695
大卫-J-马兰：哦，实际上，对着麦克风说吧。

3444
01:43:05,695 --> 01:43:06,950
嗨，我是乔希。

3445
01:43:06,950 --> 01:43:07,670
好的，很好。

3446
01:43:07,670 --> 01:43:08,240
欢迎，乔希。

3447
01:43:08,240 --> 01:43:08,782
过来吧

3449
01:43:10,850 --> 01:43:12,892
好吧，所以同样的想法在这里 -

3450
01:43:12,892 --> 01:43:13,850
我把麦克风拿回去

3451
01:43:13,850 --> 01:43:15,230
你必须站在镜头前。

3452
01:43:15,230 --> 01:43:20,150
一会儿，你就得把头放进你过去的同学制作的盒子里。

3454
01:43:22,840 --> 01:43:24,490
我们从初级开始。

3455
01:43:24,490 --> 01:43:25,180
AUDIENCE：OK.

3456
01:43:25,180 --> 01:43:28,166
马兰: 请把你的头放在盒子里。

3457
01:43:28,166 --> 01:43:29,142
好的好的

3459
01:43:43,800 --> 01:43:45,390
很好。

3460
01:43:45,390 --> 01:43:46,155
12 秒

3462
01:43:53,790 --> 01:43:55,710
注意分数已经达到 18 分了。

3463
01:43:55,710 --> 01:43:58,410
相当不错。

3464
01:43:58,410 --> 01:44:00,990
好吧，如果可以的话，请为乔希鼓掌。

3466
01:44:06,380 --> 01:44:11,330
请注意，使用一些相当简单的基元，事情很快就变得有趣起来。

3467
01:44:11,330 --> 01:44:12,560
是如何实施的？

3468
01:44:12,560 --> 01:44:14,560
嗯，可能至少有四个精灵。

3469
01:44:14,560 --> 01:44:16,222
所以，你并不局限于一只猫。

3470
01:44:16,222 --> 01:44:18,930
你可以创建越来越多的精灵，改变它们的外观。

3471
01:44:18,930 --> 01:44:20,930
因此，在这种情况下，它们实际上看起来就像一颗颗痣。

3472
01:44:20,930 --> 01:44:23,990
其中可能包含一些条件，一些持续 30 秒的循环。

3473
01:44:23,990 --> 01:44:31,550
这就是检查乔希的头部移动是否超过了某个值，或者超过了这个值，然后递增一个叫做变量的东西。

3474
01:44:31,550 --> 01:44:32,450
我们也会看到的。

3475
01:44:32,450 --> 01:44:42,350
就像代数中的 x、y 和 z，可以像数字一样存储数值，计算机程序也可以有名为 x 或 y 或 z 的变量，或者更直观地称为 Score、

3476
01:44:42,350 --> 01:44:49,632
或另一个名为 Countdown 的变量，在代码中通常是一个单词，但在本例中是两个单词，只是存储一些值。

3477
01:44:49,632 --> 01:44:54,604
因此，这里可能有一些数学运算，程序的编写者只是在递增

3478
01:44:54,604 --> 01:45:00,570
也就是说，每次检测到 "鼹鼠 "被 "捶打"（在这里是 "移动"）时，都会加上 1 和 1。

3479
01:45:00,570 --> 01:45:07,562
我自己在麻省理工学院读研究生时，就用 Scratch 实现了我的第一个程序。

3480
01:45:07,562 --> 01:45:15,500
他在麻省理工学院交叉注册，选修了麻省理工学院媒体实验室的课程，特别是终身幼儿园小组的课程，该小组本身就是 Scratch 的创建者。

3481
01:45:15,500 --> 01:45:27,120
我多年前编写的、至今仍念念不忘的程序是一个名为《奥斯卡时间》（Oscartime）的小玩意儿，我想在这里为自己播放一段简短的片段。

3482
01:45:27,120 --> 01:45:38,060
因此，在这种情况下，当音乐开始播放时，请考虑一下这个程序是如何实现的，当然，这个程序要比我们刚才做的最早的 "Say hello "示例复杂得多。

3483
01:45:38,060 --> 01:45:40,745
现在让我点击 "绿旗"。

3485
01:45:44,950 --> 01:45:46,973
鸟人奥斯卡：（唱）哦，我爱垃圾。

3486
01:45:46,973 --> 01:45:51,970
马兰：好的，一些垃圾正在移动，大概是从顶部循环移动的。

3487
01:45:51,970 --> 01:45:56,440
如果我触摸鼠标光标，它就会跟着我。

3488
01:45:56,440 --> 01:45:59,920
如果我将鼠标悬停在垃圾桶上，它就会做出反应。

3489
01:45:59,920 --> 01:46:06,910
如果我松开手，奥斯卡就会跳出来，用当前分数创建一个变量。

3490
01:46:06,910 --> 01:46:07,900
这种情况再次发生。

3491
01:46:07,900 --> 01:46:09,983
鸟人奥斯卡：（唱）洞洞真可怕。

3492
01:46:09,983 --> 01:46:11,950
鞋带也破了。

3493
01:46:11,950 --> 01:46:16,030
这是我出生那天母亲送给我的礼物。

3494
01:46:16,030 --> 01:46:20,050
我喜欢它，因为它是垃圾。

3496
01:46:21,070 --> 01:46:24,050
一开始很容易，但是 --

3497
01:46:24,050 --> 01:46:26,410
奥斯卡：（唱）--任何肮脏或邋遢的东西--

3498
01:46:26,410 --> 01:46:30,230
所以我不需要一直在舞台上当着所有人的面演奏这个。

3499
01:46:30,230 --> 01:46:32,950
因此，我的分数现在已经达到了 6 分左右。

3500
01:46:32,950 --> 01:46:35,900
但稍后，你也会看到，事态会升级。

3501
01:46:35,900 --> 01:46:38,080
所以我显然考虑到了时间问题。

3503
01:46:38,980 --> 01:46:42,343
鸟人奥斯卡：（唱）我这里有一些报纸，13 个月前的。

3504
01:46:42,343 --> 01:46:45,010
大卫-J-马兰：所以越来越多的精灵突然出现了。

3505
01:46:45,010 --> 01:46:48,040
注意，每次它们都是从屏幕的不同部分出现的。

3506
01:46:48,040 --> 01:46:52,270
这也许也是一种幻觉 -- 在 x 和 y 之间随便选一个数字。

3507
01:46:52,270 --> 01:46:56,032
因此，您实际上可以选择一些数值范围，让游戏不断变化。

3508
01:46:56,032 --> 01:47:00,860
事实上，我要继续点击 "停止"，因为几年前我花了差不多八个多小时来制作这个。

3509
01:47:00,860 --> 01:47:04,810
我再也不能听这首歌了，反正我现在也不应该听。

3510
01:47:04,810 --> 01:47:09,670
但这首歌与正在发生的许多行动是同步的。

3511
01:47:09,670 --> 01:47:12,130
归根结底，这些都是积木。

3512
01:47:12,130 --> 01:47:15,610
但我并没有坐下来立即实施我所说的 "Oscartime"。

3513
01:47:15,610 --> 01:47:17,500
可以说，我真的是一步步走过来的。

3514
01:47:17,500 --> 01:47:24,220
然后我就想，好吧，我该如何分解我当时的愿景，最终创造出这款游戏呢？

3515
01:47:24,220 --> 01:47:26,470
我该如何先咬掉最容易的部分？

3516
01:47:26,470 --> 01:47:31,120
老实说，我做的第一件事 就是找到了这张图片 然后把它拖进了Scratch --

3517
01:47:31,120 --> 01:47:33,580
好了，搞定--比如，灯柱安装完毕。

3518
01:47:33,580 --> 01:47:34,575
它什么也做不了。

3519
01:47:34,575 --> 01:47:35,450
这不是互动的。

3520
01:47:35,450 --> 01:47:37,995
但我至少为这个节目做了铺垫。

3521
01:47:37,995 --> 01:47:39,370
那我还能做什么？

3522
01:47:39,370 --> 01:47:40,640
让我来吧

3523
01:47:40,640 --> 01:47:48,980
请允许我在另一个编辑器中打开 Oscartime 的早期版本。

3524
01:47:48,980 --> 01:47:51,220
让我进入奥斯卡时间。

3525
01:47:51,220 --> 01:47:52,510
让我全屏显示。

3526
01:47:52,510 --> 01:47:59,687
这就是--让我先把垃圾藏起来--我可以称之为我的程序的第二个版本

3527
01:47:59,687 --> 01:48:06,267
其中，在舞台的右上方，我有一个灯柱，我只是拖放了一下就开始了，但随后我又添加了一个实际的精灵。

3528
01:48:06,267 --> 01:48:09,100
如果你想让它进行交互式操作，它就必须是一个精灵。

3529
01:48:09,100 --> 01:48:10,420
灯柱 不是精灵

3530
01:48:10,420 --> 01:48:14,680
如果你愿意，这只是整个舞台本身的一个形象，一套服装，一个背景。

3531
01:48:14,680 --> 01:48:20,240
但这个东西确实是一个精灵，因为它需要对代码和事件（如拖放）做出响应。

3532
01:48:20,240 --> 01:48:23,960
那么，我早期可能会用这些代码做些什么呢？

3533
01:48:23,960 --> 01:48:32,170
好吧，也许第一个版本会是这样的，而我的第一个版本的《奥斯卡时间》可能是这样的：哦，这个。

3534
01:48:32,170 --> 01:48:35,500
不如，让我像以前一样控制程序，或者说，控制事件。

3535
01:48:35,500 --> 01:48:38,630
点击 "绿旗 "后，我想做什么？

3536
01:48:38,630 --> 01:48:43,600
好吧，我想永远这样做下去。

3537
01:48:43,600 --> 01:48:46,687
所以我希望一碰盖子，盖子就会打开。

3538
01:48:46,687 --> 01:48:49,270
因此，如果光标靠近盖子，我就想让盖子打开。

3539
01:48:49,270 --> 01:48:51,340
如果我搬走了，我希望它能关闭。

3540
01:48:51,340 --> 01:48:52,640
那我该怎么做呢？

3541
01:48:52,640 --> 01:48:59,200
我想要一个 "如果"，但我只是不想要一个问题，我真的想要两个问题，可以说是一个向左或向右的岔路口。

3542
01:48:59,200 --> 01:49:02,830
让我像很久以前一样，抓住这块拼图。

3543
01:49:02,830 --> 01:49:04,690
因此，请注意，它是为了填充而生长的。

3544
01:49:04,690 --> 01:49:06,430
我想问什么问题？

3545
01:49:06,430 --> 01:49:13,863
那么，在 "感应 "功能下，我想说，如果这个垃圾桶正在触碰鼠标指针，我该怎么办？

3546
01:49:13,863 --> 01:49:16,030
我想改变垃圾桶的样子。

3547
01:49:16,030 --> 01:49:17,740
而这部分，我在课前就做了。

3548
01:49:17,740 --> 01:49:21,040
如果你进入 "服装 "页面，所有的图形都会在这里出现。

3549
01:49:21,040 --> 01:49:31,423
你会看到我导入了一大堆不同的服装，当你快速播放这些服装时，它们就像视频一样，能有效地营造出运动的错觉和一些动画效果。

3550
01:49:31,423 --> 01:49:35,320
但实际上，屏幕上显示的只是点、点、点、点、点--不同的图像。

3551
01:49:35,320 --> 01:49:39,250
其中一些服装被称为奥斯卡 1 号、奥斯卡 2 号。

3552
01:49:39,250 --> 01:49:40,810
Oscar1 已关闭。

3553
01:49:40,810 --> 01:49:42,070
奥斯卡 2 开幕。

3554
01:49:42,070 --> 01:49:43,730
所以，我们还是先解决这些问题吧。

3555
01:49:43,730 --> 01:49:48,100
所以，如果我正在触摸鼠标指针，让我到下面--"外观 "怎么样？

3556
01:49:48,100 --> 01:49:50,680
我们以前没有用过这个，但有这么一块、

3557
01:49:50,680 --> 01:49:52,870
把服装换成别的

3558
01:49:52,870 --> 01:49:55,150
我要把这个拖放到 If 中。

3559
01:49:55,150 --> 01:49:57,070
注意它有一点缩进。

3560
01:49:57,070 --> 01:50:00,730
我要把它改成 Oscar2，而不是 Oscar8。

3561
01:50:00,730 --> 01:50:10,840
否则，如果不触碰鼠标指针--这是岔路口的另一个方向--让我们继续前进，把服装换回我描述的 Oscar1。

3562
01:50:10,840 --> 01:50:12,400
让我来运行这个程序。

3563
01:50:12,400 --> 01:50:14,900
但目前还没有什么值得关注的事情发生。

3564
01:50:14,900 --> 01:50:20,030
但请注意，如果我将光标向上、向下移动--但这是怎么做到的呢？

3565
01:50:20,030 --> 01:50:22,940
这只是在改变叠加在精灵上的服装。

3566
01:50:22,940 --> 01:50:25,998
因此，这看起来像是互动，但实际上你只是在改变美学。

3567
01:50:25,998 --> 01:50:29,135
而我们人类只是假设，哦，它正在打开。

3568
01:50:29,135 --> 01:50:30,760
不，只是换一套服装。

3569
01:50:30,760 --> 01:50:31,802
这就是区别所在。

3570
01:50:31,802 --> 01:50:34,210
高级抽象--打开垃圾桶。

3571
01:50:34,210 --> 01:50:38,500
较低层次的实施细节--换装，制造幻觉。

3572
01:50:38,500 --> 01:50:46,130
如果我想让它看起来更漂亮，我可以穿上很多其他的服装，然后 "嘣、嘣、嘣、嘣"，这样就能创造出更多的每秒帧数。

3573
01:50:46,130 --> 01:50:48,820
所以我还需要做一件事。

3574
01:50:48,820 --> 01:50:52,750
也许我不小心把垃圾桶打开了，让我在这里做一个改变。

3575
01:50:52,750 --> 01:50:54,730
让我确保第一件事

3576
01:50:54,730 --> 01:51:01,810
当点击绿旗时，我总是先关闭垃圾桶，因为否则你可能会不小心把它打开。

3577
01:51:01,810 --> 01:51:03,590
这样，我就进入了某种默认状态。

3578
01:51:03,590 --> 01:51:08,133
因此，现在它总是关闭着，直到我手动将鼠标悬停在它上面。

3579
01:51:08,133 --> 01:51:09,550
那么，接下来我会怎么做呢？

3580
01:51:09,550 --> 01:51:13,587
好吧，如果我想引入垃圾之类的东西，我需要第二个精灵。

3581
01:51:13,587 --> 01:51:15,670
在这里，我已经提前抓取了图片。

3582
01:51:15,670 --> 01:51:18,310
让我假装这一切从未发生过。

3583
01:51:18,310 --> 01:51:20,260
让我把这个拖走。

3584
01:51:20,260 --> 01:51:24,033
现在，我的代码区里没有任何东西可以用来装这个垃圾。

3585
01:51:24,033 --> 01:51:25,200
但这是第二个精灵。

3586
01:51:25,200 --> 01:51:29,190
我所做的就是点击这里的小猫加号图标，创建第二个精灵。

3587
01:51:29,190 --> 01:51:30,330
我把它命名为垃圾。

3588
01:51:30,330 --> 01:51:32,250
我为它添加了一套服装。

3589
01:51:32,250 --> 01:51:34,170
我提前做了一些美学方面的工作。

3590
01:51:34,170 --> 01:51:36,360
但我现在要做的是代码。

3591
01:51:36,360 --> 01:51:37,720
我想怎么做？

3592
01:51:37,720 --> 01:51:42,160
那么，点击 "绿旗 "后，垃圾桶就会出现、

3593
01:51:42,160 --> 01:51:45,090
我想让垃圾桶并行 --

3594
01:51:45,090 --> 01:51:48,190
我想让垃圾，让垃圾做自己的事。

3595
01:51:48,190 --> 01:51:52,500
所以，我想让它做的是，让我们来做运动，怎么样？

3596
01:51:52,500 --> 01:51:54,240
让我们来看一个具体的坐标。

3597
01:51:54,240 --> 01:51:55,750
现在，这里有很多选择。

3598
01:51:55,750 --> 01:52:01,740
还有 "转弯"、"转到随机位置"、"转到 x,y"、"滑行 "等更优雅的功能。

3599
01:52:01,740 --> 01:52:03,990
有很多不同的方法来实现运动。

3600
01:52:03,990 --> 01:52:06,310
我只是想让它先到达一个非常具体的位置。

3601
01:52:06,310 --> 01:52:09,000
所以我打算先去 x,y 处。

3602
01:52:09,000 --> 01:52:14,470
我想说的是，X，怎么样，会是--让我们不要硬编码。

3603
01:52:14,470 --> 01:52:18,120
好吧，那就从 0 开始，然后是 240。

3604
01:52:18,120 --> 01:52:23,410
所以--哎呀--还是 0,240 吧，这样这块垃圾就总是从屏幕的中上部开始。

3605
01:52:23,410 --> 01:52:26,160
如果你回想一下那个坐标系，0,0 就在中间。

3606
01:52:26,160 --> 01:52:28,230
240 在其正上方。

3607
01:52:28,230 --> 01:52:31,150
好了，现在，在我做完这些之后，我想做什么？

3608
01:52:31,150 --> 01:52:34,980
那我就用永远坠落来控制它吧。

3609
01:52:34,980 --> 01:52:36,427
现在，我该如何让垃圾移动呢？

3610
01:52:36,427 --> 01:52:38,010
我们还没有看到这块拼图。

3611
01:52:38,010 --> 01:52:42,390
但在 "运动 "中，第一件事叫做 "移动一定步数"。

3612
01:52:42,390 --> 01:52:43,380
默认为 10。

3613
01:52:43,380 --> 01:52:44,880
但我们会做得更简单。

3614
01:52:44,880 --> 01:52:48,660
让我继续前进 - 哦，对不起。

3615
01:52:48,660 --> 01:52:52,350
移动 "会将它朝任何方向移动。

3616
01:52:52,350 --> 01:52:53,753
我只想让它向下移动。

3617
01:52:53,753 --> 01:52:57,540
在这里，连我自己都搞不清楚到底有多少种不同的方法。

3618
01:52:57,540 --> 01:52:59,680
我想做的事情是这样的

3619
01:52:59,680 --> 01:53:03,670
让我只对 Y 轴做如下改动。

3620
01:53:03,670 --> 01:53:06,060
这里还有一块拼图，叫做 "变化 y"。

3621
01:53:06,060 --> 01:53:07,680
因此，y 还是垂直方向。

3622
01:53:07,680 --> 01:53:14,170
因此，让我每次向下改变一个像素，所以每次-1 一个像素。

3623
01:53:14,170 --> 01:53:15,540
所以有点慢。

3624
01:53:15,540 --> 01:53:17,010
我想现在 --

3625
01:53:17,010 --> 01:53:17,890
我想就是这样了。

3626
01:53:17,890 --> 01:53:18,990
让我按 "停止 "键。

3627
01:53:18,990 --> 01:53:21,700
请注意，我的垃圾桶仍将是互动的。

3628
01:53:21,700 --> 01:53:23,370
我没有更改或删除该代码。

3629
01:53:23,370 --> 01:53:26,850
我刚刚为我的垃圾添加了代码。

3630
01:53:26,850 --> 01:53:32,920
如果我点击 "绿旗"，请注意 -- 在我启用它之后 -- 让我重新开始。

3631
01:53:32,920 --> 01:53:34,320
我把它藏在课前。

3632
01:53:34,320 --> 01:53:35,403
但现在让我来启用它 --

3633
01:53:35,403 --> 01:53:42,750
绿旗，注意它是从中心点开始的，X 等于 0，Y 等于 240，每次下降一个像素。

3634
01:53:42,750 --> 01:53:47,530
如果这看起来有点无聊，我们可以把它改成每次 -10 像素，然后，"砰 "的一声，它就完成了。

3635
01:53:47,530 --> 01:53:49,780
这就是改变程序速度的方法。

3636
01:53:49,780 --> 01:53:51,750
但我还是想把它简化为-1。

3637
01:53:51,750 --> 01:53:54,708
老实说，如果不总是从头开始，那就更好了。

3638
01:53:54,708 --> 01:53:57,083
否则，这个游戏的互动性就不会很强。

3639
01:53:57,083 --> 01:54:00,580
我简直每次都要从同一个地方抓垃圾。

3640
01:54:00,580 --> 01:54:03,250
那我为什么不这样做呢？

3641
01:54:03,250 --> 01:54:06,550
让我在 "操作员 "下随机选取一个数字。

3642
01:54:06,550 --> 01:54:12,437
因此，让我改变硬编码--手动输入的--0，让 x 介于 0 之间

3643
01:54:12,437 --> 01:54:20,970
所以从中间一直到 - - 是什么 - - 哦，我把数字弄错了 - - 240，我的Y将是180。

3644
01:54:20,970 --> 01:54:23,560
对不起，我把 x 和 y 搞混了。

3645
01:54:23,560 --> 01:54:25,420
让我再演一遍。

3646
01:54:25,420 --> 01:54:30,978
而现在，我们的游戏更像你成长过程中甚至现在玩过的游戏，有一些随机性。

3647
01:54:30,978 --> 01:54:33,660
可以说，CPU 正在做一些更有趣的事情。

3648
01:54:33,660 --> 01:54:34,570
让我再跑一遍。

3649
01:54:34,570 --> 01:54:35,820
现在向左一点。

3650
01:54:35,820 --> 01:54:36,600
让我再跑一遍。

3651
01:54:36,600 --> 01:54:38,058
现在又往左移了一点。

3652
01:54:38,058 --> 01:54:39,630
现在又回到右边了。

3653
01:54:39,630 --> 01:54:41,640
因此，随机性只会让游戏更有趣。

3654
01:54:41,640 --> 01:54:46,172
这就是为什么当你玩任何电子游戏时，如果有不同的事情发生，很可能就是随机的。

3655
01:54:46,172 --> 01:54:48,360
它被量化为一个简单的数字。

3656
01:54:48,360 --> 01:54:52,050
现在，如果可以的话，我想我只需要在这里做最后的铺垫。

3657
01:54:52,050 --> 01:54:54,060
让我来补充一下。

3658
01:54:54,060 --> 01:54:58,380
那 "活动 "呢？ 或者说，是的，"活动"。

3659
01:54:58,380 --> 01:55:02,700
当点击 "绿旗 "时，我可以在同一个精灵中执行多项操作。

3660
01:55:02,700 --> 01:55:05,190
它们不一定都要连接到同一个设备上。

3661
01:55:05,190 --> 01:55:10,110
让我继续，永远继续做别的事情。

3662
01:55:10,110 --> 01:55:20,850
那 "每当垃圾......触碰垃圾桶......就...... "怎么样？

3663
01:55:20,850 --> 01:55:28,530
那么，"触摸 "怎么样？ 这次不是 "鼠标指针"，而是 "触摸奥斯卡本人"。

3664
01:55:28,530 --> 01:55:30,810
现在让我们看看会发生什么。

3665
01:55:30,810 --> 01:55:33,750
好了，让我们点击 "绿旗"。

3666
01:55:33,750 --> 01:55:37,560
现在，我从这里下去，然后放手。

3667
01:55:37,560 --> 01:55:41,340
好吧，我有点想把它扔进垃圾桶。

3668
01:55:41,340 --> 01:55:43,620
怎样才能把它扔进垃圾桶？

3669
01:55:43,620 --> 01:55:49,950
我们怎样才能把这个高层次的想法，扔进垃圾桶，让它看起来消失不见呢？

3670
01:55:49,950 --> 01:55:51,520
从逻辑上讲，我们能做什么呢？

3673
01:55:53,245 --> 01:55:56,037
大卫-J-马兰：好吧，那么当它碰到它的时候，让它消失。

3674
01:55:56,037 --> 01:55:56,910
这样我就可以把它藏起来。

3675
01:55:56,910 --> 01:56:04,380
或者老实说，如果游戏要持续下去，就像以前那样，让我扔下越来越多的垃圾，那就让我让它继续随机选择一个新的地点吧。

3676
01:56:04,380 --> 01:56:05,560
那就让我来吧。

3677
01:56:05,560 --> 01:56:09,073
让我继续复制这块拼图，然后复制。

3678
01:56:09,073 --> 01:56:10,740
我不想要整件事情，对不起。

3679
01:56:10,740 --> 01:56:12,400
让我把这个扔掉。

3680
01:56:12,400 --> 01:56:13,540
让我这么做吧。

3681
01:56:13,540 --> 01:56:16,720
让我回到顶部的某个随机位置。

3682
01:56:16,720 --> 01:56:17,940
现在请注意发生了什么。

3683
01:56:17,940 --> 01:56:26,318
如果我点击并拖动它--它就在这里--然后松手，它看起来就像要被扔进垃圾桶，因为它又会随意地弹回到某个位置。

3684
01:56:26,318 --> 01:56:29,610
现在，我唯一没有做的事情就是记分。

3685
01:56:29,610 --> 01:56:33,940
事实证明，如果我全屏显示，默认情况下它是不可拖动的。

3686
01:56:33,940 --> 01:56:45,960
可以说，这只是一个小插曲，否则你可能会被绊倒，让我继续，让我们看看，"感知"，原来我还需要这个垃圾桶。

3687
01:56:45,960 --> 01:56:51,540
在 Scratch 中，有一种设置精灵可拖动或不可拖动的方法。

3688
01:56:51,540 --> 01:57:00,240
我需要明确规定它是可拖动的，这样当我现在全屏显示这个东西时，它仍然是可拖动的，像我这样的人可以反复播放。

3689
01:57:00,240 --> 01:57:03,120
那么，我们最后再锦上添花一下如何？

3690
01:57:03,120 --> 01:57:06,010
为什么我们现在不记录用户得分？

3691
01:57:06,010 --> 01:57:16,590
那么，当用户真的把垃圾拖到垃圾桶时，让我在这里的 "变量 "下，提前创建一个名为 "分数 "的变量。

3692
01:57:16,590 --> 01:57:20,100
我本可以把它叫做 x、y、z 或 ABC，但这样就不太好描述了。

3693
01:57:20,100 --> 01:57:24,450
在编程过程中，你通常会给事物起一个更具描述性的英文或其他语言名称。

3694
01:57:24,450 --> 01:57:26,200
因此，我把这一次称为 "得分"。

3695
01:57:26,200 --> 01:57:28,710
那么，在我的 "记分 "中，我该如何做到这一点呢？

3696
01:57:28,710 --> 01:57:37,470
好吧，让我继续前进，在这些脚本的最顶端将游戏分数设置为 0 -- 这里的其中一个程序。

3697
01:57:37,470 --> 01:57:42,570
每当我的垃圾被碰触时

3698
01:57:42,570 --> 01:57:49,630
奥斯卡，我们不要直接跳到最上面，让我们在这里把比分改成 1。

3699
01:57:49,630 --> 01:57:52,680
现在请注意，"如果感动奥斯卡，请改变比分"，就是这个意思、

3700
01:57:52,680 --> 01:57:55,920
在分数上加 1，然后选择一个新的随机位置。

3701
01:57:55,920 --> 01:57:59,520
现在是 "绿旗" 我们慢慢来

3702
01:57:59,520 --> 01:58:00,540
开始了

3703
01:58:00,540 --> 01:58:01,590
垃圾桶打开了。

3705
01:58:02,520 --> 01:58:06,660
现在请注意，在我程序的左上角，分数现在是 2。

3706
01:58:06,660 --> 01:58:10,140
注意，如果我再做一次，分数就要变成 3 了。

3707
01:58:10,140 --> 01:58:15,910
因此，我们有了让这个项目越来越好的基石。

3708
01:58:15,910 --> 01:58:22,530
因此，不管是用 Scratch、C、Python 还是其他语言，用代码解决任何问题时，一般都会采用这种方法。

3709
01:58:22,530 --> 01:58:31,530
你要把自己的愿景或家庭作业中布置给你的愿景分解成不同的部分，先把容易的部分摘下来。

3710
01:58:31,530 --> 01:58:34,980
先把灯柱放在那里，至少会让人觉得你取得了一些进展。

3711
01:58:34,980 --> 01:58:38,457
然后摘下垃圾桶之类的东西，让它做一件小事。

3712
01:58:38,457 --> 01:58:40,540
在这里，顺序不一定要相同。

3713
01:58:40,540 --> 01:58:42,750
我可以用无数种不同的方式来做这件事。

3714
01:58:42,750 --> 01:58:52,380
但要想清楚，这些小碎片最终会像我们今天解决的几个问题一样，组合成一个更大的解决方案。

3715
01:58:52,380 --> 01:58:58,470
现在，你已经有了关于这些类型的障碍和其他障碍的心理模型，让我们回到这个问题上来。

3716
01:58:58,470 --> 01:59:06,670
刚才我们看到，当我开始说 "你好，戴维"，并把这些拼图嵌套起来时，我们就有了一个完全不同的范式。

3717
01:59:06,670 --> 01:59:15,000
我对第二个版本的 "你好，世界 "的输入是，例如，将 "你叫什么名字？"传入我的函数 Ask。

3718
01:59:15,000 --> 01:59:21,690
这给我带来的不是副作用，而是我称之为返回值的东西，在 Scratch 中默认称为 "答案"。

3719
01:59:21,690 --> 01:59:31,260
现在请注意并回想一下，当我把同样的输出变为下一个程序块的输入时，它看起来是这样的--

3721
01:59:32,100 --> 01:59:37,710
那么，这种积木和积木的嵌套、堆叠，又是如何融入同一个心理模型的呢？

3722
01:59:37,710 --> 01:59:47,190
好吧，同样的想法--我对这部分故事的输入现在不是一个输入，而是两个--两个参数--"你好 "和之前的答案。

3723
01:59:47,190 --> 01:59:50,010
在这种情况下，该功能就是那个名为 Join 的新块。

3724
01:59:50,010 --> 02:00:00,840
它的输出是 "你好，戴维"，如果我们把它做成动画，它本身就成了我的最终函数的输入，而我的最终函数仍然是 Say。

3725
02:00:00,840 --> 02:00:06,729
这只是说--没有双关语的意思--你用这些拼图所做的几乎所有事情

3726
02:00:06,729 --> 02:00:16,320
无论是在《奥斯卡时间》的背景下，还是在 "鼹鼠捶 "的背景下，甚至只是像 "你好，世界 "这样简单的一句话，最终都会融入那个相对简单的心智模型中。

3727
02:00:16,320 --> 02:00:20,220
现在，我想我们最后再看几个例子。

3728
02:00:20,220 --> 02:00:22,950
这些也是您的一些前辈制作的。

3729
02:00:22,950 --> 02:00:27,760
为此，我想我们不要一起写代码，而是读代码。

3730
02:00:27,760 --> 02:00:36,720
请允许我在这里打开另一个例子，向我们展示前人制作的程序的几个不同版本。

3731
02:00:36,720 --> 02:00:38,340
给我一点时间

3732
02:00:38,340 --> 02:00:42,960
我们将看看如何建立更强的互动性。

3733
02:00:42,960 --> 02:00:51,090
稍后，我们将看到他们称之为 "常春藤最难游戏 "的东西，重点是这些特殊的机制。

3734
02:00:51,090 --> 02:00:58,560
可以说，这就是这个程序的第 0 版，我们的目标是创建一个游戏，让你走出某种迷宫。

3735
02:00:58,560 --> 02:01:01,800
在这种情况下，你必须从这个迷宫中走出哈佛大学的校徽。

3736
02:01:01,800 --> 02:01:08,040
让我继续按下 "播放 "键，这样你就能看到这个程序的第一个构件是什么了。

3737
02:01:08,040 --> 02:01:12,990
请注意，我的手实际上是放在键盘的方向键上。

3738
02:01:12,990 --> 02:01:20,432
似乎只要上下左右移动，屏幕上的这个小峰顶就会做出相应的反应。

3739
02:01:20,432 --> 02:01:22,140
现在，让我们假设一下。

3740
02:01:22,140 --> 02:01:27,260
尽管我们以前没有做过类似的工作，但如何实现这段代码呢？

3741
02:01:27,260 --> 02:01:34,220
如何让一个精灵（无论是猫还是徽章）对键盘上的按键做出反应--你能凭直觉想到吗？

3744
02:01:36,983 --> 02:01:40,410
是的，可能有什么东西能感应到你按的是什么键。

3745
02:01:40,410 --> 02:01:44,600
如果你永远循环往复地这样做，你就只能不断地监听按键。

3746
02:01:44,600 --> 02:01:47,240
如今，每款软件都是这样运行的。

3747
02:01:47,240 --> 02:01:51,690
它一直在等待你轻触手机或在屏幕上输入内容。

3748
02:01:51,690 --> 02:01:55,400
所以，让我先来看看这个现有程序的内部情况。

3749
02:01:55,400 --> 02:01:59,730
还有更多情况，但我们将快速浏览一下实际情况。

3750
02:01:59,730 --> 02:02:04,850
那么，在左上方，请注意，我们只需转到 x 等于 0 和 y 等于 0。

3751
02:02:04,850 --> 02:02:07,850
也就是说，把哈佛大学的校徽放在舞台中央的正中间。

3752
02:02:07,850 --> 02:02:13,130
然后，我们将两个函数作为自定义函数使用，这两个函数分别是

3753
02:02:13,130 --> 02:02:15,500
聆听键盘，感受墙壁。

3754
02:02:15,500 --> 02:02:17,190
因此，它同时在做两件事。

3755
02:02:17,190 --> 02:02:23,278
它永远都在聆听键盘的声音--上、下、左、右--并感觉到墙壁的存在、

3756
02:02:23,278 --> 02:02:26,010
我不想让它继续穿过那堵黑墙。

3757
02:02:26,010 --> 02:02:29,060
如果它向右移动太远，我也不想让它撞穿那堵墙。

3758
02:02:29,060 --> 02:02:34,250
因此，它要不断做两件事：听键盘声和摸墙壁声。

3759
02:02:34,250 --> 02:02:35,870
又是如何实施的？

3760
02:02:35,870 --> 02:02:37,190
这个有点长。

3761
02:02:37,190 --> 02:02:40,080
左侧是 "听键盘"。

3762
02:02:40,080 --> 02:02:47,420
因此，这块粉色拼图 "键盘监听 "首先要检查 "是否按下向上箭头键"，即问号、

3763
02:02:47,420 --> 02:02:50,570
条件中的布尔表达式，Change y By 1。

3764
02:02:50,570 --> 02:02:52,040
这意味着，将其上移 1.

3765
02:02:52,040 --> 02:02:59,540
否则，如果按下 "向下箭头 "键，则将 y 改为-1，左箭头和右箭头的操作类似。

3766
02:02:59,540 --> 02:03:04,310
尽管在这个粉红色函数中没有循环，但在我使用它的地方却有循环。

3767
02:03:04,310 --> 02:03:06,860
因此，这个问题一直被反复询问。

3768
02:03:06,860 --> 02:03:08,420
对墙壁的感觉如何？

3769
02:03:08,420 --> 02:03:13,970
好吧，在这里的右边 -- 有点断掉了 -- 但这里有《如果触摸左墙》、

3770
02:03:13,970 --> 02:03:15,260
将 x 改为 1。

3771
02:03:15,260 --> 02:03:17,200
所以，如果你碰壁了，就为时已晚。

3772
02:03:17,200 --> 02:03:18,950
你已经在吹牛了。

3773
02:03:18,950 --> 02:03:23,000
所以我想把它向后移动一个像素，这样它就不会再碰到那面墙了。

3774
02:03:23,000 --> 02:03:28,220
同样，如果它碰到了右边的墙，我想把它后退一个像素，这样它就不再碰到那面墙了。

3775
02:03:28,220 --> 02:03:33,110
因此，它就像是在轻微地反弹，这样就不会滑过那堵墙。

3776
02:03:33,110 --> 02:03:34,340
那些墙是什么？

3777
02:03:34,340 --> 02:03:41,790
注意看下面，这只是一个简单的精灵，上面有一条黑线，我把它的方向改为垂直而不是水平。

3778
02:03:41,790 --> 02:03:45,230
这样我就可以向另外两个精灵提问了。

3779
02:03:45,230 --> 02:03:47,570
现在，这给了我互动的形式。

3780
02:03:47,570 --> 02:03:49,200
我现在还能做什么？

3781
02:03:49,200 --> 02:03:52,410
那么，如果我们让这里的互动性更强一些呢？

3782
02:03:52,410 --> 02:03:55,640
让我来看看第 1 版的第二部分。

3783
02:03:55,640 --> 02:03:58,860
让我提议一下这里会发生什么。

3784
02:03:58,860 --> 02:04:02,600
那么，我们怎样才能在其中加入一点像耶鲁大学这样的东西呢？

3785
02:04:02,600 --> 02:04:07,460
那么，根据这段代码，当我现在点击绿旗时，耶鲁会怎么做？

3786
02:04:07,460 --> 02:04:09,920
有什么直觉吗？

3787
02:04:09,920 --> 02:04:13,250
下面是我的耶鲁精灵的代码。

3790
02:04:14,570 --> 02:04:19,370
戴维-J-马兰：是的，如果我继续写更多的代码，理论上它会阻挡我的前进道路，这有点不利于我。

3792
02:04:20,030 --> 02:04:22,160
它也会转到屏幕中间。

3793
02:04:22,160 --> 02:04:23,940
它指向 90 度的方向。

3794
02:04:23,940 --> 02:04:26,520
因此，同样也有一个完整的学位体系。

3795
02:04:26,520 --> 02:04:27,710
它永远在问这个问题。

3796
02:04:27,710 --> 02:04:30,920
如果触碰左墙或 -- 注意绿色块 --

3797
02:04:30,920 --> 02:04:33,900
触碰右侧墙壁，然后转体 180 度。

3798
02:04:33,900 --> 02:04:42,860
事实上，如果你从逻辑上思考一下，这就意味着你只需将自己翻转 180 度，就能在耶鲁精灵身上这样跳来跳去。

3799
02:04:42,860 --> 02:04:46,550
因此，如果我继续放大并点击 "绿旗"、

3800
02:04:46,550 --> 02:04:48,350
我仍然可以上下移动。

3801
02:04:48,350 --> 02:04:53,490
但耶鲁大学整天就是这样，来来回回，反反复复，永无止境。

3802
02:04:53,490 --> 02:04:55,710
如果我试着穿过它，就不会有坏事发生。

3803
02:04:55,710 --> 02:04:58,010
不过，我们当然可以把这一点加进去。

3804
02:04:58,010 --> 02:05:01,760
事实上，在玩这个特殊游戏之前，让我们再补充最后一项功能。

3805
02:05:01,760 --> 02:05:08,640
让我来打开这些构件的最终版本，将麻省理工学院加入其中。

3806
02:05:08,640 --> 02:05:10,940
这里是麻省理工学院。

3807
02:05:10,940 --> 02:05:13,182
谁能解释一下这段代码的作用？

3808
02:05:13,182 --> 02:05:14,390
这就是我们正在做的。

3809
02:05:14,390 --> 02:05:15,470
这本身就是一种技能。

3810
02:05:15,470 --> 02:05:20,640
阅读别人的代码并理解它是编程中除编写之外的另一个重要部分。

3813
02:05:22,015 --> 02:05:24,960
戴维-J-马兰：是的，它在追寻哈佛校徽的轮廓。

3814
02:05:24,960 --> 02:05:30,050
这显然就是这位学生制作的服装名称，哈佛校徽的轮廓。

3815
02:05:30,050 --> 02:05:32,600
显然，它会先随机进入一个位置。

3816
02:05:32,600 --> 02:05:34,700
但它却永远指向哈佛。

3817
02:05:34,700 --> 02:05:40,830
因此，无论我把它移到哪里，向上、向下、向左还是向右，麻省理工学院都比耶鲁大学更有策略，像这样来回跳动。

3818
02:05:40,830 --> 02:05:43,440
所以，让我们继续全屏播放吧。

3819
02:05:43,440 --> 02:05:45,540
这里有一面绿旗。

3820
02:05:45,540 --> 02:05:53,210
因此，如果我向上爬，麻省理工学院就会战略性地跟随我，无论我走到哪里。

3821
02:05:53,210 --> 02:05:55,190
好吧，还是没发生什么坏事。

3822
02:05:55,190 --> 02:05:56,940
但现在它在挣扎，对吗？

3823
02:05:56,940 --> 02:05:58,190
它在上升、下降、上升、下降。

3824
02:05:58,190 --> 02:06:00,950
即使我一动不动，它还是试图跟着我。

3825
02:06:00,950 --> 02:06:02,630
因此，我们需要一些最后的点缀。

3826
02:06:02,630 --> 02:06:06,740
因此，我想，为此，我们也许需要最后一位志愿者。

3827
02:06:06,740 --> 02:06:11,990
之后，蛋糕在外面等着大家，这是 CS50 第一讲结束时的传统。

3828
02:06:11,990 --> 02:06:14,840
您愿意上来做我们的志愿者吗？

3831
02:06:24,040 --> 02:06:30,040
因此，这将是实际版本，但由您的一位前辈撰写，我将在这里全屏显示。

3832
02:06:30,040 --> 02:06:35,562
它将拼接所有这些相同的基元和更多，但增加了分数和生命的概念

3833
02:06:35,562 --> 02:06:44,650
这样实际上就有了一个目标，在这种情况下，目标就是移动哈佛徽章，不断追赶右侧的角色，让你的精灵碰到那个角色。

3834
02:06:44,650 --> 02:06:46,533
你想自我介绍一下吗？

3835
02:06:46,533 --> 02:06:47,950
听众：你好，我叫穆罕默德。

3836
02:06:47,950 --> 02:06:49,000
戴维-J-马兰：好的，太好了。

3837
02:06:49,000 --> 02:06:49,630
欢迎加入。

3838
02:06:49,630 --> 02:06:56,048
在这里，如果我们想继续亮灯，但又想增加音乐，我们还需要一些说明和最后的装饰。

3841
02:07:00,486 --> 02:07:02,150
你不能这样。

3842
02:07:02,150 --> 02:07:03,025
你不能碰这个

3843
02:07:03,025 --> 02:07:05,567
大卫-J-马兰：请注意，他用的是上下左右。

3844
02:07:05,567 --> 02:07:07,320
但现在还有更多的墙。

3845
02:07:07,320 --> 02:07:08,730
第一关非常简单。

3846
02:07:08,730 --> 02:07:13,560
但现在耶鲁大学也在其中，来回跳动。

3847
02:07:13,560 --> 02:07:15,420
同样，非常简单。

3848
02:07:15,420 --> 02:07:22,290
现在有两个耶鲁大学，位置略有不同。

3849
02:07:22,290 --> 02:07:23,730
麻省理工学院即将到来。

3850
02:07:23,730 --> 02:07:25,432
但首先，我们有三个耶鲁人。

3851
02:07:25,432 --> 02:07:26,640
MC HAMMER：（唱）就是这样。

3852
02:07:26,640 --> 02:07:28,542
这个节拍，呃，你不能碰。

3853
02:07:28,542 --> 02:07:29,625
大卫-J-马兰：很好。

3855
02:07:30,125 --> 02:07:33,100
我告诉过你，伙计，你不能碰这个。

3856
02:07:33,100 --> 02:07:36,820
是啊，当你知道你不能碰这个的时候，就是这个样子。

3857
02:07:36,820 --> 02:07:40,798
看着我的眼睛，伙计，你不能碰这个。

3858
02:07:40,798 --> 02:07:43,090
Yo, let me bust the funky lyrics.

3859
02:07:43,090 --> 02:07:45,171
新鞋新裤，你一定喜欢。

3860
02:07:45,171 --> 02:07:46,504
现在，你知道你想跳舞了。

3861
02:07:46,504 --> 02:07:48,570
所以，离开你的座位，去找一只苍蝇 --

3862
02:07:48,570 --> 02:07:49,290
你得快点走 You got to go quick.

3863
02:07:49,290 --> 02:07:51,623
锤子 MC HAMMER：（唱）趁它滚动的时候，抓住这个节拍。

3865
02:07:52,130 --> 02:07:55,490
抽一点，让他们知道发生了什么，就这样，就这样。

3866
02:07:55,490 --> 02:07:57,056
寒冷在执行任务，所以请退后。

3867
02:07:57,056 --> 02:08:02,800
让他们知道你太过分了，这个节拍，呃，他们不能碰。

3868
02:08:02,800 --> 02:08:03,627
哟，我就说嘛

3869
02:08:03,627 --> 02:08:04,502
你不能碰这个

3871
02:08:08,790 --> 02:08:09,810
哟，敲钟

3872
02:08:09,810 --> 02:08:10,975
开学了，笨蛋

3873
02:08:10,975 --> 02:08:11,850
你不能碰这个

3874
02:08:11,850 --> 02:08:13,432
给我一首歌，一种节奏。

3875
02:08:13,432 --> 02:08:15,390
让他们出汗，这就是我要给他们的。

3876
02:08:15,390 --> 02:08:20,810
现在他们知道了，你说的是锤子，你说的是一场被炒得沸沸扬扬的演出。

3877
02:08:20,810 --> 02:08:24,018
歌手们满头大汗，可以递给他们一块抹布或一盘磁带，让他们学习。

3878
02:08:24,018 --> 02:08:25,060
要怎么做

3879
02:08:25,060 --> 02:08:27,040
DAVID J. MALAN：倒数第二层。

3880
02:08:27,040 --> 02:08:28,165
合法。

3881
02:08:28,165 --> 02:08:30,065
要么努力工作，要么放弃。

3882
02:08:30,065 --> 02:08:31,410
那是因为你知道

3883
02:08:31,410 --> 02:08:32,535
最后一级。

3884
02:08:32,535 --> 02:08:35,652
你不能碰这个。

3885
02:08:35,652 --> 02:08:37,124
嘿 Hey！

3889
02:08:45,170 --> 02:08:47,570
好了，CS50 到此为止。

3891
02:08:48,410 --> 02:08:49,820
蛋糕已经上桌。

3892
02:08:49,820 --> 02:08:51,950
我们下次再见。

